

ğŸŸ© 01_ROOT DIRECTORY (USB1608G_2AO_V2)
ğŸ“ tree -L 2 of .
.
â”œâ”€â”€ 01_extract
â”‚Â Â  â”œâ”€â”€ 00_summary_USB1608G_2AO_V2.txt
â”‚Â Â  â”œâ”€â”€ 01_USB1608G_2AO_V2.txt
â”‚Â Â  â”œâ”€â”€ 02_.git.txt
â”‚Â Â  â”œâ”€â”€ 03_USB1608G_2AO_V2App.txt
â”‚Â Â  â”œâ”€â”€ 04_bin.txt
â”‚Â Â  â”œâ”€â”€ 05_configure.txt
â”‚Â Â  â”œâ”€â”€ 06_db.txt
â”‚Â Â  â”œâ”€â”€ 07_dbd.txt
â”‚Â Â  â”œâ”€â”€ 08_iocBoot.txt
â”‚Â Â  â””â”€â”€ 09_lib.txt
â”œâ”€â”€ Makefile
â”œâ”€â”€ README.md
â”œâ”€â”€ USB1608G_2AO_V2.code-workspace
â”œâ”€â”€ USB1608G_2AO_V2App
â”‚Â Â  â”œâ”€â”€ Db
â”‚Â Â  â”œâ”€â”€ Makefile
â”‚Â Â  â”œâ”€â”€ op
â”‚Â Â  â””â”€â”€ src
â”œâ”€â”€ bin
â”‚Â Â  â””â”€â”€ linux-x86_64
â”œâ”€â”€ configure
â”‚Â Â  â”œâ”€â”€ CONFIG
â”‚Â Â  â”œâ”€â”€ CONFIG_SITE
â”‚Â Â  â”œâ”€â”€ Makefile
â”‚Â Â  â”œâ”€â”€ O.Common
â”‚Â Â  â”œâ”€â”€ O.linux-x86_64
â”‚Â Â  â”œâ”€â”€ RELEASE
â”‚Â Â  â”œâ”€â”€ RULES
â”‚Â Â  â”œâ”€â”€ RULES.ioc
â”‚Â Â  â”œâ”€â”€ RULES_DIRS
â”‚Â Â  â””â”€â”€ RULES_TOP
â”œâ”€â”€ db
â”‚Â Â  â”œâ”€â”€ USB1608G_2AO.substitutions
â”‚Â Â  â”œâ”€â”€ measCompAnalogIn.template
â”‚Â Â  â”œâ”€â”€ measCompAnalogInMode.template
â”‚Â Â  â”œâ”€â”€ measCompAnalogOut.template
â”‚Â Â  â”œâ”€â”€ measCompBinaryDir.template
â”‚Â Â  â”œâ”€â”€ measCompBinaryIn.template
â”‚Â Â  â”œâ”€â”€ measCompBinaryOut.template
â”‚Â Â  â”œâ”€â”€ measCompCounter.template
â”‚Â Â  â”œâ”€â”€ measCompDevice.template
â”‚Â Â  â”œâ”€â”€ measCompEncoder.template
â”‚Â Â  â”œâ”€â”€ measCompLongIn.template
â”‚Â Â  â”œâ”€â”€ measCompLongOut.template
â”‚Â Â  â”œâ”€â”€ measCompMCS.template
â”‚Â Â  â”œâ”€â”€ measCompMCSWaveform.template
â”‚Â Â  â”œâ”€â”€ measCompPulseGen.template
â”‚Â Â  â”œâ”€â”€ measCompTemperatureIn.template
â”‚Â Â  â”œâ”€â”€ measCompTrigger.template
â”‚Â Â  â”œâ”€â”€ measCompUSBTempConfig.template
â”‚Â Â  â”œâ”€â”€ measCompVoltageIn.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformDig.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformDigN.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformGen.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformGenN.template
â”‚Â Â  â”œâ”€â”€ threshold_logic.template
â”‚Â Â  â”œâ”€â”€ user.db
â”‚Â Â  â””â”€â”€ user.substitutions
â”œâ”€â”€ dbd
â”‚Â Â  â””â”€â”€ USB1608G_2AO_V2.dbd
â”œâ”€â”€ iocBoot
â”‚Â Â  â”œâ”€â”€ Makefile
â”‚Â Â  â””â”€â”€ iocUSB1608G_2AO_V2
â””â”€â”€ lib
    â””â”€â”€ linux-x86_64

16 directories, 50 files

ğŸ“„ Files directly under USB1608G_2AO_V2/:
./Makefile
./README.md
./USB1608G_2AO_V2.code-workspace

ğŸ“„ Contents of files directly under USB1608G_2AO_V2/:











ğŸ”¥ File: README.md
=================================================
epics/synApps/measComp











ğŸ”¥ File: USB1608G_2AO_V2.code-workspace
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: Makefile
=================================================
# Makefile at top of application tree
TOP = .
include $(TOP)/configure/CONFIG

# Directories to build, any order
DIRS += configure
DIRS += $(wildcard *Sup)
DIRS += $(wildcard *App)
DIRS += $(wildcard *Top)
DIRS += $(wildcard iocBoot)

# The build order is controlled by these dependency rules:

# All dirs except configure depend on configure
$(foreach dir, $(filter-out configure, $(DIRS)), \
    $(eval $(dir)_DEPEND_DIRS += configure))

# Any *App dirs depend on all *Sup dirs
$(foreach dir, $(filter %App, $(DIRS)), \
    $(eval $(dir)_DEPEND_DIRS += $(filter %Sup, $(DIRS))))

# Any *Top dirs depend on all *Sup and *App dirs
$(foreach dir, $(filter %Top, $(DIRS)), \
    $(eval $(dir)_DEPEND_DIRS += $(filter %Sup %App, $(DIRS))))

# iocBoot depends on all *App dirs
iocBoot_DEPEND_DIRS += $(filter %App,$(DIRS))

# Add any additional dependency rules here:

include $(TOP)/configure/RULES_TOP




















































ğŸŸ¦ 02_SUBDIRECTORY: .git
ğŸ“ tree -L 2 of .git/
./.git
â”œâ”€â”€ COMMIT_EDITMSG
â”œâ”€â”€ FETCH_HEAD
â”œâ”€â”€ HEAD
â”œâ”€â”€ ORIG_HEAD
â”œâ”€â”€ branches
â”œâ”€â”€ config
â”œâ”€â”€ description
â”œâ”€â”€ hooks
â”‚Â Â  â”œâ”€â”€ applypatch-msg.sample
â”‚Â Â  â”œâ”€â”€ commit-msg.sample
â”‚Â Â  â”œâ”€â”€ fsmonitor-watchman.sample
â”‚Â Â  â”œâ”€â”€ post-update.sample
â”‚Â Â  â”œâ”€â”€ pre-applypatch.sample
â”‚Â Â  â”œâ”€â”€ pre-commit.sample
â”‚Â Â  â”œâ”€â”€ pre-merge-commit.sample
â”‚Â Â  â”œâ”€â”€ pre-push.sample
â”‚Â Â  â”œâ”€â”€ pre-rebase.sample
â”‚Â Â  â”œâ”€â”€ pre-receive.sample
â”‚Â Â  â”œâ”€â”€ prepare-commit-msg.sample
â”‚Â Â  â”œâ”€â”€ push-to-checkout.sample
â”‚Â Â  â””â”€â”€ update.sample
â”œâ”€â”€ index
â”œâ”€â”€ info
â”‚Â Â  â””â”€â”€ exclude
â”œâ”€â”€ logs
â”‚Â Â  â”œâ”€â”€ HEAD
â”‚Â Â  â””â”€â”€ refs
â”œâ”€â”€ objects
â”‚Â Â  â”œâ”€â”€ 00
â”‚Â Â  â”œâ”€â”€ 01
â”‚Â Â  â”œâ”€â”€ 03
â”‚Â Â  â”œâ”€â”€ 04
â”‚Â Â  â”œâ”€â”€ 08
â”‚Â Â  â”œâ”€â”€ 0b
â”‚Â Â  â”œâ”€â”€ 0d
â”‚Â Â  â”œâ”€â”€ 0f
â”‚Â Â  â”œâ”€â”€ 12
â”‚Â Â  â”œâ”€â”€ 13
â”‚Â Â  â”œâ”€â”€ 14
â”‚Â Â  â”œâ”€â”€ 19
â”‚Â Â  â”œâ”€â”€ 1e
â”‚Â Â  â”œâ”€â”€ 21
â”‚Â Â  â”œâ”€â”€ 23
â”‚Â Â  â”œâ”€â”€ 26
â”‚Â Â  â”œâ”€â”€ 28
â”‚Â Â  â”œâ”€â”€ 2a
â”‚Â Â  â”œâ”€â”€ 2c
â”‚Â Â  â”œâ”€â”€ 2d
â”‚Â Â  â”œâ”€â”€ 31
â”‚Â Â  â”œâ”€â”€ 32
â”‚Â Â  â”œâ”€â”€ 34
â”‚Â Â  â”œâ”€â”€ 36
â”‚Â Â  â”œâ”€â”€ 3a
â”‚Â Â  â”œâ”€â”€ 3b
â”‚Â Â  â”œâ”€â”€ 3d
â”‚Â Â  â”œâ”€â”€ 3f
â”‚Â Â  â”œâ”€â”€ 42
â”‚Â Â  â”œâ”€â”€ 46
â”‚Â Â  â”œâ”€â”€ 4c
â”‚Â Â  â”œâ”€â”€ 4d
â”‚Â Â  â”œâ”€â”€ 4f
â”‚Â Â  â”œâ”€â”€ 53
â”‚Â Â  â”œâ”€â”€ 56
â”‚Â Â  â”œâ”€â”€ 57
â”‚Â Â  â”œâ”€â”€ 5b
â”‚Â Â  â”œâ”€â”€ 5e
â”‚Â Â  â”œâ”€â”€ 60
â”‚Â Â  â”œâ”€â”€ 68
â”‚Â Â  â”œâ”€â”€ 69
â”‚Â Â  â”œâ”€â”€ 6b
â”‚Â Â  â”œâ”€â”€ 6d
â”‚Â Â  â”œâ”€â”€ 6e
â”‚Â Â  â”œâ”€â”€ 73
â”‚Â Â  â”œâ”€â”€ 75
â”‚Â Â  â”œâ”€â”€ 76
â”‚Â Â  â”œâ”€â”€ 7a
â”‚Â Â  â”œâ”€â”€ 80
â”‚Â Â  â”œâ”€â”€ 82
â”‚Â Â  â”œâ”€â”€ 87
â”‚Â Â  â”œâ”€â”€ 8a
â”‚Â Â  â”œâ”€â”€ 8b
â”‚Â Â  â”œâ”€â”€ 8e
â”‚Â Â  â”œâ”€â”€ 8f
â”‚Â Â  â”œâ”€â”€ 90
â”‚Â Â  â”œâ”€â”€ 91
â”‚Â Â  â”œâ”€â”€ 92
â”‚Â Â  â”œâ”€â”€ 95
â”‚Â Â  â”œâ”€â”€ 97
â”‚Â Â  â”œâ”€â”€ 98
â”‚Â Â  â”œâ”€â”€ 9a
â”‚Â Â  â”œâ”€â”€ 9b
â”‚Â Â  â”œâ”€â”€ 9c
â”‚Â Â  â”œâ”€â”€ 9d
â”‚Â Â  â”œâ”€â”€ a1
â”‚Â Â  â”œâ”€â”€ a3
â”‚Â Â  â”œâ”€â”€ a4
â”‚Â Â  â”œâ”€â”€ a5
â”‚Â Â  â”œâ”€â”€ a6
â”‚Â Â  â”œâ”€â”€ a7
â”‚Â Â  â”œâ”€â”€ a8
â”‚Â Â  â”œâ”€â”€ aa
â”‚Â Â  â”œâ”€â”€ ab
â”‚Â Â  â”œâ”€â”€ b0
â”‚Â Â  â”œâ”€â”€ be
â”‚Â Â  â”œâ”€â”€ bf
â”‚Â Â  â”œâ”€â”€ c2
â”‚Â Â  â”œâ”€â”€ c4
â”‚Â Â  â”œâ”€â”€ c6
â”‚Â Â  â”œâ”€â”€ c7
â”‚Â Â  â”œâ”€â”€ cc
â”‚Â Â  â”œâ”€â”€ d0
â”‚Â Â  â”œâ”€â”€ d5
â”‚Â Â  â”œâ”€â”€ db
â”‚Â Â  â”œâ”€â”€ dc
â”‚Â Â  â”œâ”€â”€ dd
â”‚Â Â  â”œâ”€â”€ e0
â”‚Â Â  â”œâ”€â”€ e1
â”‚Â Â  â”œâ”€â”€ e4
â”‚Â Â  â”œâ”€â”€ e6
â”‚Â Â  â”œâ”€â”€ e7
â”‚Â Â  â”œâ”€â”€ e9
â”‚Â Â  â”œâ”€â”€ ea
â”‚Â Â  â”œâ”€â”€ ee
â”‚Â Â  â”œâ”€â”€ f2
â”‚Â Â  â”œâ”€â”€ f3
â”‚Â Â  â”œâ”€â”€ f4
â”‚Â Â  â”œâ”€â”€ f6
â”‚Â Â  â”œâ”€â”€ f8
â”‚Â Â  â”œâ”€â”€ f9
â”‚Â Â  â”œâ”€â”€ fb
â”‚Â Â  â”œâ”€â”€ fe
â”‚Â Â  â”œâ”€â”€ ff
â”‚Â Â  â”œâ”€â”€ info
â”‚Â Â  â””â”€â”€ pack
â””â”€â”€ refs
    â”œâ”€â”€ heads
    â”œâ”€â”€ remotes
    â””â”€â”€ tags

116 directories, 22 files

ğŸ“„ All files under .git/:
./.git/COMMIT_EDITMSG
./.git/FETCH_HEAD
./.git/HEAD
./.git/ORIG_HEAD
./.git/config
./.git/description
./.git/hooks/applypatch-msg.sample
./.git/hooks/commit-msg.sample
./.git/hooks/fsmonitor-watchman.sample
./.git/hooks/post-update.sample
./.git/hooks/pre-applypatch.sample
./.git/hooks/pre-commit.sample
./.git/hooks/pre-merge-commit.sample
./.git/hooks/pre-push.sample
./.git/hooks/pre-rebase.sample
./.git/hooks/pre-receive.sample
./.git/hooks/prepare-commit-msg.sample
./.git/hooks/push-to-checkout.sample
./.git/hooks/update.sample
./.git/index
./.git/info/exclude
./.git/logs/HEAD
./.git/logs/refs/heads/master
./.git/logs/refs/remotes/origin/master
./.git/objects/00/3d8153b6208b4cc7f0a5e13b62a45c5f9f4c28
./.git/objects/00/75b79ac7f77e9f374abc279d23c34338b0bf6e
./.git/objects/00/ffd9881d30c048ab3e34d0e7b17ac837dd8384
./.git/objects/01/62b29a1256911b782b656da97eba0c8398ae52
./.git/objects/03/49c852995d3c294b047ee0e6dc73924e345d2b
./.git/objects/03/b147458bbabd7b785afb5e3f29c3822dfcf8b3
./.git/objects/03/ee8cd87ba4022d4850369e9c4956db36ca8f20
./.git/objects/04/c048e51fa6ad0272a624d766bcb457c82dee6a
./.git/objects/08/da7274ac0fc28fc87bb97b64ffc0b7edc17d1d
./.git/objects/0b/106e3d642aa35e94e8738537f4ef8ae5b6a200
./.git/objects/0d/773852b753c2494b7cdcea48147c4988cff7d6
./.git/objects/0f/535151fad40e23a6d5ec9a33283dab58f0bebe
./.git/objects/0f/6cb16a904aacae3ad1096e78cd352ed5bccd63
./.git/objects/12/9691fe26f39e800cab8072d034811dd4232538
./.git/objects/13/34e9f02ea424f84e2d12af6212e2e2dee6472a
./.git/objects/14/85133bfd3155ff8ba2d2fbf79e50eef100f7e7
./.git/objects/19/68edbfa76d76d8ddaf0b1252796d8b39fbb14e
./.git/objects/19/c9068d194270e6e05a7c5983db6467b05e3d03
./.git/objects/1e/fc84c52a0ef0de2b387387e3a51c77b6074684
./.git/objects/21/2485ebe7741ac1f4f6bad0c487134bbfeaefa7
./.git/objects/23/360cff5f8922c0a2c88e45ab42acc376674671
./.git/objects/26/ef52d20a37b5930c8021d22bdf9183086fa257
./.git/objects/28/bf5ddacd5aedbadf822f031d37c4d189d67956
./.git/objects/2a/8185415d3a254f8e7da47d6619f13fcd1ffff7
./.git/objects/2c/f0f78343775f63401cc3e026afd7229e8d5993
./.git/objects/2d/c57c597a12d49dd8bb4b56d43a534beed58630
./.git/objects/31/b4c4353301fcd1462af52d14d3afe3d0824504
./.git/objects/31/fd6ff22f7ea5577ff3e44e837d164706dfd693
./.git/objects/32/f52d5692ad60002251f49106167e64ec214c72
./.git/objects/34/ace577520c2526f3d988a3e8fb7e196e983d15
./.git/objects/36/2d7c25bb405a5cc76d0c7518cc240999a574f4
./.git/objects/36/9a9f2e64e1312f7dc865079cc0ddd9271d509f
./.git/objects/3a/525245b6f9383c93cb98f69ed994cbe3af4004
./.git/objects/3b/a269dccfd9b18085c35992719103c50e091dce
./.git/objects/3d/d8c69c3a97830e664ed632b70b8a845ad1fc4c
./.git/objects/3f/cd0a81f79243456ca00f3be03fa02e42c24564
./.git/objects/42/8a16826621e5ffdcb13b429341104a0791a054
./.git/objects/46/1595257ec9349fb805e9429f3cfdd6016ee9ca
./.git/objects/4c/0d99515bc25e3ecd4e308ce997228e9476a5c1
./.git/objects/4c/2f50777701c15600414b5ccf4c9f397b19879e
./.git/objects/4c/ef507b8340cb4fa33e96c204745e4a2595b03a
./.git/objects/4d/ed8605e62ca179168c4bcb93a58cbd2eb2c1ca
./.git/objects/4f/17a1cd58c4b4b4f35375ecac6a6e681de1b0af
./.git/objects/4f/17de6b34b95a70757121306487d09725c6e631
./.git/objects/53/03868ffb6366067b38d0aa54bca649e0ec63b8
./.git/objects/56/3b2429fd5af19d5ab3d2a97264ce18d0a425f1
./.git/objects/56/d8cdbc69d39a7ef36133d88a2e4232e739e6ae
./.git/objects/57/05ee63e64f3888afc1a844869ccc89eef43659
./.git/objects/57/413bfad8e6677042e332a5579e12a208bea13e
./.git/objects/57/7abf3834496a2d2fbbb0e1c0728b0d44f7aac7
./.git/objects/5b/2a39c0977b235cbc36eb877faa869510f07b81
./.git/objects/5e/b370a751268feaf1eb988d1e2e0c9a69ec8d48
./.git/objects/60/ab8ae8883cca93035342a8795a7168f7f0a8d4
./.git/objects/68/3f22dfa4dc1e6af0ca50c37983ce4504dda34e
./.git/objects/69/3ff719bc92b9c5064beaa4edc4dae2385a391b
./.git/objects/6b/8fe9c484c4387ac717f67da7ccc70c9ebad4e8
./.git/objects/6d/56e14e8b53dc7fd6d9c57e426b4c14f8345591
./.git/objects/6d/bc4386c23a1e3302d3a3767bb18f380bdf67ff
./.git/objects/6e/6ab5a0589540de31a359008b15711d3b9ebea0
./.git/objects/6e/d9007a4868b9d6063bc172cd1da6dc142e2c90
./.git/objects/73/d9aa8bfcde597c317eff8efb48c9109d46bc84
./.git/objects/75/7ce21cdf09a950daff9dc82cd02cb0efe735bc
./.git/objects/76/36af77edec3e87bc4bd8a06c6ba2d2335bb65b
./.git/objects/7a/52f1b6c5dbade35e15c0d7f1c4bf2b8d3597d3
./.git/objects/80/6ca8c59d2532f234925400989acf58661403f3
./.git/objects/82/527192b4da2ffa15bcfeccb56d71b5eca35474
./.git/objects/87/635265bdb9d0c64f5c79916c907b8d175ca458
./.git/objects/87/d1e7e340816ed9e0b4292bc3bf4785f2acf342
./.git/objects/8a/34c12730b3922163bd6397624176f3d85da27b
./.git/objects/8b/0d2d4cbe9c1967ba09b1ebc7fa35481b1c5432
./.git/objects/8b/18f29558f963b03c74f78a297728b48e64d90b
./.git/objects/8e/3bd7e4113a087369426a58fa3e294b4d5fc672
./.git/objects/8f/050f8b64d2d22ea2f0b934d19545c1cf76c785
./.git/objects/90/1987c6cacb1d91a364439314476c259291a34e
./.git/objects/90/354670bd9c963fdb6e06e39e2cd3205ecd4433
./.git/objects/91/e47d0b536225d200b4c23255ae586d51e85468
./.git/objects/92/5430940872f6f9a78d16c0c7cd3fb18f5dd3f8
./.git/objects/92/d8cf15fa85a6c3f0edb3441e1e95be0f846b43
./.git/objects/95/86cea75cf874f3d6214120981a7f041611d37e
./.git/objects/97/0d9561966e7d03ee4ba9af5fb46e4708ac9eff
./.git/objects/98/b7dffc400cfe59dfea76bf5a048b3f604b8dbc
./.git/objects/9a/ac0ab47e352df0505eff624b6638ac26896673
./.git/objects/9b/1341040993c2598556fdc772fceae69902a4fb
./.git/objects/9b/232eb3af174e83de4953ac850d01fb3aa9a864
./.git/objects/9c/364d2d01511b88d0affd835c5b983a6e9125e2
./.git/objects/9d/2a4f11494667025a09b96373888bc5131bbc3a
./.git/objects/a1/8dda795714f9133f747f04af119c7ddc9663cf
./.git/objects/a3/a4f3ed0d1ded2961e8ad87516cd45f921202cd
./.git/objects/a4/ad20975810c0d033adedb9b903e7b9ae056003
./.git/objects/a5/1b8ce4d45f88c7c66fa8009961431c0820336c
./.git/objects/a6/9b909e0078779f21bee655de12f79205b32397
./.git/objects/a7/6e59187c780d5b54af634d85f59f825386ed77
./.git/objects/a8/517480b1f07547876ed44bad7bd99c433f7882
./.git/objects/aa/93d9d90cc2468ce083d1b282b8b827937f93e3
./.git/objects/ab/9ca848e4743cb0aac817d5ce784604f0ff76e0
./.git/objects/b0/2529475ec1274c67be6c477e94a68bccd4125b
./.git/objects/be/678b95e51dabb4463a716e0eb0fb069658f4b0
./.git/objects/bf/7debb35877ca4adb3bbabcda030202a2715c01
./.git/objects/bf/c9f9d605264cb6bf5f8ce149994eb91a7ea22c
./.git/objects/c2/e930195fa48ac1ffda5d5667ea5ce9cdd6addf
./.git/objects/c4/0f4e856d473a589982795bb28a7731225fa2d1
./.git/objects/c4/98c636825b979a7171854cfb2a085157f58860
./.git/objects/c6/3bff58e4f98410cab59de84ae59626b51bb539
./.git/objects/c7/4db9e2d8f485a9be45d1a9777bf15591822e34
./.git/objects/c7/779885494d164214dd5fc55b36e3d89e551dd3
./.git/objects/cc/ed418fe02e1be683c0d83189f10c93c8225708
./.git/objects/d0/3395d0e384014ea5c8927ffc4f956ab3e9cdce
./.git/objects/d0/9d668d537526fb41c1e08b1ecb53c1260c60b3
./.git/objects/d5/137ca5f82299919a28016efb2fc241cad7dae8
./.git/objects/db/11f09c3c6943d0fc6950bc45dff0e79973e594
./.git/objects/dc/57b0d83efd33a27899736b758aa6e548ba800d
./.git/objects/dd/e56cb9c0a13a24e3f7b2315eeabf442eb05e6f
./.git/objects/e0/9c2a18408c0fb60149b889dcfa061fbbc7f7df
./.git/objects/e0/b3229a1749e98e05191bdeac59f7b5df89f817
./.git/objects/e1/b9aa4ab50de345f4d5f0cf7013f6026aa015e3
./.git/objects/e4/b1c8a326b911c0a1c3e9d25b6657cb0aa10211
./.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
./.git/objects/e7/ccf6d39b2aecc422ac47217c888114dad5429b
./.git/objects/e9/55e50f93ea7891301582e59cb26c27a2643f15
./.git/objects/e9/63ff7bcf20ad4145100b641eddc5c6f3188c86
./.git/objects/ea/dc0da0da649f11696c1efc547d815d356fa0b6
./.git/objects/ee/1302eeb77083076390ec776cbaa6a8544e3da6
./.git/objects/f2/a7004d47cc3e1ead507554d0edec58e0e39ea4
./.git/objects/f3/1d06387a04ee4f281495b38c80994855cbf58e
./.git/objects/f4/9b7e7a235aff76a164b9d3454fa6cbd68c40a6
./.git/objects/f6/7262f4bfe141d7ce178e298d844a4a9b35050d
./.git/objects/f6/d10d1f107c61906ae0a75f0f7b1a358378fbd2
./.git/objects/f8/75745f04c23745cd4cca92652c07f35ede88ac
./.git/objects/f9/071ef85bfd75df8bb284f778a43f3cbb4bdb3b
./.git/objects/f9/c1932cb1e30fbc41ad60a7e17134eb2c05c564
./.git/objects/fb/2b39f25c7fd31cd2cc5e86e53f9ad57790f33d
./.git/objects/fb/389fe5beef2982ed9f0c883ec462985eea371d
./.git/objects/fe/985d8874727a3def0c7a93a0ecd927765189ca
./.git/objects/ff/e12e30607f2f3334d719d382db3bbc0c21d924
./.git/refs/heads/master
./.git/refs/remotes/origin/master

ğŸ“„ Contents of files under .git/:











ğŸ”¥ File: ./.git/objects/76/36af77edec3e87bc4bd8a06c6ba2d2335bb65b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/73/d9aa8bfcde597c317eff8efb48c9109d46bc84
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/2c/f0f78343775f63401cc3e026afd7229e8d5993
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/14/85133bfd3155ff8ba2d2fbf79e50eef100f7e7
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/dd/e56cb9c0a13a24e3f7b2315eeabf442eb05e6f
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/12/9691fe26f39e800cab8072d034811dd4232538
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e4/b1c8a326b911c0a1c3e9d25b6657cb0aa10211
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e9/63ff7bcf20ad4145100b641eddc5c6f3188c86
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e9/55e50f93ea7891301582e59cb26c27a2643f15
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/46/1595257ec9349fb805e9429f3cfdd6016ee9ca
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e1/b9aa4ab50de345f4d5f0cf7013f6026aa015e3
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/0d/773852b753c2494b7cdcea48147c4988cff7d6
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/4c/0d99515bc25e3ecd4e308ce997228e9476a5c1
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/4c/2f50777701c15600414b5ccf4c9f397b19879e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/4c/ef507b8340cb4fa33e96c204745e4a2595b03a
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/19/68edbfa76d76d8ddaf0b1252796d8b39fbb14e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/19/c9068d194270e6e05a7c5983db6467b05e3d03
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/cc/ed418fe02e1be683c0d83189f10c93c8225708
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/0b/106e3d642aa35e94e8738537f4ef8ae5b6a200
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/21/2485ebe7741ac1f4f6bad0c487134bbfeaefa7
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/42/8a16826621e5ffdcb13b429341104a0791a054
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/a8/517480b1f07547876ed44bad7bd99c433f7882
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/3f/cd0a81f79243456ca00f3be03fa02e42c24564
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/fb/389fe5beef2982ed9f0c883ec462985eea371d
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/fb/2b39f25c7fd31cd2cc5e86e53f9ad57790f33d
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/6d/bc4386c23a1e3302d3a3767bb18f380bdf67ff
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/6d/56e14e8b53dc7fd6d9c57e426b4c14f8345591
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/01/62b29a1256911b782b656da97eba0c8398ae52
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/04/c048e51fa6ad0272a624d766bcb457c82dee6a
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/ea/dc0da0da649f11696c1efc547d815d356fa0b6
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/9a/ac0ab47e352df0505eff624b6638ac26896673
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/9b/232eb3af174e83de4953ac850d01fb3aa9a864
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/9b/1341040993c2598556fdc772fceae69902a4fb
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/ab/9ca848e4743cb0aac817d5ce784604f0ff76e0
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/dc/57b0d83efd33a27899736b758aa6e548ba800d
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f9/c1932cb1e30fbc41ad60a7e17134eb2c05c564
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f9/071ef85bfd75df8bb284f778a43f3cbb4bdb3b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/00/3d8153b6208b4cc7f0a5e13b62a45c5f9f4c28
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/00/ffd9881d30c048ab3e34d0e7b17ac837dd8384
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/00/75b79ac7f77e9f374abc279d23c34338b0bf6e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/82/527192b4da2ffa15bcfeccb56d71b5eca35474
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/53/03868ffb6366067b38d0aa54bca649e0ec63b8
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/a4/ad20975810c0d033adedb9b903e7b9ae056003
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/c4/0f4e856d473a589982795bb28a7731225fa2d1
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/c4/98c636825b979a7171854cfb2a085157f58860
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/68/3f22dfa4dc1e6af0ca50c37983ce4504dda34e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/a3/a4f3ed0d1ded2961e8ad87516cd45f921202cd
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/a6/9b909e0078779f21bee655de12f79205b32397
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/9d/2a4f11494667025a09b96373888bc5131bbc3a
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/60/ab8ae8883cca93035342a8795a7168f7f0a8d4
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/c7/4db9e2d8f485a9be45d1a9777bf15591822e34
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/c7/779885494d164214dd5fc55b36e3d89e551dd3
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/13/34e9f02ea424f84e2d12af6212e2e2dee6472a
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e0/b3229a1749e98e05191bdeac59f7b5df89f817
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e0/9c2a18408c0fb60149b889dcfa061fbbc7f7df
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/28/bf5ddacd5aedbadf822f031d37c4d189d67956
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/95/86cea75cf874f3d6214120981a7f041611d37e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/34/ace577520c2526f3d988a3e8fb7e196e983d15
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/5b/2a39c0977b235cbc36eb877faa869510f07b81
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/69/3ff719bc92b9c5064beaa4edc4dae2385a391b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/ee/1302eeb77083076390ec776cbaa6a8544e3da6
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/36/9a9f2e64e1312f7dc865079cc0ddd9271d509f
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/36/2d7c25bb405a5cc76d0c7518cc240999a574f4
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/32/f52d5692ad60002251f49106167e64ec214c72
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/2a/8185415d3a254f8e7da47d6619f13fcd1ffff7
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f3/1d06387a04ee4f281495b38c80994855cbf58e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/4d/ed8605e62ca179168c4bcb93a58cbd2eb2c1ca
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/4f/17a1cd58c4b4b4f35375ecac6a6e681de1b0af
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/4f/17de6b34b95a70757121306487d09725c6e631
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/56/d8cdbc69d39a7ef36133d88a2e4232e739e6ae
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/56/3b2429fd5af19d5ab3d2a97264ce18d0a425f1
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/aa/93d9d90cc2468ce083d1b282b8b827937f93e3
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/1e/fc84c52a0ef0de2b387387e3a51c77b6074684
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/87/635265bdb9d0c64f5c79916c907b8d175ca458
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/87/d1e7e340816ed9e0b4292bc3bf4785f2acf342
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f2/a7004d47cc3e1ead507554d0edec58e0e39ea4
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f6/7262f4bfe141d7ce178e298d844a4a9b35050d
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f6/d10d1f107c61906ae0a75f0f7b1a358378fbd2
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/08/da7274ac0fc28fc87bb97b64ffc0b7edc17d1d
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/8f/050f8b64d2d22ea2f0b934d19545c1cf76c785
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/92/5430940872f6f9a78d16c0c7cd3fb18f5dd3f8
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/92/d8cf15fa85a6c3f0edb3441e1e95be0f846b43
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/91/e47d0b536225d200b4c23255ae586d51e85468
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f8/75745f04c23745cd4cca92652c07f35ede88ac
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/c6/3bff58e4f98410cab59de84ae59626b51bb539
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/9c/364d2d01511b88d0affd835c5b983a6e9125e2
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/c2/e930195fa48ac1ffda5d5667ea5ce9cdd6addf
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/80/6ca8c59d2532f234925400989acf58661403f3
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/57/7abf3834496a2d2fbbb0e1c0728b0d44f7aac7
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/57/413bfad8e6677042e332a5579e12a208bea13e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/57/05ee63e64f3888afc1a844869ccc89eef43659
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/a1/8dda795714f9133f747f04af119c7ddc9663cf
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/03/ee8cd87ba4022d4850369e9c4956db36ca8f20
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/03/b147458bbabd7b785afb5e3f29c3822dfcf8b3
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/03/49c852995d3c294b047ee0e6dc73924e345d2b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/6b/8fe9c484c4387ac717f67da7ccc70c9ebad4e8
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/0f/6cb16a904aacae3ad1096e78cd352ed5bccd63
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/0f/535151fad40e23a6d5ec9a33283dab58f0bebe
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/8b/0d2d4cbe9c1967ba09b1ebc7fa35481b1c5432
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/8b/18f29558f963b03c74f78a297728b48e64d90b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/db/11f09c3c6943d0fc6950bc45dff0e79973e594
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/d5/137ca5f82299919a28016efb2fc241cad7dae8
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/bf/c9f9d605264cb6bf5f8ce149994eb91a7ea22c
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/bf/7debb35877ca4adb3bbabcda030202a2715c01
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/23/360cff5f8922c0a2c88e45ab42acc376674671
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/26/ef52d20a37b5930c8021d22bdf9183086fa257
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/3a/525245b6f9383c93cb98f69ed994cbe3af4004
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/7a/52f1b6c5dbade35e15c0d7f1c4bf2b8d3597d3
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/a5/1b8ce4d45f88c7c66fa8009961431c0820336c
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/b0/2529475ec1274c67be6c477e94a68bccd4125b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/d0/9d668d537526fb41c1e08b1ecb53c1260c60b3
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/d0/3395d0e384014ea5c8927ffc4f956ab3e9cdce
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/98/b7dffc400cfe59dfea76bf5a048b3f604b8dbc
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/be/678b95e51dabb4463a716e0eb0fb069658f4b0
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/a7/6e59187c780d5b54af634d85f59f825386ed77
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/31/fd6ff22f7ea5577ff3e44e837d164706dfd693
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/31/b4c4353301fcd1462af52d14d3afe3d0824504
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/97/0d9561966e7d03ee4ba9af5fb46e4708ac9eff
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/e7/ccf6d39b2aecc422ac47217c888114dad5429b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/3b/a269dccfd9b18085c35992719103c50e091dce
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/5e/b370a751268feaf1eb988d1e2e0c9a69ec8d48
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/8a/34c12730b3922163bd6397624176f3d85da27b
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/8e/3bd7e4113a087369426a58fa3e294b4d5fc672
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/fe/985d8874727a3def0c7a93a0ecd927765189ca
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/75/7ce21cdf09a950daff9dc82cd02cb0efe735bc
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/3d/d8c69c3a97830e664ed632b70b8a845ad1fc4c
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/6e/6ab5a0589540de31a359008b15711d3b9ebea0
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/6e/d9007a4868b9d6063bc172cd1da6dc142e2c90
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/2d/c57c597a12d49dd8bb4b56d43a534beed58630
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/90/1987c6cacb1d91a364439314476c259291a34e
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/90/354670bd9c963fdb6e06e39e2cd3205ecd4433
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/ff/e12e30607f2f3334d719d382db3bbc0c21d924
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/objects/f4/9b7e7a235aff76a164b9d3454fa6cbd68c40a6
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/description
=================================================
Unnamed repository; edit this file 'description' to name the repository.











ğŸ”¥ File: ./.git/refs/remotes/origin/master
=================================================
e09c2a18408c0fb60149b889dcfa061fbbc7f7df











ğŸ”¥ File: ./.git/refs/heads/master
=================================================
e09c2a18408c0fb60149b889dcfa061fbbc7f7df











ğŸ”¥ File: ./.git/ORIG_HEAD
=================================================
4f17a1cd58c4b4b4f35375ecac6a6e681de1b0af











ğŸ”¥ File: ./.git/index
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./.git/FETCH_HEAD
=================================================
e09c2a18408c0fb60149b889dcfa061fbbc7f7df		branch 'master' of https://github.com/verysys-pal/USB1608G_2AO_V2











ğŸ”¥ File: ./.git/config
=================================================
[core]
	repositoryformatversion = 0
	filemode = true
	bare = false
	logallrefupdates = true
[remote "origin"]
	url = https://github.com/verysys-pal/USB1608G_2AO_V2.git
	fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
	remote = origin
	merge = refs/heads/master











ğŸ”¥ File: ./.git/COMMIT_EDITMSG
=================================================
ğŸ‰











ğŸ”¥ File: ./.git/logs/refs/remotes/origin/master
=================================================
0000000000000000000000000000000000000000 4f17a1cd58c4b4b4f35375ecac6a6e681de1b0af sysSTEP3 <tedanipal@gmail.com> 1756559960 +0900	update by push
4f17a1cd58c4b4b4f35375ecac6a6e681de1b0af e09c2a18408c0fb60149b889dcfa061fbbc7f7df sysSTEP3 <tedanipal@gmail.com> 1756560053 +0900	fetch: fast-forward











ğŸ”¥ File: ./.git/logs/refs/heads/master
=================================================
0000000000000000000000000000000000000000 4f17a1cd58c4b4b4f35375ecac6a6e681de1b0af sysSTEP3 <tedanipal@gmail.com> 1756559949 +0900	commit (initial): ğŸ‰
4f17a1cd58c4b4b4f35375ecac6a6e681de1b0af e09c2a18408c0fb60149b889dcfa061fbbc7f7df sysSTEP3 <tedanipal@gmail.com> 1756560055 +0900	pull --tags origin master: Fast-forward











ğŸ”¥ File: ./.git/logs/HEAD
=================================================
0000000000000000000000000000000000000000 4f17a1cd58c4b4b4f35375ecac6a6e681de1b0af sysSTEP3 <tedanipal@gmail.com> 1756559949 +0900	commit (initial): ğŸ‰
4f17a1cd58c4b4b4f35375ecac6a6e681de1b0af e09c2a18408c0fb60149b889dcfa061fbbc7f7df sysSTEP3 <tedanipal@gmail.com> 1756560055 +0900	pull --tags origin master: Fast-forward











ğŸ”¥ File: ./.git/HEAD
=================================================
ref: refs/heads/master











ğŸ”¥ File: ./.git/info/exclude
=================================================
# git ls-files --others --exclude-from=.git/info/exclude
# Lines that start with '#' are comments.
# For a project mostly in C, the following would be a good set of
# exclude patterns (uncomment them if you want to use them):
# *.[oa]
# *~











ğŸ”¥ File: ./.git/hooks/pre-push.sample
=================================================
#!/bin/sh

# An example hook script to verify what is about to be pushed.  Called by "git
# push" after it has checked the remote status, but before anything has been
# pushed.  If this script exits with a non-zero status nothing will be pushed.
#
# This hook is called with the following parameters:
#
# $1 -- Name of the remote to which the push is being done
# $2 -- URL to which the push is being done
#
# If pushing without using a named remote those arguments will be equal.
#
# Information about the commits which are being pushed is supplied as lines to
# the standard input in the form:
#
#   <local ref> <local oid> <remote ref> <remote oid>
#
# This sample shows how to prevent push of commits where the log message starts
# with "WIP" (work in progress).

remote="$1"
url="$2"

zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')

while read local_ref local_oid remote_ref remote_oid
do
	if test "$local_oid" = "$zero"
	then
		# Handle delete
		:
	else
		if test "$remote_oid" = "$zero"
		then
			# New branch, examine all commits
			range="$local_oid"
		else
			# Update to existing branch, examine new commits
			range="$remote_oid..$local_oid"
		fi

		# Check for WIP commit
		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
		if test -n "$commit"
		then
			echo >&2 "Found WIP commit in $local_ref, not pushing"
			exit 1
		fi
	fi
done

exit 0











ğŸ”¥ File: ./.git/hooks/post-update.sample
=================================================
#!/bin/sh
#
# An example hook script to prepare a packed repository for use over
# dumb transports.
#
# To enable this hook, rename this file to "post-update".

exec git update-server-info











ğŸ”¥ File: ./.git/hooks/pre-rebase.sample
=================================================
#!/bin/sh
#
# Copyright (c) 2006, 2008 Junio C Hamano
#
# The "pre-rebase" hook is run just before "git rebase" starts doing
# its job, and can prevent the command from running by exiting with
# non-zero status.
#
# The hook is called with the following parameters:
#
# $1 -- the upstream the series was forked from.
# $2 -- the branch being rebased (or empty when rebasing the current branch).
#
# This sample shows how to prevent topic branches that are already
# merged to 'next' branch from getting rebased, because allowing it
# would result in rebasing already published history.

publish=next
basebranch="$1"
if test "$#" = 2
then
	topic="refs/heads/$2"
else
	topic=`git symbolic-ref HEAD` ||
	exit 0 ;# we do not interrupt rebasing detached HEAD
fi

case "$topic" in
refs/heads/??/*)
	;;
*)
	exit 0 ;# we do not interrupt others.
	;;
esac

# Now we are dealing with a topic branch being rebased
# on top of master.  Is it OK to rebase it?

# Does the topic really exist?
git show-ref -q "$topic" || {
	echo >&2 "No such branch $topic"
	exit 1
}

# Is topic fully merged to master?
not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
if test -z "$not_in_master"
then
	echo >&2 "$topic is fully merged to master; better remove it."
	exit 1 ;# we could allow it, but there is no point.
fi

# Is topic ever merged to next?  If so you should not be rebasing it.
only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
only_next_2=`git rev-list ^master           ${publish} | sort`
if test "$only_next_1" = "$only_next_2"
then
	not_in_topic=`git rev-list "^$topic" master`
	if test -z "$not_in_topic"
	then
		echo >&2 "$topic is already up to date with master"
		exit 1 ;# we could allow it, but there is no point.
	else
		exit 0
	fi
else
	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
	/usr/bin/perl -e '
		my $topic = $ARGV[0];
		my $msg = "* $topic has commits already merged to public branch:\n";
		my (%not_in_next) = map {
			/^([0-9a-f]+) /;
			($1 => 1);
		} split(/\n/, $ARGV[1]);
		for my $elem (map {
				/^([0-9a-f]+) (.*)$/;
				[$1 => $2];
			} split(/\n/, $ARGV[2])) {
			if (!exists $not_in_next{$elem->[0]}) {
				if ($msg) {
					print STDERR $msg;
					undef $msg;
				}
				print STDERR " $elem->[1]\n";
			}
		}
	' "$topic" "$not_in_next" "$not_in_master"
	exit 1
fi

<<\DOC_END

This sample hook safeguards topic branches that have been
published from being rewound.

The workflow assumed here is:

 * Once a topic branch forks from "master", "master" is never
   merged into it again (either directly or indirectly).

 * Once a topic branch is fully cooked and merged into "master",
   it is deleted.  If you need to build on top of it to correct
   earlier mistakes, a new topic branch is created by forking at
   the tip of the "master".  This is not strictly necessary, but
   it makes it easier to keep your history simple.

 * Whenever you need to test or publish your changes to topic
   branches, merge them into "next" branch.

The script, being an example, hardcodes the publish branch name
to be "next", but it is trivial to make it configurable via
$GIT_DIR/config mechanism.

With this workflow, you would want to know:

(1) ... if a topic branch has ever been merged to "next".  Young
    topic branches can have stupid mistakes you would rather
    clean up before publishing, and things that have not been
    merged into other branches can be easily rebased without
    affecting other people.  But once it is published, you would
    not want to rewind it.

(2) ... if a topic branch has been fully merged to "master".
    Then you can delete it.  More importantly, you should not
    build on top of it -- other people may already want to
    change things related to the topic as patches against your
    "master", so if you need further changes, it is better to
    fork the topic (perhaps with the same name) afresh from the
    tip of "master".

Let's look at this example:

		   o---o---o---o---o---o---o---o---o---o "next"
		  /       /           /           /
		 /   a---a---b A     /           /
		/   /               /           /
	       /   /   c---c---c---c B         /
	      /   /   /             \         /
	     /   /   /   b---b C     \       /
	    /   /   /   /             \     /
    ---o---o---o---o---o---o---o---o---o---o---o "master"


A, B and C are topic branches.

 * A has one fix since it was merged up to "next".

 * B has finished.  It has been fully merged up to "master" and "next",
   and is ready to be deleted.

 * C has not merged to "next" at all.

We would want to allow C to be rebased, refuse A, and encourage
B to be deleted.

To compute (1):

	git rev-list ^master ^topic next
	git rev-list ^master        next

	if these match, topic has not merged in next at all.

To compute (2):

	git rev-list master..topic

	if this is empty, it is fully merged to "master".

DOC_END











ğŸ”¥ File: ./.git/hooks/prepare-commit-msg.sample
=================================================
#!/bin/sh
#
# An example hook script to prepare the commit log message.
# Called by "git commit" with the name of the file that has the
# commit message, followed by the description of the commit
# message's source.  The hook's purpose is to edit the commit
# message file.  If the hook fails with a non-zero status,
# the commit is aborted.
#
# To enable this hook, rename this file to "prepare-commit-msg".

# This hook includes three examples. The first one removes the
# "# Please enter the commit message..." help message.
#
# The second includes the output of "git diff --name-status -r"
# into the message, just before the "git status" output.  It is
# commented because it doesn't cope with --amend or with squashed
# commits.
#
# The third example adds a Signed-off-by line to the message, that can
# still be edited.  This is rarely a good idea.

COMMIT_MSG_FILE=$1
COMMIT_SOURCE=$2
SHA1=$3

/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"

# case "$COMMIT_SOURCE,$SHA1" in
#  ,|template,)
#    /usr/bin/perl -i.bak -pe '
#       print "\n" . `git diff --cached --name-status -r`
# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
#  *) ;;
# esac

# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
# if test -z "$COMMIT_SOURCE"
# then
#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
# fi











ğŸ”¥ File: ./.git/hooks/pre-applypatch.sample
=================================================
#!/bin/sh
#
# An example hook script to verify what is about to be committed
# by applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-applypatch".

. git-sh-setup
precommit="$(git rev-parse --git-path hooks/pre-commit)"
test -x "$precommit" && exec "$precommit" ${1+"$@"}
:











ğŸ”¥ File: ./.git/hooks/pre-merge-commit.sample
=================================================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git merge" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message to
# stderr if it wants to stop the merge commit.
#
# To enable this hook, rename this file to "pre-merge-commit".

. git-sh-setup
test -x "$GIT_DIR/hooks/pre-commit" &&
        exec "$GIT_DIR/hooks/pre-commit"
:











ğŸ”¥ File: ./.git/hooks/pre-receive.sample
=================================================
#!/bin/sh
#
# An example hook script to make use of push options.
# The example simply echoes all push options that start with 'echoback='
# and rejects all pushes when the "reject" push option is used.
#
# To enable this hook, rename this file to "pre-receive".

if test -n "$GIT_PUSH_OPTION_COUNT"
then
	i=0
	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
	do
		eval "value=\$GIT_PUSH_OPTION_$i"
		case "$value" in
		echoback=*)
			echo "echo from the pre-receive-hook: ${value#*=}" >&2
			;;
		reject)
			exit 1
		esac
		i=$((i + 1))
	done
fi











ğŸ”¥ File: ./.git/hooks/commit-msg.sample
=================================================
#!/bin/sh
#
# An example hook script to check the commit log message.
# Called by "git commit" with one argument, the name of the file
# that has the commit message.  The hook should exit with non-zero
# status after issuing an appropriate message if it wants to stop the
# commit.  The hook is allowed to edit the commit message file.
#
# To enable this hook, rename this file to "commit-msg".

# Uncomment the below to add a Signed-off-by line to the message.
# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
# hook is more suited to it.
#
# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"

# This example catches duplicate Signed-off-by lines.

test "" = "$(grep '^Signed-off-by: ' "$1" |
	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
	echo >&2 Duplicate Signed-off-by lines.
	exit 1
}











ğŸ”¥ File: ./.git/hooks/fsmonitor-watchman.sample
=================================================
#!/usr/bin/perl

use strict;
use warnings;
use IPC::Open2;

# An example hook script to integrate Watchman
# (https://facebook.github.io/watchman/) with git to speed up detecting
# new and modified files.
#
# The hook is passed a version (currently 2) and last update token
# formatted as a string and outputs to stdout a new update token and
# all files that have been modified since the update token. Paths must
# be relative to the root of the working tree and separated by a single NUL.
#
# To enable this hook, rename this file to "query-watchman" and set
# 'git config core.fsmonitor .git/hooks/query-watchman'
#
my ($version, $last_update_token) = @ARGV;

# Uncomment for debugging
# print STDERR "$0 $version $last_update_token\n";

# Check the hook interface version
if ($version ne 2) {
	die "Unsupported query-fsmonitor hook version '$version'.\n" .
	    "Falling back to scanning...\n";
}

my $git_work_tree = get_working_dir();

my $retry = 1;

my $json_pkg;
eval {
	require JSON::XS;
	$json_pkg = "JSON::XS";
	1;
} or do {
	require JSON::PP;
	$json_pkg = "JSON::PP";
};

launch_watchman();

sub launch_watchman {
	my $o = watchman_query();
	if (is_work_tree_watched($o)) {
		output_result($o->{clock}, @{$o->{files}});
	}
}

sub output_result {
	my ($clockid, @files) = @_;

	# Uncomment for debugging watchman output
	# open (my $fh, ">", ".git/watchman-output.out");
	# binmode $fh, ":utf8";
	# print $fh "$clockid\n@files\n";
	# close $fh;

	binmode STDOUT, ":utf8";
	print $clockid;
	print "\0";
	local $, = "\0";
	print @files;
}

sub watchman_clock {
	my $response = qx/watchman clock "$git_work_tree"/;
	die "Failed to get clock id on '$git_work_tree'.\n" .
		"Falling back to scanning...\n" if $? != 0;

	return $json_pkg->new->utf8->decode($response);
}

sub watchman_query {
	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
	or die "open2() failed: $!\n" .
	"Falling back to scanning...\n";

	# In the query expression below we're asking for names of files that
	# changed since $last_update_token but not from the .git folder.
	#
	# To accomplish this, we're using the "since" generator to use the
	# recency index to select candidate nodes and "fields" to limit the
	# output to file names only. Then we're using the "expression" term to
	# further constrain the results.
	if (substr($last_update_token, 0, 1) eq "c") {
		$last_update_token = "\"$last_update_token\"";
	}
	my $query = <<"	END";
		["query", "$git_work_tree", {
			"since": $last_update_token,
			"fields": ["name"],
			"expression": ["not", ["dirname", ".git"]]
		}]
	END

	# Uncomment for debugging the watchman query
	# open (my $fh, ">", ".git/watchman-query.json");
	# print $fh $query;
	# close $fh;

	print CHLD_IN $query;
	close CHLD_IN;
	my $response = do {local $/; <CHLD_OUT>};

	# Uncomment for debugging the watch response
	# open ($fh, ">", ".git/watchman-response.json");
	# print $fh $response;
	# close $fh;

	die "Watchman: command returned no output.\n" .
	"Falling back to scanning...\n" if $response eq "";
	die "Watchman: command returned invalid output: $response\n" .
	"Falling back to scanning...\n" unless $response =~ /^\{/;

	return $json_pkg->new->utf8->decode($response);
}

sub is_work_tree_watched {
	my ($output) = @_;
	my $error = $output->{error};
	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
		$retry--;
		my $response = qx/watchman watch "$git_work_tree"/;
		die "Failed to make watchman watch '$git_work_tree'.\n" .
		    "Falling back to scanning...\n" if $? != 0;
		$output = $json_pkg->new->utf8->decode($response);
		$error = $output->{error};
		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		# Uncomment for debugging watchman output
		# open (my $fh, ">", ".git/watchman-output.out");
		# close $fh;

		# Watchman will always return all files on the first query so
		# return the fast "everything is dirty" flag to git and do the
		# Watchman query just to get it over with now so we won't pay
		# the cost in git to look up each individual file.
		my $o = watchman_clock();
		$error = $output->{error};

		die "Watchman: $error.\n" .
		"Falling back to scanning...\n" if $error;

		output_result($o->{clock}, ("/"));
		$last_update_token = $o->{clock};

		eval { launch_watchman() };
		return 0;
	}

	die "Watchman: $error.\n" .
	"Falling back to scanning...\n" if $error;

	return 1;
}

sub get_working_dir {
	my $working_dir;
	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
		$working_dir = Win32::GetCwd();
		$working_dir =~ tr/\\/\//;
	} else {
		require Cwd;
		$working_dir = Cwd::cwd();
	}

	return $working_dir;
}











ğŸ”¥ File: ./.git/hooks/applypatch-msg.sample
=================================================
#!/bin/sh
#
# An example hook script to check the commit log message taken by
# applypatch from an e-mail message.
#
# The hook should exit with non-zero status after issuing an
# appropriate message if it wants to stop the commit.  The hook is
# allowed to edit the commit message file.
#
# To enable this hook, rename this file to "applypatch-msg".

. git-sh-setup
commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
:











ğŸ”¥ File: ./.git/hooks/update.sample
=================================================
#!/bin/sh
#
# An example hook script to block unannotated tags from entering.
# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
#
# To enable this hook, rename this file to "update".
#
# Config
# ------
# hooks.allowunannotated
#   This boolean sets whether unannotated tags will be allowed into the
#   repository.  By default they won't be.
# hooks.allowdeletetag
#   This boolean sets whether deleting tags will be allowed in the
#   repository.  By default they won't be.
# hooks.allowmodifytag
#   This boolean sets whether a tag may be modified after creation. By default
#   it won't be.
# hooks.allowdeletebranch
#   This boolean sets whether deleting branches will be allowed in the
#   repository.  By default they won't be.
# hooks.denycreatebranch
#   This boolean sets whether remotely creating branches will be denied
#   in the repository.  By default this is allowed.
#

# --- Command line
refname="$1"
oldrev="$2"
newrev="$3"

# --- Safety check
if [ -z "$GIT_DIR" ]; then
	echo "Don't run this script from the command line." >&2
	echo " (if you want, you could supply GIT_DIR then run" >&2
	echo "  $0 <ref> <oldrev> <newrev>)" >&2
	exit 1
fi

if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
	exit 1
fi

# --- Config
allowunannotated=$(git config --type=bool hooks.allowunannotated)
allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
allowmodifytag=$(git config --type=bool hooks.allowmodifytag)

# check for no description
projectdesc=$(sed -e '1q' "$GIT_DIR/description")
case "$projectdesc" in
"Unnamed repository"* | "")
	echo "*** Project description file hasn't been set" >&2
	exit 1
	;;
esac

# --- Check types
# if $newrev is 0000...0000, it's a commit to delete a ref.
zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
if [ "$newrev" = "$zero" ]; then
	newrev_type=delete
else
	newrev_type=$(git cat-file -t $newrev)
fi

case "$refname","$newrev_type" in
	refs/tags/*,commit)
		# un-annotated tag
		short_refname=${refname##refs/tags/}
		if [ "$allowunannotated" != "true" ]; then
			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
			exit 1
		fi
		;;
	refs/tags/*,delete)
		# delete tag
		if [ "$allowdeletetag" != "true" ]; then
			echo "*** Deleting a tag is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/tags/*,tag)
		# annotated tag
		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
		then
			echo "*** Tag '$refname' already exists." >&2
			echo "*** Modifying a tag is not allowed in this repository." >&2
			exit 1
		fi
		;;
	refs/heads/*,commit)
		# branch
		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
			echo "*** Creating a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/heads/*,delete)
		# delete branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	refs/remotes/*,commit)
		# tracking branch
		;;
	refs/remotes/*,delete)
		# delete tracking branch
		if [ "$allowdeletebranch" != "true" ]; then
			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
			exit 1
		fi
		;;
	*)
		# Anything else (is there anything else?)
		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
		exit 1
		;;
esac

# --- Finished
exit 0











ğŸ”¥ File: ./.git/hooks/pre-commit.sample
=================================================
#!/bin/sh
#
# An example hook script to verify what is about to be committed.
# Called by "git commit" with no arguments.  The hook should
# exit with non-zero status after issuing an appropriate message if
# it wants to stop the commit.
#
# To enable this hook, rename this file to "pre-commit".

if git rev-parse --verify HEAD >/dev/null 2>&1
then
	against=HEAD
else
	# Initial commit: diff against an empty tree object
	against=$(git hash-object -t tree /dev/null)
fi

# If you want to allow non-ASCII filenames set this variable to true.
allownonascii=$(git config --type=bool hooks.allownonascii)

# Redirect output to stderr.
exec 1>&2

# Cross platform projects tend to avoid non-ASCII filenames; prevent
# them from being added to the repository. We exploit the fact that the
# printable range starts at the space character and ends with tilde.
if [ "$allownonascii" != "true" ] &&
	# Note that the use of brackets around a tr range is ok here, (it's
	# even required, for portability to Solaris 10's /usr/bin/tr), since
	# the square bracket bytes happen to fall in the designated range.
	test $(git diff --cached --name-only --diff-filter=A -z $against |
	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
then
	cat <<\EOF
Error: Attempt to add a non-ASCII file name.

This can cause problems if you want to work with people on other platforms.

To be portable it is advisable to rename the file.

If you know what you are doing you can disable this check using:

  git config hooks.allownonascii true
EOF
	exit 1
fi

# If there are whitespace errors, print the offending file names and fail.
exec git diff-index --check --cached $against --











ğŸ”¥ File: ./.git/hooks/push-to-checkout.sample
=================================================
#!/bin/sh

# An example hook script to update a checked-out tree on a git push.
#
# This hook is invoked by git-receive-pack(1) when it reacts to git
# push and updates reference(s) in its repository, and when the push
# tries to update the branch that is currently checked out and the
# receive.denyCurrentBranch configuration variable is set to
# updateInstead.
#
# By default, such a push is refused if the working tree and the index
# of the remote repository has any difference from the currently
# checked out commit; when both the working tree and the index match
# the current commit, they are updated to match the newly pushed tip
# of the branch. This hook is to be used to override the default
# behaviour; however the code below reimplements the default behaviour
# as a starting point for convenient modification.
#
# The hook receives the commit with which the tip of the current
# branch is going to be updated:
commit=$1

# It can exit with a non-zero status to refuse the push (when it does
# so, it must not modify the index or the working tree).
die () {
	echo >&2 "$*"
	exit 1
}

# Or it can make any necessary changes to the working tree and to the
# index to bring them to the desired state when the tip of the current
# branch is updated to the new commit, and exit with a zero status.
#
# For example, the hook can simply run git read-tree -u -m HEAD "$1"
# in order to emulate git fetch that is run in the reverse direction
# with git push, as the two-tree form of git read-tree -u -m is
# essentially the same as git switch or git checkout that switches
# branches while keeping the local changes in the working tree that do
# not interfere with the difference between the branches.

# The below is a more-or-less exact translation to shell of the C code
# for the default behaviour for git's push-to-checkout hook defined in
# the push_to_deploy() function in builtin/receive-pack.c.
#
# Note that the hook will be executed from the repository directory,
# not from the working tree, so if you want to perform operations on
# the working tree, you will have to adapt your code accordingly, e.g.
# by adding "cd .." or using relative paths.

if ! git update-index -q --ignore-submodules --refresh
then
	die "Up-to-date check failed"
fi

if ! git diff-files --quiet --ignore-submodules --
then
	die "Working directory has unstaged changes"
fi

# This is a rough translation of:
#
#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
if git cat-file -e HEAD 2>/dev/null
then
	head=HEAD
else
	head=$(git hash-object -t tree --stdin </dev/null)
fi

if ! git diff-index --quiet --cached --ignore-submodules $head --
then
	die "Working directory has staged changes"
fi

if ! git read-tree -u -m "$commit"
then
	die "Could not update working tree to new HEAD"
fi




















































ğŸŸ¦ 03_SUBDIRECTORY: USB1608G_2AO_V2App
ğŸ“ tree -L 2 of USB1608G_2AO_V2App/
./USB1608G_2AO_V2App
â”œâ”€â”€ Db
â”‚Â Â  â”œâ”€â”€ Makefile
â”‚Â Â  â”œâ”€â”€ O.Common
â”‚Â Â  â”œâ”€â”€ O.linux-x86_64
â”‚Â Â  â”œâ”€â”€ USB1608G_2AO.substitutions
â”‚Â Â  â”œâ”€â”€ USB1608G_2AO_settings.req
â”‚Â Â  â”œâ”€â”€ measCompAnalogIn.template
â”‚Â Â  â”œâ”€â”€ measCompAnalogInMode.template
â”‚Â Â  â”œâ”€â”€ measCompAnalogInMode_settings.req
â”‚Â Â  â”œâ”€â”€ measCompAnalogIn_settings.req
â”‚Â Â  â”œâ”€â”€ measCompAnalogOut.template
â”‚Â Â  â”œâ”€â”€ measCompAnalogOut_settings.req
â”‚Â Â  â”œâ”€â”€ measCompBinaryDir.template
â”‚Â Â  â”œâ”€â”€ measCompBinaryDir_settings.req
â”‚Â Â  â”œâ”€â”€ measCompBinaryIn.template
â”‚Â Â  â”œâ”€â”€ measCompBinaryOut.template
â”‚Â Â  â”œâ”€â”€ measCompCounter.template
â”‚Â Â  â”œâ”€â”€ measCompDevice.template
â”‚Â Â  â”œâ”€â”€ measCompEncoder.template
â”‚Â Â  â”œâ”€â”€ measCompLongIn.template
â”‚Â Â  â”œâ”€â”€ measCompLongOut.template
â”‚Â Â  â”œâ”€â”€ measCompMCS.template
â”‚Â Â  â”œâ”€â”€ measCompMCSWaveform.template
â”‚Â Â  â”œâ”€â”€ measCompMCS_settings.req
â”‚Â Â  â”œâ”€â”€ measCompPulseGen.template
â”‚Â Â  â”œâ”€â”€ measCompPulseGen_settings.req
â”‚Â Â  â”œâ”€â”€ measCompTemperatureIn.template
â”‚Â Â  â”œâ”€â”€ measCompTemperatureIn_settings.req
â”‚Â Â  â”œâ”€â”€ measCompTrigger.template
â”‚Â Â  â”œâ”€â”€ measCompTrigger_settings.req
â”‚Â Â  â”œâ”€â”€ measCompUSBTempConfig.template
â”‚Â Â  â”œâ”€â”€ measCompUSBTempConfig_settings.req
â”‚Â Â  â”œâ”€â”€ measCompVoltageIn.template
â”‚Â Â  â”œâ”€â”€ measCompVoltageIn_settings.req
â”‚Â Â  â”œâ”€â”€ measCompWaveformDig.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformDigN.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformDig_settings.req
â”‚Â Â  â”œâ”€â”€ measCompWaveformGen.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformGenN.template
â”‚Â Â  â”œâ”€â”€ measCompWaveformGenN_settings.req
â”‚Â Â  â”œâ”€â”€ measCompWaveformGen_settings.req
â”‚Â Â  â”œâ”€â”€ threshold_logic.template
â”‚Â Â  â”œâ”€â”€ user.db
â”‚Â Â  â”œâ”€â”€ user.proto
â”‚Â Â  â””â”€â”€ user.substitutions
â”œâ”€â”€ Makefile
â”œâ”€â”€ op
â”‚Â Â  â”œâ”€â”€ USB1608G_2AO_V2.adl
â”‚Â Â  â”œâ”€â”€ USB1608G_2AO_V2.opi
â”‚Â Â  â”œâ”€â”€ measCompADCStripChart.adl
â”‚Â Â  â”œâ”€â”€ measCompAiSetup.adl
â”‚Â Â  â”œâ”€â”€ measCompAnalogIn8.adl
â”‚Â Â  â”œâ”€â”€ measCompAnalogIn8.opi
â”‚Â Â  â”œâ”€â”€ measCompAnalogOut2.adl
â”‚Â Â  â”œâ”€â”€ measCompAnalogOut2.opi
â”‚Â Â  â”œâ”€â”€ measCompAoSetup2.adl
â”‚Â Â  â”œâ”€â”€ measCompDigitalIO8.adl
â”‚Â Â  â””â”€â”€ measCompDigitalIO8.opi
â””â”€â”€ src
    â”œâ”€â”€ ErrorHandler.cpp
    â”œâ”€â”€ ErrorHandler.h
    â”œâ”€â”€ Makefile
    â”œâ”€â”€ O.Common
    â”œâ”€â”€ O.linux-x86_64
    â”œâ”€â”€ ThresholdLogicController.cpp
    â”œâ”€â”€ ThresholdLogicController.h
    â”œâ”€â”€ USB1608G_2AO_V2Main.cpp
    â”œâ”€â”€ USBCTR_SNL.st
    â”œâ”€â”€ drvMultiFunction.cpp
    â”œâ”€â”€ drvUSBCTR.cpp
    â”œâ”€â”€ measCompAppMain.cpp
    â”œâ”€â”€ measCompDiscover.cpp
    â”œâ”€â”€ measCompDiscover.h
    â”œâ”€â”€ measCompSupport.dbd
    â””â”€â”€ thresholdLogicSupport.dbd

7 directories, 68 files

ğŸ“„ All files under USB1608G_2AO_V2App/:
./USB1608G_2AO_V2App/Db/Makefile
./USB1608G_2AO_V2App/Db/O.linux-x86_64/Makefile
./USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions
./USB1608G_2AO_V2App/Db/USB1608G_2AO_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogIn.template
./USB1608G_2AO_V2App/Db/measCompAnalogInMode.template
./USB1608G_2AO_V2App/Db/measCompAnalogInMode_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogIn_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogOut.template
./USB1608G_2AO_V2App/Db/measCompAnalogOut_settings.req
./USB1608G_2AO_V2App/Db/measCompBinaryDir.template
./USB1608G_2AO_V2App/Db/measCompBinaryDir_settings.req
./USB1608G_2AO_V2App/Db/measCompBinaryIn.template
./USB1608G_2AO_V2App/Db/measCompBinaryOut.template
./USB1608G_2AO_V2App/Db/measCompCounter.template
./USB1608G_2AO_V2App/Db/measCompDevice.template
./USB1608G_2AO_V2App/Db/measCompEncoder.template
./USB1608G_2AO_V2App/Db/measCompLongIn.template
./USB1608G_2AO_V2App/Db/measCompLongOut.template
./USB1608G_2AO_V2App/Db/measCompMCS.template
./USB1608G_2AO_V2App/Db/measCompMCSWaveform.template
./USB1608G_2AO_V2App/Db/measCompMCS_settings.req
./USB1608G_2AO_V2App/Db/measCompPulseGen.template
./USB1608G_2AO_V2App/Db/measCompPulseGen_settings.req
./USB1608G_2AO_V2App/Db/measCompTemperatureIn.template
./USB1608G_2AO_V2App/Db/measCompTemperatureIn_settings.req
./USB1608G_2AO_V2App/Db/measCompTrigger.template
./USB1608G_2AO_V2App/Db/measCompTrigger_settings.req
./USB1608G_2AO_V2App/Db/measCompUSBTempConfig.template
./USB1608G_2AO_V2App/Db/measCompUSBTempConfig_settings.req
./USB1608G_2AO_V2App/Db/measCompVoltageIn.template
./USB1608G_2AO_V2App/Db/measCompVoltageIn_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformDig.template
./USB1608G_2AO_V2App/Db/measCompWaveformDigN.template
./USB1608G_2AO_V2App/Db/measCompWaveformDig_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformGen.template
./USB1608G_2AO_V2App/Db/measCompWaveformGenN.template
./USB1608G_2AO_V2App/Db/measCompWaveformGenN_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformGen_settings.req
./USB1608G_2AO_V2App/Db/threshold_logic.template
./USB1608G_2AO_V2App/Db/user.db
./USB1608G_2AO_V2App/Db/user.proto
./USB1608G_2AO_V2App/Db/user.substitutions
./USB1608G_2AO_V2App/Makefile
./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.adl
./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.opi
./USB1608G_2AO_V2App/op/measCompADCStripChart.adl
./USB1608G_2AO_V2App/op/measCompAiSetup.adl
./USB1608G_2AO_V2App/op/measCompAnalogIn8.adl
./USB1608G_2AO_V2App/op/measCompAnalogIn8.opi
./USB1608G_2AO_V2App/op/measCompAnalogOut2.adl
./USB1608G_2AO_V2App/op/measCompAnalogOut2.opi
./USB1608G_2AO_V2App/op/measCompAoSetup2.adl
./USB1608G_2AO_V2App/op/measCompDigitalIO8.adl
./USB1608G_2AO_V2App/op/measCompDigitalIO8.opi
./USB1608G_2AO_V2App/src/ErrorHandler.cpp
./USB1608G_2AO_V2App/src/ErrorHandler.h
./USB1608G_2AO_V2App/src/Makefile
./USB1608G_2AO_V2App/src/O.Common/USB1608G_2AO_V2.dbd
./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/Makefile
./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2.dbd.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.c
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.i
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.st.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.o
./USB1608G_2AO_V2App/src/ThresholdLogicController.cpp
./USB1608G_2AO_V2App/src/ThresholdLogicController.h
./USB1608G_2AO_V2App/src/USB1608G_2AO_V2Main.cpp
./USB1608G_2AO_V2App/src/USBCTR_SNL.st
./USB1608G_2AO_V2App/src/drvMultiFunction.cpp
./USB1608G_2AO_V2App/src/drvUSBCTR.cpp
./USB1608G_2AO_V2App/src/measCompAppMain.cpp
./USB1608G_2AO_V2App/src/measCompDiscover.cpp
./USB1608G_2AO_V2App/src/measCompDiscover.h
./USB1608G_2AO_V2App/src/measCompSupport.dbd
./USB1608G_2AO_V2App/src/thresholdLogicSupport.dbd

ğŸ“„ Contents of files under USB1608G_2AO_V2App/:











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompAoSetup2.adl
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.adl)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompDigitalIO8.opi
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.opi)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompADCStripChart.adl
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.adl)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompAnalogIn8.opi
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.opi)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompAiSetup.adl
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.adl)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.opi
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.opi)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompAnalogOut2.adl
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.adl)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompAnalogIn8.adl
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.adl)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompDigitalIO8.adl
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.adl)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.adl
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.adl)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/op/measCompAnalogOut2.opi
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.opi)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/ThresholdLogicController.h
=================================================
#ifndef ThresholdLogicControllerInclude
#define ThresholdLogicControllerInclude

#include <asynPortDriver.h>
#include <epicsThread.h>
#include <epicsTime.h>
#include <shareLib.h>
#include "ErrorHandler.h"

/** ì„ê³„ê°’ ê¸°ë°˜ ë¡œì§ ì œì–´ë¥¼ ìœ„í•œ asynPortDriver í´ë˜ìŠ¤
 * 
 * ì´ í´ë˜ìŠ¤ëŠ” ì•„ë‚ ë¡œê·¸ ì…ë ¥ ê°’ì„ ëª¨ë‹ˆí„°ë§í•˜ê³  ì„¤ì •ëœ ì„ê³„ê°’ê³¼ ë¹„êµí•˜ì—¬
 * ë””ì§€í„¸ ì¶œë ¥ì„ ì œì–´í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê¸°ëŠ¥ì„ í¬í•¨í•˜ì—¬ ì•ˆì •ì ì¸ ì¶œë ¥ ì œì–´ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.
 */
class epicsShareClass ThresholdLogicController : public asynPortDriver, public epicsThreadRunable {
public:
    /** ìƒì„±ì
     * \param[in] portName ì´ ë“œë¼ì´ë²„ì˜ asyn í¬íŠ¸ ì´ë¦„
     * \param[in] devicePort ì—°ê²°í•  ì¥ì¹˜ í¬íŠ¸ ì´ë¦„
     * \param[in] deviceAddr ì¥ì¹˜ ì£¼ì†Œ
     */
    ThresholdLogicController(const char* portName, const char* devicePort, int deviceAddr);
    
    /** ì†Œë©¸ì */
    virtual ~ThresholdLogicController();
    
    // asynPortDriverì—ì„œ ìƒì†ë°›ì€ ë©”ì„œë“œë“¤
    virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
    virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
    virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
    
    /** ì„ê³„ê°’ ë¡œì§ ì²˜ë¦¬ ë©”ì„œë“œ */
    void processThresholdLogic();
    
    /** ëª¨ë‹ˆí„°ë§ ì‹œì‘ */
    void startMonitoring();
    
    /** ëª¨ë‹ˆí„°ë§ ì¤‘ì§€ */
    void stopMonitoring();
    
    /** ì •ì  ìŠ¤ë ˆë“œ í•¨ìˆ˜ (epicsThreadì—ì„œ í˜¸ì¶œ) */
    static void monitorThreadFunc(void* param);
    
    /** epicsThreadRunable ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ */
    virtual void run();
    
    // í…ŒìŠ¤íŠ¸ìš© public ì ‘ê·¼ì ë©”ì„œë“œë“¤
    /** í…ŒìŠ¤íŠ¸ìš©: ë§¤ê°œë³€ìˆ˜ ì¸ë±ìŠ¤ ì ‘ê·¼ì */
    int getThresholdValueParam() const { return P_ThresholdValue; }
    int getCurrentValueParam() const { return P_CurrentValue; }
    int getOutputStateParam() const { return P_OutputState; }
    int getEnableParam() const { return P_Enable; }
    int getHysteresisParam() const { return P_Hysteresis; }
    int getUpdateRateParam() const { return P_UpdateRate; }
    int getAlarmStatusParam() const { return P_AlarmStatus; }

protected:
    // ë§¤ê°œë³€ìˆ˜ ì¸ë±ìŠ¤ë“¤
    int P_ThresholdValue;      ///< ì„ê³„ê°’ ì„¤ì • ë§¤ê°œë³€ìˆ˜
    int P_CurrentValue;        ///< í˜„ì¬ ì¸¡ì •ê°’ ë§¤ê°œë³€ìˆ˜
    int P_OutputState;         ///< ì¶œë ¥ ìƒíƒœ ë§¤ê°œë³€ìˆ˜
    int P_Enable;              ///< í™œì„±í™” ìƒíƒœ ë§¤ê°œë³€ìˆ˜
    int P_Hysteresis;          ///< íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê°’ ë§¤ê°œë³€ìˆ˜
    int P_UpdateRate;          ///< ì—…ë°ì´íŠ¸ ì£¼ê¸° ë§¤ê°œë³€ìˆ˜
    int P_AlarmStatus;         ///< ì•ŒëŒ ìƒíƒœ ë§¤ê°œë³€ìˆ˜
    int P_DevicePort;          ///< ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ ë§¤ê°œë³€ìˆ˜
    int P_DeviceAddr;          ///< ì¥ì¹˜ ì£¼ì†Œ ë§¤ê°œë³€ìˆ˜

private:
    // ìŠ¤ë ˆë“œ ê´€ë¦¬
    epicsThread *monitorThread_;    ///< ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ í¬ì¸í„°
    bool threadRunning_;            ///< ìŠ¤ë ˆë“œ ì‹¤í–‰ ìƒíƒœ
    bool threadExit_;               ///< ìŠ¤ë ˆë“œ ì¢…ë£Œ í”Œë˜ê·¸
    
    // ì„ê³„ê°’ ë¡œì§ ìƒíƒœ ë³€ìˆ˜ë“¤
    double thresholdValue_;         ///< í˜„ì¬ ì„ê³„ê°’
    double currentValue_;           ///< í˜„ì¬ ì¸¡ì •ê°’
    bool outputState_;              ///< í˜„ì¬ ì¶œë ¥ ìƒíƒœ
    bool enabled_;                  ///< í™œì„±í™” ìƒíƒœ
    double hysteresis_;             ///< íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê°’
    double updateRate_;             ///< ì—…ë°ì´íŠ¸ ì£¼ê¸° (Hz)
    int alarmStatus_;               ///< ì•ŒëŒ ìƒíƒœ
    
    // ì¥ì¹˜ ì—°ê²° ì •ë³´
    char devicePortName_[64];       ///< ì—°ê²°í•  ì¥ì¹˜ í¬íŠ¸ ì´ë¦„
    int deviceAddr_;                ///< ì¥ì¹˜ ì£¼ì†Œ
    
    // ìƒíƒœ ì¶”ì 
    epicsTimeStamp lastUpdate_;     ///< ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„
    bool lastOutputState_;          ///< ì´ì „ ì¶œë ¥ ìƒíƒœ (ìƒíƒœ ë³€í™” ê°ì§€ìš©)
    
    // ë‚´ë¶€ ë©”ì„œë“œë“¤
    /** ì¥ì¹˜ì—ì„œ í˜„ì¬ ê°’ì„ ì½ì–´ì˜´ */
    asynStatus readCurrentValueFromDevice();
    
    /** ì¥ì¹˜ì— ì¶œë ¥ ìƒíƒœë¥¼ ì„¤ì • */
    asynStatus writeOutputStateToDevice(bool state);
    
    /** ì•ŒëŒ ìƒíƒœ ì—…ë°ì´íŠ¸ */
    void updateAlarmStatus();
    
    /** ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ */
    bool validateParameters();
    
    /** ì˜¤ë¥˜ ë¡œê¹… (ErrorHandler ì‚¬ìš©) */
    void logError(const char* functionName, const char* message);
    
    /** êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬ (ErrorHandler ì‚¬ìš©) */
    bool validateConfigurationWithErrorHandler();
};

// IOC ì‰˜ ëª…ë ¹ì–´ ë“±ë¡ í•¨ìˆ˜
extern "C" {
    epicsShareFunc int ThresholdLogicConfig(const char* portName, const char* devicePort, int deviceAddr);
    epicsShareFunc void ThresholdLogicHelp(void);
    epicsShareFunc void ThresholdLogicRegister(void);
}

// ë§¤ê°œë³€ìˆ˜ ë¬¸ìì—´ ì •ì˜
#define THRESHOLD_VALUE_STRING      "THRESHOLD_VALUE"
#define CURRENT_VALUE_STRING        "CURRENT_VALUE"
#define OUTPUT_STATE_STRING         "OUTPUT_STATE"
#define ENABLE_STRING               "ENABLE"
#define HYSTERESIS_STRING           "HYSTERESIS"
#define UPDATE_RATE_STRING          "UPDATE_RATE"
#define ALARM_STATUS_STRING         "ALARM_STATUS"
#define DEVICE_PORT_STRING          "DEVICE_PORT"
#define DEVICE_ADDR_STRING          "DEVICE_ADDR"

#endif /* ThresholdLogicControllerInclude */










ğŸ”¥ File: ./USB1608G_2AO_V2App/src/ErrorHandler.h
=================================================
#ifndef ErrorHandlerInclude
#define ErrorHandlerInclude

#include <epicsTime.h>
#include <asynDriver.h>
#include <shareLib.h>

/** ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¡œê¹…ì„ ìœ„í•œ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤
 * 
 * ì´ í´ë˜ìŠ¤ëŠ” EPICS IOC ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ì˜¤ë¥˜ë¥¼ 
 * ë¶„ë¥˜í•˜ê³  ë¡œê¹…í•˜ë©°, EPICS ì•ŒëŒ ì‹œìŠ¤í…œê³¼ í†µí•©í•˜ì—¬ ìƒíƒœë¥¼ ë³´ê³ í•©ë‹ˆë‹¤.
 */
class epicsShareClass ErrorHandler {
public:
    /** ì˜¤ë¥˜ ë ˆë²¨ ì •ì˜ */
    enum ErrorLevel {
        INFO = 0,       ///< ì •ë³´ì„± ë©”ì‹œì§€
        WARNING = 1,    ///< ê²½ê³  - ë™ì‘ì— ì˜í–¥ ì—†ìŒ
        ERROR = 2,      ///< ì˜¤ë¥˜ - ê¸°ëŠ¥ì— ì˜í–¥ ìˆìŒ
        FATAL = 3       ///< ì¹˜ëª…ì  ì˜¤ë¥˜ - ì‹œìŠ¤í…œ ì¤‘ë‹¨ í•„ìš”
    };
    
    /** EPICS ì•ŒëŒ ì‹¬ê°ë„ ì •ì˜ */
    enum AlarmSeverity {
        NO_ALARM = 0,       ///< ì•ŒëŒ ì—†ìŒ
        MINOR_ALARM = 1,    ///< ê²½ë¯¸í•œ ì•ŒëŒ
        MAJOR_ALARM = 2,    ///< ì£¼ìš” ì•ŒëŒ
        INVALID_ALARM = 3   ///< ìœ íš¨í•˜ì§€ ì•Šì€ ìƒíƒœ
    };
    
    /** EPICS ì•ŒëŒ ìƒíƒœ ì •ì˜ */
    enum AlarmStatus {
        NO_ALARM_STATUS = 0,    ///< ì •ìƒ ìƒíƒœ
        READ_ALARM = 1,         ///< ì½ê¸° ì˜¤ë¥˜
        WRITE_ALARM = 2,        ///< ì“°ê¸° ì˜¤ë¥˜
        HIHI_ALARM = 3,         ///< ìƒí•œ ìƒí•œ ì•ŒëŒ
        HIGH_ALARM = 4,         ///< ìƒí•œ ì•ŒëŒ
        LOLO_ALARM = 5,         ///< í•˜í•œ í•˜í•œ ì•ŒëŒ
        LOW_ALARM = 6,          ///< í•˜í•œ ì•ŒëŒ
        STATE_ALARM = 7,        ///< ìƒíƒœ ì•ŒëŒ
        COS_ALARM = 8,          ///< ë³€í™” ì•ŒëŒ
        COMM_ALARM = 9,         ///< í†µì‹  ì•ŒëŒ
        TIMEOUT_ALARM = 10,     ///< íƒ€ì„ì•„ì›ƒ ì•ŒëŒ
        HW_LIMIT_ALARM = 11,    ///< í•˜ë“œì›¨ì–´ ì œí•œ ì•ŒëŒ
        CALC_ALARM = 12,        ///< ê³„ì‚° ì˜¤ë¥˜ ì•ŒëŒ
        SCAN_ALARM = 13,        ///< ìŠ¤ìº” ì˜¤ë¥˜ ì•ŒëŒ
        LINK_ALARM = 14,        ///< ë§í¬ ì˜¤ë¥˜ ì•ŒëŒ
        SOFT_ALARM = 15,        ///< ì†Œí”„íŠ¸ì›¨ì–´ ì•ŒëŒ
        BAD_SUB_ALARM = 16,     ///< ì˜ëª»ëœ ì„œë¸Œë ˆì½”ë“œ ì•ŒëŒ
        UDF_ALARM = 17,         ///< ì •ì˜ë˜ì§€ ì•Šì€ ê°’ ì•ŒëŒ
        DISABLE_ALARM = 18,     ///< ë¹„í™œì„±í™” ì•ŒëŒ
        SIMM_ALARM = 19,        ///< ì‹œë®¬ë ˆì´ì…˜ ì•ŒëŒ
        READ_ACCESS_ALARM = 20, ///< ì½ê¸° ì ‘ê·¼ ì•ŒëŒ
        WRITE_ACCESS_ALARM = 21 ///< ì“°ê¸° ì ‘ê·¼ ì•ŒëŒ
    };
    
    /** êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬ ê²°ê³¼ */
    struct ValidationResult {
        bool isValid;               ///< ìœ íš¨ì„± ê²€ì‚¬ í†µê³¼ ì—¬ë¶€
        ErrorLevel errorLevel;      ///< ì˜¤ë¥˜ ë ˆë²¨
        char errorMessage[256];     ///< ì˜¤ë¥˜ ë©”ì‹œì§€
        char suggestion[256];       ///< í•´ê²° ë°©ì•ˆ ì œì•ˆ
    };
    
    /** ThresholdLogicController êµ¬ì„± ë§¤ê°œë³€ìˆ˜ */
    struct ThresholdConfig {
        char portName[64];          ///< í¬íŠ¸ ì´ë¦„
        char devicePort[64];        ///< ì¥ì¹˜ í¬íŠ¸ ì´ë¦„
        int deviceAddr;             ///< ì¥ì¹˜ ì£¼ì†Œ
        double updateRate;          ///< ì—…ë°ì´íŠ¸ ì£¼ê¸° (Hz)
        int priority;               ///< ìŠ¤ë ˆë“œ ìš°ì„ ìˆœìœ„
        double thresholdValue;      ///< ì„ê³„ê°’
        double hysteresis;          ///< íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê°’
    };

public:
    /** ì˜¤ë¥˜ ë¡œê¹… ë©”ì„œë“œ
     * \param[in] level ì˜¤ë¥˜ ë ˆë²¨
     * \param[in] source ì˜¤ë¥˜ ë°œìƒ ì†ŒìŠ¤ (í´ë˜ìŠ¤ëª…::ë©”ì„œë“œëª…)
     * \param[in] message ì˜¤ë¥˜ ë©”ì‹œì§€
     * \param[in] pasynUser asyn ì‚¬ìš©ì í¬ì¸í„° (ì„ íƒì‚¬í•­)
     */
    static void logError(ErrorLevel level, const char* source, const char* message, 
                        asynUser* pasynUser = NULL);
    
    /** ìƒì„¸ ì˜¤ë¥˜ ë¡œê¹… ë©”ì„œë“œ (ì¶”ê°€ ì •ë³´ í¬í•¨)
     * \param[in] level ì˜¤ë¥˜ ë ˆë²¨
     * \param[in] source ì˜¤ë¥˜ ë°œìƒ ì†ŒìŠ¤
     * \param[in] message ì˜¤ë¥˜ ë©”ì‹œì§€
     * \param[in] details ìƒì„¸ ì •ë³´
     * \param[in] errorCode ì˜¤ë¥˜ ì½”ë“œ
     * \param[in] pasynUser asyn ì‚¬ìš©ì í¬ì¸í„° (ì„ íƒì‚¬í•­)
     */
    static void logDetailedError(ErrorLevel level, const char* source, const char* message,
                               const char* details, int errorCode, asynUser* pasynUser = NULL);
    
    /** EPICS ì•ŒëŒ ìƒíƒœ ì„¤ì •
     * \param[in] pasynUser asyn ì‚¬ìš©ì í¬ì¸í„°
     * \param[in] status ì•ŒëŒ ìƒíƒœ
     * \param[in] severity ì•ŒëŒ ì‹¬ê°ë„
     * \return asynStatus ê²°ê³¼
     */
    static asynStatus setAlarmStatus(asynUser* pasynUser, AlarmStatus status, AlarmSeverity severity);
    
    /** ThresholdLogicController êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬
     * \param[in] config ê²€ì‚¬í•  êµ¬ì„±
     * \return ValidationResult ê²€ì‚¬ ê²°ê³¼
     */
    static ValidationResult validateConfiguration(const ThresholdConfig& config);
    
    /** ëŸ°íƒ€ì„ ì˜¤ë¥˜ ì²˜ë¦¬
     * \param[in] source ì˜¤ë¥˜ ë°œìƒ ì†ŒìŠ¤
     * \param[in] errorType ì˜¤ë¥˜ ìœ í˜•
     * \param[in] errorCode ì˜¤ë¥˜ ì½”ë“œ
     * \param[in] pasynUser asyn ì‚¬ìš©ì í¬ì¸í„° (ì„ íƒì‚¬í•­)
     * \return ë³µêµ¬ ê°€ëŠ¥ ì—¬ë¶€
     */
    static bool handleRuntimeError(const char* source, const char* errorType, 
                                 int errorCode, asynUser* pasynUser = NULL);
    
    /** í†µì‹  ì˜¤ë¥˜ ì²˜ë¦¬
     * \param[in] source ì˜¤ë¥˜ ë°œìƒ ì†ŒìŠ¤
     * \param[in] devicePort ì¥ì¹˜ í¬íŠ¸ ì´ë¦„
     * \param[in] deviceAddr ì¥ì¹˜ ì£¼ì†Œ
     * \param[in] operation ìˆ˜í–‰ ì¤‘ì´ë˜ ì‘ì—…
     * \param[in] pasynUser asyn ì‚¬ìš©ì í¬ì¸í„° (ì„ íƒì‚¬í•­)
     * \return ì¬ì‹œë„ ê¶Œì¥ ì—¬ë¶€
     */
    static bool handleCommunicationError(const char* source, const char* devicePort,
                                       int deviceAddr, const char* operation,
                                       asynUser* pasynUser = NULL);
    
    /** ìŠ¤ë ˆë“œ ì˜¤ë¥˜ ì²˜ë¦¬
     * \param[in] source ì˜¤ë¥˜ ë°œìƒ ì†ŒìŠ¤
     * \param[in] threadName ìŠ¤ë ˆë“œ ì´ë¦„
     * \param[in] errorMessage ì˜¤ë¥˜ ë©”ì‹œì§€
     * \param[in] pasynUser asyn ì‚¬ìš©ì í¬ì¸í„° (ì„ íƒì‚¬í•­)
     * \return ìŠ¤ë ˆë“œ ì¬ì‹œì‘ ê¶Œì¥ ì—¬ë¶€
     */
    static bool handleThreadError(const char* source, const char* threadName,
                                const char* errorMessage, asynUser* pasynUser = NULL);
    
    /** ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
     * \param[in] paramName ë§¤ê°œë³€ìˆ˜ ì´ë¦„
     * \param[in] value ê²€ì‚¬í•  ê°’
     * \param[in] minValue ìµœì†Œê°’
     * \param[in] maxValue ìµœëŒ€ê°’
     * \param[in] source í˜¸ì¶œ ì†ŒìŠ¤
     * \return ìœ íš¨ì„± ê²€ì‚¬ í†µê³¼ ì—¬ë¶€
     */
    static bool validateParameter(const char* paramName, double value, 
                                double minValue, double maxValue, const char* source);
    
    /** ì •ìˆ˜ ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
     * \param[in] paramName ë§¤ê°œë³€ìˆ˜ ì´ë¦„
     * \param[in] value ê²€ì‚¬í•  ê°’
     * \param[in] minValue ìµœì†Œê°’
     * \param[in] maxValue ìµœëŒ€ê°’
     * \param[in] source í˜¸ì¶œ ì†ŒìŠ¤
     * \return ìœ íš¨ì„± ê²€ì‚¬ í†µê³¼ ì—¬ë¶€
     */
    static bool validateIntParameter(const char* paramName, int value, 
                                   int minValue, int maxValue, const char* source);
    
    /** ë¬¸ìì—´ ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
     * \param[in] paramName ë§¤ê°œë³€ìˆ˜ ì´ë¦„
     * \param[in] value ê²€ì‚¬í•  ë¬¸ìì—´
     * \param[in] maxLength ìµœëŒ€ ê¸¸ì´
     * \param[in] allowEmpty ë¹ˆ ë¬¸ìì—´ í—ˆìš© ì—¬ë¶€
     * \param[in] source í˜¸ì¶œ ì†ŒìŠ¤
     * \return ìœ íš¨ì„± ê²€ì‚¬ í†µê³¼ ì—¬ë¶€
     */
    static bool validateStringParameter(const char* paramName, const char* value,
                                      size_t maxLength, bool allowEmpty, const char* source);
    
    /** ì˜¤ë¥˜ í†µê³„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
     * \param[out] infoCount ì •ë³´ ë©”ì‹œì§€ ìˆ˜
     * \param[out] warningCount ê²½ê³  ë©”ì‹œì§€ ìˆ˜
     * \param[out] errorCount ì˜¤ë¥˜ ë©”ì‹œì§€ ìˆ˜
     * \param[out] fatalCount ì¹˜ëª…ì  ì˜¤ë¥˜ ë©”ì‹œì§€ ìˆ˜
     */
    static void getErrorStatistics(int* infoCount, int* warningCount, 
                                 int* errorCount, int* fatalCount);
    
    /** ì˜¤ë¥˜ í†µê³„ ì´ˆê¸°í™” */
    static void resetErrorStatistics();
    
    /** ì˜¤ë¥˜ ë ˆë²¨ì„ ë¬¸ìì—´ë¡œ ë³€í™˜
     * \param[in] level ì˜¤ë¥˜ ë ˆë²¨
     * \return ì˜¤ë¥˜ ë ˆë²¨ ë¬¸ìì—´
     */
    static const char* errorLevelToString(ErrorLevel level);
    
    /** ì•ŒëŒ ì‹¬ê°ë„ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
     * \param[in] severity ì•ŒëŒ ì‹¬ê°ë„
     * \return ì•ŒëŒ ì‹¬ê°ë„ ë¬¸ìì—´
     */
    static const char* alarmSeverityToString(AlarmSeverity severity);
    
    /** ì•ŒëŒ ìƒíƒœë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
     * \param[in] status ì•ŒëŒ ìƒíƒœ
     * \return ì•ŒëŒ ìƒíƒœ ë¬¸ìì—´
     */
    static const char* alarmStatusToString(AlarmStatus status);

private:
    // ì •ì  ë©¤ë²„ ë³€ìˆ˜ë“¤ (ì˜¤ë¥˜ í†µê³„)
    static int infoCount_;      ///< ì •ë³´ ë©”ì‹œì§€ ì¹´ìš´í„°
    static int warningCount_;   ///< ê²½ê³  ë©”ì‹œì§€ ì¹´ìš´í„°
    static int errorCount_;     ///< ì˜¤ë¥˜ ë©”ì‹œì§€ ì¹´ìš´í„°
    static int fatalCount_;     ///< ì¹˜ëª…ì  ì˜¤ë¥˜ ë©”ì‹œì§€ ì¹´ìš´í„°
    
    /** ë‚´ë¶€ ë¡œê¹… ë©”ì„œë“œ
     * \param[in] level ì˜¤ë¥˜ ë ˆë²¨
     * \param[in] source ì˜¤ë¥˜ ë°œìƒ ì†ŒìŠ¤
     * \param[in] message ë©”ì‹œì§€
     * \param[in] pasynUser asyn ì‚¬ìš©ì í¬ì¸í„°
     */
    static void internalLog(ErrorLevel level, const char* source, const char* message,
                          asynUser* pasynUser);
    
    /** íƒ€ì„ìŠ¤íƒ¬í”„ ë¬¸ìì—´ ìƒì„±
     * \param[out] buffer ì¶œë ¥ ë²„í¼
     * \param[in] bufferSize ë²„í¼ í¬ê¸°
     */
    static void getTimestampString(char* buffer, size_t bufferSize);
    
    /** asyn íŠ¸ë ˆì´ìŠ¤ ë ˆë²¨ ë³€í™˜
     * \param[in] level ErrorHandler ì˜¤ë¥˜ ë ˆë²¨
     * \return asyn íŠ¸ë ˆì´ìŠ¤ ë ˆë²¨
     */
    static int convertToAsynTraceLevel(ErrorLevel level);
};

#endif /* ErrorHandlerInclude */










ğŸ”¥ File: ./USB1608G_2AO_V2App/src/ThresholdLogicController.cpp
=================================================
/* ThresholdLogicController.cpp
 *
 * ì„ê³„ê°’ ê¸°ë°˜ ë¡œì§ ì œì–´ë¥¼ ìœ„í•œ asynPortDriver êµ¬í˜„
 * 
 * ì´ ë“œë¼ì´ë²„ëŠ” ì•„ë‚ ë¡œê·¸ ì…ë ¥ ê°’ì„ ëª¨ë‹ˆí„°ë§í•˜ê³  ì„¤ì •ëœ ì„ê³„ê°’ê³¼ ë¹„êµí•˜ì—¬
 * ë””ì§€í„¸ ì¶œë ¥ì„ ì œì–´í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 * íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê¸°ëŠ¥ì„ í¬í•¨í•˜ì—¬ ì•ˆì •ì ì¸ ì¶œë ¥ ì œì–´ë¥¼ ë³´ì¥í•©ë‹ˆë‹¤.
 *
 * Author: EPICS IOC Development Guide
 * Date: 2025
 */


/* ThresholdLogicController êµ¬í˜„ëœ ë‚´ìš©:         */
// 1. ThresholdLogicController.cpp íŒŒì¼ ìƒì„±
// 2. asynPortDriver ì´ˆê¸°í™” ë° ë§¤ê°œë³€ìˆ˜ ìƒì„±
//     ìƒì„±ìì—ì„œ asynPortDriverë¥¼ ì˜¬ë°”ë¥´ê²Œ ì´ˆê¸°í™”
//     9ê°œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ìƒì„± (ì„ê³„ê°’, í˜„ì¬ê°’, ì¶œë ¥ìƒíƒœ, í™œì„±í™”, íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ë“±)
//     ì´ˆê¸°ê°’ ì„¤ì • ë° ë§¤ê°œë³€ìˆ˜ ì½œë°± í˜¸ì¶œ
// 3. ê¸°ë³¸ì ì¸ ì½ê¸°/ì“°ê¸° ë©”ì„œë“œ ìŠ¤ì¼ˆë ˆí†¤ êµ¬í˜„
//     writeFloat64(): ì„ê³„ê°’, íˆìŠ¤í…Œë¦¬ì‹œìŠ¤, ì—…ë°ì´íŠ¸ ì£¼ê¸° ì„¤ì • ì²˜ë¦¬
//     readFloat64(): í˜„ì¬ê°’ ì½ê¸° ë° ìºì‹œëœ ê°’ ë°˜í™˜
//     writeInt32(): í™œì„±í™” ìƒíƒœ ì œì–´ ë° ì¶œë ¥ìƒíƒœ ë³´í˜¸
//     readInt32(): ì •ìˆ˜ ë§¤ê°œë³€ìˆ˜ ì½ê¸°
// 4. ì¶”ê°€ êµ¬í˜„ëœ ê¸°ëŠ¥ë“¤
//     ì†Œë©¸ì: ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë° ìŠ¤ë ˆë“œ ì¤‘ì§€
//     IOC ì‰˜ ëª…ë ¹ì–´: ThresholdLogicConfig í•¨ìˆ˜ ë° ë“±ë¡
//     ë‚´ë¶€ ë©”ì„œë“œ ìŠ¤ì¼ˆë ˆí†¤: í–¥í›„ ì‘ì—…ì—ì„œ êµ¬í˜„í•  ë©”ì„œë“œë“¤ì˜ ê¸°ë³¸ í‹€
//     ì˜¤ë¥˜ ì²˜ë¦¬: ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ ë° ë¡œê¹…
//     í•œêµ­ì–´ ì£¼ì„: ëª¨ë“  ì£¼ìš” ê¸°ëŠ¥ì— ëŒ€í•œ í•œêµ­ì–´ ì„¤ëª…
// 5. ìš”êµ¬ì‚¬í•­ ì¶©ì¡± í™•ì¸
//     ìš”êµ¬ì‚¬í•­ 4.1: asynPortDriver ìƒì† ë° ë§¤ê°œë³€ìˆ˜ ê´€ë¦¬ êµ¬í˜„
//     ìš”êµ¬ì‚¬í•­ 4.2: ê¸°ë³¸ êµ¬ì¡° ë° ì¸í„°í˜ì´ìŠ¤ ì •ì˜


#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsString.h>
#include <epicsTime.h>
#include <epicsExport.h>
#include <asynPortDriver.h>
#include <asynOctetSyncIO.h>

#include "ThresholdLogicController.h"
#include "ErrorHandler.h"

static const char *driverName = "ThresholdLogicController";

/** ThresholdLogicController ìƒì„±ì
 * \param[in] portName ì´ ë“œë¼ì´ë²„ì˜ asyn í¬íŠ¸ ì´ë¦„
 * \param[in] devicePort ì—°ê²°í•  ì¥ì¹˜ í¬íŠ¸ ì´ë¦„  
 * \param[in] deviceAddr ì¥ì¹˜ ì£¼ì†Œ
 */
ThresholdLogicController::ThresholdLogicController(const char* portName, const char* devicePort, int deviceAddr)
    : asynPortDriver(portName, 
                     1, /* maxAddr */ 
                     asynFloat64Mask | asynInt32Mask | asynDrvUserMask, /* Interface mask */
                     asynFloat64Mask | asynInt32Mask,  /* Interrupt mask */
                     ASYN_CANBLOCK, /* asynFlags */
                     1, /* Autoconnect */
                     0, /* Default priority */
                     0) /* Default stack size */
{
    const char* functionName = "ThresholdLogicController";
    
    // ì¥ì¹˜ ì—°ê²° ì •ë³´ ì €ì¥
    strncpy(devicePortName_, devicePort, sizeof(devicePortName_) - 1);
    devicePortName_[sizeof(devicePortName_) - 1] = '\0';
    deviceAddr_ = deviceAddr;
    
    // ë§¤ê°œë³€ìˆ˜ ìƒì„±
    createParam(THRESHOLD_VALUE_STRING,  asynParamFloat64, &P_ThresholdValue);
    createParam(CURRENT_VALUE_STRING,    asynParamFloat64, &P_CurrentValue);
    createParam(OUTPUT_STATE_STRING,     asynParamInt32,   &P_OutputState);
    createParam(ENABLE_STRING,           asynParamInt32,   &P_Enable);
    createParam(HYSTERESIS_STRING,       asynParamFloat64, &P_Hysteresis);
    createParam(UPDATE_RATE_STRING,      asynParamFloat64, &P_UpdateRate);
    createParam(ALARM_STATUS_STRING,     asynParamInt32,   &P_AlarmStatus);
    createParam(DEVICE_PORT_STRING,      asynParamOctet,   &P_DevicePort);
    createParam(DEVICE_ADDR_STRING,      asynParamInt32,   &P_DeviceAddr);
    
    // ì´ˆê¸°ê°’ ì„¤ì •
    thresholdValue_ = 0.0;
    currentValue_ = 0.0;
    outputState_ = false;
    enabled_ = false;
    hysteresis_ = 0.1;  // ê¸°ë³¸ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê°’
    updateRate_ = 10.0; // ê¸°ë³¸ 10Hz ì—…ë°ì´íŠ¸
    alarmStatus_ = 0;   // ì•ŒëŒ ì—†ìŒ
    lastOutputState_ = false;
    
    // ìŠ¤ë ˆë“œ ê´€ë¦¬ ë³€ìˆ˜ ì´ˆê¸°í™”
    monitorThread_ = NULL;
    threadRunning_ = false;
    threadExit_ = false;
    
    // ë§¤ê°œë³€ìˆ˜ ì´ˆê¸°ê°’ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì„¤ì •
    setDoubleParam(P_ThresholdValue, thresholdValue_);
    setDoubleParam(P_CurrentValue, currentValue_);
    setIntegerParam(P_OutputState, outputState_ ? 1 : 0);
    setIntegerParam(P_Enable, enabled_ ? 1 : 0);
    setDoubleParam(P_Hysteresis, hysteresis_);
    setDoubleParam(P_UpdateRate, updateRate_);
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    setStringParam(P_DevicePort, devicePortName_);
    setIntegerParam(P_DeviceAddr, deviceAddr_);
    
    // íƒ€ì„ìŠ¤íƒ¬í”„ ì´ˆê¸°í™”
    epicsTimeGetCurrent(&lastUpdate_);
    
    // êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬ (ErrorHandler ì‚¬ìš©)
    if (!validateConfigurationWithErrorHandler()) {
        ErrorHandler::logError(ErrorHandler::WARNING, functionName, 
                              "êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬ì—ì„œ ê²½ê³ ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", pasynUserSelf);
    }
    
    // ë§¤ê°œë³€ìˆ˜ ë³€ê²½ì‚¬í•­ì„ í´ë¼ì´ì–¸íŠ¸ì— ì•Œë¦¼
    callParamCallbacks();
    
    // ì„±ê³µì ì¸ ìƒì„± ë¡œê·¸
    char successMessage[256];
    snprintf(successMessage, sizeof(successMessage),
            "í¬íŠ¸=%s, ì¥ì¹˜í¬íŠ¸=%s, ì£¼ì†Œ=%dë¡œ ThresholdLogicController ìƒì„±ë¨",
            portName, devicePort, deviceAddr);
    ErrorHandler::logError(ErrorHandler::INFO, functionName, successMessage, pasynUserSelf);
}

/** ThresholdLogicController ì†Œë©¸ì */
ThresholdLogicController::~ThresholdLogicController()
{
    const char* functionName = "~ThresholdLogicController";
    
    // ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì¤‘ì§€
    stopMonitoring();
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ThresholdLogicController ì†Œë©¸ë¨\n",
              driverName, functionName);
}

/** Float64 ë§¤ê°œë³€ìˆ˜ ì“°ê¸° ë©”ì„œë“œ */
asynStatus ThresholdLogicController::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "writeFloat64";
    
    // ë§¤ê°œë³€ìˆ˜ë³„ ìœ íš¨ì„± ê²€ì‚¬ ë° ì²˜ë¦¬
    if (function == P_ThresholdValue) {
        // ì„ê³„ê°’ ìœ íš¨ì„± ê²€ì‚¬ (ErrorHandler ì‚¬ìš©)
        if (!ErrorHandler::validateParameter("thresholdValue", value, -10.0, 10.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "ì„ê³„ê°’ì´ ìœ íš¨ ë²”ìœ„(-10.0V ~ +10.0V)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤", pasynUser);
            return asynError;
        }
        
        // íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ì™€ì˜ ê´€ê³„ ê²€ì‚¬
        if (fabs(value) < hysteresis_) {
            char warningMsg[256];
            snprintf(warningMsg, sizeof(warningMsg),
                    "ì„ê³„ê°’ì´ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ë³´ë‹¤ ì‘ìŒ - ì„ê³„ê°’: %f, íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: %f",
                    value, hysteresis_);
            ErrorHandler::logError(ErrorHandler::WARNING, functionName, warningMsg, pasynUser);
        }
        
        thresholdValue_ = value;
        status = setDoubleParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: ì„ê³„ê°’ ì„¤ì •ë¨: %f V\n", driverName, functionName, value);
    }
    else if (function == P_Hysteresis) {
        // íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ìœ íš¨ì„± ê²€ì‚¬ (ErrorHandler ì‚¬ìš©)
        if (!ErrorHandler::validateParameter("hysteresis", value, 0.0, 5.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ê°€ ìœ íš¨ ë²”ìœ„(0.0V ~ 5.0V)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤", pasynUser);
            return asynError;
        }
        
        // ì„ê³„ê°’ê³¼ì˜ ê´€ê³„ ê²€ì‚¬
        if (value > fabs(thresholdValue_)) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ê°€ ì„ê³„ê°’ë³´ë‹¤ í¼ - íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: %f, ì„ê³„ê°’: %f\n",
                      driverName, functionName, value, thresholdValue_);
        }
        
        hysteresis_ = value;
        status = setDoubleParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì„¤ì •ë¨: %f V\n", driverName, functionName, value);
    }
    else if (function == P_UpdateRate) {
        // ì—…ë°ì´íŠ¸ ì£¼ê¸° ìœ íš¨ì„± ê²€ì‚¬ (ErrorHandler ì‚¬ìš©)
        if (!ErrorHandler::validateParameter("updateRate", value, 0.1, 1000.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "ì—…ë°ì´íŠ¸ ì£¼ê¸°ê°€ ìœ íš¨ ë²”ìœ„(0.1Hz ~ 1000Hz)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤", pasynUser);
            return asynError;
        }
        
        double oldRate = updateRate_;
        updateRate_ = value;
        status = setDoubleParam(function, value);
        
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: ì—…ë°ì´íŠ¸ ì£¼ê¸° ë³€ê²½ë¨: %f Hz -> %f Hz\n", 
                  driverName, functionName, oldRate, value);
        
        // ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° ìƒˆë¡œìš´ ì£¼ê¸°ê°€ ë‹¤ìŒ ë£¨í”„ì—ì„œ ì ìš©ë¨ì„ ì•Œë¦¼
        if (threadRunning_) {
            asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                      "%s::%s: ìƒˆë¡œìš´ ì—…ë°ì´íŠ¸ ì£¼ê¸°ëŠ” ë‹¤ìŒ ë£¨í”„ì—ì„œ ì ìš©ë©ë‹ˆë‹¤\n",
                      driverName, functionName);
        }
    }
    else if (function == P_CurrentValue) {
        // í˜„ì¬ê°’ì€ ì½ê¸° ì „ìš©ì´ë¯€ë¡œ ì“°ê¸° ê±°ë¶€
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: í˜„ì¬ê°’ì€ ì½ê¸° ì „ìš© ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤\n",
                  driverName, functionName);
        return asynError;
    }
    else {
        // ì•Œ ìˆ˜ ì—†ëŠ” ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´ì„œëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ í˜¸ì¶œ
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: ì•Œ ìˆ˜ ì—†ëŠ” Float64 ë§¤ê°œë³€ìˆ˜: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::writeFloat64(pasynUser, value);
    }
    
    // ì„±ê³µí•œ ê²½ìš°ì—ë§Œ ë§¤ê°œë³€ìˆ˜ ë³€ê²½ì‚¬í•­ì„ í´ë¼ì´ì–¸íŠ¸ì— ì•Œë¦¼
    if (status == asynSuccess) {
        callParamCallbacks();
    } else {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ë§¤ê°œë³€ìˆ˜ ì„¤ì • ì‹¤íŒ¨ - function=%d, value=%f, status=%d\n",
                  driverName, functionName, function, value, status);
    }
    
    return status;
}

/** Float64 ë§¤ê°œë³€ìˆ˜ ì½ê¸° ë©”ì„œë“œ */
asynStatus ThresholdLogicController::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "readFloat64";
    
    // ì…ë ¥ ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
    if (value == NULL) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨\n",
                  driverName, functionName);
        return asynError;
    }
    
    // ë§¤ê°œë³€ìˆ˜ë³„ ì½ê¸° ì²˜ë¦¬
    if (function == P_ThresholdValue) {
        *value = thresholdValue_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ì„ê³„ê°’ ì½ê¸°: %f V\n", driverName, functionName, *value);
    }
    else if (function == P_CurrentValue) {
        // í˜„ì¬ê°’ì€ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ë¯€ë¡œ ìµœì‹  ê°’ ë°˜í™˜
        *value = currentValue_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: í˜„ì¬ê°’ ì½ê¸°: %f V\n", driverName, functionName, *value);
        
        // í˜„ì¬ê°’ì´ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš° ê²½ê³ 
        if (*value < -10.0 || *value > 10.0) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: í˜„ì¬ê°’ì´ ì˜ˆìƒ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %f V\n",
                      driverName, functionName, *value);
        }
    }
    else if (function == P_Hysteresis) {
        *value = hysteresis_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì½ê¸°: %f V\n", driverName, functionName, *value);
    }
    else if (function == P_UpdateRate) {
        *value = updateRate_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ì—…ë°ì´íŠ¸ ì£¼ê¸° ì½ê¸°: %f Hz\n", driverName, functionName, *value);
    }
    else {
        // ì•Œ ìˆ˜ ì—†ëŠ” ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´ì„œëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ í˜¸ì¶œ
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: ì•Œ ìˆ˜ ì—†ëŠ” Float64 ë§¤ê°œë³€ìˆ˜: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::readFloat64(pasynUser, value);
        
        if (status != asynSuccess) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: ë¶€ëª¨ í´ë˜ìŠ¤ì—ì„œ ë§¤ê°œë³€ìˆ˜ ì½ê¸° ì‹¤íŒ¨: function=%d\n",
                      driverName, functionName, function);
        }
    }
    
    // ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¡œê¹…
    if (status != asynSuccess) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ë§¤ê°œë³€ìˆ˜ ì½ê¸° ì‹¤íŒ¨ - function=%d, status=%d\n",
                  driverName, functionName, function, status);
    }
    
    return status;
}

/** Int32 ë§¤ê°œë³€ìˆ˜ ì“°ê¸° ë©”ì„œë“œ */
asynStatus ThresholdLogicController::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "writeInt32";
    
    // ë§¤ê°œë³€ìˆ˜ë³„ ìœ íš¨ì„± ê²€ì‚¬ ë° ì²˜ë¦¬
    if (function == P_Enable) {
        // í™œì„±í™” ìƒíƒœ ìœ íš¨ì„± ê²€ì‚¬ (0 ë˜ëŠ” 1ë§Œ í—ˆìš©)
        if (value != 0 && value != 1) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: í™œì„±í™” ê°’ì´ 0 ë˜ëŠ” 1ì´ ì•„ë‹˜: %d (0ìœ¼ë¡œ ì²˜ë¦¬)\n",
                      driverName, functionName, value);
            value = (value != 0) ? 1 : 0; // 0ì´ ì•„ë‹Œ ê°’ì€ 1ë¡œ ì²˜ë¦¬
        }
        
        bool newEnabled = (value != 0);
        if (newEnabled != enabled_) {
            // ìƒíƒœ ë³€ê²½ ì „ ìœ íš¨ì„± ê²€ì‚¬
            if (newEnabled) {
                // í™œì„±í™”í•˜ê¸° ì „ í•„ìˆ˜ ë§¤ê°œë³€ìˆ˜ ê²€ì‚¬
                if (!validateParameters()) {
                    asynPrint(pasynUser, ASYN_TRACE_ERROR,
                              "%s::%s: ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ - í™œì„±í™”í•  ìˆ˜ ì—†ìŒ\n",
                              driverName, functionName);
                    return asynError;
                }
                
                // ì¥ì¹˜ ì—°ê²° ìƒíƒœ í™•ì¸
                if (strlen(devicePortName_) == 0) {
                    asynPrint(pasynUser, ASYN_TRACE_ERROR,
                              "%s::%s: ì¥ì¹˜ í¬íŠ¸ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ - í™œì„±í™”í•  ìˆ˜ ì—†ìŒ\n",
                              driverName, functionName);
                    return asynError;
                }
            }
            
            enabled_ = newEnabled;
            status = setIntegerParam(function, value);
            
            if (enabled_) {
                startMonitoring();
                asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                          "%s::%s: ì„ê³„ê°’ ë¡œì§ í™œì„±í™”ë¨ (í¬íŠ¸: %s, ì£¼ì†Œ: %d)\n", 
                          driverName, functionName, devicePortName_, deviceAddr_);
            } else {
                stopMonitoring();
                asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                          "%s::%s: ì„ê³„ê°’ ë¡œì§ ë¹„í™œì„±í™”ë¨\n", driverName, functionName);
            }
        } else {
            // ìƒíƒœ ë³€ê²½ì´ ì—†ëŠ” ê²½ìš°ì—ë„ ë§¤ê°œë³€ìˆ˜ ì—…ë°ì´íŠ¸
            status = setIntegerParam(function, value);
            asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                      "%s::%s: í™œì„±í™” ìƒíƒœ ìœ ì§€: %s\n", 
                      driverName, functionName, enabled_ ? "í™œì„±í™”" : "ë¹„í™œì„±í™”");
        }
    }
    else if (function == P_OutputState) {
        // ì¶œë ¥ ìƒíƒœëŠ” ì½ê¸° ì „ìš©ì´ë¯€ë¡œ ì“°ê¸° ê±°ë¶€
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ì¶œë ¥ ìƒíƒœëŠ” ì½ê¸° ì „ìš© ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤ (ì‹œë„ëœ ê°’: %d)\n",
                  driverName, functionName, value);
        return asynError;
    }
    else if (function == P_AlarmStatus) {
        // ì•ŒëŒ ìƒíƒœë„ ì½ê¸° ì „ìš©ì´ë¯€ë¡œ ì“°ê¸° ê±°ë¶€
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ì•ŒëŒ ìƒíƒœëŠ” ì½ê¸° ì „ìš© ë§¤ê°œë³€ìˆ˜ì…ë‹ˆë‹¤ (ì‹œë„ëœ ê°’: %d)\n",
                  driverName, functionName, value);
        return asynError;
    }
    else if (function == P_DeviceAddr) {
        // ì¥ì¹˜ ì£¼ì†Œ ìœ íš¨ì„± ê²€ì‚¬ (0-255 ë²”ìœ„)
        if (value < 0 || value > 255) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: ì¥ì¹˜ ì£¼ì†Œê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %d (ë²”ìœ„: 0-255)\n",
                      driverName, functionName, value);
            return asynError;
        }
        
        // í™œì„±í™” ìƒíƒœì—ì„œëŠ” ì¥ì¹˜ ì£¼ì†Œ ë³€ê²½ ë¶ˆê°€
        if (enabled_) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: í™œì„±í™” ìƒíƒœì—ì„œëŠ” ì¥ì¹˜ ì£¼ì†Œë¥¼ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤\n",
                      driverName, functionName);
            return asynError;
        }
        
        deviceAddr_ = value;
        status = setIntegerParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: ì¥ì¹˜ ì£¼ì†Œ ì„¤ì •ë¨: %d\n", driverName, functionName, value);
    }
    else {
        // ì•Œ ìˆ˜ ì—†ëŠ” ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´ì„œëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ í˜¸ì¶œ
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: ì•Œ ìˆ˜ ì—†ëŠ” Int32 ë§¤ê°œë³€ìˆ˜: function=%d, value=%d\n",
                  driverName, functionName, function, value);
        status = asynPortDriver::writeInt32(pasynUser, value);
    }
    
    // ì„±ê³µí•œ ê²½ìš°ì—ë§Œ ë§¤ê°œë³€ìˆ˜ ë³€ê²½ì‚¬í•­ì„ í´ë¼ì´ì–¸íŠ¸ì— ì•Œë¦¼
    if (status == asynSuccess) {
        callParamCallbacks();
    } else {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ë§¤ê°œë³€ìˆ˜ ì„¤ì • ì‹¤íŒ¨ - function=%d, value=%d, status=%d\n",
                  driverName, functionName, function, value, status);
    }
    
    return status;
}

/** Int32 ë§¤ê°œë³€ìˆ˜ ì½ê¸° ë©”ì„œë“œ */
asynStatus ThresholdLogicController::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "readInt32";
    
    // ì…ë ¥ ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
    if (value == NULL) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨\n",
                  driverName, functionName);
        return asynError;
    }
    
    // ë§¤ê°œë³€ìˆ˜ë³„ ì½ê¸° ì²˜ë¦¬
    if (function == P_Enable) {
        *value = enabled_ ? 1 : 0;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: í™œì„±í™” ìƒíƒœ ì½ê¸°: %d (%s)\n", 
                  driverName, functionName, *value, enabled_ ? "í™œì„±í™”" : "ë¹„í™œì„±í™”");
    }
    else if (function == P_OutputState) {
        *value = outputState_ ? 1 : 0;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ì¶œë ¥ ìƒíƒœ ì½ê¸°: %d (%s)\n", 
                  driverName, functionName, *value, outputState_ ? "HIGH" : "LOW");
        
        // ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì´ì§€ ì•Šì€ë° ì¶œë ¥ ìƒíƒœê°€ ë³€ê²½ëœ ê²½ìš° ê²½ê³ 
        if (!threadRunning_ && outputState_) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œê°€ ì¤‘ì§€ëœ ìƒíƒœì—ì„œ ì¶œë ¥ì´ HIGHì…ë‹ˆë‹¤\n",
                      driverName, functionName);
        }
    }
    else if (function == P_AlarmStatus) {
        *value = alarmStatus_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ì•ŒëŒ ìƒíƒœ ì½ê¸°: %d\n", driverName, functionName, *value);
        
        // ì•ŒëŒ ìƒíƒœì— ë”°ë¥¸ ì¶”ê°€ ì •ë³´ ì œê³µ
        const char* alarmDesc = "";
        switch (alarmStatus_) {
            case 0: alarmDesc = "ì •ìƒ"; break;
            case 1: alarmDesc = "ê²½ê³ "; break;
            case 2: alarmDesc = "ì£¼ìš” ì˜¤ë¥˜"; break;
            case 3: alarmDesc = "ì¹˜ëª…ì  ì˜¤ë¥˜"; break;
            default: alarmDesc = "ì•Œ ìˆ˜ ì—†ìŒ"; break;
        }
        
        if (alarmStatus_ != 0) {
            asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                      "%s::%s: ì•ŒëŒ ìƒíƒœ ìƒì„¸: %s\n", 
                      driverName, functionName, alarmDesc);
        }
    }
    else if (function == P_DeviceAddr) {
        *value = deviceAddr_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ì¥ì¹˜ ì£¼ì†Œ ì½ê¸°: %d\n", driverName, functionName, *value);
    }
    else {
        // ì•Œ ìˆ˜ ì—†ëŠ” ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´ì„œëŠ” ë¶€ëª¨ í´ë˜ìŠ¤ í˜¸ì¶œ
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: ì•Œ ìˆ˜ ì—†ëŠ” Int32 ë§¤ê°œë³€ìˆ˜: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::readInt32(pasynUser, value);
        
        if (status != asynSuccess) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: ë¶€ëª¨ í´ë˜ìŠ¤ì—ì„œ ë§¤ê°œë³€ìˆ˜ ì½ê¸° ì‹¤íŒ¨: function=%d\n",
                      driverName, functionName, function);
        }
    }
    
    // ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¡œê¹…
    if (status != asynSuccess) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ë§¤ê°œë³€ìˆ˜ ì½ê¸° ì‹¤íŒ¨ - function=%d, status=%d\n",
                  driverName, functionName, function, status);
    }
    
    return status;
}

/** ì„ê³„ê°’ ë¡œì§ ì²˜ë¦¬ ë©”ì„œë“œ 
 * 
 * ì´ ë©”ì„œë“œëŠ” ë‹¤ìŒ ê¸°ëŠ¥ë“¤ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤:
 * 1. ì¥ì¹˜ì—ì„œ í˜„ì¬ ê°’ì„ ì½ì–´ì˜´
 * 2. ì„ê³„ê°’ê³¼ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ë¥¼ ê³ ë ¤í•œ ë¹„êµ ë¡œì§ ìˆ˜í–‰
 * 3. ì¶œë ¥ ìƒíƒœ ë³€í™” ê°ì§€ ë° ì œì–´
 * 4. ì•ŒëŒ ìƒíƒœ ì„¤ì • ë° íƒ€ì„ìŠ¤íƒ¬í”„ ì—…ë°ì´íŠ¸
 */
void ThresholdLogicController::processThresholdLogic()
{
    const char* functionName = "processThresholdLogic";
    asynStatus status = asynSuccess;
    
    // í™œì„±í™”ë˜ì§€ ì•Šì€ ê²½ìš° ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
    if (!enabled_) {
        return;
    }
    
    // 1. ì¥ì¹˜ì—ì„œ í˜„ì¬ ê°’ì„ ì½ì–´ì˜´
    status = readCurrentValueFromDevice();
    if (status != asynSuccess) {
        ErrorHandler::handleCommunicationError(functionName, devicePortName_, deviceAddr_, 
                                              "í˜„ì¬ê°’ ì½ê¸°", pasynUserSelf);
        alarmStatus_ = 2; // MAJOR ì•ŒëŒ
        ErrorHandler::setAlarmStatus(pasynUserSelf, ErrorHandler::COMM_ALARM, 
                                   ErrorHandler::MAJOR_ALARM);
        updateAlarmStatus();
        return;
    }
    
    // 2. ì„ê³„ê°’ ë¹„êµ ë° íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ë¡œì§ êµ¬í˜„
    bool newOutputState = outputState_; // í˜„ì¬ ì¶œë ¥ ìƒíƒœë¡œ ì´ˆê¸°í™”
    
    if (!outputState_) {
        // í˜„ì¬ ì¶œë ¥ì´ LOWì¸ ê²½ìš°: ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ HIGHë¡œ ë³€ê²½
        if (currentValue_ > thresholdValue_) {
            newOutputState = true;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: ì„ê³„ê°’ ì´ˆê³¼ ê°ì§€ - í˜„ì¬ê°’: %f, ì„ê³„ê°’: %f\n",
                      driverName, functionName, currentValue_, thresholdValue_);
        }
    } else {
        // í˜„ì¬ ì¶œë ¥ì´ HIGHì¸ ê²½ìš°: ì„ê³„ê°’-íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©´ LOWë¡œ ë³€ê²½
        double lowerThreshold = thresholdValue_ - hysteresis_;
        if (currentValue_ < lowerThreshold) {
            newOutputState = false;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì„ê³„ê°’ ë¯¸ë§Œ ê°ì§€ - í˜„ì¬ê°’: %f, í•˜í•œì„ê³„ê°’: %f\n",
                      driverName, functionName, currentValue_, lowerThreshold);
        }
    }
    
    // 3. ìƒíƒœ ë³€í™” ê°ì§€ ë° ì¶œë ¥ ì œì–´
    if (newOutputState != outputState_) {
        // ìƒíƒœê°€ ë³€ê²½ëœ ê²½ìš°
        lastOutputState_ = outputState_; // ì´ì „ ìƒíƒœ ì €ì¥
        outputState_ = newOutputState;   // ìƒˆë¡œìš´ ìƒíƒœ ì„¤ì •
        
        // ì¥ì¹˜ì— ìƒˆë¡œìš´ ì¶œë ¥ ìƒíƒœ ì„¤ì •
        status = writeOutputStateToDevice(outputState_);
        if (status != asynSuccess) {
            ErrorHandler::handleCommunicationError(functionName, devicePortName_, deviceAddr_, 
                                                  "ì¶œë ¥ìƒíƒœ ì„¤ì •", pasynUserSelf);
            alarmStatus_ = 2; // MAJOR ì•ŒëŒ
            ErrorHandler::setAlarmStatus(pasynUserSelf, ErrorHandler::WRITE_ALARM, 
                                       ErrorHandler::MAJOR_ALARM);
        } else {
            // ì„±ê³µì ìœ¼ë¡œ ì¶œë ¥ ìƒíƒœê°€ ë³€ê²½ë¨
            alarmStatus_ = 0; // ì•ŒëŒ í•´ì œ
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: ì¶œë ¥ ìƒíƒœ ë³€ê²½ë¨: %s -> %s\n",
                      driverName, functionName, 
                      lastOutputState_ ? "HIGH" : "LOW",
                      outputState_ ? "HIGH" : "LOW");
        }
        
        // ì¶œë ¥ ìƒíƒœ ë§¤ê°œë³€ìˆ˜ ì—…ë°ì´íŠ¸
        setIntegerParam(P_OutputState, outputState_ ? 1 : 0);
    } else {
        // ìƒíƒœ ë³€í™”ê°€ ì—†ëŠ” ê²½ìš° - ì •ìƒ ë™ì‘
        if (alarmStatus_ == 0) {
            // ì´ë¯¸ ì•ŒëŒì´ ì—†ëŠ” ìƒíƒœë¼ë©´ ê·¸ëŒ€ë¡œ ìœ ì§€
        } else {
            // ì´ì „ì— ì•ŒëŒì´ ìˆì—ˆë‹¤ë©´ í•´ì œ
            alarmStatus_ = 0;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: ì •ìƒ ë™ì‘ - ì•ŒëŒ í•´ì œ\n",
                      driverName, functionName);
        }
    }
    
    // 4. ë§¤ê°œë³€ìˆ˜ ì—…ë°ì´íŠ¸ ë° íƒ€ì„ìŠ¤íƒ¬í”„ ê°±ì‹ 
    setDoubleParam(P_CurrentValue, currentValue_);
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    
    // íƒ€ì„ìŠ¤íƒ¬í”„ ì—…ë°ì´íŠ¸
    epicsTimeGetCurrent(&lastUpdate_);
    
    // 5. ì•ŒëŒ ìƒíƒœ ì—…ë°ì´íŠ¸ ë° í´ë¼ì´ì–¸íŠ¸ ì•Œë¦¼
    updateAlarmStatus();
    callParamCallbacks();
    
    // ë””ë²„ê·¸ ì •ë³´ ì¶œë ¥ (TRACE_FLOW ë ˆë²¨)
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ì²˜ë¦¬ ì™„ë£Œ - í˜„ì¬ê°’: %f, ì„ê³„ê°’: %f, ì¶œë ¥: %s, ì•ŒëŒ: %d\n",
              driverName, functionName, currentValue_, thresholdValue_,
              outputState_ ? "HIGH" : "LOW", alarmStatus_);
}

/** ëª¨ë‹ˆí„°ë§ ì‹œì‘ ë©”ì„œë“œ */
void ThresholdLogicController::startMonitoring()
{
    const char* functionName = "startMonitoring";
    
    // ì´ë¯¸ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° ì¤‘ë³µ ì‹œì‘ ë°©ì§€
    if (threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤\n",
                  driverName, functionName);
        return;
    }
    
    // ìŠ¤ë ˆë“œ ì¢…ë£Œ í”Œë˜ê·¸ ì´ˆê¸°í™”
    threadExit_ = false;
    
    // ì—…ë°ì´íŠ¸ ì£¼ê¸° ìœ íš¨ì„± ê²€ì‚¬ (0.1Hz ~ 1000Hz ë²”ìœ„)
    if (updateRate_ < 0.1 || updateRate_ > 1000.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: ì—…ë°ì´íŠ¸ ì£¼ê¸°ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨ (%f Hz), ê¸°ë³¸ê°’ 10Hzë¡œ ì„¤ì •\n",
                  driverName, functionName, updateRate_);
        updateRate_ = 10.0;
        setDoubleParam(P_UpdateRate, updateRate_);
    }
    
    // ìŠ¤ë ˆë“œ ì´ë¦„ ìƒì„±
    char threadName[64];
    snprintf(threadName, sizeof(threadName), "ThresholdMonitor_%s", portName);
    
    // epicsThread ìƒì„± ë° ì‹œì‘
    try {
        monitorThread_ = new epicsThread(
            *this,                      // epicsThreadRunable ê°ì²´ (this)
            threadName,                 // ìŠ¤ë ˆë“œ ì´ë¦„
            epicsThreadGetStackSize(epicsThreadStackMedium), // ìŠ¤íƒ í¬ê¸°
            epicsThreadPriorityMedium   // ì¤‘ê°„ ìš°ì„ ìˆœìœ„
        );
        
        if (monitorThread_ == NULL) {
            ErrorHandler::handleThreadError(functionName, threadName, 
                                           "ìŠ¤ë ˆë“œ ê°ì²´ ìƒì„± ì‹¤íŒ¨", pasynUserSelf);
            return;
        }
        
        // ìŠ¤ë ˆë“œ ì‹œì‘
        monitorThread_->start();
        threadRunning_ = true;
        
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘ë¨ - ì—…ë°ì´íŠ¸ ì£¼ê¸°: %f Hz\n",
                  driverName, functionName, updateRate_);
        
    } catch (std::exception& e) {
        ErrorHandler::handleThreadError(functionName, threadName, e.what(), pasynUserSelf);
        
        // ì‹¤íŒ¨ ì‹œ ì •ë¦¬
        if (monitorThread_) {
            delete monitorThread_;
            monitorThread_ = NULL;
        }
        threadRunning_ = false;
    }
}

/** ëª¨ë‹ˆí„°ë§ ì¤‘ì§€ ë©”ì„œë“œ */
void ThresholdLogicController::stopMonitoring()
{
    const char* functionName = "stopMonitoring";
    
    // ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì´ì§€ ì•Šì€ ê²½ìš°
    if (!threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì´ì§€ ì•ŠìŠµë‹ˆë‹¤\n",
                  driverName, functionName);
        return;
    }
    
    // ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹ í˜¸ ì„¤ì •
    threadExit_ = true;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì¢…ë£Œ ì‹ í˜¸ ì „ì†¡\n",
              driverName, functionName);
    
    // ìŠ¤ë ˆë“œê°€ ì¢…ë£Œë  ë•Œê¹Œì§€ ëŒ€ê¸° (ìµœëŒ€ 5ì´ˆ)
    if (monitorThread_) {
        int waitCount = 0;
        const int maxWaitCount = 50; // 5ì´ˆ (100ms * 50)
        
        while (threadRunning_ && waitCount < maxWaitCount) {
            epicsThreadSleep(0.1); // 100ms ëŒ€ê¸°
            waitCount++;
        }
        
        if (threadRunning_) {
            // ìŠ¤ë ˆë“œê°€ ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë˜ì§€ ì•Šì€ ê²½ìš° ê°•ì œ ì¢…ë£Œ
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: ìŠ¤ë ˆë“œê°€ ì •ìƒ ì¢…ë£Œë˜ì§€ ì•Šì•„ ê°•ì œ ì¢…ë£Œí•©ë‹ˆë‹¤\n",
                      driverName, functionName);
        } else {
            asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                      "%s::%s: ìŠ¤ë ˆë“œê°€ ì •ìƒì ìœ¼ë¡œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤\n",
                      driverName, functionName);
        }
        
        // ìŠ¤ë ˆë“œ ê°ì²´ ì‚­ì œ
        try {
            delete monitorThread_;
            monitorThread_ = NULL;
        } catch (std::exception& e) {
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: ìŠ¤ë ˆë“œ ì‚­ì œ ì¤‘ ì˜ˆì™¸ ë°œìƒ: %s\n",
                      driverName, functionName, e.what());
        }
    }
    
    // ìƒíƒœ ë³€ìˆ˜ ì´ˆê¸°í™”
    threadRunning_ = false;
    threadExit_ = false;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ëª¨ë‹ˆí„°ë§ ì¤‘ì§€ ì™„ë£Œ\n",
              driverName, functionName);
}

/** epicsThreadRunable ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ - ì£¼ê¸°ì  ë°ì´í„° ìˆ˜ì§‘ ë° ì„ê³„ê°’ ë¡œì§ ì²˜ë¦¬ */
void ThresholdLogicController::run()
{
    const char* functionName = "run";
    
    // ìŠ¤ë ˆë“œ ì‹œì‘ ë¡œê·¸
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì‹œì‘ - PID: %lu\n",
              driverName, functionName, (unsigned long)epicsThreadGetIdSelf());
    
    // ì—…ë°ì´íŠ¸ ì£¼ê¸° ê³„ì‚° (Hzë¥¼ ì´ˆ ë‹¨ìœ„ë¡œ ë³€í™˜)
    double sleepTime = 1.0 / updateRate_;
    
    // ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë³€ìˆ˜
    int cycleCount = 0;
    epicsTimeStamp startTime, currentTime;
    epicsTimeGetCurrent(&startTime);
    
    // ë©”ì¸ ëª¨ë‹ˆí„°ë§ ë£¨í”„
    while (!threadExit_) {
        try {
            // ë£¨í”„ ì‹œì‘ ì‹œê°„ ê¸°ë¡
            epicsTimeStamp loopStart;
            epicsTimeGetCurrent(&loopStart);
            
            // ì»¨íŠ¸ë¡¤ëŸ¬ê°€ í™œì„±í™”ëœ ê²½ìš°ì—ë§Œ ì„ê³„ê°’ ë¡œì§ ì²˜ë¦¬
            if (enabled_) {
                // ì„ê³„ê°’ ë¡œì§ ì²˜ë¦¬ (ë©”ì¸ ê¸°ëŠ¥)
                processThresholdLogic();
                
                // ì²˜ë¦¬ ì™„ë£Œ í›„ ë§¤ê°œë³€ìˆ˜ ì½œë°± í˜¸ì¶œ (í´ë¼ì´ì–¸íŠ¸ ì—…ë°ì´íŠ¸)
                callParamCallbacks();
            } else {
                // ë¹„í™œì„±í™” ìƒíƒœì—ì„œëŠ” í˜„ì¬ ê°’ë§Œ ì—…ë°ì´íŠ¸ (ëª¨ë‹ˆí„°ë§ ìœ ì§€)
                asynStatus status = readCurrentValueFromDevice();
                if (status == asynSuccess) {
                    setDoubleParam(P_CurrentValue, currentValue_);
                    callParamCallbacks();
                }
            }
            
            // ì£¼ê¸°ì  ì„±ëŠ¥ ë¦¬í¬íŠ¸ (1000 ì‚¬ì´í´ë§ˆë‹¤)
            cycleCount++;
            if (cycleCount % 1000 == 0) {
                epicsTimeGetCurrent(&currentTime);
                double elapsedTime = epicsTimeDiffInSeconds(&currentTime, &startTime);
                double actualRate = cycleCount / elapsedTime;
                
                asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                          "%s::%s: ì„±ëŠ¥ ë¦¬í¬íŠ¸ - ì‚¬ì´í´: %d, ì‹¤ì œ ì£¼ê¸°: %.2f Hz, ëª©í‘œ ì£¼ê¸°: %.2f Hz\n",
                          driverName, functionName, cycleCount, actualRate, updateRate_);
                
                // ì¹´ìš´í„° ë° ì‹œê°„ ë¦¬ì…‹
                cycleCount = 0;
                startTime = currentTime;
            }
            
            // ë£¨í”„ ì²˜ë¦¬ ì‹œê°„ ê³„ì‚°
            epicsTimeStamp loopEnd;
            epicsTimeGetCurrent(&loopEnd);
            double processingTime = epicsTimeDiffInSeconds(&loopEnd, &loopStart);
            
            // ì²˜ë¦¬ ì‹œê°„ì´ ì—…ë°ì´íŠ¸ ì£¼ê¸°ë³´ë‹¤ ê¸´ ê²½ìš° ê²½ê³ 
            if (processingTime > sleepTime) {
                asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                          "%s::%s: ì²˜ë¦¬ ì‹œê°„ ì´ˆê³¼ - ì²˜ë¦¬ì‹œê°„: %.3fì´ˆ, ëª©í‘œì£¼ê¸°: %.3fì´ˆ\n",
                          driverName, functionName, processingTime, sleepTime);
            }
            
            // ë‚¨ì€ ì‹œê°„ë§Œí¼ ëŒ€ê¸° (ì •í™•í•œ ì£¼ê¸° ìœ ì§€)
            double remainingSleepTime = sleepTime - processingTime;
            if (remainingSleepTime > 0.001) { // ìµœì†Œ 1ms ëŒ€ê¸°
                epicsThreadSleep(remainingSleepTime);
            } else {
                // ì²˜ë¦¬ ì‹œê°„ì´ ë„ˆë¬´ ê¸¸ì–´ì„œ ëŒ€ê¸°í•  ì‹œê°„ì´ ì—†ëŠ” ê²½ìš° ìµœì†Œ ëŒ€ê¸°
                epicsThreadSleep(0.001); // 1ms ìµœì†Œ ëŒ€ê¸°
            }
            
        } catch (std::exception& e) {
            // ì˜ˆì™¸ ë°œìƒ ì‹œ ë¡œê·¸ ì¶œë ¥ ë° ê³„ì† ì‹¤í–‰
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: ìŠ¤ë ˆë“œ ë£¨í”„ ì¤‘ ì˜ˆì™¸ ë°œìƒ: %s\n",
                      driverName, functionName, e.what());
            
            // ì˜ˆì™¸ ë°œìƒ ì‹œ ì ì‹œ ëŒ€ê¸° í›„ ê³„ì†
            epicsThreadSleep(1.0);
        } catch (...) {
            // ì•Œ ìˆ˜ ì—†ëŠ” ì˜ˆì™¸ ì²˜ë¦¬
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: ì•Œ ìˆ˜ ì—†ëŠ” ì˜ˆì™¸ ë°œìƒ\n",
                      driverName, functionName);
            
            // ì˜ˆì™¸ ë°œìƒ ì‹œ ì ì‹œ ëŒ€ê¸° í›„ ê³„ì†
            epicsThreadSleep(1.0);
        }
        
        // ì—…ë°ì´íŠ¸ ì£¼ê¸°ê°€ ë³€ê²½ëœ ê²½ìš° ìƒˆë¡œìš´ ì£¼ê¸°ë¡œ ì—…ë°ì´íŠ¸
        double newSleepTime = 1.0 / updateRate_;
        if (fabs(newSleepTime - sleepTime) > 0.001) { // 1ms ì´ìƒ ì°¨ì´ë‚˜ëŠ” ê²½ìš°
            sleepTime = newSleepTime;
            asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                      "%s::%s: ì—…ë°ì´íŠ¸ ì£¼ê¸° ë³€ê²½ë¨: %.2f Hz (%.3fì´ˆ ê°„ê²©)\n",
                      driverName, functionName, updateRate_, sleepTime);
        }
    }
    
    // ìŠ¤ë ˆë“œ ì¢…ë£Œ ì²˜ë¦¬
    threadRunning_ = false;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ì¢…ë£Œ - ì´ ì‚¬ì´í´: %d\n",
              driverName, functionName, cycleCount);
}

/** ì •ì  ìŠ¤ë ˆë“œ í•¨ìˆ˜ - í˜¸í™˜ì„±ì„ ìœ„í•´ ìœ ì§€ (ì‚¬ìš©ë˜ì§€ ì•ŠìŒ) */
void ThresholdLogicController::monitorThreadFunc(void* param)
{
    const char* functionName = "monitorThreadFunc";
    
    // ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŒ (run() ë©”ì„œë“œë¡œ ëŒ€ì²´ë¨)
    printf("%s::%s: ê²½ê³  - ì´ í•¨ìˆ˜ëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. run() ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.\n", 
           driverName, functionName);
}

/** ì¥ì¹˜ì—ì„œ í˜„ì¬ ê°’ì„ ì½ì–´ì˜¤ëŠ” ë©”ì„œë“œ 
 * 
 * ì´ ë©”ì„œë“œëŠ” ì—°ê²°ëœ ì¥ì¹˜ í¬íŠ¸ë¥¼ í†µí•´ ì•„ë‚ ë¡œê·¸ ì…ë ¥ ê°’ì„ ì½ì–´ì˜µë‹ˆë‹¤.
 * ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” asyn í´ë¼ì´ì–¸íŠ¸ë¥¼ í†µí•´ ì¥ì¹˜ì™€ í†µì‹ í•©ë‹ˆë‹¤.
 */
asynStatus ThresholdLogicController::readCurrentValueFromDevice()
{
    const char* functionName = "readCurrentValueFromDevice";
    asynStatus status = asynSuccess;
    asynUser *pasynUser = NULL;
    
    // asyn í´ë¼ì´ì–¸íŠ¸ ìƒì„± (ì¥ì¹˜ í¬íŠ¸ì— ì—°ê²°)
    status = pasynOctetSyncIO->connect(devicePortName_, deviceAddr_, &pasynUser, NULL);
    if (status != asynSuccess) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì¥ì¹˜ í¬íŠ¸ %sì— ì—°ê²° ì‹¤íŒ¨\n",
                  driverName, functionName, devicePortName_);
        return status;
    }
    
    try {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì—¬ê¸°ì„œ ì¥ì¹˜ë³„ í”„ë¡œí† ì½œì— ë”°ë¼ ê°’ì„ ì½ì–´ì˜´
        // í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•´ ê°„ë‹¨í•œ ê°’ì„ ìƒì„±
        // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” measComp ë“œë¼ì´ë²„ë¥¼ í†µí•´ USB1608G-2AOì—ì„œ ê°’ì„ ì½ì–´ì˜´
        
        // ì‹œë®¬ë ˆì´ì…˜: ì‹œê°„ì— ë”°ë¼ ë³€í™”í•˜ëŠ” ì‚¬ì¸íŒŒ ê°’ ìƒì„± (í…ŒìŠ¤íŠ¸ìš©)
        epicsTimeStamp now;
        epicsTimeGetCurrent(&now);
        double timeSeconds = now.secPastEpoch + now.nsec / 1e9;
        
        // 0.0 ~ 10.0V ë²”ìœ„ì˜ ì‚¬ì¸íŒŒ + ë…¸ì´ì¦ˆ
        currentValue_ = 5.0 + 4.0 * sin(timeSeconds * 0.1) + 0.1 * (rand() / (double)RAND_MAX - 0.5);
        
        // ê°’ì˜ ìœ íš¨ì„± ê²€ì‚¬
        if (currentValue_ < -10.0 || currentValue_ > 10.0) {
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: ì½ì–´ì˜¨ ê°’ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %f\n",
                      driverName, functionName, currentValue_);
            currentValue_ = fmax(-10.0, fmin(10.0, currentValue_)); // ë²”ìœ„ ì œí•œ
        }
        
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ì¥ì¹˜ì—ì„œ ê°’ ì½ê¸° ì„±ê³µ: %f V\n",
                  driverName, functionName, currentValue_);
        
    } catch (...) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì¥ì¹˜ ì½ê¸° ì¤‘ ì˜ˆì™¸ ë°œìƒ\n",
                  driverName, functionName);
        status = asynError;
    }
    
    // asyn í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ
    if (pasynUser) {
        pasynOctetSyncIO->disconnect(pasynUser);
    }
    
    return status;
}

/** ì¥ì¹˜ì— ì¶œë ¥ ìƒíƒœë¥¼ ì„¤ì •í•˜ëŠ” ë©”ì„œë“œ 
 * 
 * ì´ ë©”ì„œë“œëŠ” ì—°ê²°ëœ ì¥ì¹˜ í¬íŠ¸ë¥¼ í†µí•´ ë””ì§€í„¸ ì¶œë ¥ ìƒíƒœë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
 * ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” asyn í´ë¼ì´ì–¸íŠ¸ë¥¼ í†µí•´ ì¥ì¹˜ì™€ í†µì‹ í•©ë‹ˆë‹¤.
 */
asynStatus ThresholdLogicController::writeOutputStateToDevice(bool state)
{
    const char* functionName = "writeOutputStateToDevice";
    asynStatus status = asynSuccess;
    asynUser *pasynUser = NULL;
    
    // asyn í´ë¼ì´ì–¸íŠ¸ ìƒì„± (ì¥ì¹˜ í¬íŠ¸ì— ì—°ê²°)
    status = pasynOctetSyncIO->connect(devicePortName_, deviceAddr_, &pasynUser, NULL);
    if (status != asynSuccess) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì¥ì¹˜ í¬íŠ¸ %sì— ì—°ê²° ì‹¤íŒ¨\n",
                  driverName, functionName, devicePortName_);
        return status;
    }
    
    try {
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì—¬ê¸°ì„œ ì¥ì¹˜ë³„ í”„ë¡œí† ì½œì— ë”°ë¼ ì¶œë ¥ì„ ì„¤ì •
        // í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•´ ë¡œê·¸ë§Œ ì¶œë ¥
        // ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” measComp ë“œë¼ì´ë²„ë¥¼ í†µí•´ USB1608G-2AOì˜ ë””ì§€í„¸ ì¶œë ¥ì„ ì œì–´
        
        // ì‹œë®¬ë ˆì´ì…˜: ì¶œë ¥ ìƒíƒœ ì„¤ì • ëª…ë ¹ ì „ì†¡ (í…ŒìŠ¤íŠ¸ìš©)
        const char* stateStr = state ? "HIGH" : "LOW";
        int digitalValue = state ? 1 : 0;
        
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ì¥ì¹˜ì— ë””ì§€í„¸ ì¶œë ¥ ì„¤ì • - ìƒíƒœ: %s (ê°’: %d)\n",
                  driverName, functionName, stateStr, digitalValue);
        
        // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì—¬ê¸°ì„œ ë‹¤ìŒê³¼ ê°™ì€ ì‘ì—…ì„ ìˆ˜í–‰:
        // 1. ì¥ì¹˜ì˜ ë””ì§€í„¸ ì¶œë ¥ ë ˆì§€ìŠ¤í„°ì— ê°’ ì“°ê¸°
        // 2. ëª…ë ¹ ì „ì†¡ ë° ì‘ë‹µ í™•ì¸
        // 3. ì˜¤ë¥˜ ìƒíƒœ ê²€ì‚¬
        
        // ì‹œë®¬ë ˆì´ì…˜: ì„±ê³µì ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆë‹¤ê³  ê°€ì •
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                  "%s::%s: ì¶œë ¥ ìƒíƒœ ì„¤ì • ì™„ë£Œ: %s\n",
                  driverName, functionName, stateStr);
        
    } catch (...) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì¥ì¹˜ ì“°ê¸° ì¤‘ ì˜ˆì™¸ ë°œìƒ\n",
                  driverName, functionName);
        status = asynError;
    }
    
    // asyn í´ë¼ì´ì–¸íŠ¸ ì—°ê²° í•´ì œ
    if (pasynUser) {
        pasynOctetSyncIO->disconnect(pasynUser);
    }
    
    return status;
}

/** ì•ŒëŒ ìƒíƒœ ì—…ë°ì´íŠ¸ ë©”ì„œë“œ 
 * 
 * ì´ ë©”ì„œë“œëŠ” í˜„ì¬ ì•ŒëŒ ìƒíƒœì— ë”°ë¼ EPICS ì•ŒëŒ ì‹œìŠ¤í…œì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
 * ì•ŒëŒ ì‹¬ê°ë„ì™€ ìƒíƒœë¥¼ ì„¤ì •í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ì— ì•Œë¦¼ì„ ì œê³µí•©ë‹ˆë‹¤.
 */
void ThresholdLogicController::updateAlarmStatus()
{
    const char* functionName = "updateAlarmStatus";
    int alarmSeverity = 0;  // NO_ALARM
    int alarmStatus = 0;    // NO_ALARM
    
    // ì•ŒëŒ ìƒíƒœì— ë”°ë¥¸ ì‹¬ê°ë„ ë° ìƒíƒœ ì„¤ì •
    switch (alarmStatus_) {
        case 0:  // ì •ìƒ ìƒíƒœ
            alarmSeverity = 0;  // NO_ALARM
            alarmStatus = 0;    // NO_ALARM
            break;
            
        case 1:  // ê²½ê³  ìƒíƒœ (MINOR)
            alarmSeverity = 1;  // MINOR_ALARM
            alarmStatus = 3;    // STATE_ALARM
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: MINOR ì•ŒëŒ ì„¤ì • - ê²½ê³  ìƒíƒœ\n",
                      driverName, functionName);
            break;
            
        case 2:  // ì£¼ìš” ì˜¤ë¥˜ ìƒíƒœ (MAJOR)
            alarmSeverity = 2;  // MAJOR_ALARM
            alarmStatus = 4;    // COMM_ALARM (í†µì‹  ì˜¤ë¥˜)
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: MAJOR ì•ŒëŒ ì„¤ì • - í†µì‹  ì˜¤ë¥˜\n",
                      driverName, functionName);
            break;
            
        case 3:  // ì¹˜ëª…ì  ì˜¤ë¥˜ ìƒíƒœ (INVALID)
            alarmSeverity = 3;  // INVALID_ALARM
            alarmStatus = 17;   // UDF_ALARM (ì •ì˜ë˜ì§€ ì•Šì€ ê°’)
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: INVALID ì•ŒëŒ ì„¤ì • - ì¹˜ëª…ì  ì˜¤ë¥˜\n",
                      driverName, functionName);
            break;
            
        default:
            // ì•Œ ìˆ˜ ì—†ëŠ” ì•ŒëŒ ìƒíƒœ
            alarmSeverity = 2;  // MAJOR_ALARM
            alarmStatus = 17;   // UDF_ALARM
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: ì•Œ ìˆ˜ ì—†ëŠ” ì•ŒëŒ ìƒíƒœ: %d\n",
                      driverName, functionName, alarmStatus_);
            break;
    }
    
    // ì£¼ìš” ë§¤ê°œë³€ìˆ˜ë“¤ì— ì•ŒëŒ ìƒíƒœ ì„¤ì •
    // í˜„ì¬ ê°’ ë§¤ê°œë³€ìˆ˜ì— ì•ŒëŒ ì„¤ì •
    setParamAlarmStatus(P_CurrentValue, alarmStatus);
    setParamAlarmSeverity(P_CurrentValue, alarmSeverity);
    
    // ì¶œë ¥ ìƒíƒœ ë§¤ê°œë³€ìˆ˜ì— ì•ŒëŒ ì„¤ì •
    setParamAlarmStatus(P_OutputState, alarmStatus);
    setParamAlarmSeverity(P_OutputState, alarmSeverity);
    
    // ì•ŒëŒ ìƒíƒœ ë§¤ê°œë³€ìˆ˜ ìì²´ ì—…ë°ì´íŠ¸
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    setParamAlarmStatus(P_AlarmStatus, alarmStatus);
    setParamAlarmSeverity(P_AlarmStatus, alarmSeverity);
    
    // ë””ë²„ê·¸ ì •ë³´ ì¶œë ¥
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ì•ŒëŒ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ - ìƒíƒœ: %d, ì‹¬ê°ë„: %d, EPICSìƒíƒœ: %d\n",
              driverName, functionName, alarmStatus_, alarmSeverity, alarmStatus);
}

/** ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ ë©”ì„œë“œ */
bool ThresholdLogicController::validateParameters()
{
    const char* functionName = "validateParameters";
    bool isValid = true;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ ì‹œì‘\n",
              driverName, functionName);
    
    // 1. ì„ê³„ê°’ ìœ íš¨ì„± ê²€ì‚¬
    if (thresholdValue_ < -10.0 || thresholdValue_ > 10.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì„ê³„ê°’ì´ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %f (ë²”ìœ„: -10.0 ~ +10.0 V)\n",
                  driverName, functionName, thresholdValue_);
        isValid = false;
    }
    
    // 2. íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ìœ íš¨ì„± ê²€ì‚¬
    if (hysteresis_ < 0.0 || hysteresis_ > 5.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %f (ë²”ìœ„: 0.0 ~ 5.0 V)\n",
                  driverName, functionName, hysteresis_);
        isValid = false;
    }
    
    // 3. ì„ê³„ê°’ê³¼ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê´€ê³„ ê²€ì‚¬
    if (hysteresis_ > fabs(thresholdValue_)) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ê°€ ì„ê³„ê°’ì˜ ì ˆëŒ“ê°’ë³´ë‹¤ í¼ - íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: %f, ì„ê³„ê°’: %f\n",
                  driverName, functionName, hysteresis_, thresholdValue_);
        // ê²½ê³ ì´ì§€ë§Œ ë™ì‘ì€ ê°€ëŠ¥í•˜ë¯€ë¡œ isValidëŠ” falseë¡œ ì„¤ì •í•˜ì§€ ì•ŠìŒ
    }
    
    // 4. ì—…ë°ì´íŠ¸ ì£¼ê¸° ìœ íš¨ì„± ê²€ì‚¬
    if (updateRate_ < 0.1 || updateRate_ > 1000.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì—…ë°ì´íŠ¸ ì£¼ê¸°ê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %f (ë²”ìœ„: 0.1 ~ 1000.0 Hz)\n",
                  driverName, functionName, updateRate_);
        isValid = false;
    }
    
    // 5. ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ ê²€ì‚¬
    if (strlen(devicePortName_) == 0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ì´ ì„¤ì •ë˜ì§€ ì•ŠìŒ\n",
                  driverName, functionName);
        isValid = false;
    } else if (strlen(devicePortName_) >= sizeof(devicePortName_)) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ì´ ë„ˆë¬´ ê¹€: %s\n",
                  driverName, functionName, devicePortName_);
        isValid = false;
    }
    
    // 6. ì¥ì¹˜ ì£¼ì†Œ ìœ íš¨ì„± ê²€ì‚¬
    if (deviceAddr_ < 0 || deviceAddr_ > 255) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì¥ì¹˜ ì£¼ì†Œê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %d (ë²”ìœ„: 0-255)\n",
                  driverName, functionName, deviceAddr_);
        isValid = false;
    }
    
    // 7. í˜„ì¬ê°’ ìœ íš¨ì„± ê²€ì‚¬ (ê²½ê³ ë§Œ ì¶œë ¥)
    if (currentValue_ < -10.0 || currentValue_ > 10.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: í˜„ì¬ê°’ì´ ì˜ˆìƒ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %f V (ì˜ˆìƒ ë²”ìœ„: -10.0 ~ +10.0 V)\n",
                  driverName, functionName, currentValue_);
        // í˜„ì¬ê°’ì€ ì¸¡ì •ê°’ì´ë¯€ë¡œ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ë¡œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
    }
    
    // 8. ì•ŒëŒ ìƒíƒœ ìœ íš¨ì„± ê²€ì‚¬
    if (alarmStatus_ < 0 || alarmStatus_ > 3) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ì•ŒëŒ ìƒíƒœê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: %d (ë²”ìœ„: 0-3)\n",
                  driverName, functionName, alarmStatus_);
        // ì•ŒëŒ ìƒíƒœë¥¼ ì •ìƒìœ¼ë¡œ ë¦¬ì…‹
        alarmStatus_ = 0;
        setIntegerParam(P_AlarmStatus, alarmStatus_);
    }
    
    // 9. ë…¼ë¦¬ì  ì¼ê´€ì„± ê²€ì‚¬
    if (enabled_ && !threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: í™œì„±í™” ìƒíƒœì´ì§€ë§Œ ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ë˜ì§€ ì•ŠìŒ\n",
                  driverName, functionName);
        // ì´ëŠ” ì¼ì‹œì ì¸ ìƒíƒœì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì˜¤ë¥˜ë¡œ ì²˜ë¦¬í•˜ì§€ ì•ŠìŒ
    }
    
    // 10. ë©”ëª¨ë¦¬ ë° ë¦¬ì†ŒìŠ¤ ìƒíƒœ ê²€ì‚¬
    if (enabled_ && monitorThread_ == NULL) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: í™œì„±í™” ìƒíƒœì´ì§€ë§Œ ëª¨ë‹ˆí„°ë§ ìŠ¤ë ˆë“œ ê°ì²´ê°€ NULLì„\n",
                  driverName, functionName);
        isValid = false;
    }
    
    // ê²€ì‚¬ ê²°ê³¼ ë¡œê¹…
    if (isValid) {
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: ëª¨ë“  ë§¤ê°œë³€ìˆ˜ê°€ ìœ íš¨í•¨\n",
                  driverName, functionName);
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: í˜„ì¬ ì„¤ì • - ì„ê³„ê°’: %f V, íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: %f V, ì£¼ê¸°: %f Hz\n",
                  driverName, functionName, thresholdValue_, hysteresis_, updateRate_);
    } else {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ - ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”\n",
                  driverName, functionName);
    }
    
    return isValid;
}



/* IOC ì‰˜ ëª…ë ¹ì–´ êµ¬í˜„ */

/** ThresholdLogicConfig IOC ì‰˜ ëª…ë ¹ì–´ êµ¬í˜„
 * 
 * ìƒˆë¡œìš´ ThresholdLogicController ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³  êµ¬ì„±í•©ë‹ˆë‹¤.
 * 
 * ë§¤ê°œë³€ìˆ˜:
 *   portName   - ìƒì„±í•  asyn í¬íŠ¸ì˜ ì´ë¦„ (ë¬¸ìì—´)
 *   devicePort - ì—°ê²°í•  ì¥ì¹˜ í¬íŠ¸ì˜ ì´ë¦„ (ë¬¸ìì—´)  
 *   deviceAddr - ì¥ì¹˜ ì£¼ì†Œ (ì •ìˆ˜, 0-255 ë²”ìœ„)
 * 
 * ë°˜í™˜ê°’:
 *   0  - ì„±ê³µ
 *   -1 - ì‹¤íŒ¨
 * 
 * ì‚¬ìš© ì˜ˆ:
 *   ThresholdLogicConfig("THRESHOLD1", "USB1608G_2AO_cpp_PORT", 0)
 */
extern "C" int ThresholdLogicConfig(const char* portName, const char* devicePort, int deviceAddr)
{
    const char* functionName = "ThresholdLogicConfig";
    
    // ì…ë ¥ ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
    if (portName == NULL || strlen(portName) == 0) {
        printf("%s ì˜¤ë¥˜: í¬íŠ¸ ì´ë¦„ì´ NULLì´ê±°ë‚˜ ë¹„ì–´ìˆìŠµë‹ˆë‹¤\n", functionName);
        return -1;
    }
    
    if (devicePort == NULL || strlen(devicePort) == 0) {
        printf("%s ì˜¤ë¥˜: ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ì´ NULLì´ê±°ë‚˜ ë¹„ì–´ìˆìŠµë‹ˆë‹¤\n", functionName);
        return -1;
    }
    
    if (deviceAddr < 0 || deviceAddr > 255) {
        printf("%s ì˜¤ë¥˜: ì¥ì¹˜ ì£¼ì†Œê°€ ìœ íš¨ ë²”ìœ„(0-255)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤: %d\n", 
               functionName, deviceAddr);
        return -1;
    }
    
    // í¬íŠ¸ ì´ë¦„ ì¤‘ë³µ ê²€ì‚¬
    if (findAsynPortDriver(portName) != NULL) {
        printf("%s ì˜¤ë¥˜: í¬íŠ¸ ì´ë¦„ '%s'ì´ ì´ë¯¸ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤\n", 
               functionName, portName);
        return -1;
    }
    
    try {
        // ThresholdLogicController ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        ThresholdLogicController* pController = new ThresholdLogicController(portName, devicePort, deviceAddr);
        
        if (pController == NULL) {
            printf("%s ì˜¤ë¥˜: ThresholdLogicController ìƒì„± ì‹¤íŒ¨\n", functionName);
            return -1;
        }
        
        printf("%s: ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë¨ - í¬íŠ¸: %s, ì¥ì¹˜í¬íŠ¸: %s, ì£¼ì†Œ: %d\n",
               functionName, portName, devicePort, deviceAddr);
        
        return 0;
        
    } catch (std::bad_alloc& e) {
        printf("%s ì˜¤ë¥˜: ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨ - %s\n", functionName, e.what());
        return -1;
    } catch (std::exception& e) {
        printf("%s ì˜¤ë¥˜: ì˜ˆì™¸ ë°œìƒ - %s\n", functionName, e.what());
        return -1;
    } catch (...) {
        printf("%s ì˜¤ë¥˜: ì•Œ ìˆ˜ ì—†ëŠ” ì˜ˆì™¸ ë°œìƒ\n", functionName);
        return -1;
    }
}

/** ThresholdLogicHelp IOC ì‰˜ ëª…ë ¹ì–´ êµ¬í˜„ - ì‚¬ìš©ë²• ë„ì›€ë§ í‘œì‹œ */
extern "C" void ThresholdLogicHelp(void)
{
    printf("\n=== ThresholdLogicController ì‚¬ìš© ê°€ì´ë“œ ===\n\n");
    
    printf("1. ThresholdLogicConfig - ì„ê³„ê°’ ë¡œì§ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±\n");
    printf("   ì‚¬ìš©ë²•: ThresholdLogicConfig(portName, devicePort, deviceAddr)\n");
    printf("   ë§¤ê°œë³€ìˆ˜:\n");
    printf("     portName   : ìƒì„±í•  asyn í¬íŠ¸ ì´ë¦„ (ë¬¸ìì—´)\n");
    printf("     devicePort : ì—°ê²°í•  ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ (ë¬¸ìì—´)\n");
    printf("     deviceAddr : ì¥ì¹˜ ì£¼ì†Œ (ì •ìˆ˜, 0-255)\n");
    printf("   ì˜ˆì œ:\n");
    printf("     ThresholdLogicConfig(\"THRESHOLD1\", \"USB1608G_2AO_cpp_PORT\", 0)\n\n");
    
    printf("2. ì£¼ìš” ê¸°ëŠ¥:\n");
    printf("   - ì•„ë‚ ë¡œê·¸ ì…ë ¥ ê°’ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§\n");
    printf("   - ì„¤ì • ê°€ëŠ¥í•œ ì„ê³„ê°’ê³¼ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤\n");
    printf("   - ë””ì§€í„¸ ì¶œë ¥ ìë™ ì œì–´\n");
    printf("   - EPICS ë ˆì½”ë“œë¥¼ í†µí•œ ì›ê²© ì œì–´\n");
    printf("   - ì•ŒëŒ ë° ìƒíƒœ ëª¨ë‹ˆí„°ë§\n\n");
    
    printf("3. ë°ì´í„°ë² ì´ìŠ¤ ë ˆì½”ë“œ ì ‘ê·¼:\n");
    printf("   $(P)$(R)Threshold     - ì„ê³„ê°’ ì„¤ì • (V)\n");
    printf("   $(P)$(R)CurrentValue  - í˜„ì¬ ì¸¡ì •ê°’ (V)\n");
    printf("   $(P)$(R)OutputState   - ì¶œë ¥ ìƒíƒœ (0/1)\n");
    printf("   $(P)$(R)Enable        - í™œì„±í™” ì œì–´ (0/1)\n");
    printf("   $(P)$(R)Hysteresis    - íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê°’ (V)\n");
    printf("   $(P)$(R)UpdateRate    - ì—…ë°ì´íŠ¸ ì£¼ê¸° (Hz)\n");
    printf("   $(P)$(R)AlarmStatus   - ì•ŒëŒ ìƒíƒœ\n\n");
    
    printf("4. ì¼ë°˜ì ì¸ ì‚¬ìš© ìˆœì„œ:\n");
    printf("   a) ThresholdLogicConfigë¡œ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±\n");
    printf("   b) ë°ì´í„°ë² ì´ìŠ¤ í…œí”Œë¦¿ ë¡œë“œ\n");
    printf("   c) ì„ê³„ê°’ ë° íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì„¤ì •\n");
    printf("   d) Enable ë ˆì½”ë“œë¡œ ëª¨ë‹ˆí„°ë§ ì‹œì‘\n\n");
    
    printf("5. ë¬¸ì œ í•´ê²°:\n");
    printf("   - í¬íŠ¸ ì´ë¦„ ì¤‘ë³µ: ë‹¤ë¥¸ í¬íŠ¸ ì´ë¦„ ì‚¬ìš©\n");
    printf("   - ì¥ì¹˜ ì—°ê²° ì‹¤íŒ¨: ì¥ì¹˜ í¬íŠ¸ ë° ì£¼ì†Œ í™•ì¸\n");
    printf("   - ì•ŒëŒ ë°œìƒ: AlarmStatus ë ˆì½”ë“œ í™•ì¸\n");
    printf("   - ì„±ëŠ¥ ë¬¸ì œ: UpdateRate ì¡°ì •\n\n");
    
    printf("ìì„¸í•œ ì •ë³´ëŠ” ThresholdLogicController ë¬¸ì„œë¥¼ ì°¸ì¡°í•˜ì„¸ìš”.\n");
    printf("===============================================\n\n");
}

/* IOC ì‰˜ ëª…ë ¹ì–´ ë“±ë¡ êµ¬ì¡°ì²´ ì •ì˜ */

// ThresholdLogicConfig ëª…ë ¹ì–´ ì¸ìˆ˜ ì •ì˜
static const iocshArg thresholdConfigArg0 = {
    "portName", 
    iocshArgString
};
static const iocshArg thresholdConfigArg1 = {
    "devicePort", 
    iocshArgString
};
static const iocshArg thresholdConfigArg2 = {
    "deviceAddr", 
    iocshArgInt
};

static const iocshArg *thresholdConfigArgs[] = {
    &thresholdConfigArg0,
    &thresholdConfigArg1,
    &thresholdConfigArg2
};

// ThresholdLogicConfig ëª…ë ¹ì–´ ì •ì˜
static const iocshFuncDef thresholdConfigFuncDef = {
    "ThresholdLogicConfig",                    // ëª…ë ¹ì–´ ì´ë¦„
    3,                                         // ì¸ìˆ˜ ê°œìˆ˜
    thresholdConfigArgs                        // ì¸ìˆ˜ ë°°ì—´
};

// ThresholdLogicHelp ëª…ë ¹ì–´ ì •ì˜ (ì¸ìˆ˜ ì—†ìŒ)
static const iocshFuncDef thresholdHelpFuncDef = {
    "ThresholdLogicHelp",                      // ëª…ë ¹ì–´ ì´ë¦„
    0,                                         // ì¸ìˆ˜ ê°œìˆ˜
    NULL                                       // ì¸ìˆ˜ ì—†ìŒ
};

/* IOC ì‰˜ ëª…ë ¹ì–´ ì½œë°± í•¨ìˆ˜ë“¤ */

/** ThresholdLogicConfig ëª…ë ¹ì–´ ì½œë°± í•¨ìˆ˜ */
static void thresholdConfigCallFunc(const iocshArgBuf *args)
{
    // ì¸ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬
    if (args == NULL) {
        printf("ThresholdLogicConfig: ì¸ìˆ˜ê°€ NULLì…ë‹ˆë‹¤\n");
        return;
    }
    
    // ëª…ë ¹ì–´ ì‹¤í–‰ ë° ê²°ê³¼ ì²˜ë¦¬
    int result = ThresholdLogicConfig(args[0].sval, args[1].sval, args[2].ival);
    
    if (result != 0) {
        printf("ThresholdLogicConfig: ëª…ë ¹ì–´ ì‹¤í–‰ ì‹¤íŒ¨ (ë°˜í™˜ê°’: %d)\n", result);
        printf("ë„ì›€ë§ì„ ë³´ë ¤ë©´ 'ThresholdLogicHelp'ë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n");
    }
}

/** ThresholdLogicHelp ëª…ë ¹ì–´ ì½œë°± í•¨ìˆ˜ */
static void thresholdHelpCallFunc(const iocshArgBuf *args)
{
    // ì¸ìˆ˜ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ (ë„ì›€ë§ ëª…ë ¹ì–´)
    (void)args; // ì»´íŒŒì¼ëŸ¬ ê²½ê³  ë°©ì§€
    
    ThresholdLogicHelp();
}

/** IOC ì‰˜ ëª…ë ¹ì–´ ë“±ë¡ í•¨ìˆ˜ 
 * 
 * ì´ í•¨ìˆ˜ëŠ” EPICS IOC ì‹œì‘ ì‹œ ìë™ìœ¼ë¡œ í˜¸ì¶œë˜ì–´
 * ThresholdLogicController ê´€ë ¨ ëª…ë ¹ì–´ë“¤ì„ IOC ì‰˜ì— ë“±ë¡í•©ë‹ˆë‹¤.
 */
extern "C" void ThresholdLogicRegister(void)
{
    const char* functionName = "ThresholdLogicRegister";
    
    // ThresholdLogicConfig ëª…ë ¹ì–´ ë“±ë¡
    iocshRegister(&thresholdConfigFuncDef, thresholdConfigCallFunc);
    
    // ThresholdLogicHelp ëª…ë ¹ì–´ ë“±ë¡
    iocshRegister(&thresholdHelpFuncDef, thresholdHelpCallFunc);
    
    printf("%s: IOC ì‰˜ ëª…ë ¹ì–´ ë“±ë¡ ì™„ë£Œ\n", functionName);
    printf("  - ThresholdLogicConfig: ì„ê³„ê°’ ë¡œì§ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±\n");
    printf("  - ThresholdLogicHelp: ì‚¬ìš©ë²• ë„ì›€ë§ í‘œì‹œ\n");
    printf("ë„ì›€ë§ì„ ë³´ë ¤ë©´ 'ThresholdLogicHelp'ë¥¼ ì…ë ¥í•˜ì„¸ìš”.\n");
}

/** êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬ (ErrorHandler ì‚¬ìš©) */
bool ThresholdLogicController::validateConfigurationWithErrorHandler()
{
    const char* functionName = "validateConfigurationWithErrorHandler";
    
    // ErrorHandler::ThresholdConfig êµ¬ì¡°ì²´ ìƒì„±
    ErrorHandler::ThresholdConfig config;
    strncpy(config.portName, portName, sizeof(config.portName) - 1);
    config.portName[sizeof(config.portName) - 1] = '\0';
    
    strncpy(config.devicePort, devicePortName_, sizeof(config.devicePort) - 1);
    config.devicePort[sizeof(config.devicePort) - 1] = '\0';
    
    config.deviceAddr = deviceAddr_;
    config.updateRate = updateRate_;
    config.priority = 50; // ê¸°ë³¸ ìš°ì„ ìˆœìœ„
    config.thresholdValue = thresholdValue_;
    config.hysteresis = hysteresis_;
    
    // ErrorHandlerë¥¼ ì‚¬ìš©í•œ ìœ íš¨ì„± ê²€ì‚¬
    ErrorHandler::ValidationResult result = ErrorHandler::validateConfiguration(config);
    
    if (!result.isValid) {
        ErrorHandler::logError(result.errorLevel, functionName, result.errorMessage, pasynUserSelf);
        if (strlen(result.suggestion) > 0) {
            ErrorHandler::logError(ErrorHandler::INFO, functionName, 
                                  result.suggestion, pasynUserSelf);
        }
        return false;
    }
    
    if (result.errorLevel == ErrorHandler::WARNING) {
        ErrorHandler::logError(ErrorHandler::WARNING, functionName, 
                              result.errorMessage, pasynUserSelf);
        if (strlen(result.suggestion) > 0) {
            ErrorHandler::logError(ErrorHandler::INFO, functionName, 
                                  result.suggestion, pasynUserSelf);
        }
    }
    
    return true;
}

/** ì˜¤ë¥˜ ë¡œê¹… (ErrorHandler ì‚¬ìš©) */
void ThresholdLogicController::logError(const char* functionName, const char* message)
{
    if (functionName == NULL || message == NULL) {
        ErrorHandler::logError(ErrorHandler::ERROR, "ThresholdLogicController::logError", 
                              "NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨");
        return;
    }
    
    // ì „ì²´ í•¨ìˆ˜ ì´ë¦„ êµ¬ì„±
    char fullFunctionName[128];
    snprintf(fullFunctionName, sizeof(fullFunctionName), 
            "ThresholdLogicController::%s", functionName);
    
    // ErrorHandlerë¥¼ í†µí•œ ë¡œê¹…
    ErrorHandler::logError(ErrorHandler::ERROR, fullFunctionName, message, pasynUserSelf);
}
/* EPICS ë“±ë¡ì ë‚´ë³´ë‚´ê¸° */
epicsExportRegistrar(ThresholdLogicRegister);











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.Common/USB1608G_2AO_V2.dbd
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.dbd)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/USB1608G_2AO_V2Main.cpp
=================================================
/* USB1608G_2AO_V2Main.cpp */
/* Author:  Marty Kraimer Date:    17MAR2000 */

#include <stddef.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "epicsExit.h"
#include "epicsThread.h"
#include "iocsh.h"

int main(int argc,char *argv[])
{
    if(argc>=2) {
        iocsh(argv[1]);
        epicsThreadSleep(.2);
    }
    iocsh(NULL);
    epicsExit(0);
    return(0);
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/drvUSBCTR.cpp
=================================================
/* drvUSBCTR.cpp
 *
 * Driver for Measurement Computing USB-CTR04/08 counter/timer module using asynPortDriver base class
 *
 * This driver supports simple digital in/out bit and word, timer (digital pulse generator), counter,
 *   EPICS scaler record, multi-channel scaler mode
 *
 * Mark Rivers
 * May 29, 2014
*/

#include <math.h>
#include <stdlib.h>
#include <string.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsTime.h>

#include <asynPortDriver.h>

#include "drvMca.h"
#include "devScalerAsyn.h"

#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

#include <epicsExport.h>
#include <measCompDiscover.h>

#define DRIVER_VERSION "4.2"

typedef enum {
  MCSPoint0Clear,
  MCSPoint0NoClear,
  MCSPoint0Skip
} MCSPoint0Action_t;

static const char *driverName = "USBCTR";

// Board parameters
#define modelNameString           "MODEL_NAME"
#define modelNumberString         "MODEL_NUMBER"
#define firmwareVersionString     "FIRMWARE_VERSION"
#define uniqueIDString            "UNIQUE_ID"
#define ULVersionString           "UL_VERSION"
#define driverVersionString       "DRIVER_VERSION"
#define pollSleepMSString         "POLL_SLEEP_MS"
#define pollTimeMSString          "POLL_TIME_MS"
#define lastErrorMessageString    "LAST_ERROR_MESSAGE"

// Pulse output parameters
#define pulseGenRunString         "PULSE_RUN"
#define pulseGenPeriodString      "PULSE_PERIOD"
#define pulseGenDutyCycleString   "PULSE_DUTY_CYCLE"
#define pulseGenDelayString       "PULSE_DELAY"
#define pulseGenCountString       "PULSE_COUNT"
#define pulseGenIdleStateString   "PULSE_IDLE_STATE"

// Counter parameters
#define counterCountsString       "COUNTER_VALUE"
#define counterResetString        "COUNTER_RESET"

// Trigger parameters
#define triggerModeString         "TRIGGER_MODE"

// Digital I/O parameters
#define digitalDirectionString    "DIGITAL_DIRECTION"
#define digitalInputString        "DIGITAL_INPUT"
#define digitalOutputString       "DIGITAL_OUTPUT"

// MCS parameters other than those in drvMca.h
#define MCSCurrentPointString     "MCS_CURRENT_POINT"
#define MCSMaxPointsString        "MCS_MAX_POINTS"
#define MCSTimeWFString           "MCS_TIME_WF"
#define MCSAbsTimeWFString        "MCS_ABS_TIME_WF"
#define MCSCounterEnableString    "MCS_COUNTER_ENABLE"
#define MCSPrescaleCounterString  "MCS_PRESCALE_COUNTER"
#define MCSPoint0ActionString     "MCS_POINT0_ACTION"

// Model ID
#define modelString               "MODEL"

#define MIN_FREQUENCY   0.023
#define MAX_FREQUENCY   48e6
#define MIN_DELAY       0.
#define MAX_DELAY       67.11
#define MAX_COUNTERS    8   // Maximum mumber of counters on USB-CTR04/08
#define MAX_MCS_COUNTERS (MAX_COUNTERS + 1) // +1 for collecting the digital I/O in MCS mode
#define DIGITAL_IO_COUNTER (MAX_MCS_COUNTERS-1) // Index of the digital I/O enable in mcsCounterEnable_ array;
#define MAX_DAQ_LEN     2*MAX_MCS_COUNTERS // Each counter can take 2 words
#define NUM_TIMERS      4   // Number of timers on USB-CTR08
#define NUM_IO_BITS     8   // Number of digital I/O bits on USB-CTR08
#define MAX_SIGNALS     MAX_MCS_COUNTERS
#define MAX_ERROR_STRING_LEN 256
#define MAX_BOARDNAME_LEN    256

#define DEFAULT_POLL_TIME 0.01
#define SINGLEIO_THRESHOLD_TIME 0.01  // Above this time uses SINGLEIO, below uses block I/O.

/** This is the class definition for the USBCTR class
  */
class USBCTR : public asynPortDriver {
public:
  USBCTR(const char *portName, const char *uniqueID, int maxTimePoints, double pollTime);

  /* These are the methods that we override from asynPortDriver */
  virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
  virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
  virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
  virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);
  virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn);
  virtual void report(FILE *fp, int details);
  // These should be private but are called from C
  virtual void pollerThread(void);

protected:
  // Model parameters
  int modelName_;
  int modelNumber_;
  int firmwareVersion_;
  int uniqueID_;
  int ULVersion_;
  int driverVersion_;
  int pollSleepMS_;
  int pollTimeMS_;
  int lastErrorMessage_;

  // Pulse generator parameters
  int pulseGenRun_;
  int pulseGenPeriod_;
  int pulseGenDutyCycle_;
  int pulseGenDelay_;
  int pulseGenCount_;
  int pulseGenIdleState_;

  // Counter parameters
  int counterCounts_;
  int counterReset_;

  // Trigger parameters
  int triggerMode_;

  // Digital I/O parameters
  int digitalDirection_;
  int digitalInput_;
  int digitalOutput_;

  // MCS parameters other than those in drvMca.h
  int MCSCurrentPoint_;
  int MCSMaxPoints_;
  int MCSTimeWF_;
  int MCSAbsTimeWF_;
  int MCSCounterEnable_;
  int MCSPrescaleCounter_;
  int MCSPoint0Action_;

  // Command for EPICS MCA record
  int mcaStartAcquire_;
  int mcaStopAcquire_;
  int mcaErase_;
  int mcaData_;
  int mcaReadStatus_;
  int mcaChannelAdvanceSource_;
  int mcaNumChannels_;
  int mcaDwellTime_;
  int mcaPresetLiveTime_;
  int mcaPresetRealTime_;
  int mcaPresetCounts_;
  int mcaPresetLowChannel_;
  int mcaPresetHighChannel_;
  int mcaPresetSweeps_;
  int mcaAcquireMode_;
  int mcaSequence_;
  int mcaPrescale_;
  int mcaAcquiring_;
  int mcaElapsedLiveTime_;
  int mcaElapsedRealTime_;
  int mcaElapsedCounts_;

  // Commands for EPICS scaler record
  int scalerReset_;
  int scalerChannels_;
  int scalerRead_;
  int scalerPresets_;
  int scalerArm_;
  int scalerDone_;

// Model ID
  int model_;

private:
  int boardType_;
  #ifdef _WIN32
    int boardNum_;
  #else
    DaqDeviceHandle daqDeviceHandle_;
  #endif
  DaqDeviceDescriptor daqDeviceDescriptor_;
  char boardName_[MAX_BOARDNAME_LEN];
  double pollTime_;
  int forceCallback_;
  int numCounters_;
  int numMCSCounters_;
  int maxTimePoints_;
  epicsInt32 scalerCounts_[MAX_COUNTERS];
  epicsInt32 scalerPresetCounts_[MAX_COUNTERS];
  epicsInt32 *MCSBuffer_[MAX_MCS_COUNTERS];
  bool mcsCounterEnable_[MAX_MCS_COUNTERS];
  short chanArray_[MAX_DAQ_LEN];
  short chanTypeArray_[MAX_DAQ_LEN];
  short gainArray_[MAX_DAQ_LEN];

  epicsFloat32 *MCSTimeBuffer_;
  epicsFloat64 *MCSAbsTimeBuffer_;
  epicsFloat64 *pCountsF64_;
  epicsUInt64 *pCountsUI64_;
  epicsInt32 *pCountsI32_;
  epicsInt16 *pCountsI16_;
  int counterBits_;

  bool pulseGenRunning_[NUM_TIMERS];
  bool scalerRunning_;
  bool MCSRunning_;
  bool MCSErased_;
  epicsTimeStamp startTime_;
  double elapsedPrevious_;
  char errorMessage_[MAX_ERROR_STRING_LEN];

  char *getErrorMessage(int error);
  int startPulseGenerator(int timerNum);
  int stopPulseGenerator(int timerNum);
  int resetScaler();
  int startScaler();
  int readScaler();
  int stopScaler();
  int clearScalerPresets();
  int setScalerPresets();
  int startMCS();
  int stopMCS();
  int readMCS();
  int eraseMCS();
  int computeMCSTimes();
};

static void pollerThreadC(void * pPvt)
{
    USBCTR *pUSBCTR = (USBCTR *)pPvt;
    pUSBCTR->pollerThread();
}

USBCTR::USBCTR(const char *portName, const char *uniqueID, int maxTimePoints, double pollTime)
  : asynPortDriver(portName, MAX_SIGNALS,
      asynInt32Mask | asynUInt32DigitalMask | asynInt32ArrayMask | asynFloat32ArrayMask | asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask |asynDrvUserMask,
      asynInt32Mask | asynUInt32DigitalMask | asynInt32ArrayMask | asynFloat32ArrayMask | asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask,
      // Note: ASYN_CANBLOCK must not be set because the scaler record does not work with asynchronous device support
      ASYN_MULTIDEVICE, 1, /* ASYN_CANBLOCK=0, ASYN_MULTIDEVICE=1, autoConnect=1 */
      0, 0),  /* Default priority and stack size */
    pollTime_((pollTime > 0.) ? pollTime : DEFAULT_POLL_TIME),
    forceCallback_(1),
    maxTimePoints_(maxTimePoints),
    scalerRunning_(false),
    MCSRunning_(false)
{
  int i;
  int status;
  long long handle;
  //static const char *functionName = "USBCTR";

  for (i=0; i<NUM_TIMERS; i++) pulseGenRunning_[i]=0;

  status = measCompCreateDevice(uniqueID, daqDeviceDescriptor_, &handle);
  if (status) {
    printf("Error creating device with measCompCreateDevice\n");
    return;
  }

  #ifdef _WIN32
    boardNum_ = (int) handle;
    strcpy(boardName_, daqDeviceDescriptor_.ProductName);
    boardType_ = daqDeviceDescriptor_.ProductID;
  #else
    daqDeviceHandle_ = handle;
    strcpy(boardName_, daqDeviceDescriptor_.productName);
    boardType_ = daqDeviceDescriptor_.productId;
  #endif

  // Model parameters
  createParam(modelNameString,                 asynParamOctet,  &modelName_);
  createParam(modelNumberString,               asynParamInt32,  &modelNumber_);
  createParam(firmwareVersionString,            asynParamOctet, &firmwareVersion_);
  createParam(uniqueIDString,                   asynParamOctet, &uniqueID_);
  createParam(ULVersionString,                  asynParamOctet, &ULVersion_);
  createParam(driverVersionString,              asynParamOctet, &driverVersion_);
  createParam(pollSleepMSString,              asynParamFloat64, &pollSleepMS_);
  createParam(pollTimeMSString,               asynParamFloat64, &pollTimeMS_);
  createParam(lastErrorMessageString,           asynParamOctet, &lastErrorMessage_);

  // Pulse generator parameters
  createParam(pulseGenRunString,               asynParamInt32, &pulseGenRun_);
  createParam(pulseGenPeriodString,          asynParamFloat64, &pulseGenPeriod_);
  createParam(pulseGenDutyCycleString,       asynParamFloat64, &pulseGenDutyCycle_);
  createParam(pulseGenDelayString,           asynParamFloat64, &pulseGenDelay_);
  createParam(pulseGenCountString,             asynParamInt32, &pulseGenCount_);
  createParam(pulseGenIdleStateString,         asynParamInt32, &pulseGenIdleState_);

  // Counter parameters
  createParam(counterCountsString,             asynParamInt32, &counterCounts_);
  createParam(counterResetString,              asynParamInt32, &counterReset_);

  // Trigger parameters
  createParam(triggerModeString,               asynParamInt32, &triggerMode_);

  // Digital I/O parameters
  createParam(digitalDirectionString,  asynParamUInt32Digital, &digitalDirection_);
  createParam(digitalInputString,      asynParamUInt32Digital, &digitalInput_);
  createParam(digitalOutputString,     asynParamUInt32Digital, &digitalOutput_);

  // MCS parameters other than those in drvMca.h
  createParam(MCSCurrentPointString,           asynParamInt32, &MCSCurrentPoint_);
  createParam(MCSMaxPointsString,              asynParamInt32, &MCSMaxPoints_);
  createParam(MCSTimeWFString,          asynParamFloat32Array, &MCSTimeWF_);
  createParam(MCSAbsTimeWFString,       asynParamFloat64Array, &MCSAbsTimeWF_);
  createParam(MCSCounterEnableString,  asynParamUInt32Digital, &MCSCounterEnable_);
  createParam(MCSPrescaleCounterString,        asynParamInt32, &MCSPrescaleCounter_);
  createParam(MCSPoint0ActionString,           asynParamInt32, &MCSPoint0Action_);

  // MCA record parameters
  createParam(mcaStartAcquireString,                asynParamInt32, &mcaStartAcquire_);
  createParam(mcaStopAcquireString,                 asynParamInt32, &mcaStopAcquire_);            /* int32, write */
  createParam(mcaEraseString,                       asynParamInt32, &mcaErase_);                  /* int32, write */
  createParam(mcaDataString,                   asynParamInt32Array, &mcaData_);                   /* int32Array, read/write */
  createParam(mcaReadStatusString,                  asynParamInt32, &mcaReadStatus_);             /* int32, write */
  createParam(mcaChannelAdvanceSourceString,        asynParamInt32, &mcaChannelAdvanceSource_);   /* int32, write */
  createParam(mcaNumChannelsString,                 asynParamInt32, &mcaNumChannels_);            /* int32, write */
  createParam(mcaDwellTimeString,                 asynParamFloat64, &mcaDwellTime_);              /* float64, write */
  createParam(mcaPresetLiveTimeString,            asynParamFloat64, &mcaPresetLiveTime_);         /* float64, write */
  createParam(mcaPresetRealTimeString,            asynParamFloat64, &mcaPresetRealTime_);         /* float64, write */
  createParam(mcaPresetCountsString,              asynParamFloat64, &mcaPresetCounts_);           /* float64, write */
  createParam(mcaPresetLowChannelString,            asynParamInt32, &mcaPresetLowChannel_);       /* int32, write */
  createParam(mcaPresetHighChannelString,           asynParamInt32, &mcaPresetHighChannel_);      /* int32, write */
  createParam(mcaPresetSweepsString,                asynParamInt32, &mcaPresetSweeps_);           /* int32, write */
  createParam(mcaAcquireModeString,                 asynParamInt32, &mcaAcquireMode_);            /* int32, write */
  createParam(mcaSequenceString,                    asynParamInt32, &mcaSequence_);               /* int32, write */
  createParam(mcaPrescaleString,                    asynParamInt32, &mcaPrescale_);               /* int32, write */
  createParam(mcaAcquiringString,                   asynParamInt32, &mcaAcquiring_);              /* int32, read */
  createParam(mcaElapsedLiveTimeString,           asynParamFloat64, &mcaElapsedLiveTime_);        /* float64, read */
  createParam(mcaElapsedRealTimeString,           asynParamFloat64, &mcaElapsedRealTime_);        /* float64, read */
  createParam(mcaElapsedCountsString,             asynParamFloat64, &mcaElapsedCounts_);          /* float64, read */

  // Scaler record parameters
  createParam(SCALER_RESET_COMMAND_STRING,          asynParamInt32, &scalerReset_);               /* int32, write */
  createParam(SCALER_CHANNELS_COMMAND_STRING,       asynParamInt32, &scalerChannels_);            /* int32, read */
  createParam(SCALER_READ_COMMAND_STRING,      asynParamInt32Array, &scalerRead_);                /* int32Array, read */
  createParam(SCALER_PRESET_COMMAND_STRING,         asynParamInt32, &scalerPresets_);             /* int32, write */
  createParam(SCALER_ARM_COMMAND_STRING,            asynParamInt32, &scalerArm_);                 /* int32, write */
  createParam(SCALER_DONE_COMMAND_STRING,           asynParamInt32, &scalerDone_);                /* int32, read */

  // Model ID
  createParam(modelString,                          asynParamInt32, &model_);                     /* int32, read */

  if (strcmp(boardName_, "USB-CTR08") == 0) {
    setIntegerParam(model_, 0);
    numCounters_ = 8;
  } else if (strcmp(boardName_, "USB-CTR04") == 0) {
    setIntegerParam(model_, 1);
    numCounters_ = 4;
  } else {
    printf("Unknown model\n");
  }

  char uniqueIDStr[256];
  char firmwareVersion[256];
  char ULVersion[256];
  #ifdef _WIN32
    int size = sizeof(uniqueIDStr);
    cbGetConfigString(BOARDINFO, boardNum_, 0, BIDEVUNIQUEID, uniqueIDStr, &size);
    size = sizeof(firmwareVersion);
    cbGetConfigString(BOARDINFO, boardNum_, VER_FW_MAIN, BIDEVVERSION, firmwareVersion, &size);
    float DLLRevNum, VXDRevNum;
    cbGetRevision(&DLLRevNum, &VXDRevNum);
    sprintf(ULVersion, "%f %f", DLLRevNum, VXDRevNum);
  #else
    strcpy(uniqueIDStr, uniqueID);
    unsigned int size = sizeof(firmwareVersion);
    ulDevGetConfigStr(daqDeviceHandle_, ::DEV_CFG_VER_STR, DEV_VER_FW_MAIN, firmwareVersion, &size);
    size = sizeof(ULVersion);
    ulGetInfoStr(UL_INFO_VER_STR, 0, ULVersion, &size);
  #endif
  setIntegerParam(modelNumber_, boardType_);
  setStringParam(modelName_, boardName_);
  setStringParam(uniqueID_, uniqueIDStr);
  setStringParam(firmwareVersion_, firmwareVersion);
  setStringParam(ULVersion_, ULVersion);
  setStringParam(driverVersion_, DRIVER_VERSION);
  
  // Allocate memory for the input buffers
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    MCSBuffer_[i]  = (epicsInt32 *) calloc(maxTimePoints_,  sizeof(epicsInt32));
  }
  MCSTimeBuffer_    = (epicsFloat32 *) calloc(maxTimePoints_,  sizeof(epicsFloat32));
  MCSAbsTimeBuffer_ = (epicsFloat64 *) calloc(maxTimePoints_,  sizeof(epicsFloat64));
  for (i=0; i<MAX_DAQ_LEN; i++) {
    gainArray_[i] = BIP10VOLTS;
  }
  pCountsF64_  = (epicsFloat64 *) calloc((maxTimePoints+1)  * MAX_MCS_COUNTERS, sizeof(epicsFloat64));
  pCountsUI64_ = (epicsUInt64 *)pCountsF64_;
  pCountsI32_ = (epicsInt32 *)pCountsF64_;
  pCountsI16_ = (epicsInt16 *)pCountsF64_;

  // Set values of some parameters that need to be set because init record order is not predictable
  // or because the corresponding records are PINI=NO.
  setIntegerParam(pulseGenRun_, 0);
  setIntegerParam(scalerDone_, 1);
  setIntegerParam(scalerChannels_, numCounters_);
  setIntegerParam(MCSMaxPoints_, maxTimePoints_);
  setIntegerParam(mcaNumChannels_, maxTimePoints_);
  resetScaler();
  clearScalerPresets();
  MCSErased_ = false;

  eraseMCS();

  // Put pulse generators in known state
  for (i=0; i<NUM_TIMERS; i++) {
    stopPulseGenerator(i);
  }

  /* Start the thread to poll counters and digital inputs and do callbacks to
   * device support */
  epicsThreadCreate("USBCTRPoller",
                    epicsThreadPriorityLow,
                    epicsThreadGetStackSize(epicsThreadStackMedium),
                    (EPICSTHREADFUNC)pollerThreadC,
                    this);
}

char *USBCTR::getErrorMessage(int error)
{
  #ifdef _WIN32
      cbGetErrMsg(error, errorMessage_);
  #else
      ulGetErrMsg((UlError)error, errorMessage_);
  #endif
  return errorMessage_;
}

int USBCTR::startPulseGenerator(int timerNum)
{
  int status=0;
  double frequency, period, delay;
  double dutyCycle;
  int count, idleState;
  static const char *functionName = "startPulseGenerator";

  getDoubleParam (timerNum, pulseGenPeriod_,    &period);
  getDoubleParam (timerNum, pulseGenDutyCycle_, &dutyCycle);
  getDoubleParam (timerNum, pulseGenDelay_,     &delay);
  getIntegerParam(timerNum, pulseGenCount_,     &count);
  getIntegerParam(timerNum, pulseGenIdleState_, &idleState);

  frequency = 1./period;
  if (frequency < MIN_FREQUENCY) frequency = MIN_FREQUENCY;
  if (frequency > MAX_FREQUENCY) frequency = MAX_FREQUENCY;
  period = 1. / frequency;
  if (dutyCycle <= 0.) dutyCycle = .0001;
  if (dutyCycle >= 1.) dutyCycle = .9999;
  if (delay < MIN_DELAY) delay = MIN_DELAY;
  if (delay > MAX_DELAY) delay = MAX_DELAY;

  #ifdef _WIN32
    status = cbPulseOutStart(boardNum_, timerNum, &frequency, &dutyCycle, count, &delay, idleState, 0);
  #else
    TmrIdleState idle = (idleState == 0) ? TMRIS_LOW : TMRIS_HIGH;
    status = ulTmrPulseOutStart(daqDeviceHandle_, timerNum, &frequency, &dutyCycle, count, &delay, idle, PO_DEFAULT);
  #endif
  if (status != 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbPulseOutStart timerNum=%d frequency=%f, dutyCycle=%f,"
      " count=%d, delay=%f, idleState=%d, status=%d, error=%s\n",
      driverName, functionName, timerNum, frequency, dutyCycle,
      count, delay, idleState, status, getErrorMessage(status));
    return status;
  }
  // We may not have gotten the frequency, dutyCycle, and delay we asked for, set the actual values
  // in the parameter library
  pulseGenRunning_[timerNum] = true;
  period = 1. / frequency;
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: started pulse generator %d actual frequency=%f, actual period=%f, actual duty cycle=%f, actual delay=%f\n",
    driverName, functionName, timerNum, frequency, period, dutyCycle, delay);
  setDoubleParam(timerNum, pulseGenPeriod_, period);
  setDoubleParam(timerNum, pulseGenDutyCycle_, dutyCycle);
  setDoubleParam(timerNum, pulseGenDelay_, delay);
  return 0;
}

int USBCTR::stopPulseGenerator(int timerNum)
{
  int status;
  static const char *functionName = "stopPulseGenerator";

  pulseGenRunning_[timerNum] = false;
  #ifdef _WIN32
    status = cbPulseOutStop(boardNum_, timerNum);
  #else
    status = ulTmrPulseOutStop(daqDeviceHandle_, timerNum);
  #endif
  if (status != 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbPulseOutStop timerNum=%d, status=%d, error=%s\n",
      driverName, functionName, timerNum, status, getErrorMessage(status));
  }
  return status;
}

int USBCTR::startMCS()
{
  int numPoints;
  int i;
  int options;
  int status;
  epicsUInt32 counterEnable;
  int prescale;
  int prescaleCounter;
  int mode;
  int point0Action;
  double dwell;
  int channelAdvance;
  static const char *functionName = "startMCS";

  getIntegerParam(MCSPrescaleCounter_, &prescaleCounter);
  getIntegerParam(mcaPrescale_, &prescale);
  getIntegerParam(mcaChannelAdvanceSource_, &channelAdvance);
  getUIntDigitalParam(MCSCounterEnable_,  &counterEnable, 0xFFFFFFFF);

  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    mcsCounterEnable_[i] = (counterEnable & (1<<i)) ? true : false;
  }
  numMCSCounters_ = 0;
  for (i=0; i<numCounters_; i++) {
    if (!mcsCounterEnable_[i]) continue;
    numMCSCounters_++;
    #ifdef _WIN32
      mode = OUTPUT_ON | CLEAR_ON_READ;
      status = cbCConfigScan(boardNum_, i, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
    #else
      mode = CMM_OUTPUT_ON | CMM_CLEAR_ON_READ;
      status = ulCConfigScan(daqDeviceHandle_, i, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
        driverName, functionName, i, mode, status, getErrorMessage(status));
    }
  }

  if ((channelAdvance == mcaChannelAdvance_External) && (prescale > 1) ) {
    #ifdef _WIN32
      status = cbCLoad32(boardNum_, OUTPUTVAL0REG0+prescaleCounter, 0);
      status = cbCLoad32(boardNum_, OUTPUTVAL1REG0+prescaleCounter, prescale-1);
      status = cbCLoad32(boardNum_, MAXLIMITREG0+prescaleCounter, prescale-1);
      mode = OUTPUT_ON | RANGE_LIMIT_ON;
      status = cbCConfigScan(boardNum_, prescaleCounter, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_OUTPUT_VAL0, 0);
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_OUTPUT_VAL1, prescale-1);
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_MAX_LIMIT, prescale-1);
      mode = CMM_OUTPUT_ON | CMM_RANGE_LIMIT_ON;
      status = ulCConfigScan(daqDeviceHandle_, prescaleCounter, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
        driverName, functionName, prescaleCounter, mode, status, getErrorMessage(status));
    }
  }
  getIntegerParam(mcaNumChannels_, &numPoints);
  getDoubleParam(mcaDwellTime_, &dwell);
  getIntegerParam(MCSPoint0Action_, &point0Action);
  if (point0Action == MCSPoint0Skip) numPoints++;
  #ifdef _WIN32
    long count;
    int chanCount;
    long pretrigCount = 0;
    double rateFactor=1.0;
    if (dwell > 1e-6) rateFactor = 1000.;
    long rate = (LONG)((rateFactor / dwell) + 0.5);
    options = 0;
    if (dwell > 1e-4) {
      counterBits_ = 32;
    } else {
      counterBits_ = 16;
    }
    options |= BACKGROUND;
    if (rateFactor > 1.0)
      options |= HIGHRESRATE;
    if (channelAdvance == mcaChannelAdvance_External)
      options |= EXTCLOCK;
    // At long dwell times read use a single buffer for reading the data
    if (dwell >= SINGLEIO_THRESHOLD_TIME)
      options |= SINGLEIO;
    // Always use EXTTRIGGER
    options |= EXTTRIGGER;
    if (point0Action == MCSPoint0NoClear)
      options |= NOCLEAR;
  
    for (i=0, chanCount=0; i<numCounters_; i++) {
      if (!mcsCounterEnable_[i]) continue;
      chanArray_[chanCount] = i;
      chanTypeArray_[chanCount] = CTRBANK0;
      chanCount++;
      if (counterBits_ == 16) continue;
      chanArray_[chanCount] = i;
      chanTypeArray_[chanCount] = CTRBANK1;
      chanCount++;
    }
    if (mcsCounterEnable_[DIGITAL_IO_COUNTER]) {
      numMCSCounters_++;
      chanArray_[chanCount] = AUXPORT;
      chanTypeArray_[chanCount] = DIGITAL8;
      chanCount++;
      if (counterBits_ == 32) { // Add padding for binary data
        chanArray_[chanCount] = 0;
        chanTypeArray_[chanCount] = PADZERO;
        chanCount++;
      }
    }
    count = chanCount * numPoints;
    status = cbDaqInScan(boardNum_, chanArray_, chanTypeArray_, gainArray_, chanCount, &rate,
                         &pretrigCount, &count, pCountsI16_, options);
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
      "%s::%s called cbDaqInScan, chanCount=%d, count=%ld, rate=%ld,"
      " inputMemHandle_=%p, options=0x%x, status=%d\n",
      driverName, functionName, chanCount, count, rate,
      pCountsI16_, options, status);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbDaqInScan, chanCount=%d, count=%ld, rate=%ld,"
        " inputMemHandle_=%p, options=0x%x, status=%d, error=%s\n",
        driverName, functionName, chanCount, count, rate,
        pCountsI16_, options, status, getErrorMessage(status));
    }
    // The actual dwell time can be different from requested due to clock granularity
    setDoubleParam(mcaDwellTime_, rateFactor/rate);
  #else
    double rate = 1. / dwell;  
    options = SO_DEFAULTIO;
    if (channelAdvance == mcaChannelAdvance_External)
      options |= SO_EXTCLOCK;
    // At long dwell times read use a single buffer for reading the data
    if (dwell >= SINGLEIO_THRESHOLD_TIME)
      options |= SO_SINGLEIO;
    // Always use EXTTRIGGER
    options |= SO_EXTTRIGGER;
    int flags = DAQINSCAN_FF_DEFAULT;
    if (point0Action == MCSPoint0NoClear)
      flags |= DAQINSCAN_FF_NOCLEAR;
    DaqInChanDescriptor *pDICD = new DaqInChanDescriptor[MAX_MCS_COUNTERS];
    int outChan=0;
    for (i=0; i<numCounters_; i++) {
      if (!mcsCounterEnable_[i]) continue;
      pDICD[outChan].channel = i;
      pDICD[outChan].type = DAQI_CTR32;
      pDICD[outChan].range = BIP10VOLTS;
      outChan++;
    }
    if (mcsCounterEnable_[DIGITAL_IO_COUNTER]) {
      numMCSCounters_++;
      pDICD[outChan].channel = AUXPORT;
      pDICD[outChan].type = DAQI_DIGITAL;
      pDICD[outChan].range = BIP10VOLTS;
      outChan++;
    }
    int numChans = outChan;
    status = ulDaqInScan(daqDeviceHandle_, pDICD, numChans, numPoints, &rate, (ScanOption) options, (DaqInScanFlag) flags, pCountsF64_);
    delete[] pDICD;
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling ulDaqInScan, numChans=%d, numPoints=%d, rate=%f, options=0x%x, flags=0x%x, status=%d, error=%s\n",
        driverName, functionName, numChans, numPoints, rate,
        options, status, flags, getErrorMessage(status));
    }
    // The actual dwell time can be different from requested due to clock granularity
    setDoubleParam(mcaDwellTime_, 1./rate);
  #endif
  setIntegerParam(MCSCurrentPoint_, 0);
  MCSRunning_ = true;

  return 0;
}

int USBCTR::readMCS()
{
  int lastPoint=0;
  int currentPoint;
  int status;
  int i, j;
  short ctrStatus;
  long ctrCount, ctrIndex;
  epicsTimeStamp now;
  int numTimePoints;
  int point0Action;
  double presetReal, elapsedTime;
  static const char *functionName = "readMCS";

  // We need to treat Windows and Linux differently here because with UL for Linux the buffer is always float64, while on
  // Windows it is either int32 or int16.
  getIntegerParam(MCSCurrentPoint_, &currentPoint);
  getIntegerParam(mcaNumChannels_,  &numTimePoints);
  getIntegerParam(MCSPoint0Action_, &point0Action);
  #ifdef _WIN32
    status = cbGetIOStatus(boardNum_, &ctrStatus, &ctrCount, &ctrIndex, DAQIFUNCTION);
  #else
    ScanStatus scanStatus;
    TransferStatus xferStatus;
    status = ulDaqInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
    ctrStatus = scanStatus;
    ctrCount = xferStatus.currentTotalCount;
    ctrIndex = xferStatus.currentIndex;
  #endif
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s getStatus returned status=%d, ctrStatus=%d, ctrCount=%ld, ctrIndex=%ld\n",
    driverName, functionName, status, ctrStatus, ctrCount, ctrIndex);
  if (ctrStatus == 0) {
    MCSRunning_ = false;
  }
  if (ctrIndex >= 0) {
#ifdef _WIN32
    if (counterBits_ == 32) ctrIndex /= 2;
#endif
    lastPoint = ctrIndex / numMCSCounters_ + 1;

    int inPtr = currentPoint;
    if (point0Action == MCSPoint0Skip) {
      inPtr++;
    }
    epicsTimeStamp now;
    epicsTimeGetCurrent(&now);
    for(; inPtr < lastPoint; inPtr++) {
      for (i=0, j=0; i<MAX_MCS_COUNTERS; i++) {
        if (!mcsCounterEnable_[i]) continue;
#ifdef _WIN32
        if (counterBits_ == 32) {
          MCSBuffer_[i][currentPoint] = pCountsI32_[inPtr*numMCSCounters_ + j];
          // There seems to be a bug in PADZERO and it is actually giving counter0 value not 0
          if (i == DIGITAL_IO_COUNTER) MCSBuffer_[i][currentPoint] &= 0xff;
        } else {
          MCSBuffer_[i][currentPoint] = pCountsI16_[inPtr*numMCSCounters_ + j];
        }
#else
          MCSBuffer_[i][currentPoint] = (int) pCountsF64_[inPtr*numMCSCounters_ + j];
#endif
        j++;
      }
      MCSAbsTimeBuffer_[currentPoint] = now.secPastEpoch + now.nsec/1.e9;
      currentPoint++;
    }
  }
  setIntegerParam(MCSCurrentPoint_, currentPoint);

  getDoubleParam(mcaPresetRealTime_,  &presetReal);
  getDoubleParam(mcaElapsedRealTime_, &elapsedTime);
  epicsTimeGetCurrent(&now);
  elapsedTime = epicsTimeDiffInSeconds(&now, &startTime_);
  if (MCSRunning_ && (presetReal > 0) && (elapsedTime >= presetReal)) {
    MCSRunning_ = false;
  }

  // Set elapsed times
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    setDoubleParam(i, mcaElapsedRealTime_, elapsedTime);
    setDoubleParam(i, mcaElapsedLiveTime_, elapsedTime);
  }

  if (!MCSRunning_) {
    stopMCS();
    for (i=0; i<numCounters_; i++) {
      setIntegerParam(i, mcaAcquiring_, 0);
    }
  }

  // Do callbacks on all channels
  for (i=0; i<numCounters_; i++) {
    callParamCallbacks(i);
  }

  return 0;
}

int USBCTR::eraseMCS()
{
  int i;
  int numTimePoints;
  //static const char *functionName="eraseMCS";

  MCSErased_ = true;

  getIntegerParam(mcaNumChannels_, &numTimePoints);

  /* Reset pointers to start of buffer */
  setIntegerParam(MCSCurrentPoint_, 0);

  /* Reset the elapsed time and counts */
  elapsedPrevious_ = 0.;
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    memset(MCSBuffer_[i], 0, numTimePoints * sizeof(epicsUInt32));
    setDoubleParam(i, mcaElapsedLiveTime_, 0.0);
    setDoubleParam(i, mcaElapsedRealTime_, 0.0);
    setDoubleParam(i, mcaElapsedCounts_, 0.0);
    callParamCallbacks(i);
  }

  /* Reset the start time.  This is necessary here because we may be
   * acquiring, and AcqOn will not be called. Normally this is set in AcqOn.
   */
  epicsTimeGetCurrent(&startTime_);

  return 0;
}

int USBCTR::stopMCS()
{
  int status;
  static const char *functionName = "stopMCS";

  if (MCSRunning_) {
    // Forced stop
    MCSRunning_ = false;
    readMCS();
    // readMCS will call this function when it finds MCSRunning=false so we can return now
    return 0;
  }
  #ifdef _WIN32
    status = cbStopBackground(boardNum_, DAQIFUNCTION);
  #else
    status = ulDaqInScanStop(daqDeviceHandle_);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s ERROR calling cbStopBackground(CTRFUNCTION), status=%d, error=%s\n",
      driverName, functionName, status, getErrorMessage(status));
  }
  return status;
}

int USBCTR::computeMCSTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(mcaNumChannels_, &numPoints);
  getDoubleParam(mcaDwellTime_, &dwell);
  for (i=0; i<numPoints; i++) {
    MCSTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(MCSTimeBuffer_, numPoints, MCSTimeWF_, 0);
  return 0;
}

int USBCTR::startScaler()
{
  int status;
  int i;
  int mode;
  int samplesPerCounter = 20;
  long rate = 100;
  int firstCounter = 0;
  int lastCounter = numCounters_ - 1;
  int options;
  static const char *functionName = "startScaler";

  #ifdef _WIN32
    for (i=0; i<numCounters_; i++) {
      mode = OUTPUT_ON | COUNT_DOWN_OFF | GATING_ON;
      if (i == 0) mode = mode | RANGE_LIMIT_ON | NO_RECYCLE_ON | INVERT_GATE;
      status = cbCConfigScan(boardNum_, i, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
          driverName, functionName, i, mode, status, getErrorMessage(status));
      }
    }
    int count = samplesPerCounter * numCounters_;
    options = BACKGROUND | CONTINUOUS | CTR64BIT | SINGLEIO;
    status = cbCInScan(boardNum_, firstCounter, lastCounter, count, &rate,
                       pCountsUI64_, options);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCInScan, firstCounter=%d, lastCounter=%d, count=%d, rate=%d, options=0x%x, status=%d, error=%s\n",
        driverName, functionName, firstCounter, lastCounter, count, rate, options, status, getErrorMessage(status));
    }
  #else
    for (i=0; i<numCounters_; i++) {
      mode = CMM_OUTPUT_ON | CMM_GATING_ON;
      if (i == 0) mode = mode | CMM_RANGE_LIMIT_ON | CMM_NO_RECYCLE | CMM_INVERT_GATE;
      status = ulCConfigScan(daqDeviceHandle_, i, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling ulCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
          driverName, functionName, i, mode, status, getErrorMessage(status));
      }
    }
    options = SO_CONTINUOUS | SO_SINGLEIO;
    double dblRate = (double) rate;
    CInScanFlag flags = CINSCAN_FF_CTR64_BIT;
    status = ulCInScan(daqDeviceHandle_, firstCounter, lastCounter, samplesPerCounter, &dblRate, (ScanOption) options, flags, pCountsUI64_);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling ulCInScan, firstCounter=%d, lastCounter=%d, samplesPerCounter=%d, rate=%d, options=0x%x, flags=0x%x, status=%d, error=%s\n",
        driverName, functionName, firstCounter, lastCounter, samplesPerCounter, (int) rate, options, flags, status, getErrorMessage(status));
    }
  #endif
  scalerRunning_ = true;
  return 0;
}

int USBCTR::readScaler()
{
  int numValues;
  int i, j;
  int status;
  short ctrStatus;
  long ctrCount, ctrIndex;
  int lastIndex;
  bool scalerDone = false;
  static const char *functionName = "readScaler";

  // Poll the status of the counter scan
  #ifdef _WIN32
    status = cbGetIOStatus(boardNum_, &ctrStatus, &ctrCount, &ctrIndex, CTRFUNCTION);
  #else
    ScanStatus scanStatus;
    TransferStatus xferStatus;
    status = ulDaqInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
    ctrStatus = scanStatus;
    ctrCount = xferStatus.currentTotalCount;
    ctrIndex = xferStatus.currentIndex;
  #endif
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s getStatus returned status=%d, ctrStatus=%d, ctrCount=%ld, ctrIndex=%ld\n",
    driverName, functionName, status, ctrStatus, ctrCount, ctrIndex);

  numValues = ctrIndex + 1;
  // Get the index of the start of the last complete set of counts in the buffer
  if (numValues < numCounters_) return 0;
  lastIndex = (numValues/numCounters_ - 1) * numCounters_;
  for (i=0; i<=lastIndex; i+= numCounters_) {
    for (j=0; j<numCounters_; j++) {
      scalerCounts_[j] = (epicsInt32) pCountsUI64_[i+j];
      if ((scalerPresetCounts_[j] > 0) && (scalerCounts_[j] >= scalerPresetCounts_[j])) {
        scalerDone = true;
      }
    }
    if (scalerDone) {
      stopScaler();
      break;
    }
  }
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s lastIndex=%d, scalerCounts_[0]=%d, scalerPresetCounts_[0]=%d\n",
    driverName, functionName, lastIndex, scalerCounts_[0], scalerPresetCounts_[0]);
  return 0;
}

int USBCTR::stopScaler()
{
  int status;
  static const char *functionName = "stopScaler";

  #ifdef _WIN32
    status = cbStopBackground(boardNum_, CTRFUNCTION);
  #else
    status = ulCInScanStop(daqDeviceHandle_);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s ERROR calling cbStopBackground(CTRFUNCTION), status=%d, error=%s\n",
      driverName, functionName, status, getErrorMessage(status));
  }
  scalerRunning_ = false;
  setIntegerParam(scalerDone_, 1);
  return status;
}

int USBCTR::resetScaler()
{
  int i;
  int status=0;

  /* Reset scaler */
  if (scalerRunning_) {
    status = stopScaler();
  }
  for (i=0; i<numCounters_; i++) {
    scalerCounts_[i] = 0;
  }
  return status;
}


int USBCTR::clearScalerPresets()
{
  int i;

  for (i=0; i<numCounters_; i++) {
    scalerPresetCounts_[i] = 0;
  }
  return 0;
}

int USBCTR::setScalerPresets()
{
  int i;
  int status;
  static const char *functionName = "setScalerPresets";

  for (i=0; i<numCounters_; i++) {
    getIntegerParam(i, scalerPresets_, &scalerPresetCounts_[i]);
    if (scalerPresetCounts_[i] > 0) {
      #ifdef _WIN32
        status = cbCLoad32(boardNum_, MAXLIMITREG0+i, scalerPresetCounts_[i]);
      #else
        status = ulCLoad(daqDeviceHandle_, i, CRT_MAX_LIMIT, scalerPresetCounts_[i]);
      #endif
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling cbCLoad32, counter=%d, presetCounts=%d, status=%d, error=%s\n",
          driverName, functionName, i, scalerPresetCounts_[i], status, getErrorMessage(status));
      }
    }
  }
  // For counter0 output register 0 and 1 control when the counter output goes low and high
  #ifdef _WIN32
    status = cbCLoad32(boardNum_, OUTPUTVAL0REG0, 0);
  #else 
    status = ulCLoad(daqDeviceHandle_, 0, CRT_OUTPUT_VAL0, 0);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbCLoad32, reg=OUTPUTVAL0REG0, value=%d, status=%d, error=%s\n",
      driverName, functionName, 0, status, getErrorMessage(status));
  }
  #ifdef _WIN32
    status = cbCLoad32(boardNum_, OUTPUTVAL1REG0, scalerPresetCounts_[0]);
  #else 
    status = ulCLoad(daqDeviceHandle_, 0, CRT_OUTPUT_VAL1, scalerPresetCounts_[0]);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbCLoad32, reg=OUTPUTVAL1REG0, value=%d, status=%d, error=%s\n",
      driverName, functionName, scalerPresetCounts_[0], status, getErrorMessage(status));
  }

  return 0;
}

asynStatus USBCTR::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  int numTimePoints;
  int currentPoint;
  int i;
  static const char *functionName = "writeInt32";

  this->getAddress(pasynUser, &addr);
  setIntegerParam(addr, function, value);

  // Pulse generator functions
  if (function == pulseGenRun_) {
    // Allow starting a run even if it thinks its running,
    // since there is no way to know when it got done if Count!=0
    if (value) {
      status = startPulseGenerator(addr);
    }
    else if (!value && pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
    }
  }
  if ((function == pulseGenCount_) ||
      (function == pulseGenIdleState_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Counter functions
  if (function == counterReset_) {
    #ifdef _WIN32
      // LOADREG0=0, LOADREG1=1, so we use addr
      status = cbCLoad32(boardNum_, addr, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, addr, CRT_LOAD, 0);
    #endif
  }

  // Trigger functions
  if (function == triggerMode_) {
    #ifdef _WIN32
      status = cbDaqSetTrigger(boardNum_, TRIG_EXTTTL, value, 0, CTRBANK0, 0, 0, 0, START_EVENT);
    #else
      TriggerType triggerType = TRIG_LOW;
      // We map the UL Windows trigger types to Ul Linux
      // We can't use macros from cbw.h because that file conflicts with uldaq.h
      switch (value) {
        case 0: triggerType = TRIG_RISING; break;
        case 1: triggerType = TRIG_FALLING; break;
        case 6: triggerType = TRIG_HIGH; break;
        case 7: triggerType = TRIG_LOW; break;
        default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
            "%s::%s error unsupported trigger value=%d\n",
            driverName, functionName, value);
          break;
      }
      DaqInChanDescriptor trigChanDescriptor;
      status = ulDaqInSetTrigger(daqDeviceHandle_, triggerType, trigChanDescriptor, 0, 0, 0);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbDaqSetTrigger status=%d, error=%s\n",
        driverName, functionName, status, getErrorMessage(status));
    }
  }

  // Scaler functions
  else if (function == scalerReset_) {
    /* Reset scaler */
    if (MCSRunning_) goto done;
    resetScaler();
    scalerRunning_ = false;
    /* Clear all of the presets and counts*/
    for (i=0; i<numCounters_; i++) {
      scalerCounts_[i] = 0;
      setIntegerParam(i, scalerPresets_, 0);
    }
  }

  else if (function == scalerArm_) {
    if (MCSRunning_) goto done;
    /* Arm or disarm scaler */
    if (value != 0) {
      setScalerPresets();
      startScaler();
    } else {
      stopScaler();
    }
    setIntegerParam(scalerDone_, 0);
  }

  // MCA commands
  getIntegerParam(mcaNumChannels_, &numTimePoints);
  if (function == mcaStartAcquire_) {
    if (scalerRunning_) {
      status = -1;
      goto done;
    }
    if (MCSRunning_) goto done;
    // If we have already completed acquisition due to nextChan_, don't start, signal error
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    if (currentPoint >= numTimePoints) {
        // Must toggle mcaAcquiring to 1 and back to 0 to signal SNL program to clear Acquiring
      setIntegerParam(mcaAcquiring_, 1);
      callParamCallbacks();
      setIntegerParam(mcaAcquiring_, 0);
      goto done;
    }
    setIntegerParam(mcaAcquiring_, 1);
    MCSErased_ = false;
    // Set the acquisition start time
    epicsTimeGetCurrent(&startTime_);
    // Start the hardware
    startMCS();
  }

  else if (function == mcaStopAcquire_) {
    if (scalerRunning_) goto done;
    /* Stop data acquisition */
    if (!MCSRunning_) {
      // We are not acquiring.
      status = asynSuccess;
      goto done;
    }
    // Stop the hardware
    stopMCS();
  }

  else if (function == mcaErase_) {
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: [%s addr=%d]: erased\n",
              driverName, functionName, portName, addr);

    /* Erase the buffer in the private data structure */
    eraseMCS();

  }

  else if (function == mcaNumChannels_) {
    /* Terminology warning:
     * This is the number of channels that are to be acquired. Channels
     * correspond to time bins or external channel advance triggers, as
     * opposed to the 8 input counters that the USB-CTR08 supports.
     */
    if (value > maxTimePoints_) {
      setIntegerParam(mcaNumChannels_, maxTimePoints_);
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
                "%s:%s:  # channels=%d too large, max=%d\n",
                driverName, functionName, value, maxTimePoints_);
    }
  }

  done:
  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, function=%d, wrote %d to address %d\n",
             driverName, functionName, this->portName, function, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, function=%d, ERROR writing %d to address %d, status=%d\n",
             driverName, functionName, this->portName, function, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}


asynStatus USBCTR::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  //static const char *functionName = "readInt32";

  this->getAddress(pasynUser, &addr);

  if (function == scalerRead_) {
    /* Read a single scaler channel */
    *value = scalerCounts_[addr];
  }

  // Other functions we call the base class method
  else {
     status = asynPortDriver::readInt32(pasynUser, value);
  }

  callParamCallbacks(addr);
  return (status==0) ? asynSuccess : asynError;
}

asynStatus USBCTR::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  static const char *functionName = "writeFloat64";

  this->getAddress(pasynUser, &addr);
  setDoubleParam(addr, function, value);

  // Pulse generator functions
  if ((function == pulseGenPeriod_)    ||
      (function == pulseGenDutyCycle_) ||
      (function == pulseGenDelay_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // MCS functions
  else if (function == mcaDwellTime_) {
    computeMCSTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %f to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing %f to address %d, status=%d\n",
             driverName, functionName, this->portName, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

asynStatus USBCTR::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
  int function = pasynUser->reason;
  int status=0;
  int i;
  epicsUInt32 outValue=0, outMask, direction;
  static const char *functionName = "writeUInt32Digital";


  setUIntDigitalParam(function, value, mask);
  if (function == digitalDirection_) {
    for (i=0; i<NUM_IO_BITS; i++) {
      if ((mask & (1<<i)) != 0) {
        #ifdef _WIN32
          int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
          status = cbDConfigBit(boardNum_, AUXPORT, i, dir);
        #else
          DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
          status = ulDConfigBit(daqDeviceHandle_, AUXPORT, i, dir);
        #endif
      }
    }
  }

  else if (function == digitalOutput_) {
    getUIntDigitalParam(digitalDirection_, &direction, 0xFFFFFFFF);
    for (i=0, outMask=1; i<NUM_IO_BITS; i++, outMask = (outMask<<1)) {
      // Only write the value if the mask has this bit set and the direction for that bit is output (1)
      outValue = ((value &outMask) == 0) ? 0 : 1;
      if ((mask & outMask & direction) != 0) {
        #ifdef _WIN32
          status = cbDBitOut(boardNum_, AUXPORT, i, outValue);
        #else
          status = ulDBitOut(daqDeviceHandle_, AUXPORT, i, outValue);
        #endif
      }
    }
  }

  callParamCallbacks();
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote outValue=0x%x, value=0x%x, mask=0x%x, direction=0x%x\n",
             driverName, functionName, this->portName, outValue, value, mask, direction);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing outValue=0x%x, value=0x%x, mask=0x%x, direction=0x%x, status=%d\n",
             driverName, functionName, this->portName, outValue, value, mask, direction, status);
  }
  return (status==0) ? asynSuccess : asynError;
}


asynStatus USBCTR::readInt32Array(asynUser *pasynUser, epicsInt32 *data,
                                  size_t numRead, size_t *numActual)
{
  int signal;
  int command;
  const char *paramName;
  asynStatus status = asynSuccess;
  int currentPoint;
  size_t i;
  static const char* functionName="readInt32Array";

  parseAsynUser(pasynUser, &command, &signal, &paramName);
  pasynManager->getAddr(pasynUser, &signal);
  asynPrint(pasynUser, ASYN_TRACE_FLOW,
            "%s:%s: entry, command=%d, signal=%d, numRead=%d, &data=%p\n",
            driverName, functionName, command, signal, (int)numRead, data);

  if (command == mcaData_) {
    /* Transfer the data from the private driver structure to the supplied data
     * buffer. The private data structure will have the information for all the
     * signals, so we need to just extract the signal being requested.
     */
    int nChans;
    int numCopy;
    getIntegerParam(mcaNumChannels_, &nChans);
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    numCopy = (int)numRead;
    if (numCopy > nChans) numCopy = nChans;
    // We copy all the channels but we only report nchans
    // This ensures the entire array is correct even if it was not set to zero at the start
    memcpy(data, MCSBuffer_[signal], numCopy*sizeof(epicsInt32));
    *numActual = numRead;
    if ((int)*numActual > currentPoint) *numActual = currentPoint;
    // Make it set NORD non-zero?
    if (*numActual == 0) *numActual = 1;
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: [signal=%d]: read %d chans (numRead=%d, numCopy=%d, currentPoint=%d, nChans=%d)\n",
              driverName, functionName, signal, (int)*numActual, (int)numRead, numCopy, currentPoint, nChans);
    }
  else if (command == scalerRead_) {
    for (i=0; (i<numRead && i<(size_t)numCounters_); i++) {
      data[i] = scalerCounts_[i];
    }
    for (i=numCounters_; i<numRead; i++) {
      data[i] = 0;
    }
    *numActual = numRead;
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: scalerReadCommand: read %d chans, data=%d %d %d %d %d %d %d %d\n",
              driverName, functionName, (int)numRead, data[0], data[1], data[2], data[3],
                                                      data[4], data[5], data[6], data[7]);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
              "%s:%s: got illegal command %d\n",
              driverName, functionName, command);
    status = asynError;
  }
  return status;
}


asynStatus USBCTR::readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat32 *inPtr;
  static const char *functionName = "readFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (function == MCSTimeWF_) {
    inPtr = MCSTimeBuffer_;
    getIntegerParam(mcaNumChannels_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat32));

  return asynSuccess;
}

asynStatus USBCTR::readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat64 *inPtr;
  static const char *functionName = "readFloat6Array";

  this->getAddress(pasynUser, &addr);

  if (function == MCSAbsTimeWF_) {
    inPtr = MCSAbsTimeBuffer_;
    getIntegerParam(mcaNumChannels_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat64));

  return asynSuccess;
}

void USBCTR::pollerThread()
{
  /* This function runs in a separate thread.  It waits for the poll
   * time */
  static const char *functionName = "pollerThread";
  epicsUInt32 newValue, changedBits, prevInput=0;
  epicsTime startTime=epicsTime::getCurrent(), endTime, currentTime;
  unsigned short biVal;;
  int i;
  int status;

  while(1) {
    lock();
    endTime = epicsTime::getCurrent();
    setDoubleParam(pollTimeMS_, (endTime-startTime)*1000.);
    startTime = epicsTime::getCurrent();

    // Read the digital inputs
    #ifdef _WIN32
      status = cbDIn(boardNum_, AUXPORT, &biVal);
    #else
      unsigned long long data;
      status = ulDIn(daqDeviceHandle_, AUXPORT, &data);
      biVal = (unsigned short) data;
    #endif
    if (status)
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                "%s:%s: ERROR calling cbDIn, status=%d\n",
                driverName, functionName, status);
    newValue = biVal;
    changedBits = newValue ^ prevInput;
    if (forceCallback_ || (changedBits != 0)) {
      prevInput = newValue;
      forceCallback_ = 0;
      setUIntDigitalParam(digitalInput_, newValue, 0xFFFFFFFF);
    }

    if (scalerRunning_) {
      readScaler();
    }

    if (MCSRunning_) {
      readMCS();
    }

    for (i=0; i<MAX_SIGNALS; i++) {
      callParamCallbacks(i);
    }
    double pollTime;
    getDoubleParam(pollSleepMS_, &pollTime);
    unlock();
    epicsThreadSleep(pollTime/1000.);
  }
}


/* Report  parameters */
void USBCTR::report(FILE *fp, int details)
{
  int i;
  int currentPoint;

  fprintf(fp, "  Port: %s, pollTime=%f\n",
          this->portName, pollTime_);
  if (details >= 1) {
    fprintf(fp, "  Pulse generators:\n");
    for (i=0; i<NUM_TIMERS; i++) {
      fprintf(fp, "    %d: Running:%d\n", i, pulseGenRunning_[i]);
    }
    fprintf(fp, "  numCounters: %d\n", numCounters_);
    fprintf(fp, "  Scaler:\n");
    fprintf(fp, "    Running: %d\n", scalerRunning_);
    for (i=0; i<numCounters_; i++) {
      fprintf(fp, "    %d: preset=%d, count=%d\n", i, scalerPresetCounts_[i], scalerCounts_[i]);
    }
    fprintf(fp, "  MCS:\n");
    fprintf(fp, "    Running: %d\n", MCSRunning_);
    fprintf(fp, "    maxTimePoints: %d\n", maxTimePoints_);
    fprintf(fp, "    MCSErased: %d\n", MCSErased_);
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    fprintf(fp, "    currentPoint: %d\n", currentPoint);
  }
  asynPortDriver::report(fp, details);
}

/** Configuration command, called directly or from iocsh */
extern "C" int USBCTRConfig(const char *portName, const char *uniqueID,
                            int maxTimePoints, double pollTime)
{
  new USBCTR(portName, uniqueID, maxTimePoints, pollTime);
  return(asynSuccess);
}


static const iocshArg configArg0 = { "Port name",             iocshArgString};
static const iocshArg configArg1 = { "uniqueID",              iocshArgString};
static const iocshArg configArg2 = { "Max. # of time points", iocshArgInt};
static const iocshArg configArg3 = { "Poll time",             iocshArgDouble};
static const iocshArg * const configArgs[] = {&configArg0,
                                              &configArg1,
                                              &configArg2,
                                              &configArg3};
static const iocshFuncDef configFuncDef = {"USBCTRConfig",4,configArgs};
static void configCallFunc(const iocshArgBuf *args)
{
  USBCTRConfig(args[0].sval, args[1].sval, args[2].ival, args[3].dval);
}

void drvUSBCTRRegister(void)
{
  iocshRegister(&configFuncDef,configCallFunc);
}

extern "C" {
epicsExportRegistrar(drvUSBCTRRegister);
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/measCompDiscover.cpp
=================================================
#include <stdio.h>
#include <string>
#include <string.h>
#include <stdlib.h>
#include <osiSock.h>
#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

#include <measCompDiscover.h>

#define MAX_DEVICES 100
// All current Measurement Computing devices (E-1608, E-TC, TC32) use this port for
// discovery.  But it is configurable so we allow the user to specify it.
#define DEFAULT_DISCOVERY_PORT 54211

static DaqDeviceDescriptor measCompInventory[MAX_DEVICES];
static int measCompNumDevices = 0;
bool measCompInventoryInitialized = false;

int measCompDiscoverDevices()
{
  int numDevices = MAX_DEVICES;
  int status;

  if (measCompInventoryInitialized) return 0;
  #ifdef WIN32
    cbIgnoreInstaCal();
    status = cbGetDaqDeviceInventory(ANY_IFC, measCompInventory, &numDevices);
    // Windows eliminates leading zeros on USB device serial numbers, Linux does not.
    // Add the leading zero if the string length is 7
    for (int i=0; i<numDevices; i++) {
        if (measCompInventory[i].InterfaceType == USB_IFC) {
            if (strlen(measCompInventory[i].UniqueID) == 7) {
                std::string tempString = "0" + std::string(measCompInventory[i].UniqueID);
                strcpy(measCompInventory[i].UniqueID, tempString.c_str());
            }
        }
    } 
  #else
    status = ulGetDaqDeviceInventory(ANY_IFC, measCompInventory, (unsigned int *)&numDevices);
    // Copy the IP address to the reserved field for Ethernet devices.
    for (int i=0; i<numDevices; i++) {
        if (measCompInventory[i].devInterface == ETHERNET_IFC) {
            DaqDeviceHandle devHandle = ulCreateDaqDevice(measCompInventory[i]);
            unsigned int maxLen = sizeof(measCompInventory[i].reserved);
            ulDevGetConfigStr(devHandle, DEV_CFG_IP_ADDR_STR, 0, measCompInventory[i].reserved, &maxLen);
            ulReleaseDaqDevice(devHandle);
        }
    }
  #endif
  if (status) {
    printf("Error calling cbGetDaqDeviceInventory=%d\n", status);
    return status;
  }
  measCompNumDevices = numDevices;
  measCompInventoryInitialized = true;
  return 0;
}

void measCompShowDevices()
{
  measCompDiscoverDevices();
  printf("measCompShowDevices, numDevices=%d\n", measCompNumDevices);
  #ifdef WIN32
    for (int i=0; i<measCompNumDevices; i++) {
      printf("Device %d\n", i);
      printf("    ProductName: %s\n",   measCompInventory[i].ProductName);
      printf("      ProductID: %d\n",   measCompInventory[i].ProductID);
      printf("  InterfaceType: %d\n",   measCompInventory[i].InterfaceType);
      printf("      DevString: %s\n",   measCompInventory[i].DevString);
      printf("       UniqueID: %s\n",   measCompInventory[i].UniqueID);
      printf("           NUID: %llu\n", measCompInventory[i].NUID);
      printf("       Reserved: %s\n",   measCompInventory[i].Reserved);
    }
  #else
    for (int i=0; i<measCompNumDevices; i++) {
      printf("Device %d\n", i);
      printf("    ProductName: %s\n",   measCompInventory[i].productName);
      printf("      ProductID: %d\n",   measCompInventory[i].productId);
      printf("  InterfaceType: %d\n",   measCompInventory[i].devInterface);
      printf("      DevString: %s\n",   measCompInventory[i].devString);
      printf("       UniqueID: %s\n",   measCompInventory[i].uniqueId);
      printf("       Reserved: %s\n",   measCompInventory[i].reserved);
    }
  #endif
}

/** Create a measComp device.
  * This method finds a device and connects to it.  It is called from the driver constructor.
  * \param[in] uniqueID 
  *                     This is an 8 digital hex serial number for USB devices without a leading 0x.
  *                     For Ethernet devices it can be:
  *                         An IP DNS name with optional discovery port, e.g. gse-e1608-6:54211
  *                         An IP address with optional discovery port, e.g. 10.54.160.63:54211
  *                         A MAC address, e.g. 00:80:2F:24:53:E5
  * \param[out] deviceDescriptor Pointer to a DaqDeviceDescription structure for this device
  * \param[out] handle A handle for this device.  
  *                         On Windows this is the index in the device inventory list.
  *                         On Linux it is a DaqDeviceHandle.
  */
int measCompCreateDevice(std::string uniqueId, DaqDeviceDescriptor& deviceDescriptor, long long *handle)
{
  size_t colon;
  std::string host = uniqueId;
  std::string port;
  struct sockaddr_in ipAddr;
  bool isEthernet = false;
  char *endptr;
  int portNum = DEFAULT_DISCOVERY_PORT;
  int status;
  int devIndex=-1;
  char ipAddrAsString[25];
  double timeout = 1.0;

  measCompDiscoverDevices();
  // If the uniqueId is a hex number it is USB, else Ethernet
  strtol(uniqueId.c_str(), &endptr, 16);
  if (*endptr != '\0') isEthernet = true;

  // Use hostToIPAddr for 2 reasons:
  // - It will translate IP names to IP addresses
  // - It will fail if the uniqueId is a MAC address
  status = aToIPAddr(uniqueId.c_str(), portNum, &ipAddr);
  if (isEthernet && (status == 0)) {
    ipAddrToDottedIP(&ipAddr, ipAddrAsString, sizeof(ipAddrAsString));
    // The string from ipAddrToDottedIP will always have a :port at the end
    // Parse the port and remove from the host string.
    host = ipAddrAsString;
    colon = host.find(":");
    if (colon != std::string::npos) {
      port = host.substr(colon+1, std::string::npos);
      portNum = atoi(port.c_str());
      host = host.substr(0, colon);
    }
    // See if this host is already known, i.e. it was found on the local subnet
    for (int i=0; i<measCompNumDevices; i++) {
      #ifdef WIN32
        /*  This logic does not work on Windows because there is no way to retrieve the IP address and copy it to .Reserved
         *  This is OK, it is just slightly less efficient because it will always call cbGetNetDeviceDescriptor unless UniqueID is a MAC address.
        if (host.compare(measCompInventory[i].Reserved) == 0) {
          devIndex = i;
        } */
      #else
        if (host.compare(measCompInventory[i].reserved) == 0) {
          devIndex = i;
        }
      #endif
    }
    // We did not find this device on the local subnet, create a new one
    if (devIndex == -1) {
      devIndex = measCompNumDevices++;
      #ifdef WIN32
        status = cbGetNetDeviceDescriptor((char*)host.c_str(), portNum,
                                          &measCompInventory[devIndex], (int) (timeout * 1000));
      #else
        status = ulGetNetDaqDeviceDescriptor((char*)host.c_str(), portNum, NULL,
                                             &measCompInventory[devIndex], timeout);
      #endif
      if (status) {
          printf("Error calling cbGetNetDeviceDescriptor=%d\n", status);
          return -1;
      }
    }
  }
  else {
    // uniqueId was not an IP address or IP DNS name, so it must be a serial number (USB) or MAC address (Ethernet)
    // Search the inventory for the matching UniqueID
    for (int i=0; i<measCompNumDevices; i++) {
      #ifdef WIN32
        if (uniqueId.compare(measCompInventory[i].UniqueID) == 0) {
      #else
        if (uniqueId.compare(measCompInventory[i].uniqueId) == 0) {
      #endif
        devIndex = i;
        break;
      }
    }
  }
  if (devIndex != -1) {
    #ifdef WIN32
      status = cbCreateDaqDevice(devIndex, measCompInventory[devIndex]);
      if (status) {
        printf("Error calling cbCreateDaqDevice=%d\n", status);
        return -1;
      }
      *handle = devIndex;
    #else
      DaqDeviceHandle devHandle = ulCreateDaqDevice(measCompInventory[devIndex]);
      if (!devHandle) {
        printf("Error calling ulCreateDaqDevice devIndex=%d\n", devIndex);
        return -1;
      }
      *handle = devHandle;
      UlError error = ulConnectDaqDevice(devHandle);
      if (error) {
        printf("Error calling ulConnectDaqDevice error=%d\n", error);
        return -1;
      }
    #endif
    //
    deviceDescriptor = measCompInventory[devIndex];
    return 0;
  }
  return -1;
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/src/measCompAppMain.cpp
=================================================
/* exampleMain.cpp */
/* Author:  Marty Kraimer Date:    17MAR2000 */

#include <stddef.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "epicsExit.h"
#include "epicsThread.h"
#include "iocsh.h"

int main(int argc,char *argv[])
{
    if(argc>=2) {
        iocsh(argv[1]);
        epicsThreadSleep(.2);
    }
    iocsh(NULL);
    epicsExit(0);
    return(0);
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/measCompDiscover.h
=================================================
#ifndef measCompDiscoverInclude
#define measCompDiscoverInclude

#include <string>
#include <shareLib.h>
#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

epicsShareFunc int measCompDiscoverDevices();
epicsShareFunc void measCompShowDevices();
epicsShareFunc int measCompCreateDevice(std::string uniqueId, DaqDeviceDescriptor& deviceDescriptor, long long *handle);

#endif /* measCompDiscoverInclude */











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/measCompSupport.dbd
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.dbd)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/USBCTR_SNL.st
=================================================
program USBCTR_SNL("P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ")

/*  This sequencer program works with measCompMCS.template
 *  It supports multi-element MCA operations
 *
 *  Mark Rivers
 *  June 2, 2014
 *
 * This program must be compiled with the recursive option so that multiple copies
 * can run at once */
option +r;

/* Allow the program to start, even if not all assigned channels are connected.
 * This could be useful if the SNL is running on a different ioc. */
option -c;

%%#include <stdlib.h>
%%#include <errlog.h>
%%#include <string.h>

/* Maximum number of counters supported */
#define MAX_COUNTERS 9

int i;
int n;
int numCounters;
char temp[100];

char *prefix;
char *record;
char *field;

int     ReadArray[MAX_COUNTERS];
assign  ReadArray to {};
int     ReadArrays; assign ReadArrays to "{P}DoReadAll";
monitor ReadArrays; evflag ReadArraysMon; sync ReadArrays ReadArraysMon;

int     HardwareAcquiring; assign HardwareAcquiring to "{P}HardwareAcquiring";
monitor HardwareAcquiring; evflag HardwareAcquiringMon; sync HardwareAcquiring HardwareAcquiringMon;

int     MCSAbsTimeWF; assign MCSAbsTimeWF to "{P}AbsTimeWF.PROC";

int     SNL_Connected;  assign SNL_Connected      to "{P}SNL_Connected";
int     AsynDebug;      assign AsynDebug          to "{P}Asyn.TB1";
monitor AsynDebug;

int Acquiring; assign Acquiring to "{P}Acquiring";

ss mca_control {
  state init {
    when() {
      prefix = macValueGet("P");
      record = macValueGet("R");
      field = macValueGet("FIELD");
      numCounters = atoi(macValueGet("NUM_COUNTERS"));
      if ((numCounters <= 0) || (numCounters > MAX_COUNTERS)) {
        printf ("NUM_COUNTERS is illegal.\n");
        numCounters = 0;
      }
      for (i=0; i<numCounters; i++) {
        n = i+1;
        sprintf(temp, "%s%s%d.%s", prefix, record, n, field);
        pvAssign(ReadArray[i], temp);
       }
    } state waitConnected
  }

  state waitConnected {
    when (numCounters <= 0) {
      printf (">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
    } state dead

    when (pvAssignCount () == pvConnectCount ()) {
      printf ("USBCTR: All channels connected.\n");
      SNL_Connected = 1;
      pvPut(SNL_Connected);
    } state monitor_changes
  }

  state dead {
    when (delay (3600.0)) {
    } state dead
  }

  state monitor_changes {
    when (pvAssignCount () != pvConnectCount ()) {
      printf ("USBCTR: Not all channels connected.\n");
    } state waitConnected

    when(efTestAndClear(ReadArraysMon) && (ReadArrays == 1)) {
      if (AsynDebug) printf("USBCTR.st: Read array data\n");
      for (i=0; i<numCounters; i++) {
        ReadArray[i] = 1;
        pvPut(ReadArray[i]);
      }
      MCSAbsTimeWF = 1;
      pvPut(MCSAbsTimeWF);
      ReadArrays = 0;
      pvPut(ReadArrays);
    } state monitor_changes

    when(efTestAndClear(HardwareAcquiringMon)) {
      if (AsynDebug) printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", HardwareAcquiring);
      /* If the detector is acquiring then force each record to read status */
      if (!HardwareAcquiring) {
        /* If the detector is done then force each record to read data */
        for (i=0; i<numCounters; i++) {
          ReadArray[i] = 1;
          pvPut(ReadArray[i], SYNC);
        }
        MCSAbsTimeWF = 1;
        pvPut(MCSAbsTimeWF);
        /* Clear the Acquiring busy record */
        Acquiring = 0;
        pvPut(Acquiring);
      }
    } state monitor_changes
  }
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/src/drvMultiFunction.cpp
=================================================
/* drvMultiFunction.cpp
 *
 * Driver for Measurement Computing multi-function DAQ board using asynPortDriver base class
 *
 * This driver supports simple analog in/out, digital in/out bit and word, timer (digital pulse generator), counter,
 *   waveform out (aribtrary waveform generator), and waveform in (digital oscilloscope)
 *
 * This driver was previously name drv1608G.cpp but was renamed because it now supports several models.
 *
 * Mark Rivers
 * November 1, 2015
*/

#include <math.h>
#include <string.h>
#include <stdlib.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsString.h>

#include <asynPortDriver.h>

#define DRIVER_VERSION "4.2"

#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

// This needs to be global because we need to protect the UL library from simultaneous access from any driver
epicsMutex ULMutex;

// This function maps the Gain values from UL on Windows to the Range values in UL for Linux.
// We can't use the macros from Windows cbw.h because they conflict with UL for Linux.
// These definitions are taken from cbw.h, but added CBW_ prefix.
#define CBW_BIP60VOLTS       20             /* -60 to 60 Volts */
#define CBW_BIP30VOLTS       23
#define CBW_BIP20VOLTS       15             /* -20 to +20 Volts */
#define CBW_BIP15VOLTS       21             /* -15 to +15 Volts */
#define CBW_BIP10VOLTS       1              /* -10 to +10 Volts */
#define CBW_BIP5VOLTS        0              /* -5 to +5 Volts */
#define CBW_BIP4VOLTS        16             /* -4 to + 4 Volts */
#define CBW_BIP2PT5VOLTS     2              /* -2.5 to +2.5 Volts */
#define CBW_BIP2VOLTS        14             /* -2.0 to +2.0 Volts */
#define CBW_BIP1PT25VOLTS    3              /* -1.25 to +1.25 Volts */
#define CBW_BIP1VOLTS        4              /* -1 to +1 Volts */
#define CBW_BIPPT625VOLTS    5              /* -.625 to +.625 Volts */
#define CBW_BIPPT5VOLTS      6              /* -.5 to +.5 Volts */
#define CBW_BIPPT25VOLTS     12             /* -0.25 to +0.25 Volts */
#define CBW_BIPPT2VOLTS      13             /* -0.2 to +0.2 Volts */
#define CBW_BIPPT1VOLTS      7              /* -.1 to +.1 Volts */
#define CBW_BIPPT05VOLTS     8              /* -.05 to +.05 Volts */
#define CBW_BIPPT01VOLTS     9              /* -.01 to +.01 Volts */
#define CBW_BIPPT005VOLTS    10             /* -.005 to +.005 Volts */
#define CBW_BIP1PT67VOLTS    11             /* -1.67 to +1.67 Volts */
#define CBW_BIPPT312VOLTS    17             /* -0.312 to +0.312 Volts */
#define CBW_BIPPT156VOLTS    18             /* -0.156 to +0.156 Volts */
#define CBW_BIPPT125VOLTS    22             /* -0.125 to +0.125 Volts */
#define CBW_BIPPT078VOLTS    19             /* -0.078 to +0.078 Volts */


#define CBW_UNI10VOLTS       100            /* 0 to 10 Volts*/
#define CBW_UNI5VOLTS        101            /* 0 to 5 Volts */
#define CBW_UNI4VOLTS        114            /* 0 to 4 Volts */
#define CBW_UNI2PT5VOLTS     102            /* 0 to 2.5 Volts */
#define CBW_UNI2VOLTS        103            /* 0 to 2 Volts */
#define CBW_UNI1PT67VOLTS    109            /* 0 to 1.67 Volts */
#define CBW_UNI1PT25VOLTS    104            /* 0 to 1.25 Volts */
#define CBW_UNI1VOLTS        105            /* 0 to 1 Volt */
#define CBW_UNIPT5VOLTS      110            /* 0 to .5 Volt */
#define CBW_UNIPT25VOLTS     111            /* 0 to 0.25 Volt */
#define CBW_UNIPT2VOLTS      112            /* 0 to .2 Volt */
#define CBW_UNIPT1VOLTS      106            /* 0 to .1 Volt */
#define CBW_UNIPT05VOLTS     113            /* 0 to .05 Volt */
#define CBW_UNIPT02VOLTS     108            /* 0 to .02 Volt*/
#define CBW_UNIPT01VOLTS     107            /* 0 to .01 Volt*/

#define CBW_MA4TO20          200            /* 4 to 20 ma */
#define CBW_MA2TO10          201            /* 2 to 10 ma */
#define CBW_MA1TO5           202            /* 1 to 5 ma */
#define CBW_MAPT5TO2PT5      203            /* .5 to 2.5 ma */
#define CBW_MA0TO20          204            /* 0 to 20 ma */
#define CBW_BIPPT025AMPS     205            /* -0.025 to 0.025 ma */

#include <epicsExport.h>
#include <measCompDiscover.h>

static const char *driverName = "MultiFunction";

typedef enum {
  waveTypeUser,
  waveTypeSin,
  waveTypeSquare,
  waveTypeSawTooth,
  waveTypePulse,
  waveTypeRandom
} waveType_t;

// Board parameters
#define modelNameString           "MODEL_NAME"
#define modelNumberString         "MODEL_NUMBER"
#define firmwareVersionString     "FIRMWARE_VERSION"
#define uniqueIDString            "UNIQUE_ID"
#define ULVersionString           "UL_VERSION"
#define driverVersionString       "DRIVER_VERSION"
#define pollSleepMSString         "POLL_SLEEP_MS"
#define pollTimeMSString          "POLL_TIME_MS"
#define lastErrorMessageString    "LAST_ERROR_MESSAGE"

// Pulse output parameters
#define pulseGenRunString         "PULSE_RUN"
#define pulseGenPeriodString      "PULSE_PERIOD"
#define pulseGenDutyCycleString   "PULSE_DUTY_CYCLE"
#define pulseGenDelayString       "PULSE_DELAY"
#define pulseGenCountString       "PULSE_COUNT"
#define pulseGenIdleStateString   "PULSE_IDLE_STATE"

// Counter parameters
#define counterCountsString       "COUNTER_VALUE"
#define counterResetString        "COUNTER_RESET"

// Analog input parameters
#define analogInValueString       "ANALOG_IN_VALUE"
#define analogInRangeString       "ANALOG_IN_RANGE"
#define analogInTypeString        "ANALOG_IN_TYPE"
#define analogInModeString        "ANALOG_IN_MODE"
#define analogInRateString        "ANALOG_IN_RATE"

// Voltage input parameters
#define voltageInValueString      "VOLTAGE_IN_VALUE"
#define voltageInRangeString      "VOLTAGE_IN_RANGE"

// Temperature parameters
#define temperatureInValueString  "TEMPERATURE_IN_VALUE"
#define thermocoupleTypeString    "THERMOCOUPLE_TYPE"
#define thermocoupleOpenDetectString "THERMOCOUPLE_OPEN_DETECT"
#define temperatureScaleString    "TEMPERATURE_SCALE"
#define temperatureFilterString   "TEMPERATURE_FILTER"
#define temperatureSensorString   "TEMPERATURE_SENSOR"
#define temperatureWiringString   "TEMPERATURE_WIRING"

// Waveform digitizer parameters - global
#define waveDigDwellString        "WAVEDIG_DWELL"
#define waveDigDwellActualString  "WAVEDIG_DWELL_ACTUAL"
#define waveDigTotalTimeString    "WAVEDIG_TOTAL_TIME"
#define waveDigFirstChanString    "WAVEDIG_FIRST_CHAN"
#define waveDigNumChansString     "WAVEDIG_NUM_CHANS"
#define waveDigNumPointsString    "WAVEDIG_NUM_POINTS"
#define waveDigCurrentPointString "WAVEDIG_CURRENT_POINT"
#define waveDigExtTriggerString   "WAVEDIG_EXT_TRIGGER"
#define waveDigExtClockString     "WAVEDIG_EXT_CLOCK"
#define waveDigContinuousString   "WAVEDIG_CONTINUOUS"
#define waveDigAutoRestartString  "WAVEDIG_AUTO_RESTART"
#define waveDigRetriggerString    "WAVEDIG_RETRIGGER"
#define waveDigTriggerCountString "WAVEDIG_TRIGGER_COUNT"
#define waveDigBurstModeString    "WAVEDIG_BURST_MODE"
#define waveDigRunString          "WAVEDIG_RUN"
#define waveDigTimeWFString       "WAVEDIG_TIME_WF"
#define waveDigAbsTimeWFString    "WAVEDIG_ABS_TIME_WF"
#define waveDigReadWFString       "WAVEDIG_READ_WF"
// Waveform digitizer parameters - per input
#define waveDigVoltWFString       "WAVEDIG_VOLT_WF"

// Analog output parameters
#define analogOutValueString      "ANALOG_OUT_VALUE"
#define analogOutRangeString      "ANALOG_OUT_RANGE"

// Waveform generator parameters - global
#define waveGenFreqString         "WAVEGEN_FREQ"
#define waveGenDwellString        "WAVEGEN_DWELL"
#define waveGenDwellActualString  "WAVEGEN_DWELL_ACTUAL"
#define waveGenTotalTimeString    "WAVEGEN_TOTAL_TIME"
#define waveGenNumPointsString    "WAVEGEN_NUM_POINTS"
#define waveGenCurrentPointString "WAVEGEN_CURRENT_POINT"
#define waveGenIntDwellString     "WAVEGEN_INT_DWELL"
#define waveGenUserDwellString    "WAVEGEN_USER_DWELL"
#define waveGenIntNumPointsString  "WAVEGEN_INT_NUM_POINTS"
#define waveGenUserNumPointsString "WAVEGEN_USER_NUM_POINTS"
#define waveGenExtTriggerString   "WAVEGEN_EXT_TRIGGER"
#define waveGenExtClockString     "WAVEGEN_EXT_CLOCK"
#define waveGenContinuousString   "WAVEGEN_CONTINUOUS"
#define waveGenRetriggerString    "WAVEGEN_RETRIGGER"
#define waveGenTriggerCountString "WAVEGEN_TRIGGER_COUNT"
#define waveGenRunString          "WAVEGEN_RUN"
#define waveGenUserTimeWFString   "WAVEGEN_USER_TIME_WF"
#define waveGenIntTimeWFString    "WAVEGEN_INT_TIME_WF"
// Waveform generator parameters - per output
#define waveGenWaveTypeString     "WAVEGEN_WAVE_TYPE"
#define waveGenEnableString       "WAVEGEN_ENABLE"
#define waveGenAmplitudeString    "WAVEGEN_AMPLITUDE"
#define waveGenOffsetString       "WAVEGEN_OFFSET"
#define waveGenPulseWidthString   "WAVEGEN_PULSE_WIDTH"
#define waveGenIntWFString        "WAVEGEN_INT_WF"
#define waveGenUserWFString       "WAVEGEN_USER_WF"

// Trigger parameters
#define triggerModeString         "TRIGGER_MODE"

// Digital I/O parameters
#define digitalDirectionString    "DIGITAL_DIRECTION"
#define digitalInputString        "DIGITAL_INPUT"
#define digitalOutputString       "DIGITAL_OUTPUT"

// MAX_ANALOG_IN and MAX_ANALOG_OUT may need to be changed if additional models are added with larger numbers
// These are used as a convenience for allocating small arrays of pointers, not large amounts of data
#define MAX_ANALOG_IN      16
#define MAX_TEMPERATURE_IN 64
#define MAX_ANALOG_OUT     16
#define MAX_IO_PORTS        8
#define MAX_PULSE_GEN       4
#define MAX_SIGNALS        MAX_TEMPERATURE_IN

// For simplicity define a few constants on Linux to be the same as Windows cbw.h
// These need to be copied from cbw.h because uldaq.h and cbw.h cannot both be included due to some conflicting definitions
#ifdef linux
  #define AI_CHAN_TYPE_VOLTAGE  AI_VOLTAGE
  #define AI_CHAN_TYPE_TC       AI_TC
  #define TC_TYPE_J             TC_J
  #define DIFFERENTIAL          0
  #define SINGLE_ENDED          1
  /* Temperature scales */
  #define CELSIUS          0
  #define FAHRENHEIT       1
  #define KELVIN           2
  #define VOLTS            4     /* special scale for DAS-TC boards */
  #define NOSCALE          5
  /* Types of digital input ports */
  #define DIGITALOUT       1
  #define DIGITALIN        2
#endif

typedef enum {
  USB_231            = 297,
  USB_1208LS         = 122,
  USB_1208FS         = 130,
  USB_1208FS_PLUS    = 232,
  USB_1608G          = 308,
  USB_1608GX         = 309,
  USB_1608GX_2AO_OLD = 274,
  USB_1608GX_2AO     = 310,
  USB_1608HS_2AO     = 153,
  USB_1808           = 317, // Fix this when we know the correct value
  USB_1808X          = 318,
  USB_2408_2AO       = 254,
  USB_3101           = 154,
  USB_3102           = 155,
  USB_3103           = 156,
  USB_3104           = 157,
  USB_3105           = 158,
  USB_3106           = 159,
  USB_3110           = 162,
  USB_3112           = 163,
  USB_3114           = 164,
  USB_SSR08          = 134,
  USB_TEMP           = 141,
  USB_TEMP_AI        = 188,
  USB_TC32           = 305,
  ETH_TC32           = 306,
  E_1608             = 303,
  E_DIO24            = 311,
  E_TC               = 312,
  MAX_BOARD_TYPES
} boardType_t;

typedef struct {
  char *enumString;
  int  enumValue;
} enumStruct_t;

static const enumStruct_t inputRangeUSB_231[] = {
  {"+= 20V",   CBW_BIP20VOLTS},
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 4V",    CBW_BIP4VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 2V",    CBW_BIP2VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS},
  {"+= 1V",    CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_231[] = {
  {"+= 10V", CBW_UNI5VOLTS}
};

static const enumStruct_t inputTypeUSB_231[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1208[] = {
  {"+= 20V",   CBW_BIP20VOLTS},
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 4V",    CBW_BIP4VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 2V",    CBW_BIP2VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS},
  {"+= 1V",    CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_1208[] = {
  {"+= 5V", CBW_UNI5VOLTS}
};

static const enumStruct_t outputRangeUSB_1208FS[] = {
  {"+= 4V", CBW_UNI4VOLTS}
};

static const enumStruct_t inputTypeUSB_1208[] = {
    {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1608G[] = {
  {"+= 10V", CBW_BIP10VOLTS},
  {"+= 5V",  CBW_BIP5VOLTS},
  {"+= 2V",  CBW_BIP2VOLTS},
  {"+= 1V",  CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_1608G[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_1608G[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1808[] = {
  {"+= 10V",    CBW_BIP10VOLTS},
  {"+= 5V",     CBW_BIP5VOLTS},
  {"0-10V",     CBW_UNI10VOLTS},
  {"0-5V",      CBW_UNI5VOLTS}
};

static const enumStruct_t outputRangeUSB_1808[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_1808[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_2408[] = {
  {"+= 10V",    CBW_BIP10VOLTS},
  {"+= 5V",     CBW_BIP5VOLTS},
  {"+= 2.5V",   CBW_BIP2PT5VOLTS},
  {"+= 1.25V",  CBW_BIP1PT25VOLTS},
  {"+= 0.625V", CBW_BIPPT625VOLTS},
  {"+= 0.312V", CBW_BIPPT312VOLTS},
  {"+= 0.156V", CBW_BIPPT156VOLTS},
  {"+= 0.078V", CBW_BIPPT078VOLTS}
};

static const enumStruct_t outputRangeUSB_2408[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_2408[] = {
  {"Volts",   AI_CHAN_TYPE_VOLTAGE},
  {"TC deg.", AI_CHAN_TYPE_TC}
};

static const enumStruct_t inputRangeUSB_3101[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeUSB_3101[] = {
  {"0-10V",  CBW_UNI10VOLTS},
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_3101[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_SSR08[] = {
  {"N.A.",  0}
};

static const enumStruct_t outputRangeUSB_SSR08[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_SSR08[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_TEMP[] = {
  {"N.A.", 0},
};

static const enumStruct_t outputRangeUSB_TEMP[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_TEMP[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_TEMP_AI[] = {
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS}
};

static const enumStruct_t outputRangeUSB_TEMP_AI[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_TEMP_AI[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeTC32[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeTC32[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeTC32[] = {
  {"TC deg.", AI_CHAN_TYPE_TC}
};

static const enumStruct_t inputRangeE_1608[] = {
  {"+= 10V", CBW_BIP10VOLTS},
  {"+= 5V",  CBW_BIP5VOLTS},
  {"+= 2V",  CBW_BIP2VOLTS},
  {"+= 1V",  CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeE_1608[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeE_1608[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeE_TC[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeE_TC[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeE_TC[] = {
  {"TC deg.", AI_CHAN_TYPE_TC}
};

#ifdef _WIN32
  // The sensor type cannot be configured in UL for Windows so widthwe use these default enum values
  static const enumStruct_t temperatureSensorUSB_TEMP[] = {
    {"RTD",           0},
    {"Thermistor",    1},
    {"Thermocouple",  2},
    {"Semiconductor", 3},
    {"Disabled",      4}
  };
  // The wiring cannot be configured in UL for Windows so we use these default enum values
  static const enumStruct_t temperatureWiringUSB_TEMP[] = {
    {"2 wire 1 sensor",   0},
    {"2 wire 2 sensors",  1},
    {"3 wire",            2},
    {"4 wire",            3}
  };
#else
  // These enum values are for UL for Linux.  
  static const enumStruct_t temperatureSensorUSB_TEMP[] = {
    {"RTD",           AI_RTD},
    {"Thermistor",    AI_THERMISTOR},
    {"Thermocouple",  AI_TC},
    {"Semiconductor", AI_SEMICONDUCTOR},
    {"Disabled",      AI_DISABLED}
  };
  static const enumStruct_t temperatureWiringUSB_TEMP[] = {
    {"2 wire 1 sensor",   SCT_2_WIRE_1},
    {"2 wire 2 sensors",  SCT_2_WIRE_2},
    {"3 wire",            SCT_3_WIRE},
    {"4 wire",            SCT_4_WIRE}
  };
#endif

typedef struct {
  boardType_t boardFamily;
  const enumStruct_t *pInputRange;
  int numInputRange;
  const enumStruct_t *pOutputRange;
  int numOutputRange;
  const enumStruct_t *pInputType;
  int numInputType;
} boardEnums_t;

static const boardEnums_t allBoardEnums[] = {
  {USB_231,        inputRangeUSB_231,     sizeof(inputRangeUSB_231)/sizeof(enumStruct_t),
                   outputRangeUSB_231,    sizeof(outputRangeUSB_231)/sizeof(enumStruct_t),
                   inputTypeUSB_231,      sizeof(inputTypeUSB_231)/sizeof(enumStruct_t)},

  {USB_1208LS,     inputRangeUSB_1208,    sizeof(inputRangeUSB_1208)/sizeof(enumStruct_t),
                   outputRangeUSB_1208,   sizeof(outputRangeUSB_1208)/sizeof(enumStruct_t),
                   inputTypeUSB_1208,     sizeof(inputTypeUSB_1208)/sizeof(enumStruct_t)},

  {USB_1208FS,     inputRangeUSB_1208,    sizeof(inputRangeUSB_1208)/sizeof(enumStruct_t),
                   outputRangeUSB_1208FS, sizeof(outputRangeUSB_1208FS)/sizeof(enumStruct_t),
                   inputTypeUSB_1208,     sizeof(inputTypeUSB_1208)/sizeof(enumStruct_t)},

  {USB_1608G,      inputRangeUSB_1608G,   sizeof(inputRangeUSB_1608G)/sizeof(enumStruct_t),
                   outputRangeUSB_1608G,  sizeof(outputRangeUSB_1608G)/sizeof(enumStruct_t),
                   inputTypeUSB_1608G,    sizeof(inputTypeUSB_1608G)/sizeof(enumStruct_t)},

  {USB_1808,       inputRangeUSB_1808,    sizeof(inputRangeUSB_1808)/sizeof(enumStruct_t),
                   outputRangeUSB_1808,   sizeof(outputRangeUSB_1808)/sizeof(enumStruct_t),
                   inputTypeUSB_1808,     sizeof(inputTypeUSB_1808)/sizeof(enumStruct_t)},

  {USB_3101,       inputRangeUSB_3101,    sizeof(inputRangeUSB_3101)/sizeof(enumStruct_t),
                   outputRangeUSB_3101,   sizeof(outputRangeUSB_3101)/sizeof(enumStruct_t),
                   inputTypeUSB_3101,     sizeof(inputTypeUSB_3101)/sizeof(enumStruct_t)},

  {USB_2408_2AO,   inputRangeUSB_2408,    sizeof(inputRangeUSB_2408)/sizeof(enumStruct_t),
                   outputRangeUSB_2408,   sizeof(outputRangeUSB_2408)/sizeof(enumStruct_t),
                   inputTypeUSB_2408,     sizeof(inputTypeUSB_2408)/sizeof(enumStruct_t)},

  {USB_SSR08,      inputRangeUSB_SSR08,   sizeof(inputRangeUSB_SSR08)/sizeof(enumStruct_t),
                   outputRangeUSB_SSR08,  sizeof(outputRangeUSB_SSR08)/sizeof(enumStruct_t),
                   inputTypeUSB_SSR08,    sizeof(inputTypeUSB_SSR08)/sizeof(enumStruct_t)},

  {USB_TEMP,       inputRangeUSB_TEMP,    sizeof(inputRangeUSB_TEMP)/sizeof(enumStruct_t),
                   outputRangeUSB_TEMP,   sizeof(outputRangeUSB_TEMP)/sizeof(enumStruct_t),
                   inputTypeUSB_TEMP,     sizeof(inputTypeUSB_TEMP)/sizeof(enumStruct_t)},

  {USB_TEMP_AI,    inputRangeUSB_TEMP_AI, sizeof(inputRangeUSB_TEMP_AI)/sizeof(enumStruct_t),
                   outputRangeUSB_TEMP_AI,sizeof(outputRangeUSB_TEMP_AI)/sizeof(enumStruct_t),
                   inputTypeUSB_TEMP_AI,  sizeof(inputTypeUSB_TEMP_AI)/sizeof(enumStruct_t)},

  {USB_TC32,       inputRangeTC32,        sizeof(inputRangeTC32)/sizeof(enumStruct_t),
                   outputRangeTC32,       sizeof(outputRangeTC32)/sizeof(enumStruct_t),
                   inputTypeTC32,         sizeof(inputTypeTC32)/sizeof(enumStruct_t)},

  {E_1608,         inputRangeE_1608,      sizeof(inputRangeE_1608)/sizeof(enumStruct_t),
                   outputRangeE_1608,     sizeof(outputRangeE_1608)/sizeof(enumStruct_t),
                   inputTypeE_1608,       sizeof(inputTypeE_1608)/sizeof(enumStruct_t)},

  {E_DIO24,        inputRangeE_DIO24,     sizeof(inputRangeE_DIO24)/sizeof(enumStruct_t),
                   outputRangeE_DIO24,    sizeof(outputRangeE_DIO24)/sizeof(enumStruct_t),
                   inputTypeE_DIO24,      sizeof(inputTypeE_DIO24)/sizeof(enumStruct_t)},

  {E_TC,           inputRangeE_TC,        sizeof(inputRangeE_TC)/sizeof(enumStruct_t),
                   outputRangeE_TC,       sizeof(outputRangeE_TC)/sizeof(enumStruct_t),
                   inputTypeE_TC,         sizeof(inputTypeE_TC)/sizeof(enumStruct_t)},
};

static int maxBoardFamilies = (int) (sizeof(allBoardEnums) / sizeof(boardEnums_t));
#define ROUND(x) ((x) >= 0. ? (int)x+0.5 : (int)(x-0.5))
#define MAX_BOARDNAME_LEN 256
#define MAX_LIBRARY_MESSAGE_LEN 256
#define PI 3.14159265

/** This is the class definition for the MultiFunction class
  */
class MultiFunction : public asynPortDriver {
public:
  MultiFunction(const char *portName, const char *uniqueID, int maxInputPoints, int maxOutputPoints);

  /* These are the methods that we override from asynPortDriver */
  virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
  virtual asynStatus getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high);
  virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
  virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
  virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);
  virtual asynStatus readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus writeFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements);
  virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readEnum(asynUser *pasynUser, char *strings[], int values[], int severities[], size_t nElements, size_t *nIn);
  virtual void report(FILE *fp, int details);
  // These should be private but are called from C
  virtual void pollerThread(void);

protected:
  // Model parameters
  int modelName_;
  int modelNumber_;
  int firmwareVersion_;
  int uniqueID_;
  int ULVersion_;
  int driverVersion_;
  int pollSleepMS_;
  int pollTimeMS_;
  int lastErrorMessage_;

  // Pulse generator parameters
  int pulseGenRun_;
  int pulseGenPeriod_;
  int pulseGenDutyCycle_;
  int pulseGenDelay_;
  int pulseGenCount_;
  int pulseGenIdleState_;

  // Counter parameters
  int counterCounts_;
  int counterReset_;

  // Analog input parameters
  int analogInValue_;
  int analogInRange_;
  int analogInType_;
  int analogInMode_;
  int analogInRate_;

  // Voltage input parameters
  int voltageInValue_;
  int voltageInRange_;

  // Temperature parameters
  int temperatureInValue_;
  int thermocoupleType_;
  int thermocoupleOpenDetect_;
  int temperatureScale_;
  int temperatureFilter_;
  int temperatureSensor_;
  int temperatureWiring_;

  // Waveform digitizer parameters - global
  int waveDigDwell_;
  int waveDigDwellActual_;
  int waveDigTotalTime_;
  int waveDigFirstChan_;
  int waveDigNumChans_;
  int waveDigNumPoints_;
  int waveDigCurrentPoint_;
  int waveDigExtTrigger_;
  int waveDigExtClock_;
  int waveDigContinuous_;
  int waveDigAutoRestart_;
  int waveDigRetrigger_;
  int waveDigTriggerCount_;
  int waveDigBurstMode_;
  int waveDigRun_;
  int waveDigTimeWF_;
  int waveDigAbsTimeWF_;
  int waveDigReadWF_;
  // Waveform digitizer parameters - per input
  int waveDigVoltWF_;

  // Analog output parameters
  int analogOutValue_;
  int analogOutRange_;

  // Waveform generator parameters - global
  int waveGenFreq_;
  int waveGenDwell_;
  int waveGenDwellActual_;
  int waveGenTotalTime_;
  int waveGenNumPoints_;
  int waveGenCurrentPoint_;
  int waveGenIntDwell_;
  int waveGenUserDwell_;
  int waveGenIntNumPoints_;
  int waveGenUserNumPoints_;
  int waveGenExtTrigger_;
  int waveGenExtClock_;
  int waveGenContinuous_;
  int waveGenRetrigger_;
  int waveGenTriggerCount_;
  int waveGenRun_;
  int waveGenUserTimeWF_;
  int waveGenIntTimeWF_;
  // Waveform generator parameters - per output
  int waveGenWaveType_;
  int waveGenEnable_;
  int waveGenAmplitude_;
  int waveGenOffset_;
  int waveGenPulseWidth_;
  int waveGenIntWF_;
  int waveGenUserWF_;

  // Trigger parameters
  int triggerMode_;

  // Digital I/O parameters
  int digitalDirection_;
  int digitalInput_;
  int digitalOutput_;

private:
  #ifdef _WIN32
    int boardNum_;
  #else
    DaqDeviceHandle daqDeviceHandle_;
  #endif
  DaqDeviceDescriptor daqDeviceDescriptor_;
  char boardName_[MAX_BOARDNAME_LEN];
  int boardType_;
  int boardFamily_;
  const boardEnums_t *pBoardEnums_;
  int numAnalogIn_;
  int analogInTypeConfigurable_;
  int analogInDataRateConfigurable_;
  int analogOutRangeConfigurable_;
  int numAnalogOut_;
  #ifdef linux
    AiInputMode aiInputMode_;
    TriggerType triggerType_;
    int aiScanTrigCount_;  // Not currently used
    int aoScanTrigCount_;  // Not currently used
  #endif
  int ADCResolution_;
  int DACResolution_;
  int numCounters_;
  int firstCounter_;
  int numTimers_;
  int numIOPorts_;
  int numTempChans_;
  int digitalIOPort_[MAX_IO_PORTS];
  int digitalIOBitConfigurable_[MAX_IO_PORTS];
  int digitalIOPortConfigurable_[MAX_IO_PORTS];
  int digitalIOPortWriteOnly_[MAX_IO_PORTS];
  int digitalIOPortReadOnly_[MAX_IO_PORTS];
  int numIOBits_[MAX_IO_PORTS];
  epicsUInt32 digitalIOMask_[MAX_IO_PORTS];
  double minPulseGenFrequency_;
  double maxPulseGenFrequency_;
  double minPulseGenDelay_;
  double maxPulseGenDelay_;
  double pollTime_;
  int forceCallback_[MAX_IO_PORTS];
  size_t maxInputPoints_;
  size_t maxOutputPoints_;
  epicsFloat64 *waveDigBuffer_[MAX_ANALOG_IN];
  epicsFloat32 *waveDigTimeBuffer_;
  epicsFloat64 *waveDigAbsTimeBuffer_;
  epicsFloat32 *waveGenIntBuffer_[MAX_ANALOG_OUT];
  epicsFloat32 *waveGenUserBuffer_[MAX_ANALOG_OUT];
  epicsFloat32 *waveGenUserTimeBuffer_;
  epicsFloat32 *waveGenIntTimeBuffer_;
  epicsFloat64 *pInBuffer_;
  #ifdef _WIN32
    epicsUInt16  *waveGenOutBuffer_;
  #else
    epicsFloat64 *waveGenOutBuffer_;
  #endif
  int numWaveGenChans_;
  int numWaveDigChans_;
  int pulseGenRunning_[MAX_PULSE_GEN];
  int waveGenRunning_;
  int waveDigRunning_;
  int startPulseGenerator(int timerNum);
  int stopPulseGenerator(int timerNum);
  int startWaveGen();
  int stopWaveGen();
  int computeWaveGenTimes();
  int startWaveDig();
  int stopWaveDig();
  int readWaveDig();
  int computeWaveDigTimes();
  int defineWaveform(int channel);
  int setOpenThermocoupleDetect(int addr, int value);
  int reportError(int err, const char *functionName, const char *message);
  #ifdef linux
  int mapRange(int Gain, Range *range);
  int mapTriggerType(int cbwTriggerType, TriggerType *triggerType);
  #endif
};

static void pollerThreadC(void * pPvt)
{
    MultiFunction *pMultiFunction = (MultiFunction *)pPvt;
    pMultiFunction->pollerThread();
}

MultiFunction::MultiFunction(const char *portName, const char *uniqueID, int maxInputPoints, int maxOutputPoints)
  : asynPortDriver(portName, MAX_SIGNALS,
      asynUInt32DigitalMask | asynInt32Mask   | asynInt32ArrayMask   | asynFloat32ArrayMask | 
                              asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask        | asynEnumMask | asynDrvUserMask,
      asynUInt32DigitalMask | asynInt32Mask   | asynInt32ArrayMask   | asynFloat32ArrayMask | 
                              asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask        | asynEnumMask,
      ASYN_MULTIDEVICE | ASYN_CANBLOCK, 1, /* ASYN_CANBLOCK=1, ASYN_MULTIDEVICE=1, autoConnect=1 */
      0, 0),  /* Default priority and stack size */
    maxInputPoints_(maxInputPoints),
    maxOutputPoints_(maxOutputPoints),
    numWaveGenChans_(1),
    numWaveDigChans_(1),
    waveGenRunning_(0),
    waveDigRunning_(0)
{
  int i, j;
  int status;
  long long handle;
  static const char *functionName = "MultiFunction";

  for (i=0; i<MAX_PULSE_GEN; i++) pulseGenRunning_[i]=0;
  for (i=0; i<MAX_IO_PORTS; i++) forceCallback_[i] = 1;

  status = measCompCreateDevice(uniqueID, daqDeviceDescriptor_, &handle);
  if (status) {
    printf("Error creating device with measCompCreateDevice\n");
    return;
  }
  #ifdef _WIN32
    boardNum_ = (int) handle;
    strcpy(boardName_, daqDeviceDescriptor_.ProductName);
    boardType_ = daqDeviceDescriptor_.ProductID;
  #else
    daqDeviceHandle_ = handle;
    strcpy(boardName_, daqDeviceDescriptor_.productName);
    boardType_ = daqDeviceDescriptor_.productId;
  #endif

  // Model parameters
  createParam(modelNameString,                 asynParamOctet,  &modelName_);
  createParam(modelNumberString,               asynParamInt32,  &modelNumber_);
  createParam(firmwareVersionString,            asynParamOctet, &firmwareVersion_);
  createParam(uniqueIDString,                   asynParamOctet, &uniqueID_);
  createParam(ULVersionString,                  asynParamOctet, &ULVersion_);
  createParam(driverVersionString,              asynParamOctet, &driverVersion_);
  createParam(pollSleepMSString,              asynParamFloat64, &pollSleepMS_);
  createParam(pollTimeMSString,               asynParamFloat64, &pollTimeMS_);
  createParam(lastErrorMessageString,           asynParamOctet, &lastErrorMessage_);

  // Pulse generator parameters
  createParam(pulseGenRunString,               asynParamInt32, &pulseGenRun_);
  createParam(pulseGenPeriodString,          asynParamFloat64, &pulseGenPeriod_);
  createParam(pulseGenDutyCycleString,       asynParamFloat64, &pulseGenDutyCycle_);
  createParam(pulseGenDelayString,           asynParamFloat64, &pulseGenDelay_);
  createParam(pulseGenCountString,             asynParamInt32, &pulseGenCount_);
  createParam(pulseGenIdleStateString,         asynParamInt32, &pulseGenIdleState_);

  // Counter parameters
  createParam(counterCountsString,             asynParamInt32, &counterCounts_);
  createParam(counterResetString,              asynParamInt32, &counterReset_);

  // Analog input parameters
  createParam(analogInValueString,             asynParamInt32, &analogInValue_);
  createParam(analogInRangeString,             asynParamInt32, &analogInRange_);
  createParam(analogInTypeString,              asynParamInt32, &analogInType_);
  createParam(analogInModeString,              asynParamInt32, &analogInMode_);
  createParam(analogInRateString,              asynParamInt32, &analogInRate_);

  // Voltage input parameters
  createParam(voltageInValueString,          asynParamFloat64, &voltageInValue_);
  createParam(voltageInRangeString,            asynParamInt32, &voltageInRange_);

  // Temperature parameters
  createParam(temperatureInValueString,      asynParamFloat64, &temperatureInValue_);
  createParam(thermocoupleTypeString,          asynParamInt32, &thermocoupleType_);
  createParam(thermocoupleOpenDetectString,    asynParamInt32, &thermocoupleOpenDetect_);
  createParam(temperatureScaleString,          asynParamInt32, &temperatureScale_);
  createParam(temperatureFilterString,         asynParamInt32, &temperatureFilter_);
  createParam(temperatureSensorString,         asynParamInt32, &temperatureSensor_);
  createParam(temperatureWiringString,         asynParamInt32, &temperatureWiring_);

  // Waveform digitizer parameters - global
  createParam(waveDigDwellString,            asynParamFloat64, &waveDigDwell_);
  createParam(waveDigDwellActualString,      asynParamFloat64, &waveDigDwellActual_);
  createParam(waveDigTotalTimeString,        asynParamFloat64, &waveDigTotalTime_);
  createParam(waveDigFirstChanString,          asynParamInt32, &waveDigFirstChan_);
  createParam(waveDigNumChansString,           asynParamInt32, &waveDigNumChans_);
  createParam(waveDigNumPointsString,          asynParamInt32, &waveDigNumPoints_);
  createParam(waveDigCurrentPointString,       asynParamInt32, &waveDigCurrentPoint_);
  createParam(waveDigExtTriggerString,         asynParamInt32, &waveDigExtTrigger_);
  createParam(waveDigExtClockString,           asynParamInt32, &waveDigExtClock_);
  createParam(waveDigContinuousString,         asynParamInt32, &waveDigContinuous_);
  createParam(waveDigAutoRestartString,        asynParamInt32, &waveDigAutoRestart_);
  createParam(waveDigRetriggerString,          asynParamInt32, &waveDigRetrigger_);
  createParam(waveDigTriggerCountString,       asynParamInt32, &waveDigTriggerCount_);
  createParam(waveDigBurstModeString,          asynParamInt32, &waveDigBurstMode_);
  createParam(waveDigRunString,                asynParamInt32, &waveDigRun_);
  createParam(waveDigTimeWFString,      asynParamFloat32Array, &waveDigTimeWF_);
  createParam(waveDigAbsTimeWFString,   asynParamFloat64Array, &waveDigAbsTimeWF_);
  createParam(waveDigReadWFString,             asynParamInt32, &waveDigReadWF_);
  // Waveform digitizer parameters - per input
  createParam(waveDigVoltWFString,      asynParamFloat32Array, &waveDigVoltWF_);

  // Analog output parameters
  createParam(analogOutValueString,            asynParamInt32, &analogOutValue_);
  createParam(analogOutRangeString,            asynParamInt32, &analogOutRange_);

  // Waveform generator parameters - global
  createParam(waveGenFreqString,             asynParamFloat64, &waveGenFreq_);
  createParam(waveGenDwellString,            asynParamFloat64, &waveGenDwell_);
  createParam(waveGenDwellActualString,      asynParamFloat64, &waveGenDwellActual_);
  createParam(waveGenTotalTimeString,        asynParamFloat64, &waveGenTotalTime_);
  createParam(waveGenNumPointsString,          asynParamInt32, &waveGenNumPoints_);
  createParam(waveGenCurrentPointString,       asynParamInt32, &waveGenCurrentPoint_);
  createParam(waveGenIntDwellString,         asynParamFloat64, &waveGenIntDwell_);
  createParam(waveGenUserDwellString,        asynParamFloat64, &waveGenUserDwell_);
  createParam(waveGenIntNumPointsString,       asynParamInt32, &waveGenIntNumPoints_);
  createParam(waveGenUserNumPointsString,      asynParamInt32, &waveGenUserNumPoints_);
  createParam(waveGenExtTriggerString,         asynParamInt32, &waveGenExtTrigger_);
  createParam(waveGenExtClockString,           asynParamInt32, &waveGenExtClock_);
  createParam(waveGenContinuousString,         asynParamInt32, &waveGenContinuous_);
  createParam(waveGenRetriggerString,          asynParamInt32, &waveGenRetrigger_);
  createParam(waveGenTriggerCountString,       asynParamInt32, &waveGenTriggerCount_);
  createParam(waveGenRunString,                asynParamInt32, &waveGenRun_);
  createParam(waveGenUserTimeWFString,  asynParamFloat32Array, &waveGenUserTimeWF_);
  createParam(waveGenIntTimeWFString,   asynParamFloat32Array, &waveGenIntTimeWF_);
  // Waveform generator parameters - per output
  createParam(waveGenWaveTypeString,           asynParamInt32, &waveGenWaveType_);
  createParam(waveGenEnableString,             asynParamInt32, &waveGenEnable_);
  createParam(waveGenAmplitudeString,        asynParamFloat64, &waveGenAmplitude_);
  createParam(waveGenOffsetString,           asynParamFloat64, &waveGenOffset_);
  createParam(waveGenPulseWidthString,       asynParamFloat64, &waveGenPulseWidth_);
  createParam(waveGenIntWFString,       asynParamFloat32Array, &waveGenIntWF_);
  createParam(waveGenUserWFString,      asynParamFloat32Array, &waveGenUserWF_);

  // Trigger parameters
  createParam(triggerModeString,               asynParamInt32, &triggerMode_);

  // Digital I/O parameters
  createParam(digitalDirectionString,  asynParamUInt32Digital, &digitalDirection_);
  createParam(digitalInputString,      asynParamUInt32Digital, &digitalInput_);
  createParam(digitalOutputString,     asynParamUInt32Digital, &digitalOutput_);

  // Map very similar boards for simplicity
  boardFamily_ = boardType_;
  switch (boardType_) {
    case USB_1208LS:
    case USB_1208FS_PLUS:
      boardFamily_ = USB_1208LS;
      break;
    case USB_1608G:
    case USB_1608GX:
    case USB_1608GX_2AO:
    case USB_1608GX_2AO_OLD:
    case USB_1608HS_2AO:
      boardFamily_ = USB_1608G;
      break;
    case USB_1808:
    case USB_1808X:
      boardFamily_ = USB_1808;
      break;
    case USB_3101:
    case USB_3102:
    case USB_3103:
    case USB_3104:
    case USB_3105:
    case USB_3106:
    case USB_3110:
    case USB_3112:
    case USB_3114:
      boardFamily_ = USB_3101;
      break;
    case USB_TC32:
    case ETH_TC32:
      boardFamily_ = USB_TC32;
      break;
    default:
      break;
  }

  char uniqueIDStr[256];
  char firmwareVersion[256];
  char ULVersion[256];
  ULMutex.lock();
  #ifdef _WIN32
    int size = sizeof(uniqueIDStr);
    cbGetConfigString(BOARDINFO, boardNum_, 0, BIDEVUNIQUEID, uniqueIDStr, &size);
    size = sizeof(firmwareVersion);
    cbGetConfigString(BOARDINFO, boardNum_, VER_FW_MAIN, BIDEVVERSION, firmwareVersion, &size);
    float DLLRevNum, VXDRevNum;
    cbGetRevision(&DLLRevNum, &VXDRevNum);
    sprintf(ULVersion, "%f %f", DLLRevNum, VXDRevNum);
  #else
    strcpy(uniqueIDStr, uniqueID);
    unsigned int size = sizeof(firmwareVersion);
    ulDevGetConfigStr(daqDeviceHandle_, ::DEV_CFG_VER_STR, DEV_VER_FW_MAIN, firmwareVersion, &size);
    size = sizeof(ULVersion);
    ulGetInfoStr(UL_INFO_VER_STR, 0, ULVersion, &size);
  #endif
  setIntegerParam(modelNumber_, boardType_);
  setStringParam(modelName_, boardName_);
  setStringParam(uniqueID_, uniqueIDStr);
  setStringParam(firmwareVersion_, firmwareVersion);
  setStringParam(ULVersion_, ULVersion);
  setStringParam(driverVersion_, DRIVER_VERSION);
  
  #ifdef _WIN32
    int inMask, outMask;
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMADCHANS,    &numAnalogIn_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMDACHANS,    &numAnalogOut_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIADRES,         &ADCResolution_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIDACRES,        &DACResolution_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIDINUMDEVS,     &numIOPorts_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMTEMPCHANS,  &numTempChans_);
  #else
    long long infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_NUM_CHANS_BY_TYPE, AI_VOLTAGE, &infoValue);
    if (status)
      numAnalogIn_ = 0;
    else
      numAnalogIn_ = infoValue;
    status = ulAOGetInfo(daqDeviceHandle_, AO_INFO_NUM_CHANS, 0, &infoValue);
    if (status)
      numAnalogOut_ = 0;
    else
      numAnalogOut_ = infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_RESOLUTION, 0, &infoValue);
    ADCResolution_ = infoValue;
    status = ulAOGetInfo(daqDeviceHandle_, AO_INFO_RESOLUTION, 0, &infoValue);
    DACResolution_ = infoValue;
    status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_NUM_PORTS, 0, &infoValue);
    numIOPorts_ = infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_NUM_CHANS_BY_TYPE, AI_TC, &infoValue);
    numTempChans_ = infoValue;
  #endif
  if (numIOPorts_ > MAX_IO_PORTS) numIOPorts_ = MAX_IO_PORTS;
  for (i=0; i<numIOPorts_; i++) {
    digitalIOPortConfigurable_[i] = 0;
    #ifdef _WIN32
      cbGetConfig(DIGITALINFO, boardNum_, i, DIDEVTYPE, &digitalIOPort_[i]);
      cbGetConfig(DIGITALINFO, boardNum_, i, DIINMASK,  &inMask);
      cbGetConfig(DIGITALINFO, boardNum_, i, DIOUTMASK, &outMask);
      digitalIOPortReadOnly_[i]    = ((inMask != 0) && (outMask == 0));
      digitalIOPortWriteOnly_[i]   = ((inMask == 0) && (outMask != 0));
      digitalIOBitConfigurable_[i] = ((inMask & outMask) == 0);
      cbGetConfig(DIGITALINFO, boardNum_, i, DINUMBITS, &numIOBits_[i]);
    #else
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_PORT_TYPE, i, &infoValue);
      digitalIOPort_[i] = infoValue;
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_PORT_IO_TYPE, i, &infoValue);
      digitalIOPortReadOnly_[i]    = (infoValue == DPIOT_IN);
      digitalIOPortWriteOnly_[i]   = (infoValue == DPIOT_OUT);
      digitalIOBitConfigurable_[i] = (infoValue == DPIOT_BITIO);
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_NUM_BITS, i, &infoValue);
      numIOBits_[i] = infoValue;
    #endif
    digitalIOMask_[i] = 0;
    for (j=0; j<numIOBits_[i]; j++) {
      digitalIOMask_[i] |= (1 << j);
    }
  }
  ULMutex.unlock();
  // Assume only voltage input is supported
  analogInTypeConfigurable_ = 0;
  // Assume analog in data rate not configurable
  analogInDataRateConfigurable_ = 0;
  // Assume analog output range is not configurable
  analogOutRangeConfigurable_ = 0;
  switch (boardFamily_) {
    case USB_231:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      // For output need to address all bits using first port
      numIOBits_[0] = 8;
      // The rules for bit configurable above don't work for this model
      digitalIOPortConfigurable_[0] = 1;
      digitalIOPortConfigurable_[1] = 1;
      digitalIOBitConfigurable_[0] = 0;
      digitalIOPortConfigurable_[1] = 1;
      break;
    case USB_1208LS:
    case USB_1208FS:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 1;
      // For output need to address all bits using first port
      numIOBits_[0] = 16;
      // The rules for bit configurable above don't work for this model
      digitalIOPortConfigurable_[0] = 1;
      digitalIOPortConfigurable_[1] = 1;
      digitalIOBitConfigurable_[0] = 0;
      digitalIOPortConfigurable_[1] = 1;
      break;
    case USB_1608G:
      numTimers_    = 1;
      numCounters_  = 2;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 32e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 67.11;
      break;
    case USB_1608HS_2AO:
      numTimers_    = 1;
      numCounters_  = 1;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 32e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 67.11;
      break;
    case USB_1808:
      numTimers_    = 2;
      numCounters_  = 4;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 50e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 42.94;
      break;
    case USB_2408_2AO:
      numTimers_    = 0;
      numCounters_  = 2;
      firstCounter_ = 0;
      analogInTypeConfigurable_  = 1; // Supports voltage and thermocouple
      analogInDataRateConfigurable_ = 1; // Can configure analog input data rate
      break;
    case USB_3101:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      analogOutRangeConfigurable_ = 1; // Can select 0-10V or +-10V
      break;
    case USB_SSR08:
      numTimers_    = 0;
      numCounters_  = 0;
      for (i=0; i<2; i++) {
        // Digital I/O port 0 is outputs 1 - 4      
        // Digital I/O port 1 is outputs 5 - 8      
        setUIntDigitalParam(i, digitalDirection_, 0xFFFFFFFF, digitalIOMask_[i]);
      }
      break;
    case USB_TEMP:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<8; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      break;
    case USB_TEMP_AI:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<4; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      for (i=4; i<8; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_VOLTAGE);
      }
      break;
    case USB_TC32:
      numTimers_    = 0;
      numCounters_  = 0;
      for (i=0; i<MAX_TEMPERATURE_IN; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      // On Linux the TC-32 reports that numIOPorts_ = 4, but it is really only 2
      // This should be fixed in uldaq.
      #ifdef linux
        numIOPorts_ = 2;
      #endif
      // Digital I/O port 0 is input only
      setUIntDigitalParam(0, digitalDirection_, 0, 0xFFFFFFFF);
      // Digital I/O port 1 is output and temperature alarms
      setUIntDigitalParam(1, digitalDirection_, 0xFFFFFFFF, 0xFFFFFFFF);
      break;
    case E_1608:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      break;
    case E_DIO24:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      break;
    case E_TC:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<MAX_TEMPERATURE_IN; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      break;
    default:
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error, unknown board type=%d, board family=%d\n",
        driverName, functionName, boardType_, boardFamily_);
      break;
  }

  for (i=0, pBoardEnums_=0; i<maxBoardFamilies; i++) {
    if (allBoardEnums[i].boardFamily == boardFamily_) {
       pBoardEnums_ = &allBoardEnums[i];
       break;
    }
  }
  if (pBoardEnums_ == 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error, unknown board family=%d\n",
      driverName, functionName, boardFamily_);
  }

  // Allocate memory for the input and output buffers
  for (i=0; i<numAnalogIn_; i++) {
    waveDigBuffer_[i]  = (epicsFloat64 *) calloc(maxInputPoints_,  sizeof(epicsFloat64));
  }
  for (i=0; i<numAnalogOut_; i++) {
    waveGenIntBuffer_[i]  = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
    waveGenUserBuffer_[i] = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  }
  waveGenUserTimeBuffer_ = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  waveGenIntTimeBuffer_  = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  waveDigTimeBuffer_     = (epicsFloat32 *) calloc(maxInputPoints_,  sizeof(epicsFloat32));
  waveDigAbsTimeBuffer_  = (epicsFloat64 *) calloc(maxInputPoints_,  sizeof(epicsFloat64));
  pInBuffer_ = (epicsFloat64 *) calloc(maxInputPoints  * numAnalogIn_, sizeof(epicsFloat64));
  #ifdef _WIN32
    waveGenOutBuffer_ = (epicsUInt16 *) calloc(maxOutputPoints * numAnalogOut_, sizeof(epicsUInt16));
  #else
    waveGenOutBuffer_ = (epicsFloat64 *) calloc(maxOutputPoints * numAnalogOut_, sizeof(epicsFloat64));
  #endif

  // Set values of some parameters that need to be set because init record order is not predictable
  // or because the corresponding records are PINI=NO.
  setIntegerParam(waveGenUserNumPoints_, 1);
  setIntegerParam(waveGenIntNumPoints_, 1);
  setIntegerParam(waveDigNumPoints_, 1);
  setIntegerParam(pulseGenRun_, 0);
  setIntegerParam(waveDigRun_, 0);
  setIntegerParam(waveGenRun_, 0);
  for (i=0; i<numTempChans_; i++) {
    setIntegerParam(i, thermocoupleType_, TC_TYPE_J);
  }
  // Set the analog output range to the first supported value for this model
  for (i=0; i<MAX_ANALOG_OUT; i++) {
    setIntegerParam(i, analogOutRange_, pBoardEnums_->pOutputRange[0].enumValue);
  }

  /* Start the thread to poll counters and digital inputs and do callbacks to
   * device support */
  epicsThreadCreate("MultiFunctionPoller",
                    epicsThreadPriorityLow,
                    epicsThreadGetStackSize(epicsThreadStackMedium),
                    (EPICSTHREADFUNC)pollerThreadC,
                    this);
}

int  MultiFunction::reportError(int err, const char *functionName, const char *message)
{
  char libraryMessage[MAX_LIBRARY_MESSAGE_LEN];
  ULMutex.lock();
  switch (err) {
    case 0: 
      asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
        "%s::%s Info: %s\n", driverName, functionName, message);
      break;
    case -1: 
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s Error: %s\n", driverName, functionName, message);
      break;
    default:
      #ifdef _WIN32
        cbGetErrMsg(err, libraryMessage);
      #else
        ulGetErrMsg((UlError)err, libraryMessage);
      #endif
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s Error: %s, err=%d %s\n", driverName, functionName, message, err, libraryMessage);
  }
  ULMutex.unlock();
  return err;
}

#ifdef linux
int MultiFunction::mapRange(int Gain, Range *range)
{
    static const char *functionName = "mapRange";
    // Converts cbw Gain to uldaq Range
    switch (Gain) {
      case CBW_BIP60VOLTS:    *range = BIP60VOLTS; break;
      case CBW_BIP30VOLTS:    *range = BIP30VOLTS; break;
      case CBW_BIP20VOLTS:    *range = BIP20VOLTS; break;
      case CBW_BIP15VOLTS:    *range = BIP15VOLTS; break;
      case CBW_BIP10VOLTS:    *range = BIP10VOLTS; break;
      case CBW_BIP5VOLTS:     *range = BIP5VOLTS; break;
      case CBW_BIP4VOLTS:     *range = BIP4VOLTS; break;
      case CBW_BIP2PT5VOLTS:  *range = BIP2PT5VOLTS; break;
      case CBW_BIP2VOLTS:     *range = BIP2VOLTS; break;
      case CBW_BIP1PT25VOLTS: *range = BIP1PT25VOLTS; break;
      case CBW_BIP1VOLTS:     *range = BIP1VOLTS; break;
      case CBW_BIPPT625VOLTS: *range = BIPPT625VOLTS; break;
      case CBW_BIPPT5VOLTS:   *range = BIPPT5VOLTS; break;
      case CBW_BIPPT25VOLTS:  *range = BIPPT25VOLTS; break;
      case CBW_BIPPT2VOLTS:   *range = BIPPT2VOLTS; break;
      case CBW_BIPPT1VOLTS:   *range = BIPPT1VOLTS; break;
      case CBW_BIPPT05VOLTS:  *range = BIPPT05VOLTS; break;
      case CBW_BIPPT01VOLTS:  *range = BIPPT01VOLTS; break;
      case CBW_BIPPT005VOLTS: *range = BIPPT005VOLTS; break;
//      case CBW_BIP1PT67VOLTS: *range = BIP1PT67VOLTS; break;
      case CBW_BIPPT312VOLTS: *range = BIPPT312VOLTS; break;
      case CBW_BIPPT156VOLTS: *range = BIPPT156VOLTS; break;
      case CBW_BIPPT125VOLTS: *range = BIPPT125VOLTS; break;
      case CBW_BIPPT078VOLTS: *range = BIPPT078VOLTS; break;

      case CBW_UNI10VOLTS:    *range = UNI10VOLTS; break;
      case CBW_UNI5VOLTS:     *range = UNI5VOLTS; break;
      case CBW_UNI4VOLTS:     *range = UNI4VOLTS; break;
      case CBW_UNI2PT5VOLTS:  *range = UNI2PT5VOLTS; break;
      case CBW_UNI2VOLTS:     *range = UNI2VOLTS; break;
//      case CBW_UNI1PT67VOLTS: *range = UNI1PT67VOLTS; break;
      case CBW_UNI1PT25VOLTS: *range = UNI1PT25VOLTS; break;
      case CBW_UNI1VOLTS:     *range = UNI1VOLTS; break;
      case CBW_UNIPT5VOLTS:   *range = UNIPT5VOLTS; break;
      case CBW_UNIPT25VOLTS:  *range = UNIPT25VOLTS; break;
      case CBW_UNIPT2VOLTS:   *range = UNIPT2VOLTS; break;
      case CBW_UNIPT1VOLTS:   *range = UNIPT1VOLTS; break;
      case CBW_UNIPT05VOLTS:  *range = UNIPT05VOLTS; break;
//      case CBW_UNIPT02VOLTS:  *range = UNIPT02VOLTS; break;
      case CBW_UNIPT01VOLTS:  *range = UNIPT01VOLTS; break;

      case CBW_MA0TO20:       *range = MA0TO20; break;
      default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
            "%s::%s unsupported gain=%d\n", driverName, functionName, Gain);
          return -1;
    }
    return 0;
}

// This function maps the trigger types from UL on Windows to the values in UL for Linux.
// We can't use the macros from Windows cbw.h because they conflict with UL for Linux.
// These definitions are taken from cbw.h, but added CBW_ prefix.

#define CBW_TRIGABOVE           0
#define CBW_TRIGBELOW           1
#define CBW_GATE_NEG_HYS        2
#define CBW_GATE_POS_HYS        3
#define CBW_GATE_ABOVE          4
#define CBW_GATE_BELOW          5
#define CBW_GATE_IN_WINDOW      6
#define CBW_GATE_OUT_WINDOW     7
#define CBW_GATE_HIGH           8
#define CBW_GATE_LOW            9
#define CBW_TRIG_HIGH           10
#define CBW_TRIG_LOW            11
#define CBW_TRIG_POS_EDGE       12
#define CBW_TRIG_NEG_EDGE       13
#define CBW_TRIG_RISING         14
#define CBW_TRIG_FALLING        15
#define CBW_TRIG_PATTERN_EQ     16
#define CBW_TRIG_PATTERN_NE     17
#define CBW_TRIG_PATTERN_ABOVE  18
#define CBW_TRIG_PATTERN_BELOW  19

int MultiFunction::mapTriggerType(int cbwTriggerType, TriggerType *triggerType)
{
    static const char *functionName = "mapTriggerType";
    // Converts cbw trigger type to uldaq trigger type;
    switch (cbwTriggerType) {
      case CBW_TRIG_POS_EDGE:       *triggerType = TRIG_POS_EDGE; break;
      case CBW_TRIG_NEG_EDGE:       *triggerType = TRIG_NEG_EDGE; break;
      case CBW_TRIG_HIGH:           *triggerType = TRIG_HIGH; break;
      case CBW_TRIG_LOW:            *triggerType = TRIG_LOW; break;
      case CBW_GATE_HIGH:           *triggerType = GATE_HIGH; break;
      case CBW_GATE_LOW:            *triggerType = GATE_LOW; break;
      case CBW_TRIG_RISING:         *triggerType = TRIG_RISING; break;
      case CBW_TRIG_FALLING:        *triggerType = TRIG_FALLING; break;
      case CBW_TRIGABOVE:           *triggerType = TRIG_ABOVE; break;
      case CBW_TRIGBELOW:           *triggerType = TRIG_BELOW; break;
      case CBW_GATE_ABOVE:          *triggerType = GATE_ABOVE; break;
      case CBW_GATE_BELOW:          *triggerType = GATE_BELOW; break;
      case CBW_GATE_IN_WINDOW:      *triggerType = GATE_IN_WINDOW; break;
      case CBW_GATE_OUT_WINDOW:     *triggerType = GATE_OUT_WINDOW; break;
      case CBW_TRIG_PATTERN_EQ:     *triggerType = TRIG_PATTERN_EQ; break;
      case CBW_TRIG_PATTERN_NE:     *triggerType = TRIG_PATTERN_NE; break;
      case CBW_TRIG_PATTERN_ABOVE:  *triggerType = TRIG_PATTERN_ABOVE; break;
      case CBW_TRIG_PATTERN_BELOW:  *triggerType = TRIG_PATTERN_BELOW; break;
      default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s unsupported cbwTriggerType=%d\n", driverName, functionName, cbwTriggerType);
          *triggerType = TRIG_NONE;
          return -1;
    }
    return 0;
}

#endif

int MultiFunction::startPulseGenerator(int timerNum)
{
  int status=0;
  double frequency, period, delay;
  double dutyCycle;
  int count, idleState;
  static const char *functionName = "startPulseGenerator";

  getDoubleParam (timerNum, pulseGenPeriod_,    &period);
  getDoubleParam (timerNum, pulseGenDutyCycle_, &dutyCycle);
  getDoubleParam (timerNum, pulseGenDelay_,     &delay);
  getIntegerParam(timerNum, pulseGenCount_,     &count);
  getIntegerParam(timerNum, pulseGenIdleState_, &idleState);

  frequency = 1./period;
  if (frequency < minPulseGenFrequency_) frequency = minPulseGenFrequency_;
  if (frequency > maxPulseGenFrequency_) frequency = maxPulseGenFrequency_;
  period = 1. / frequency;
  if (dutyCycle <= 0.) dutyCycle = .0001;
  if (dutyCycle >= 1.) dutyCycle = .9999;
  if (delay < minPulseGenDelay_) delay = minPulseGenDelay_;
  if (delay > maxPulseGenDelay_) delay = maxPulseGenDelay_;

  ULMutex.lock();
  #ifdef _WIN32
    status = cbPulseOutStart(boardNum_, timerNum, &frequency, &dutyCycle, count, &delay, idleState, 0);
  #else
    TmrIdleState idle = (idleState == 0) ? TMRIS_LOW : TMRIS_HIGH;
    status = ulTmrPulseOutStart(daqDeviceHandle_, timerNum, &frequency, &dutyCycle, count, &delay, idle, PO_DEFAULT);
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling PulseOutStart");
  if (status) return status;
  // We may not have gotten the frequency, dutyCycle, and delay we asked for, set the actual values
  // in the parameter library
  pulseGenRunning_[timerNum] = 1;
  period = 1. / frequency;
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: started pulse generator %d actual frequency=%f, actual period=%f, actual duty cycle=%f, actual delay=%f\n",
    driverName, functionName, timerNum, frequency, period, dutyCycle, delay);
  setDoubleParam(timerNum, pulseGenPeriod_, period);
  setDoubleParam(timerNum, pulseGenDutyCycle_, dutyCycle);
  setDoubleParam(timerNum, pulseGenDelay_, delay);
  return 0;
}

int MultiFunction::stopPulseGenerator(int timerNum)
{
  pulseGenRunning_[timerNum] = 0;
  int err;
  ULMutex.lock();
  #ifdef _WIN32
    err = cbPulseOutStop(boardNum_, timerNum);
  #else
    err = ulTmrPulseOutStop(daqDeviceHandle_, timerNum);
  #endif
  ULMutex.unlock();
  return err;
}

int MultiFunction::defineWaveform(int channel)
{
  int waveType;
  int numPoints;
  int nPulse;
  int i;
  epicsFloat32 *outPtr = waveGenIntBuffer_[channel];
  double dwell, offset, base, amplitude, pulseWidth, scale;
  static const char *functionName = "defineWaveform";

  getIntegerParam(channel, waveGenWaveType_,  &waveType);
  if (waveType == waveTypeUser) {
    getIntegerParam(waveGenUserNumPoints_, &numPoints);
    if ((size_t)numPoints > maxOutputPoints_) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s:%s: ERROR numPoints=%d must be less than maxOutputPoints=%d\n",
        driverName, functionName, numPoints, (int)maxOutputPoints_);
      return -1;
    }
    getDoubleParam(waveGenUserDwell_, &dwell);
    setIntegerParam(waveGenNumPoints_, numPoints);
    setDoubleParam(waveGenDwell_, dwell);
    setDoubleParam(waveGenFreq_, 1./dwell/numPoints);
    return 0;
  }

  getIntegerParam(waveGenIntNumPoints_,  &numPoints);
  if ((size_t)numPoints > maxOutputPoints_) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s:%s: ERROR numPoints=%d must be less than maxOutputPoints=%d\n",
      driverName, functionName, numPoints, (int)maxOutputPoints_);
    return -1;
  }

  getDoubleParam(waveGenIntDwell_,             &dwell);
  getDoubleParam(channel, waveGenOffset_,      &offset);
  getDoubleParam(channel, waveGenAmplitude_,   &amplitude);
  getDoubleParam(channel, waveGenPulseWidth_,  &pulseWidth);
  setIntegerParam(waveGenNumPoints_, numPoints);
  setDoubleParam(waveGenDwell_, dwell);
  setDoubleParam(waveGenFreq_, 1./dwell/numPoints);
  base = offset - amplitude/2.;
  switch (waveType) {
    case waveTypeSin:
      scale = 2.*PI/(numPoints-1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (offset + amplitude/2. * sin(i*scale));
      break;
    case waveTypeSquare:
      for (i=0; i<numPoints/2; i++)         *outPtr++ = (epicsFloat32) (base + amplitude);
      for (i=numPoints/2; i<numPoints; i++) *outPtr++ = (epicsFloat32) (base);
      break;
    case waveTypeSawTooth:
      scale = 1./(numPoints-1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (base + amplitude*i*scale);
      break;
    case waveTypePulse:
      nPulse = (int) ((pulseWidth / dwell) + 0.5);
      if (nPulse < 1) nPulse = 1;
      if (nPulse >= numPoints-1) nPulse = numPoints-1;
      for (i=0; i<nPulse; i++)              *outPtr++ = (epicsFloat32) (base + amplitude);
      for (i=nPulse; i<numPoints; i++)      *outPtr++ = (epicsFloat32) (base);
      break;
    case waveTypeRandom:
      scale = amplitude / RAND_MAX;
      srand(1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (base + rand() * scale);
      break;
  }
  doCallbacksFloat32Array(waveGenIntBuffer_[channel], numPoints, waveGenIntWF_, channel);
  return 0;
}

int MultiFunction::startWaveGen()
{
  int status=0;
  int numPoints;
  int enable;
  int firstChan=-1, lastChan=-1, firstType=-1;
  int waveType;
  int extTrigger, extClock, continuous, retrigger;
  int options;
  int i, j, k;
  double offset, scale;
  double userOffset, userAmplitude;
  double dwell;
  epicsFloat32* inPtr[MAX_ANALOG_OUT];
  #ifdef _WIN32
    epicsUInt16 *outPtr;
  #else
    epicsFloat64 *outPtr;
  #endif
  static const char *functionName = "startWaveGen";

  getIntegerParam(waveGenExtTrigger_, &extTrigger);
  getIntegerParam(waveGenExtClock_,   &extClock);
  getIntegerParam(waveGenContinuous_, &continuous);
  getIntegerParam(waveGenRetrigger_,  &retrigger);

  for (i=0; i<numAnalogOut_; i++) {
    getIntegerParam(i, waveGenEnable_, &enable);
    if (!enable) continue;
    getIntegerParam(i, waveGenWaveType_,  &waveType);
    if (waveType == waveTypeUser)
      inPtr[i] = waveGenUserBuffer_[i];
    else
      inPtr[i] = waveGenIntBuffer_[i];
    if (firstChan < 0) {
      firstChan = i;
      firstType = waveType;
    }
    // Cannot mix user-defined and internal waveform types, because internal modifies dwell time
    // based on frequency
    if (((firstType == waveTypeUser) && (waveType != waveTypeUser)) ||
        ((firstType != waveTypeUser) && (waveType == waveTypeUser))) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s:%s: ERROR if any enabled waveform type is user-defined then all must be.\n",
        driverName, functionName);
      return -1;
    }
    lastChan = i;
    status = defineWaveform(i);
    if (status) return -1;
  }

  if (firstChan < 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s:%s: ERROR no enabled channels\n",
      driverName, functionName);
     return -1;
  }

  numWaveGenChans_ = lastChan - firstChan + 1;

  // dwell and numPoints were computed by defineWaveform above
  getIntegerParam(waveGenNumPoints_, &numPoints);
  getDoubleParam(waveGenDwell_, &dwell);
 
  // Copy data from float32 array to outputMemHandel, converting from volts to D/A units
  // Pre-defined waveforms have been fully defined at this point
  // User-defined waveforms need to have the offset and scale applied
  for (i=0; i<numWaveGenChans_; i++) {
    k = firstChan + i;
    outPtr = &(waveGenOutBuffer_[i]);
    offset = 10.;        // Mid-scale range of DAC
    scale = 65535./20.;  // D/A units per volt; 16-bit DAC, +-10V range
    if (waveType == waveTypeUser) {
      getDoubleParam(i, waveGenOffset_, &userOffset);
      getDoubleParam(i, waveGenAmplitude_,  &userAmplitude);
    } else {
      userOffset = 0.;
      userAmplitude = 1.0;
    }
    for (j=0; j<numPoints; j++) {
     *outPtr = (epicsUInt16)((inPtr[k][j]*userAmplitude + userOffset + offset)*scale + 0.5);
      outPtr += numWaveGenChans_;
    }
  }
  ULMutex.lock();
  #ifdef _WIN32
    long pointsPerSecond = (long)((1. / dwell) + 0.5);
    options                  = BACKGROUND;
    if (extTrigger) options |= EXTTRIGGER;
    if (extClock)   options |= EXTCLOCK;
    if (continuous) options |= CONTINUOUS;
    if (retrigger)  options |= RETRIGMODE;
    status = cbAOutScan(boardNum_, firstChan, lastChan, numWaveGenChans_*numPoints, &pointsPerSecond, BIP10VOLTS,
                        waveGenOutBuffer_, options);
    // Convert back from pointsPerSecond to dwell, since value might have changed
    dwell = (1. / pointsPerSecond);
  #else
    options                  = SO_DEFAULTIO;
    if (extTrigger) options |= SO_EXTTRIGGER;
    if (extClock)   options |= SO_EXTCLOCK;
    if (continuous) options |= SO_CONTINUOUS;
    if (retrigger)  options |= SO_RETRIGGER;
    double rate = 1./dwell;
    status = ulAOutScan(daqDeviceHandle_, firstChan, lastChan, BIP10VOLTS, numPoints, &rate, (ScanOption) options, AOUTSCAN_FF_NOSCALEDATA, waveGenOutBuffer_);
    // Convert back from rate to dwell, since value might have changed
    dwell = 1./rate;
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling AOutScan");

  if (status) return status;

  waveGenRunning_ = 1;
  setIntegerParam(waveGenRun_, 1);
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: called cbAOutScan, firstChan=%d, lastChan=%d, numPoints*numWaveGenChans_=%d, dwell=%f, options=0x%x\n",
    driverName, functionName, firstChan, lastChan,  numWaveGenChans_*numPoints, dwell, options);

  setDoubleParam(waveGenDwellActual_, dwell);
  setDoubleParam(waveGenTotalTime_, dwell*numPoints);
  return status;
}

int MultiFunction::stopWaveGen()
{
  int err;
  waveGenRunning_ = 0;
  setIntegerParam(waveGenRun_, 0);
  ULMutex.lock();
  #ifdef _WIN32
    err = cbStopBackground(boardNum_, AOFUNCTION);
  #else
    err = ulAOutScanStop(daqDeviceHandle_);
  #endif
  ULMutex.unlock();
  return err;
}

int MultiFunction::computeWaveGenTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(waveGenUserNumPoints_, &numPoints);
  getDoubleParam(waveGenUserDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveGenUserTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveGenUserTimeBuffer_, numPoints, waveGenUserTimeWF_, 0);

  getIntegerParam(waveGenIntNumPoints_, &numPoints);
  getDoubleParam(waveGenIntDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveGenIntTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveGenIntTimeBuffer_, numPoints, waveGenIntTimeWF_, 0);
  return 0;
}

int MultiFunction::startWaveDig()
{
  int firstChan, lastChan, numChans, numPoints;
  int chan, range;
  short gainArray[MAX_ANALOG_IN], chanArray[MAX_ANALOG_IN];
  int i;
  int extTrigger, extClock, continuous, retrigger, burstMode;
  int status;
  int options;
  double dwell;
  bool invalidScanRate=false;
  static const char *functionName = "startWaveDig";

  getIntegerParam(waveDigNumPoints_,  &numPoints);
  getIntegerParam(waveDigFirstChan_,  &firstChan);
  getIntegerParam(waveDigNumChans_,   &numChans);
  numWaveDigChans_ = numChans;
  getIntegerParam(waveDigExtTrigger_, &extTrigger);
  getIntegerParam(waveDigExtClock_,   &extClock);
  getIntegerParam(waveDigContinuous_, &continuous);
  getIntegerParam(waveDigRetrigger_,  &retrigger);
  getIntegerParam(waveDigBurstMode_,  &burstMode);
  getDoubleParam(waveDigDwell_, &dwell);

  lastChan = firstChan + numChans - 1;
  setIntegerParam(waveDigCurrentPoint_, 0);

  // Construct the gain array
  for (i=0; i<numChans; i++) {
    chan = firstChan + i;
    chanArray[i] = chan;
    getIntegerParam(chan, analogInRange_, &range);
    gainArray[i] = range;
  }
  ULMutex.lock();
  #ifdef _WIN32
    status = cbALoadQueue(boardNum_, chanArray, gainArray, numChans);
  #else
    AiQueueElement *queue = new AiQueueElement[numChans];
    for (int i=0; i<numChans; i++) {
        queue[i].channel = chanArray[i];
        queue[i].inputMode = aiInputMode_ == DIFFERENTIAL ? AI_DIFFERENTIAL : AI_SINGLE_ENDED;
        mapRange(gainArray[i], &queue[i].range);
    }
    status = ulAInLoadQueue(daqDeviceHandle_, queue, numChans);
    delete[] queue;
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling ALoadQueue");
  if (status) return status;

  ULMutex.lock();
  #ifdef _WIN32
    long pointsPerSecond = (long)((1. / dwell) + 0.5);
    options                  = BACKGROUND;
    options                 |= SCALEDATA;
    if (extTrigger) options |= EXTTRIGGER;
    if (extClock)   options |= EXTCLOCK;
    if (continuous) options |= CONTINUOUS;
    if (retrigger)  options |= RETRIGMODE;
    if (burstMode)  options |= BURSTMODE;
    status = cbAInScan(boardNum_, firstChan, lastChan, numWaveDigChans_*numPoints, &pointsPerSecond, BIP10VOLTS,
                       pInBuffer_, options);
    if (status == BADRATE) invalidScanRate = true;
    // Convert back from pointsPerSecond to dwell, since value might have changed
    dwell = (1. / pointsPerSecond);
  #else
    double rate = 1./dwell;
    options                  = SO_DEFAULTIO;
    if (extTrigger) options |= SO_EXTTRIGGER;
    if (extClock)   options |= SO_EXTCLOCK;
    if (continuous) options |= SO_CONTINUOUS;
    if (retrigger)  options |= SO_RETRIGGER;
    if (burstMode)  options |= SO_BURSTMODE;
    // This is equivalent to OPTIONS |= SCALEDATA on Windows
    AInScanFlag flags = AINSCAN_FF_DEFAULT;
    status = ulAInScan(daqDeviceHandle_, firstChan, lastChan, aiInputMode_, BIP10VOLTS, numPoints, &rate, (ScanOption) options, flags, pInBuffer_);
    if (status == ERR_BAD_RATE) invalidScanRate = true;
     // Convert back from rate to dwell, since value might have changed
    dwell = (1. / rate);
  #endif
  ULMutex.unlock();

  if (invalidScanRate) {
    setDoubleParam(waveDigDwellActual_, -9999);
  } else {
    setDoubleParam(waveDigDwellActual_, dwell);
  }

  reportError(status, functionName, "Calling AInScan");
  if (status) return status;

  waveDigRunning_ = 1;
  setIntegerParam(waveDigRun_, 1);
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: called cbAInScan, firstChan=%d, lastChan=%d, numPoints=%d, dwell=%f, options=0x%x\n",
    driverName, functionName, firstChan, lastChan, numPoints, dwell, options);

  setDoubleParam(waveDigTotalTime_, dwell*numPoints);
  return 0;
}

int MultiFunction::stopWaveDig()
{
  int autoRestart;
  int status;
  static const char *functionName = "stopWaveDig";

  waveDigRunning_ = 0;
  setIntegerParam(waveDigRun_, 0);
  readWaveDig();
  getIntegerParam(waveDigAutoRestart_, &autoRestart);
  ULMutex.lock();
  #ifdef _WIN32
    status = cbStopBackground(boardNum_, AIFUNCTION);
  #else
    status = ulAInScanStop(daqDeviceHandle_);
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Stopping AIn scan");
  if (autoRestart)
    status |= startWaveDig();
  return status;
}

int MultiFunction::readWaveDig()
{
  int firstChan, lastChan;
  int currentPoint;
  int i;
  static const char *functionName = "readWaveDig";

  getIntegerParam(waveDigFirstChan_,    &firstChan);
  lastChan = firstChan + numWaveDigChans_ - 1;
  getIntegerParam(waveDigCurrentPoint_, &currentPoint);

  for (i=firstChan; i<=lastChan; i++) {
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
      "%s:%s:, doing callbacks on input %d, first value=%f\n",
      driverName, functionName, i, waveDigBuffer_[i][0]);
    doCallbacksFloat64Array(waveDigBuffer_[i], currentPoint, waveDigVoltWF_, i);
  }
  doCallbacksFloat64Array(waveDigAbsTimeBuffer_, currentPoint, waveDigAbsTimeWF_, 0);
  return 0;
}

int MultiFunction::computeWaveDigTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(waveDigNumPoints_, &numPoints);
  getDoubleParam(waveDigDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveDigTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveDigTimeBuffer_, numPoints, waveDigTimeWF_, 0);
  return 0;
}


asynStatus MultiFunction::getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high)
{
  int function = pasynUser->reason;


  if (function == analogOutValue_) {
    *low = 0;
    *high = (1 << DACResolution_) - 1;
  }
  else if (function == analogInValue_) {
    *low = 0;
    *high = (1 << ADCResolution_) - 1;
  }
  else {
    return(asynError);
  }
  return(asynSuccess);
}

asynStatus MultiFunction::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
  int addr;
  int function = pasynUser->reason;
  int range;
  int status=0;
  static const char *functionName = "writeInt32";

  this->getAddress(pasynUser, &addr);
  setIntegerParam(addr, function, value);

  bool isThermocouple = true;
  if (analogInTypeConfigurable_) {
    int ival;
    getIntegerParam(addr, analogInType_, &ival);
    if (ival != AI_CHAN_TYPE_TC) isThermocouple = false;
  }

  ULMutex.lock();
  // Analog input functions
  if (function == analogInType_ && analogInTypeConfigurable_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIADCHANTYPE, value);
      // It seems to be necessary to reprogram the thermocouple type when switching from volts to TC
    #else
      long long configValue = (value == AI_CHAN_TYPE_VOLTAGE) ? AI_VOLTAGE : AI_TC;
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TYPE, addr, configValue);
    #endif
    reportError(status, functionName, "Setting analog input type");
    // It seems to be necessary to reprogram the thermocouple type when switching from volts to TC
    if (value == AI_CHAN_TYPE_TC) {
      int ival;
      // Set the TC type.  Note that the enums for thermocouple types are the same on Windows and Linux
      getIntegerParam(addr, thermocoupleType_, &ival);
      #ifdef _WIN32
        status = cbSetConfig(BOARDINFO, boardNum_, addr, BICHANTCTYPE, ival);
      #else
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TC_TYPE, addr, ival);
      #endif
      reportError(status, functionName, "Set thermocouple type");
      // Set open thermocouple detection
      getIntegerParam(addr, thermocoupleOpenDetect_, &ival);
      setOpenThermocoupleDetect(addr, ival);
    }
  }

  // Analog output functions
  if ((function == analogOutRange_) && analogOutRangeConfigurable_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIDACRANGE, value);
    #else
      // No function to immediately set it on Linux, this value is read from parameter library when calling ulAOut
    #endif
    reportError(status, functionName, "Setting analog out range");
  }

  else if (function == analogInMode_) {
    #ifdef _WIN32
      status = cbAInputMode(boardNum_, value);
    #else
      aiInputMode_ = (value == DIFFERENTIAL) ? AI_DIFFERENTIAL : AI_SINGLE_ENDED;
    #endif
    reportError(status, functionName, "Setting analog input mode");
  }

  else if ((function == analogInRate_) && analogInDataRateConfigurable_) {
    #ifdef _WIN32 
        status = cbSetConfig(BOARDINFO, boardNum_, addr, BIADDATARATE, value);
    #else
        status = ulAISetConfigDbl(daqDeviceHandle_, AI_CFG_CHAN_DATA_RATE, addr, value);
    #endif
    reportError(status, functionName, "Setting data rate");
  }

  else if ((function == thermocoupleType_) && isThermocouple) {
    // NOTE:
    // This sleep is a hack to get it working on the TC-32.  Without it the call to cbSetConfig()
    // will often hang if more than 6 channels are being configured.
    // This makes no sense.  The problem cannot be reproduced in the testTC32.c test application
    if (boardFamily_ == USB_TC32) epicsThreadSleep(0.01);
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BICHANTCTYPE, value);
    #else
      // The enums for thermocouple types are the same on Windows and Linux
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TC_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting thermocouple type");
  }

  else if ((function == thermocoupleOpenDetect_) && isThermocouple) {
    setOpenThermocoupleDetect(addr, value);
  }

  else if (function == temperatureSensor_) {
    #ifdef _WIN32 
      // Sensor cannot be configured on UL for Windows
      status = NOERRORS;
    #else
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting temperature sensor");
  }

  else if (function == temperatureWiring_) {
    #ifdef _WIN32
      // Wiring cannot be configured on UL for Windows
      status = NOERRORS;
    #else
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_SENSOR_CONNECTION_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting temperature wiring");
  }

  // Pulse generator functions
  else if (function == pulseGenRun_) {
    // Allow starting a run even if it thinks its running,
    // since there is no way to know when it got done if Count!=0
    if (value) {
      status = startPulseGenerator(addr);
    }
    else if (!value && pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
    }
  }
  else if ((function == pulseGenCount_) ||
           (function == pulseGenIdleState_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Counter functions
  else if (function == counterReset_) {
    #ifdef _WIN32
      // LOADREG0=0, LOADREG1=1, so we use addr
      status = cbCLoad32(boardNum_, addr, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, addr, CRT_LOAD, 0);
    #endif
    reportError(status, functionName, "Resetting counter");
  }

  // Trigger functions
  else if (function == triggerMode_) {
    #ifdef _WIN32
      status = cbSetTrigger(boardNum_, value, 0, 0);
    #else
      // In uldaq there are separate calls for ulDaqInSetTrigger, ulDaqOutSetTrigger, etc.
      // We just cache the information here and then call those functions when starting the appropriate scan
      status = mapTriggerType(value, &triggerType_);
    #endif
    reportError(status, functionName, "Setting trigger mode");
  }

  // Waveform digitizer functions
  else if (function == waveDigRun_) {
    if (value && !waveDigRunning_)
      status = startWaveDig();
    else if (!value && waveDigRunning_)
      status = stopWaveDig();
  }

  else if (function == waveDigReadWF_) {
    readWaveDig();
  }

  else if (function == waveDigNumPoints_) {
    if (value > (int)maxInputPoints_) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                "%s::%s error WaveDigNumPoints=%d must be less than MaxInputPoints=%d\n",
                driverName, functionName, value, (int)maxInputPoints_);
      setIntegerParam(waveDigNumPoints_, maxInputPoints_);
    }
    computeWaveDigTimes();
  }

  else if (function == waveDigTriggerCount_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, 0, BIADTRIGCOUNT, value);
    #else
      aiScanTrigCount_ = value;
    #endif
    reportError(status, functionName, "Setting waveDig trigger count");
  }

  // Analog output functions
  else if (function == analogOutValue_) {
    if (waveGenRunning_) {
      reportError(-1, functionName, "cannot write analog outputs while waveform generator is running.");
      ULMutex.unlock();
      return asynError;
    }
    status = getIntegerParam(addr, analogOutRange_, &range);

    #ifdef _WIN32
      status = cbAOut(boardNum_, addr, range, value);
    #else
      Range ulRange;
      mapRange(range, &ulRange);
      status = ulAOut(daqDeviceHandle_, addr, ulRange, AOUT_FF_NOSCALEDATA, (double) value);
    #endif
    reportError(status, functionName, "calling AOut");
  }

  // Waveform generator functions
  else if (function == waveGenRun_) {
    if (value && !waveGenRunning_)
      status = startWaveGen();
    else if (!value && waveGenRunning_)
      status = stopWaveGen();
  }

  else if ((function == waveGenWaveType_) ||
      (function == waveGenUserNumPoints_) ||
      (function == waveGenIntNumPoints_)  ||
      (function == waveGenEnable_)        ||
      (function == waveGenExtTrigger_)    ||
      (function == waveGenExtClock_)      ||
      (function == waveGenContinuous_)) {
    defineWaveform(addr);
    if (waveGenRunning_) {
      status = stopWaveGen();
      status |= startWaveGen();
    }
  }

  else if (function == waveGenTriggerCount_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, 0, BIDACTRIGCOUNT, value);
    #else
      aoScanTrigCount_ = value;
    #endif
    reportError(status, functionName, "Setting waveGen trigger count");
  }
  ULMutex.unlock();

  // This is a separate if statement because these cases are also treated above
  if ((function == waveGenUserNumPoints_) ||
      (function == waveGenIntNumPoints_)) {
    computeWaveGenTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %d to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, function=%d, ERROR writing %d to address %d, status=%d\n",
             driverName, functionName, this->portName, function, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

int MultiFunction::setOpenThermocoupleDetect(int addr, int value)
{
  int status=0;
  static const char *functionName = "setOpenThermocoupleDetect";

  if ((boardFamily_ != USB_TEMP) && (boardFamily_ != USB_TEMP_AI)) {
    ULMutex.lock();
    #ifdef _WIN32 
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIDETECTOPENTC, value);
    #else
      OtdMode mode = value ? OTD_ENABLED : OTD_DISABLED;
      // TC-32 and E-TC can only change open thermocouple detect for the entire device, not per-channel
      if (boardFamily_ == USB_TC32 || boardFamily_ == E_TC ) {
        int dev = 0;
        if (addr >= 32) dev = 1;
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_OTD_MODE, dev, mode);
      } else { 
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_OTD_MODE, addr, mode);
      }
    #endif
    ULMutex.unlock();
    reportError(status, functionName, "Setting thermocouple open detect mode");
  }
  return status;
}

asynStatus MultiFunction::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  static const char *functionName = "writeFloat64";

  this->getAddress(pasynUser, &addr);
  setDoubleParam(addr, function, value);

  // Pulse generator functions
  if ((function == pulseGenPeriod_)    ||
      (function == pulseGenDutyCycle_) ||
      (function == pulseGenDelay_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Waveform generator functions
  else if ((function == waveGenUserDwell_)  ||
           (function == waveGenIntDwell_)   ||
           (function == waveGenPulseWidth_) ||
           (function == waveGenAmplitude_)  ||
           (function == waveGenOffset_)) {
    defineWaveform(addr);
    if (waveGenRunning_) {
      status = stopWaveGen();
      status |= startWaveGen();
    }
  }

  // Waveform digitizer functions
  else if (function == waveDigDwell_) {
    computeWaveDigTimes();
  }

  // This is a separate if statement because these cases are also treated above
  if ((function == waveGenUserDwell_)  ||
      (function == waveGenIntDwell_)) {
    computeWaveGenTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %f to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing %f to address %d, status=%d\n",
             driverName, functionName, this->portName, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  int type;
  int scale;
  int filter=0;
  int range;
  static const char *functionName = "readFloat64";

  this->getAddress(pasynUser, &addr);

  // Temperature input function
  if (function == temperatureInValue_) {
    if (waveDigRunning_) {
      int currentPoint;
      getIntegerParam(waveDigCurrentPoint_, &currentPoint);
      if (currentPoint > 0) {
        *value = waveDigBuffer_[addr][currentPoint-1];
      }
    }
    else {
      getIntegerParam(addr, analogInType_, &type);
      getIntegerParam(addr, temperatureScale_, &scale);
      getIntegerParam(addr, temperatureFilter_, &filter);
      if (type != AI_CHAN_TYPE_TC) return asynSuccess;
      ULMutex.lock();
      #ifdef _WIN32
        float fVal;
        status = cbTIn(boardNum_, addr, scale, &fVal, filter);
        if (status == OPENCONNECTION) {
          // This is an "expected" error if the thermocouple is broken or disconnected
          // Don't print error message, just set temp to -9999.
          fVal = -9999.;
          status = 0;
          *value = (double) fVal;
        }
        *value = (double) fVal;
      #else
        TempScale tempScale;
        // cbTin has a filter option but ulTin does not?
        TInFlag flags = TIN_FF_DEFAULT;
        switch (scale) {
            case CELSIUS:     tempScale = TS_CELSIUS; break;
            case FAHRENHEIT:  tempScale = TS_FAHRENHEIT; break;
            case KELVIN:      tempScale = TS_KELVIN; break;
            case VOLTS:       tempScale = TS_VOLTS; break;
            case NOSCALE:     tempScale = TS_NOSCALE; break;
            default:
                asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s unsupported Scale=%d\n", driverName, functionName, scale);
                tempScale = TS_CELSIUS;
        }
        status = ulTIn(daqDeviceHandle_, addr, tempScale, flags, value);
        if (status == ERR_OPEN_CONNECTION) {
          // This is an "expected" error if the thermocouple is broken or disconnected
          // Don't print error message, just set temp to -9999.
          status = 0;
          *value = -9999.;
        }
      #endif
      ULMutex.unlock();
    }
    setDoubleParam(addr, temperatureInValue_, *value);
    reportError(status, functionName, "Calling TIn");
  }
  else if (function == voltageInValue_) {
    getIntegerParam(addr, voltageInRange_, &range);
    ULMutex.lock();
    #ifdef _WIN32
      float fVal;
      status = cbVIn(boardNum_, addr, range, &fVal, 0);
      *value = fVal;
    #else
      double data;
      Range ulRange;
      mapRange(range, &ulRange);
      int chan = addr;
      if (boardFamily_ == USB_TEMP_AI) {
        // On Linux the address needs to be 4 larger
        chan = addr + 4;
      }
      status = ulAIn(daqDeviceHandle_, chan, aiInputMode_, ulRange, AIN_FF_DEFAULT, &data);
      *value = (float) data;
    #endif
    ULMutex.unlock();
    reportError(status, functionName, "Calling AIn");
    setDoubleParam(addr, voltageInValue_, *value);
  }

  // Other functions we call the base class method
  else {
     status = asynPortDriver::readFloat64(pasynUser, value);
  }

  callParamCallbacks(addr);
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
  int function = pasynUser->reason;
  int status=0;
  int i;
  int addr;
  epicsUInt32 direction=0;
  static const char *functionName = "writeUInt32Digital";

  this->getAddress(pasynUser, &addr);
  setUIntDigitalParam(addr, function, value, mask);
  ULMutex.lock();
  if (function == digitalDirection_) {
    if (digitalIOPortConfigurable_[addr]) {
      #ifdef _WIN32
        int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
        status = cbDConfigPort(boardNum_, digitalIOPort_[addr], dir);
      #else
        DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
        status = ulDConfigPort(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], dir);
      #endif
      reportError(status, functionName, "Calling ConfigPort");
      direction = value ? 0xFFFF : 0;
      setUIntDigitalParam(0, digitalDirection_, direction, 0xFFFFFFFF);
    }
    else {
      for (i=0; i<numIOBits_[addr]; i++) {
        if ((mask & (1<<i)) != 0) {
          if (digitalIOBitConfigurable_[addr]) {
            #ifdef _WIN32
              int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
              status = cbDConfigBit(boardNum_, digitalIOPort_[addr], i, dir);
            #else
             DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
             status = ulDConfigBit(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, dir);
            #endif
            reportError(status, functionName, "Calling ConfigBit");
          }
          else {
            // Cannot program direction.  Set open collector output to 0.
            #ifdef _WIN32
              status = cbDBitOut(boardNum_, digitalIOPort_[addr], i, 0);
            #else
              status = ulDBitOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, 0);
            #endif
            reportError(status, functionName, "Calling BitOut");
          }
        }
      }
    }
  }

  else if (function == digitalOutput_) {
    getUIntDigitalParam(addr, digitalDirection_, &direction, 0xFFFFFFFF);
    if ((mask & direction) == digitalIOMask_[addr]) {
      // Use word I/O if all bits are outputs and we are writing all bits
      #ifdef _WIN32
        if (numIOBits_[addr] > 16) {
          status = cbDOut32(boardNum_, digitalIOPort_[addr], value & mask);
        } else {
          status = cbDOut(boardNum_, digitalIOPort_[addr], value & mask);
        }
      #else
        status = ulDOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], value & mask);
      #endif
      reportError(status, functionName, "Calling DOut");
    }
    else {
      // Use bit I/O if we are not writing all bits
      epicsUInt32 outMask, outValue;
      for (i=0, outMask=1; i<numIOBits_[addr]; i++, outMask = (outMask<<1)) {
        // Only write the value if the mask has this bit set and the direction for that bit is output (1)
        outValue = ((value & outMask) == 0) ? 0 : 1;
        if ((mask & outMask & direction) != 0) {
          #ifdef _WIN32
            status = cbDBitOut(boardNum_, digitalIOPort_[addr], i, outValue);
          #else
            status = ulDBitOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, outValue);
          #endif
          reportError(status, functionName, "Calling DBitOut");
        }
      }
    }
  }
  ULMutex.unlock();

  callParamCallbacks();
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, function=%d, wrote value=0x%x, mask=0x%x, direction=0x%x\n",
             driverName, functionName, this->portName, function, value, mask, direction);
  } 
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat32 *inPtr;
  static const char *functionName = "readFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (addr >= numAnalogOut_) {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: addr=%d max=%d\n",
      driverName, functionName, addr, numAnalogOut_-1);
    return asynError;
  }
  // Assume WaveGen function, WaveDig numPoints handled below
  getIntegerParam(waveGenNumPoints_, &numPoints);
  if (function == waveGenUserWF_)
    inPtr = waveGenUserBuffer_[addr];
  else if (function == waveGenIntWF_)
    inPtr = waveGenIntBuffer_[addr];
  else if (function == waveGenUserTimeWF_)
    inPtr = waveGenUserTimeBuffer_;
  else if (function == waveGenIntTimeWF_)
    inPtr = waveGenIntTimeBuffer_;
  else if (function == waveDigTimeWF_) {
    inPtr = waveDigTimeBuffer_;
    getIntegerParam(waveDigNumPoints_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat32));

  return asynSuccess;
}

asynStatus MultiFunction::readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat64 *inPtr;
  static const char *functionName = "readFloat64Array";

  this->getAddress(pasynUser, &addr);

  if (function == waveDigVoltWF_) {
    if (addr >= numAnalogIn_) {
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
        "%s:%s: ERROR: addr=%d max=%d\n",
        driverName, functionName, addr, numAnalogIn_-1);
      return asynError;
    }
    inPtr = waveDigBuffer_[addr];
  }
  else if (function == waveDigAbsTimeWF_) {
    inPtr = waveDigAbsTimeBuffer_;
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  getIntegerParam(waveDigNumPoints_, &numPoints);
  if (*nIn > (size_t)numPoints) *nIn = numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat64));
  return asynSuccess;
}

asynStatus MultiFunction::writeFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements)
{
  int function = pasynUser->reason;
  int addr;
  static const char *functionName = "writeFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (function == waveGenUserWF_) {
    if ((addr >= numAnalogOut_) || (nElements > maxOutputPoints_)) {
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
        "%s:%s: ERROR: addr=%d max=%d, nElements=%d max=%d\n",
        driverName, functionName, addr, numAnalogOut_-1, (int)nElements, (int)maxOutputPoints_);
      return asynError;
    }
    memcpy(waveGenUserBuffer_[addr], value, nElements*sizeof(epicsFloat32));
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }

  return asynSuccess;
}

asynStatus MultiFunction::readEnum(asynUser *pasynUser, char *strings[], int values[], int severities[], size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int i;
  const enumStruct_t *pEnum;
  int numEnums;
  //static const char *functionName = "readEnum";

  if (function == analogInRange_) {
    pEnum    = pBoardEnums_->pInputRange;
    numEnums = pBoardEnums_->numInputRange;
  }
  else if (function == voltageInRange_) {
    pEnum    = pBoardEnums_->pInputRange;
    numEnums = pBoardEnums_->numInputRange;
  }
  else if (function == analogOutRange_) {
    pEnum    = pBoardEnums_->pOutputRange;
    numEnums = pBoardEnums_->numOutputRange;
  }
  else if (function == analogInType_) {
    pEnum    = pBoardEnums_->pInputType;
    numEnums = pBoardEnums_->numInputType;
  }
  else if (function == temperatureSensor_) {
    pEnum    = temperatureSensorUSB_TEMP;
    numEnums = sizeof(temperatureSensorUSB_TEMP)/sizeof(enumStruct_t);
  }
  else if (function == temperatureWiring_) {
    pEnum    = temperatureWiringUSB_TEMP;
    numEnums = sizeof(temperatureWiringUSB_TEMP)/sizeof(enumStruct_t);
  }
  else {
      *nIn = 0;
      return asynError;
  }
  for (i=0; ((i<numEnums) && (i<(int)nElements)); i++) {
    if (strings[i]) free(strings[i]);
    strings[i] = epicsStrDup(pEnum[i].enumString);
    values[i] = pEnum[i].enumValue;
    severities[i] = 0;
  }
  *nIn = i;
  return asynSuccess;
}

void MultiFunction::pollerThread()
{
  /* This function runs in a separate thread.  It waits for the poll
   * time */
  static const char *functionName = "pollerThread";
  epicsUInt32 newValue, changedBits, prevInput[MAX_IO_PORTS]={0};
  int i;
  int currentPoint;
  epicsUInt32 countVal;
  long aoCount, aoIndex, aiCount, aiIndex;
  short aoStatus, aiStatus;
  epicsTime startTime=epicsTime::getCurrent(), endTime, currentTime;
  int lastPoint;
  int status=0, prevStatus=0;

  while(1) {
    lock();
    ULMutex.lock();
    endTime = epicsTime::getCurrent();
    setDoubleParam(pollTimeMS_, (endTime-startTime)*1000.);
    startTime = epicsTime::getCurrent();

    // Read the digital inputs
    for (i=0; i<numIOPorts_; i++) {
      if (digitalIOPortWriteOnly_[i]) continue;
      #ifdef _WIN32
        epicsUInt16 biVal16;
        if (numIOBits_[i] > 16) {
          status = cbDIn32(boardNum_, digitalIOPort_[i], &newValue);
        } else {
          status = cbDIn(boardNum_, digitalIOPort_[i], &biVal16);
          newValue = biVal16;
        }
      #else
        unsigned long long data;
        status = ulDIn(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[i], &data);
        newValue = (epicsUInt32) data;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling DIn");
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR, "portNumber=%d\n", i);
        }
        goto error;
      }
      changedBits = newValue ^ prevInput[i];
      if (forceCallback_[i] || (changedBits != 0)) {
        prevInput[i] = newValue;
        forceCallback_[i] = 0;
        setUIntDigitalParam(i, digitalInput_, newValue, 0xFFFFFFFF);
      }
    }

    // Read the counter inputs
    for (i=0; i<numCounters_; i++) {
      #ifdef _WIN32
        ULONG data;
        status = cbCIn32(boardNum_, firstCounter_ + i, &data);
        countVal = (epicsUInt32)data;
      #else
        unsigned long long data;
        status = ulCIn(daqDeviceHandle_, firstCounter_ + i, &data);
        countVal = (epicsUInt32)data;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling CIn");
        }
        goto error;
      }
      setIntegerParam(i, counterCounts_, countVal);
    }

    if (waveGenRunning_) {
      // Poll the status of the waveform generator output
      #ifdef _WIN32
        status = cbGetIOStatus(boardNum_, &aoStatus, &aoCount, &aoIndex, AOFUNCTION);
      #else
        ScanStatus scanStatus;
        TransferStatus xferStatus;
        status = ulAOutScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
        aoStatus = scanStatus;
        aoCount = xferStatus.currentTotalCount;
        aoIndex = xferStatus.currentIndex;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling AOutScanStatus");
        }
        goto error;
      } else {
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
          "%s::%s waveform generator status, aoStatus=%d, aoCount=%ld, aoIndex=%ld\n",
          driverName, functionName, aoStatus, aoCount, aoIndex);
      }
      currentPoint = (aoIndex / numWaveGenChans_) + 1;
      setIntegerParam(waveGenCurrentPoint_, currentPoint);
      if (aoStatus == 0) {
        stopWaveGen();
      }
    }

    if (waveDigRunning_) {
      // Poll the status of the waveform digitizer input
      #ifdef _WIN32
        status = cbGetIOStatus(boardNum_, &aiStatus, &aiCount, &aiIndex, AIFUNCTION);
      #else
        ScanStatus scanStatus;
        TransferStatus xferStatus;
        status = ulAInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
        aiStatus = scanStatus;
        aiCount = xferStatus.currentTotalCount;
        aiIndex = xferStatus.currentIndex;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling AInScanStatus");
        }
        #ifdef _WIN32
          // On Windows after a network glitch cbGetIOStatus will return continually return DEADDEV
          // Need to stop and start the waveform digitizer if it was running
          if (status == DEADDEV) {
            stopWaveDig();
            startWaveDig();
          }
          goto error;
        #endif
      } else {
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
          "%s::%s waveform digitizer status, aiStatus=%d, aiCount=%ld, aiIndex=%ld\n",
          driverName, functionName, aiStatus, aiCount, aiIndex);
      }
      getIntegerParam(waveDigCurrentPoint_, &currentPoint);
      lastPoint = aiIndex / numWaveDigChans_ + 1;
      if (lastPoint > currentPoint) {
        currentTime = epicsTime::getCurrent();
        epicsTimeStamp now = (epicsTimeStamp)currentTime;
        int firstChan;
        getIntegerParam(waveDigFirstChan_, &firstChan);
        int lastChan = firstChan + numWaveDigChans_ - 1;
        epicsFloat64 *pAnalogIn = pInBuffer_ + currentPoint*numWaveDigChans_;
        for(; currentPoint < lastPoint; currentPoint++) {
          for (int j=firstChan; j<=lastChan; j++) {
            waveDigBuffer_[j][currentPoint] = *pAnalogIn++;
          }
          waveDigAbsTimeBuffer_[currentPoint] = now.secPastEpoch + now.nsec/1.e9;
        }
        setIntegerParam(waveDigCurrentPoint_, currentPoint);
      }
      if (aiStatus == 0) {
        stopWaveDig();
      }
    } else {
      // If the waveform digitizer is not running then read the analog inputs
      int range, type, mode;
      epicsInt32 value;
      getIntegerParam(0, analogInMode_, &mode);
      for (i=0; i<numAnalogIn_; i++) {
        getIntegerParam(i, analogInRange_, &range);
        getIntegerParam(i, analogInType_, &type);
        if (type != AI_CHAN_TYPE_VOLTAGE) continue;
        if ((boardType_ == E_1608) && (mode == DIFFERENTIAL) && (i>3)) break;
        #ifdef _WIN32
          if (ADCResolution_ <= 16) {
            epicsUInt16 shortVal;
            status = cbAIn(boardNum_, i, range, &shortVal);
            value = shortVal;
          } else {
            ULONG ulongVal;
            status = cbAIn32(boardNum_, i, range, &ulongVal, 0);
            value = (epicsInt32)ulongVal;
          }
        #else
          double data;
          Range ulRange;
          mapRange(range, &ulRange);
          status = ulAIn(daqDeviceHandle_, i, aiInputMode_, ulRange, AIN_FF_NOSCALEDATA, &data);
          value = (epicsInt32) data;
        #endif
        setIntegerParam(i, analogInValue_, value);
      }
    }

    for (i=0; i<MAX_SIGNALS; i++) {
      callParamCallbacks(i);
    }
error:
    if (prevStatus && !status) {
      reportError(-1, functionName, "Device returned to normal status");
    }
    prevStatus = status;
    double pollTime;
    getDoubleParam(pollSleepMS_, &pollTime);
    ULMutex.unlock();
    unlock();
    epicsThreadSleep(pollTime/1000.);
  }
}

/* Report  parameters */
void MultiFunction::report(FILE *fp, int details)
{
  int i;
  int counts;

  asynPortDriver::report(fp, details);
  fprintf(fp, "  Port: %s, board ID=%d, board type=%s\n",
          this->portName, boardType_, boardName_);
  if (details >= 1) {
    fprintf(fp, "  analog inputs      = %d\n", numAnalogIn_);
    fprintf(fp, "  analog input bits  = %d\n", ADCResolution_);
    fprintf(fp, "  analog outputs     = %d\n", numAnalogOut_);
    fprintf(fp, "  analog output bits = %d\n", DACResolution_);
    fprintf(fp, "  temperature inputs = %d\n", numTempChans_);
    fprintf(fp, "  digital I/O ports  = %d\n", numIOPorts_);
    for (i=0; i<numIOPorts_; i++) {
      fprintf(fp, "  digital I/O port     %d\n", i);
      fprintf(fp, "    I/O port              = %d\n", digitalIOPort_[i]);
      fprintf(fp, "    I/O bits              = %d\n", numIOBits_[i]);
      fprintf(fp, "    I/O bit configurable  = %d\n", digitalIOBitConfigurable_[i]);
      fprintf(fp, "    I/O port configurable = %d\n", digitalIOPortConfigurable_[i]);
      fprintf(fp, "    I/O port read only    = %d\n", digitalIOPortReadOnly_[i]);
      fprintf(fp, "    I/O port write only   = %d\n", digitalIOPortWriteOnly_[i]);
      fprintf(fp, "    I/O port mask         = 0x%x\n", digitalIOMask_[i]);
    }
    fprintf(fp, "  timers             = %d\n", numTimers_);
    if (numTimers_ > 0) {
      fprintf(fp, "  pulse generator\n");
      fprintf(fp, "    frequency range  = %f : %f\n", minPulseGenFrequency_, maxPulseGenFrequency_);
      fprintf(fp, "    delay range      = %f : %f\n", minPulseGenDelay_, maxPulseGenDelay_);
    }
    fprintf(fp, "  # counters         = %d", numCounters_);
    fprintf(fp, "  first counter      = %d", firstCounter_);
    fprintf(fp, "  counterCounts = ");
    for (i=0; i<numCounters_; i++) {
      getIntegerParam(i, counterCounts_, &counts);
      fprintf(fp, " %d", counts);
    }
    fprintf(fp, "\n");
  }
}

/** Configuration command, called directly or from iocsh */
extern "C" int MultiFunctionConfig(const char *portName, const char *uniqueID,
                              int maxInputPoints, int maxOutputPoints)
{
  new MultiFunction(portName, uniqueID, maxInputPoints, maxOutputPoints);
  return asynSuccess;
}


static const iocshArg configArg0 = { "Port name",      iocshArgString};
static const iocshArg configArg1 = { "UniqueID",       iocshArgString};
static const iocshArg configArg2 = { "Max. input points", iocshArgInt};
static const iocshArg configArg3 = { "Max. output points",iocshArgInt};
static const iocshArg * const configArgs[] = {&configArg0,
                                              &configArg1,
                                              &configArg2,
                                              &configArg3};
static const iocshFuncDef configFuncDef = {"MultiFunctionConfig",4,configArgs};
static void configCallFunc(const iocshArgBuf *args)
{
  MultiFunctionConfig(args[0].sval, args[1].sval, args[2].ival, args[3].ival);
}


static const iocshFuncDef showDevicesFuncDef = {"measCompShowDevices",0,0};
static void showDevicesCallFunc(const iocshArgBuf *args)
{
  measCompShowDevices();
}

void drvMultiFunctionRegister(void)
{
  iocshRegister(&configFuncDef,configCallFunc);
  iocshRegister(&showDevicesFuncDef,showDevicesCallFunc);
}


extern "C" {
epicsExportRegistrar(drvMultiFunctionRegister);
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/src/thresholdLogicSupport.dbd
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.dbd)]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/Makefile
=================================================
TOP=../..

include $(TOP)/configure/CONFIG
#----------------------------------------
# Build the IOC application


PROD_IOC = USB1608G_2AO_V2
# USB1608G_2AO_V2.dbd will be created and installed
DBD += USB1608G_2AO_V2.dbd


# USB1608G_2AO_V2.dbd will be made up from these files:
USB1608G_2AO_V2_DBD += base.dbd
USB1608G_2AO_V2_DBD += measCompApp.dbd
USB1608G_2AO_V2_DBD += measCompSupport.dbd
USB1608G_2AO_V2_DBD += thresholdLogicSupport.dbd


# Include dbd files from all support applications:
#USB1608G_2AO_V2_DBD += xxx.dbd

# Add all the support libraries needed by this IOC
#USB1608G_2AO_V2_LIBS += xxx

# #USB1608G_2AO_V2_registerRecordDeviceDriver.cpp derives from #USB1608G_2AO_V2.dbd
USB1608G_2AO_V2_SRCS += USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
USB1608G_2AO_V2_SRCS += drvMultiFunction.cpp
USB1608G_2AO_V2_SRCS += drvUSBCTR.cpp
USB1608G_2AO_V2_SRCS += measCompDiscover.cpp
USB1608G_2AO_V2_SRCS += ThresholdLogicController.cpp
USB1608G_2AO_V2_SRCS += ErrorHandler.cpp
USB1608G_2AO_V2_SRCS += USBCTR_SNL.st


# Build the main IOC entry point on workstation OSs.
USB1608G_2AO_V2_SRCS_DEFAULT += USB1608G_2AO_V2Main.cpp
USB1608G_2AO_V2_SRCS_vxWorks += -nil-

# Add support from base/src/vxWorks if needed
#USB1608G_2AO_V2_OBJS_vxWorks += $(EPICS_BASE_BIN)/vxComLibrary

# Finally link to the EPICS Base libraries
USB1608G_2AO_V2_LIBS += $(EPICS_BASE_IOC_LIBS)
USB1608G_2AO_V2_LIBS += measComp
USB1608G_2AO_V2_LIBS += scaler
USB1608G_2AO_V2_LIBS += busy
USB1608G_2AO_V2_LIBS += calc
USB1608G_2AO_V2_LIBS += mca
USB1608G_2AO_V2_LIBS += sscan
USB1608G_2AO_V2_LIBS += autosave
USB1608G_2AO_V2_LIBS += asyn
USB1608G_2AO_V2_LIBS += seq pv

USB1608G_2AO_V2_SYS_LIBS_Linux += uldaq
USB1608G_2AO_V2_SYS_LIBS_Linux += usb-1.0
#===========================

include $(TOP)/configure/RULES
#----------------------------------------
#  ADD RULES AFTER THIS LINE











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/ErrorHandler.cpp
=================================================
/* ErrorHandler.cpp
 *
 * ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¡œê¹…ì„ ìœ„í•œ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ êµ¬í˜„
 * 
 * ì´ í´ë˜ìŠ¤ëŠ” EPICS IOC ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ë°œìƒí•˜ëŠ” ë‹¤ì–‘í•œ ì˜¤ë¥˜ë¥¼ 
 * ë¶„ë¥˜í•˜ê³  ë¡œê¹…í•˜ë©°, EPICS ì•ŒëŒ ì‹œìŠ¤í…œê³¼ í†µí•©í•˜ì—¬ ìƒíƒœë¥¼ ë³´ê³ í•©ë‹ˆë‹¤.
 *
 * Author: EPICS IOC Development Guide
 * Date: 2025
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include <epicsTime.h>
#include <epicsString.h>
#include <epicsThread.h>
#include <epicsMutex.h>
#include <asynDriver.h>

#include "ErrorHandler.h"

// ì •ì  ë©¤ë²„ ë³€ìˆ˜ ì´ˆê¸°í™”
int ErrorHandler::infoCount_ = 0;
int ErrorHandler::warningCount_ = 0;
int ErrorHandler::errorCount_ = 0;
int ErrorHandler::fatalCount_ = 0;

// ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì„ ìœ„í•œ ë®¤í…ìŠ¤
static epicsMutexId errorStatsMutex = NULL;

// ë®¤í…ìŠ¤ ì´ˆê¸°í™” (í•œ ë²ˆë§Œ ì‹¤í–‰)
static void initializeMutex() {
    if (errorStatsMutex == NULL) {
        errorStatsMutex = epicsMutexCreate();
    }
}

/** ì˜¤ë¥˜ ë¡œê¹… ë©”ì„œë“œ */
void ErrorHandler::logError(ErrorLevel level, const char* source, const char* message, 
                           asynUser* pasynUser)
{
    if (source == NULL || message == NULL) {
        printf("ErrorHandler::logError: NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨\n");
        return;
    }
    
    // ë®¤í…ìŠ¤ ì´ˆê¸°í™” í™•ì¸
    initializeMutex();
    
    // í†µê³„ ì—…ë°ì´íŠ¸ (ìŠ¤ë ˆë“œ ì•ˆì „)
    epicsMutexLock(errorStatsMutex);
    switch (level) {
        case INFO:    infoCount_++;    break;
        case WARNING: warningCount_++; break;
        case ERROR:   errorCount_++;   break;
        case FATAL:   fatalCount_++;   break;
    }
    epicsMutexUnlock(errorStatsMutex);
    
    // ë‚´ë¶€ ë¡œê¹… í˜¸ì¶œ
    internalLog(level, source, message, pasynUser);
}

/** ìƒì„¸ ì˜¤ë¥˜ ë¡œê¹… ë©”ì„œë“œ */
void ErrorHandler::logDetailedError(ErrorLevel level, const char* source, const char* message,
                                   const char* details, int errorCode, asynUser* pasynUser)
{
    if (source == NULL || message == NULL) {
        printf("ErrorHandler::logDetailedError: NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨\n");
        return;
    }
    
    // ìƒì„¸ ë©”ì‹œì§€ êµ¬ì„±
    char detailedMessage[512];
    if (details != NULL && strlen(details) > 0) {
        snprintf(detailedMessage, sizeof(detailedMessage), 
                "%s [ìƒì„¸: %s] [ì˜¤ë¥˜ì½”ë“œ: %d]", message, details, errorCode);
    } else {
        snprintf(detailedMessage, sizeof(detailedMessage), 
                "%s [ì˜¤ë¥˜ì½”ë“œ: %d]", message, errorCode);
    }
    
    // ì¼ë°˜ ë¡œê¹… ë©”ì„œë“œ í˜¸ì¶œ
    logError(level, source, detailedMessage, pasynUser);
}

/** EPICS ì•ŒëŒ ìƒíƒœ ì„¤ì • */
asynStatus ErrorHandler::setAlarmStatus(asynUser* pasynUser, AlarmStatus status, AlarmSeverity severity)
{
    if (pasynUser == NULL) {
        logError(ERROR, "ErrorHandler::setAlarmStatus", "NULL asynUser í¬ì¸í„°");
        return asynError;
    }
    
    // EPICS ì•ŒëŒ ì„¤ì • (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” asynPortDriverì˜ setParamAlarmStatus ì‚¬ìš©)
    // ì—¬ê¸°ì„œëŠ” ë¡œê¹…ë§Œ ìˆ˜í–‰
    char alarmMessage[256];
    snprintf(alarmMessage, sizeof(alarmMessage),
            "ì•ŒëŒ ì„¤ì • - ìƒíƒœ: %s, ì‹¬ê°ë„: %s",
            alarmStatusToString(status), alarmSeverityToString(severity));
    
    ErrorLevel logLevel = INFO;
    switch (severity) {
        case NO_ALARM:      logLevel = INFO;    break;
        case MINOR_ALARM:   logLevel = WARNING; break;
        case MAJOR_ALARM:   logLevel = ERROR;   break;
        case INVALID_ALARM: logLevel = FATAL;   break;
    }
    
    logError(logLevel, "ErrorHandler::setAlarmStatus", alarmMessage, pasynUser);
    
    return asynSuccess;
}

/** ThresholdLogicController êµ¬ì„± ìœ íš¨ì„± ê²€ì‚¬ */
ErrorHandler::ValidationResult ErrorHandler::validateConfiguration(const ThresholdConfig& config)
{
    ValidationResult result;
    result.isValid = true;
    result.errorLevel = INFO;
    strcpy(result.errorMessage, "");
    strcpy(result.suggestion, "");
    
    // í¬íŠ¸ ì´ë¦„ ê²€ì‚¬
    if (!validateStringParameter("portName", config.portName, sizeof(config.portName), 
                                false, "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "í¬íŠ¸ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤");
        strcpy(result.suggestion, "1-63ìì˜ ì˜ìˆ«ìì™€ ì–¸ë”ìŠ¤ì½”ì–´ë§Œ ì‚¬ìš©í•˜ì„¸ìš”");
        return result;
    }
    
    // ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ ê²€ì‚¬
    if (!validateStringParameter("devicePort", config.devicePort, sizeof(config.devicePort), 
                                false, "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "ì¥ì¹˜ í¬íŠ¸ ì´ë¦„ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤");
        strcpy(result.suggestion, "ìœ íš¨í•œ asyn í¬íŠ¸ ì´ë¦„ì„ ì§€ì •í•˜ì„¸ìš”");
        return result;
    }
    
    // ì¥ì¹˜ ì£¼ì†Œ ê²€ì‚¬
    if (!validateIntParameter("deviceAddr", config.deviceAddr, 0, 255, 
                             "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "ì¥ì¹˜ ì£¼ì†Œê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤");
        strcpy(result.suggestion, "0-255 ë²”ìœ„ì˜ ê°’ì„ ì‚¬ìš©í•˜ì„¸ìš”");
        return result;
    }
    
    // ì—…ë°ì´íŠ¸ ì£¼ê¸° ê²€ì‚¬
    if (!validateParameter("updateRate", config.updateRate, 0.1, 1000.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "ì—…ë°ì´íŠ¸ ì£¼ê¸°ê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤");
        strcpy(result.suggestion, "0.1-1000.0 Hz ë²”ìœ„ì˜ ê°’ì„ ì‚¬ìš©í•˜ì„¸ìš”");
        return result;
    }
    
    // ìŠ¤ë ˆë“œ ìš°ì„ ìˆœìœ„ ê²€ì‚¬
    if (!validateIntParameter("priority", config.priority, 0, 99, 
                             "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = WARNING;
        strcpy(result.errorMessage, "ìŠ¤ë ˆë“œ ìš°ì„ ìˆœìœ„ê°€ ê¶Œì¥ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤");
        strcpy(result.suggestion, "0-99 ë²”ìœ„ì˜ ê°’ì„ ì‚¬ìš©í•˜ì„¸ìš” (ê¸°ë³¸ê°’: 50)");
        // ê²½ê³ ì´ë¯€ë¡œ ê³„ì† ê²€ì‚¬
    }
    
    // ì„ê³„ê°’ ê²€ì‚¬
    if (!validateParameter("thresholdValue", config.thresholdValue, -10.0, 10.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "ì„ê³„ê°’ì´ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤");
        strcpy(result.suggestion, "-10.0V ~ +10.0V ë²”ìœ„ì˜ ê°’ì„ ì‚¬ìš©í•˜ì„¸ìš”");
        return result;
    }
    
    // íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê²€ì‚¬
    if (!validateParameter("hysteresis", config.hysteresis, 0.0, 5.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ê°€ ìœ íš¨ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤");
        strcpy(result.suggestion, "0.0V ~ 5.0V ë²”ìœ„ì˜ ê°’ì„ ì‚¬ìš©í•˜ì„¸ìš”");
        return result;
    }
    
    // ì„ê³„ê°’ê³¼ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê´€ê³„ ê²€ì‚¬
    if (config.hysteresis > fabs(config.thresholdValue)) {
        result.isValid = false;
        result.errorLevel = WARNING;
        strcpy(result.errorMessage, "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ê°€ ì„ê³„ê°’ë³´ë‹¤ í½ë‹ˆë‹¤");
        strcpy(result.suggestion, "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ë¥¼ ì„ê³„ê°’ ì ˆëŒ“ê°’ë³´ë‹¤ ì‘ê²Œ ì„¤ì •í•˜ì„¸ìš”");
        // ê²½ê³ ì´ë¯€ë¡œ ìœ íš¨ì„±ì€ í†µê³¼ë¡œ ì²˜ë¦¬
        result.isValid = true;
    }
    
    // ëª¨ë“  ê²€ì‚¬ í†µê³¼
    if (result.isValid && result.errorLevel == INFO) {
        strcpy(result.errorMessage, "êµ¬ì„±ì´ ìœ íš¨í•©ë‹ˆë‹¤");
        strcpy(result.suggestion, "");
    }
    
    return result;
}

/** ëŸ°íƒ€ì„ ì˜¤ë¥˜ ì²˜ë¦¬ */
bool ErrorHandler::handleRuntimeError(const char* source, const char* errorType, 
                                     int errorCode, asynUser* pasynUser)
{
    if (source == NULL || errorType == NULL) {
        logError(ERROR, "ErrorHandler::handleRuntimeError", "NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨");
        return false;
    }
    
    char errorMessage[256];
    snprintf(errorMessage, sizeof(errorMessage), 
            "ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°œìƒ - ìœ í˜•: %s, ì½”ë“œ: %d", errorType, errorCode);
    
    ErrorLevel level = ERROR;
    bool recoverable = true;
    
    // ì˜¤ë¥˜ ìœ í˜•ë³„ ì²˜ë¦¬
    if (strcmp(errorType, "MEMORY_ALLOCATION") == 0) {
        level = FATAL;
        recoverable = false;
        logError(level, source, "ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨ - ì‹œìŠ¤í…œ ì¬ì‹œì‘ í•„ìš”", pasynUser);
    }
    else if (strcmp(errorType, "THREAD_CREATION") == 0) {
        level = ERROR;
        recoverable = true;
        logError(level, source, "ìŠ¤ë ˆë“œ ìƒì„± ì‹¤íŒ¨ - ì¬ì‹œë„ ê°€ëŠ¥", pasynUser);
    }
    else if (strcmp(errorType, "PARAMETER_VALIDATION") == 0) {
        level = WARNING;
        recoverable = true;
        logError(level, source, "ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨ - ê¸°ë³¸ê°’ ì‚¬ìš©", pasynUser);
    }
    else if (strcmp(errorType, "DEVICE_COMMUNICATION") == 0) {
        level = ERROR;
        recoverable = true;
        logError(level, source, "ì¥ì¹˜ í†µì‹  ì˜¤ë¥˜ - ì—°ê²° í™•ì¸ í•„ìš”", pasynUser);
    }
    else if (strcmp(errorType, "TIMEOUT") == 0) {
        level = WARNING;
        recoverable = true;
        logError(level, source, "íƒ€ì„ì•„ì›ƒ ë°œìƒ - ì¬ì‹œë„ ê¶Œì¥", pasynUser);
    }
    else {
        // ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ ìœ í˜•
        logError(level, source, errorMessage, pasynUser);
    }
    
    return recoverable;
}

/** í†µì‹  ì˜¤ë¥˜ ì²˜ë¦¬ */
bool ErrorHandler::handleCommunicationError(const char* source, const char* devicePort,
                                           int deviceAddr, const char* operation,
                                           asynUser* pasynUser)
{
    if (source == NULL || devicePort == NULL || operation == NULL) {
        logError(ERROR, "ErrorHandler::handleCommunicationError", "NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨");
        return false;
    }
    
    char errorMessage[256];
    snprintf(errorMessage, sizeof(errorMessage),
            "í†µì‹  ì˜¤ë¥˜ - í¬íŠ¸: %s, ì£¼ì†Œ: %d, ì‘ì—…: %s", 
            devicePort, deviceAddr, operation);
    
    logError(ERROR, source, errorMessage, pasynUser);
    
    // ì•ŒëŒ ì„¤ì •
    if (pasynUser != NULL) {
        setAlarmStatus(pasynUser, COMM_ALARM, MAJOR_ALARM);
    }
    
    // í†µì‹  ì˜¤ë¥˜ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì¬ì‹œë„ ê°€ëŠ¥
    return true;
}

/** ìŠ¤ë ˆë“œ ì˜¤ë¥˜ ì²˜ë¦¬ */
bool ErrorHandler::handleThreadError(const char* source, const char* threadName,
                                    const char* errorMessage, asynUser* pasynUser)
{
    if (source == NULL || threadName == NULL || errorMessage == NULL) {
        logError(ERROR, "ErrorHandler::handleThreadError", "NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨");
        return false;
    }
    
    char fullMessage[256];
    snprintf(fullMessage, sizeof(fullMessage),
            "ìŠ¤ë ˆë“œ ì˜¤ë¥˜ - ì´ë¦„: %s, ë©”ì‹œì§€: %s", threadName, errorMessage);
    
    logError(ERROR, source, fullMessage, pasynUser);
    
    // ìŠ¤ë ˆë“œ ì˜¤ë¥˜ëŠ” ëŒ€ë¶€ë¶„ ì¬ì‹œì‘ ê°€ëŠ¥
    bool restartRecommended = true;
    
    // íŠ¹ì • ì˜¤ë¥˜ ìœ í˜•ì— ë”°ë¥¸ ì²˜ë¦¬
    if (strstr(errorMessage, "FATAL") != NULL || strstr(errorMessage, "SEGFAULT") != NULL) {
        restartRecommended = false;
        logError(FATAL, source, "ì¹˜ëª…ì  ìŠ¤ë ˆë“œ ì˜¤ë¥˜ - ì¬ì‹œì‘ ë¶ˆê°€", pasynUser);
    }
    
    return restartRecommended;
}

/** ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ */
bool ErrorHandler::validateParameter(const char* paramName, double value, 
                                   double minValue, double maxValue, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateParameter", "NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨");
        return false;
    }
    
    if (isnan(value) || isinf(value)) {
        char message[256];
        snprintf(message, sizeof(message), 
                "ë§¤ê°œë³€ìˆ˜ '%s'ê°€ ìœ íš¨í•˜ì§€ ì•Šì€ ê°’ì…ë‹ˆë‹¤ (NaN ë˜ëŠ” Inf)", paramName);
        logError(ERROR, source, message);
        return false;
    }
    
    if (value < minValue || value > maxValue) {
        char message[256];
        snprintf(message, sizeof(message),
                "ë§¤ê°œë³€ìˆ˜ '%s' ê°’ %fì´ ìœ íš¨ ë²”ìœ„ [%f, %f]ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤",
                paramName, value, minValue, maxValue);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** ì •ìˆ˜ ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ */
bool ErrorHandler::validateIntParameter(const char* paramName, int value, 
                                       int minValue, int maxValue, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateIntParameter", "NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨");
        return false;
    }
    
    if (value < minValue || value > maxValue) {
        char message[256];
        snprintf(message, sizeof(message),
                "ì •ìˆ˜ ë§¤ê°œë³€ìˆ˜ '%s' ê°’ %dì´ ìœ íš¨ ë²”ìœ„ [%d, %d]ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤",
                paramName, value, minValue, maxValue);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** ë¬¸ìì—´ ë§¤ê°œë³€ìˆ˜ ìœ íš¨ì„± ê²€ì‚¬ */
bool ErrorHandler::validateStringParameter(const char* paramName, const char* value,
                                          size_t maxLength, bool allowEmpty, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateStringParameter", "NULL í¬ì¸í„°ê°€ ì „ë‹¬ë¨");
        return false;
    }
    
    if (value == NULL) {
        char message[256];
        snprintf(message, sizeof(message), "ë¬¸ìì—´ ë§¤ê°œë³€ìˆ˜ '%s'ê°€ NULLì…ë‹ˆë‹¤", paramName);
        logError(ERROR, source, message);
        return false;
    }
    
    size_t length = strlen(value);
    
    if (!allowEmpty && length == 0) {
        char message[256];
        snprintf(message, sizeof(message), "ë¬¸ìì—´ ë§¤ê°œë³€ìˆ˜ '%s'ê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤", paramName);
        logError(WARNING, source, message);
        return false;
    }
    
    if (length >= maxLength) {
        char message[256];
        snprintf(message, sizeof(message),
                "ë¬¸ìì—´ ë§¤ê°œë³€ìˆ˜ '%s' ê¸¸ì´ %zuê°€ ìµœëŒ€ ê¸¸ì´ %zuë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤",
                paramName, length, maxLength - 1);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** ì˜¤ë¥˜ í†µê³„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° */
void ErrorHandler::getErrorStatistics(int* infoCount, int* warningCount, 
                                     int* errorCount, int* fatalCount)
{
    initializeMutex();
    
    epicsMutexLock(errorStatsMutex);
    if (infoCount)    *infoCount = infoCount_;
    if (warningCount) *warningCount = warningCount_;
    if (errorCount)   *errorCount = errorCount_;
    if (fatalCount)   *fatalCount = fatalCount_;
    epicsMutexUnlock(errorStatsMutex);
}

/** ì˜¤ë¥˜ í†µê³„ ì´ˆê¸°í™” */
void ErrorHandler::resetErrorStatistics()
{
    initializeMutex();
    
    epicsMutexLock(errorStatsMutex);
    infoCount_ = 0;
    warningCount_ = 0;
    errorCount_ = 0;
    fatalCount_ = 0;
    epicsMutexUnlock(errorStatsMutex);
    
    logError(INFO, "ErrorHandler::resetErrorStatistics", "ì˜¤ë¥˜ í†µê³„ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤");
}

/** ì˜¤ë¥˜ ë ˆë²¨ì„ ë¬¸ìì—´ë¡œ ë³€í™˜ */
const char* ErrorHandler::errorLevelToString(ErrorLevel level)
{
    switch (level) {
        case INFO:    return "ì •ë³´";
        case WARNING: return "ê²½ê³ ";
        case ERROR:   return "ì˜¤ë¥˜";
        case FATAL:   return "ì¹˜ëª…ì ";
        default:      return "ì•Œìˆ˜ì—†ìŒ";
    }
}

/** ì•ŒëŒ ì‹¬ê°ë„ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜ */
const char* ErrorHandler::alarmSeverityToString(AlarmSeverity severity)
{
    switch (severity) {
        case NO_ALARM:      return "ì•ŒëŒì—†ìŒ";
        case MINOR_ALARM:   return "ê²½ë¯¸í•œì•ŒëŒ";
        case MAJOR_ALARM:   return "ì£¼ìš”ì•ŒëŒ";
        case INVALID_ALARM: return "ìœ íš¨í•˜ì§€ì•ŠìŒ";
        default:            return "ì•Œìˆ˜ì—†ìŒ";
    }
}

/** ì•ŒëŒ ìƒíƒœë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜ */
const char* ErrorHandler::alarmStatusToString(AlarmStatus status)
{
    switch (status) {
        case NO_ALARM_STATUS:     return "ì •ìƒ";
        case READ_ALARM:          return "ì½ê¸°ì˜¤ë¥˜";
        case WRITE_ALARM:         return "ì“°ê¸°ì˜¤ë¥˜";
        case HIHI_ALARM:          return "ìƒí•œìƒí•œ";
        case HIGH_ALARM:          return "ìƒí•œ";
        case LOLO_ALARM:          return "í•˜í•œí•˜í•œ";
        case LOW_ALARM:           return "í•˜í•œ";
        case STATE_ALARM:         return "ìƒíƒœì˜¤ë¥˜";
        case COS_ALARM:           return "ë³€í™”ì•ŒëŒ";
        case COMM_ALARM:          return "í†µì‹ ì˜¤ë¥˜";
        case TIMEOUT_ALARM:       return "íƒ€ì„ì•„ì›ƒ";
        case HW_LIMIT_ALARM:      return "í•˜ë“œì›¨ì–´ì œí•œ";
        case CALC_ALARM:          return "ê³„ì‚°ì˜¤ë¥˜";
        case SCAN_ALARM:          return "ìŠ¤ìº”ì˜¤ë¥˜";
        case LINK_ALARM:          return "ë§í¬ì˜¤ë¥˜";
        case SOFT_ALARM:          return "ì†Œí”„íŠ¸ì›¨ì–´ì•ŒëŒ";
        case BAD_SUB_ALARM:       return "ì˜ëª»ëœì„œë¸Œë ˆì½”ë“œ";
        case UDF_ALARM:           return "ì •ì˜ë˜ì§€ì•Šì€ê°’";
        case DISABLE_ALARM:       return "ë¹„í™œì„±í™”";
        case SIMM_ALARM:          return "ì‹œë®¬ë ˆì´ì…˜";
        case READ_ACCESS_ALARM:   return "ì½ê¸°ì ‘ê·¼ì˜¤ë¥˜";
        case WRITE_ACCESS_ALARM:  return "ì“°ê¸°ì ‘ê·¼ì˜¤ë¥˜";
        default:                  return "ì•Œìˆ˜ì—†ìŒ";
    }
}

/** ë‚´ë¶€ ë¡œê¹… ë©”ì„œë“œ */
void ErrorHandler::internalLog(ErrorLevel level, const char* source, const char* message,
                              asynUser* pasynUser)
{
    // íƒ€ì„ìŠ¤íƒ¬í”„ ìƒì„±
    char timestamp[64];
    getTimestampString(timestamp, sizeof(timestamp));
    
    // ë¡œê·¸ ë©”ì‹œì§€ êµ¬ì„±
    char logMessage[512];
    snprintf(logMessage, sizeof(logMessage),
            "[%s] [%s] %s: %s",
            timestamp, errorLevelToString(level), source, message);
    
    // ì½˜ì†” ì¶œë ¥
    printf("%s\n", logMessage);
    
    // asyn íŠ¸ë ˆì´ìŠ¤ ì¶œë ¥ (pasynUserê°€ ìˆëŠ” ê²½ìš°)
    if (pasynUser != NULL) {
        int traceLevel = convertToAsynTraceLevel(level);
        asynPrint(pasynUser, traceLevel, "%s\n", logMessage);
    }
}

/** íƒ€ì„ìŠ¤íƒ¬í”„ ë¬¸ìì—´ ìƒì„± */
void ErrorHandler::getTimestampString(char* buffer, size_t bufferSize)
{
    if (buffer == NULL || bufferSize == 0) {
        return;
    }
    
    epicsTimeStamp currentTime;
    epicsTimeGetCurrent(&currentTime);
    
    // EPICS ì‹œê°„ì„ ë¬¸ìì—´ë¡œ ë³€í™˜
    char epicsTimeStr[64];
    epicsTimeToStrftime(epicsTimeStr, sizeof(epicsTimeStr), "%Y-%m-%d %H:%M:%S.%06f", &currentTime);
    
    strncpy(buffer, epicsTimeStr, bufferSize - 1);
    buffer[bufferSize - 1] = '\0';
}

/** asyn íŠ¸ë ˆì´ìŠ¤ ë ˆë²¨ ë³€í™˜ */
int ErrorHandler::convertToAsynTraceLevel(ErrorLevel level)
{
    switch (level) {
        case INFO:    return ASYN_TRACE_FLOW;
        case WARNING: return ASYN_TRACE_WARNING;
        case ERROR:   return ASYN_TRACE_ERROR;
        case FATAL:   return ASYN_TRACE_ERROR;
        default:      return ASYN_TRACE_ERROR;
    }
}










ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.d
=================================================
ErrorHandler.o: ../ErrorHandler.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 ../ErrorHandler.h /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.d
=================================================
ThresholdLogicController.o: ../ThresholdLogicController.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctetSyncIO.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 ../ThresholdLogicController.h ../ErrorHandler.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.d
=================================================
USB1608G_2AO_V2_registerRecordDeviceDriver.o: \
 USB1608G_2AO_V2_registerRecordDeviceDriver.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdlib.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdStrtod.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocshRegisterCommon.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbCoreAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/registryCommon.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbStaticLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbFldTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbBase.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbDefs.h \
 /usr/local/epics/EPICS_R7.0/base/include/recSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/devSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/link.h \
 /usr/local/epics/EPICS_R7.0/base/include/cantProceed.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbJLink.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbCoreAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/registryRecordType.h \
 /usr/local/epics/EPICS_R7.0/base/include/recSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.d
=================================================
USBCTR_SNL.o: USBCTR_SNL.c \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_snc.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seqCom.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/pvAlarm.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_release.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_prim_types.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_mask.h \
 /usr/local/epics/EPICS_R7.0/base/include/errlog.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.d
=================================================
measCompDiscover.o: ../measCompDiscover.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/osiSock.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdSock.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h ../measCompDiscover.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
=================================================
/* THIS IS A GENERATED FILE. DO NOT EDIT! */
/* Generated from ../O.Common/USB1608G_2AO_V2.dbd */

#include <string.h>
#ifndef USE_TYPED_RSET
#  define USE_TYPED_RSET
#endif
#include "compilerDependencies.h"
#include "epicsStdlib.h"
#include "iocsh.h"
#include "iocshRegisterCommon.h"
#include "registryCommon.h"
#include "recSup.h"
#include "shareLib.h"

extern "C" {

epicsShareExtern typed_rset *pvar_rset_aSubRSET, *pvar_rset_aaiRSET,
    *pvar_rset_aaoRSET, *pvar_rset_acalcoutRSET, *pvar_rset_aiRSET,
    *pvar_rset_aoRSET, *pvar_rset_asynRSET, *pvar_rset_biRSET,
    *pvar_rset_boRSET, *pvar_rset_busyRSET, *pvar_rset_calcRSET,
    *pvar_rset_calcoutRSET, *pvar_rset_compressRSET,
    *pvar_rset_dfanoutRSET, *pvar_rset_eventRSET, *pvar_rset_fanoutRSET,
    *pvar_rset_histogramRSET, *pvar_rset_int64inRSET,
    *pvar_rset_int64outRSET, *pvar_rset_longinRSET,
    *pvar_rset_longoutRSET, *pvar_rset_lsiRSET, *pvar_rset_lsoRSET,
    *pvar_rset_mbbiRSET, *pvar_rset_mbbiDirectRSET, *pvar_rset_mbboRSET,
    *pvar_rset_mbboDirectRSET, *pvar_rset_mcaRSET,
    *pvar_rset_permissiveRSET, *pvar_rset_printfRSET,
    *pvar_rset_scalcoutRSET, *pvar_rset_scalerRSET,
    *pvar_rset_scanparmRSET, *pvar_rset_selRSET, *pvar_rset_seqRSET,
    *pvar_rset_sscanRSET, *pvar_rset_sseqRSET, *pvar_rset_stateRSET,
    *pvar_rset_stringinRSET, *pvar_rset_stringoutRSET, *pvar_rset_subRSET,
    *pvar_rset_subArrayRSET, *pvar_rset_swaitRSET,
    *pvar_rset_transformRSET, *pvar_rset_waveformRSET;

typedef int (*rso_func)(dbRecordType *pdbRecordType);
epicsShareExtern rso_func pvar_func_aSubRecordSizeOffset,
    pvar_func_aaiRecordSizeOffset, pvar_func_aaoRecordSizeOffset,
    pvar_func_acalcoutRecordSizeOffset, pvar_func_aiRecordSizeOffset,
    pvar_func_aoRecordSizeOffset, pvar_func_asynRecordSizeOffset,
    pvar_func_biRecordSizeOffset, pvar_func_boRecordSizeOffset,
    pvar_func_busyRecordSizeOffset, pvar_func_calcRecordSizeOffset,
    pvar_func_calcoutRecordSizeOffset, pvar_func_compressRecordSizeOffset,
    pvar_func_dfanoutRecordSizeOffset, pvar_func_eventRecordSizeOffset,
    pvar_func_fanoutRecordSizeOffset, pvar_func_histogramRecordSizeOffset,
    pvar_func_int64inRecordSizeOffset, pvar_func_int64outRecordSizeOffset,
    pvar_func_longinRecordSizeOffset, pvar_func_longoutRecordSizeOffset,
    pvar_func_lsiRecordSizeOffset, pvar_func_lsoRecordSizeOffset,
    pvar_func_mbbiRecordSizeOffset, pvar_func_mbbiDirectRecordSizeOffset,
    pvar_func_mbboRecordSizeOffset, pvar_func_mbboDirectRecordSizeOffset,
    pvar_func_mcaRecordSizeOffset, pvar_func_permissiveRecordSizeOffset,
    pvar_func_printfRecordSizeOffset, pvar_func_scalcoutRecordSizeOffset,
    pvar_func_scalerRecordSizeOffset, pvar_func_scanparmRecordSizeOffset,
    pvar_func_selRecordSizeOffset, pvar_func_seqRecordSizeOffset,
    pvar_func_sscanRecordSizeOffset, pvar_func_sseqRecordSizeOffset,
    pvar_func_stateRecordSizeOffset, pvar_func_stringinRecordSizeOffset,
    pvar_func_stringoutRecordSizeOffset, pvar_func_subRecordSizeOffset,
    pvar_func_subArrayRecordSizeOffset, pvar_func_swaitRecordSizeOffset,
    pvar_func_transformRecordSizeOffset,
    pvar_func_waveformRecordSizeOffset;

static const char * const recordTypeNames[] = {
    "aSub", "aai", "aao", "acalcout", "ai", "ao", "asyn", "bi", "bo",
    "busy", "calc", "calcout", "compress", "dfanout", "event", "fanout",
    "histogram", "int64in", "int64out", "longin", "longout", "lsi", "lso",
    "mbbi", "mbbiDirect", "mbbo", "mbboDirect", "mca", "permissive",
    "printf", "scalcout", "scaler", "scanparm", "sel", "seq", "sscan",
    "sseq", "state", "stringin", "stringout", "sub", "subArray", "swait",
    "transform", "waveform"
};

static const recordTypeLocation rtl[] = {
    {(struct typed_rset *)pvar_rset_aSubRSET, pvar_func_aSubRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aaiRSET, pvar_func_aaiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aaoRSET, pvar_func_aaoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_acalcoutRSET, pvar_func_acalcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aiRSET, pvar_func_aiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aoRSET, pvar_func_aoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_asynRSET, pvar_func_asynRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_biRSET, pvar_func_biRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_boRSET, pvar_func_boRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_busyRSET, pvar_func_busyRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_calcRSET, pvar_func_calcRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_calcoutRSET, pvar_func_calcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_compressRSET, pvar_func_compressRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_dfanoutRSET, pvar_func_dfanoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_eventRSET, pvar_func_eventRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_fanoutRSET, pvar_func_fanoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_histogramRSET, pvar_func_histogramRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_int64inRSET, pvar_func_int64inRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_int64outRSET, pvar_func_int64outRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_longinRSET, pvar_func_longinRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_longoutRSET, pvar_func_longoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_lsiRSET, pvar_func_lsiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_lsoRSET, pvar_func_lsoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbbiRSET, pvar_func_mbbiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbbiDirectRSET, pvar_func_mbbiDirectRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbboRSET, pvar_func_mbboRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbboDirectRSET, pvar_func_mbboDirectRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mcaRSET, pvar_func_mcaRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_permissiveRSET, pvar_func_permissiveRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_printfRSET, pvar_func_printfRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scalcoutRSET, pvar_func_scalcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scalerRSET, pvar_func_scalerRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scanparmRSET, pvar_func_scanparmRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_selRSET, pvar_func_selRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_seqRSET, pvar_func_seqRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_sscanRSET, pvar_func_sscanRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_sseqRSET, pvar_func_sseqRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stateRSET, pvar_func_stateRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stringinRSET, pvar_func_stringinRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stringoutRSET, pvar_func_stringoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_subRSET, pvar_func_subRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_subArrayRSET, pvar_func_subArrayRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_swaitRSET, pvar_func_swaitRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_transformRSET, pvar_func_transformRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_waveformRSET, pvar_func_waveformRecordSizeOffset}
};

epicsShareExtern dset *pvar_dset_devAaiSoft, *pvar_dset_asynInt8ArrayAai,
    *pvar_dset_asynInt16ArrayAai, *pvar_dset_asynInt32ArrayAai,
    *pvar_dset_asynFloat32ArrayAai, *pvar_dset_asynFloat64ArrayAai,
    *pvar_dset_asynInt64ArrayAai, *pvar_dset_devAaoSoft,
    *pvar_dset_asynInt8ArrayAao, *pvar_dset_asynInt16ArrayAao,
    *pvar_dset_asynInt32ArrayAao, *pvar_dset_asynFloat32ArrayAao,
    *pvar_dset_asynFloat64ArrayAao, *pvar_dset_asynInt64ArrayAao,
    *pvar_dset_devaCalcoutSoft, *pvar_dset_devAiSoft,
    *pvar_dset_devAiSoftRaw, *pvar_dset_devAiSoftCallback,
    *pvar_dset_devTimestampAI, *pvar_dset_devAiGeneralTime,
    *pvar_dset_asynAiInt32, *pvar_dset_asynAiInt32Average,
    *pvar_dset_asynAiFloat64, *pvar_dset_asynAiFloat64Average,
    *pvar_dset_asynAiInt64, *pvar_dset_devAoSoft, *pvar_dset_devAoSoftRaw,
    *pvar_dset_devAoSoftCallback, *pvar_dset_asynAoInt32,
    *pvar_dset_asynAoFloat64, *pvar_dset_asynAoInt64,
    *pvar_dset_asynRecordDevice, *pvar_dset_devBiSoft,
    *pvar_dset_devBiSoftRaw, *pvar_dset_devBiSoftCallback,
    *pvar_dset_devBiDbState, *pvar_dset_asynBiInt32,
    *pvar_dset_asynBiUInt32Digital, *pvar_dset_devBoSoft,
    *pvar_dset_devBoSoftRaw, *pvar_dset_devBoSoftCallback,
    *pvar_dset_devBoGeneralTime, *pvar_dset_devBoDbState,
    *pvar_dset_asynBoInt32, *pvar_dset_asynBoUInt32Digital,
    *pvar_dset_devBusySoft, *pvar_dset_devBusySoftRaw,
    *pvar_dset_asynBusyInt32, *pvar_dset_devCalcoutSoft,
    *pvar_dset_devCalcoutSoftCallback, *pvar_dset_devEventSoft,
    *pvar_dset_devHistogramSoft, *pvar_dset_devI64inSoft,
    *pvar_dset_devI64inSoftCallback, *pvar_dset_asynInt64In,
    *pvar_dset_devI64outSoft, *pvar_dset_devI64outSoftCallback,
    *pvar_dset_asynInt64Out, *pvar_dset_devLiSoft,
    *pvar_dset_devLiSoftCallback, *pvar_dset_devLiGeneralTime,
    *pvar_dset_asynLiInt32, *pvar_dset_asynLiUInt32Digital,
    *pvar_dset_asynLiInt64, *pvar_dset_devLoSoft,
    *pvar_dset_devLoSoftCallback, *pvar_dset_asynLoInt32,
    *pvar_dset_asynLoUInt32Digital, *pvar_dset_asynLoInt64,
    *pvar_dset_devLsiSoft, *pvar_dset_devLsiEnviron,
    *pvar_dset_asynLsiOctetCmdResponse, *pvar_dset_asynLsiOctetWriteRead,
    *pvar_dset_asynLsiOctetRead, *pvar_dset_devLsoSoft,
    *pvar_dset_devLsoSoftCallback, *pvar_dset_devLsoStdio,
    *pvar_dset_asynLsoOctetWrite, *pvar_dset_devMbbiSoft,
    *pvar_dset_devMbbiSoftRaw, *pvar_dset_devMbbiSoftCallback,
    *pvar_dset_asynMbbiInt32, *pvar_dset_asynMbbiUInt32Digital,
    *pvar_dset_devMbbiDirectSoft, *pvar_dset_devMbbiDirectSoftRaw,
    *pvar_dset_devMbbiDirectSoftCallback,
    *pvar_dset_asynMbbiDirectUInt32Digital, *pvar_dset_devMbboSoft,
    *pvar_dset_devMbboSoftRaw, *pvar_dset_devMbboSoftCallback,
    *pvar_dset_asynMbboInt32, *pvar_dset_asynMbboUInt32Digital,
    *pvar_dset_devMbboDirectSoft, *pvar_dset_devMbboDirectSoftRaw,
    *pvar_dset_devMbboDirectSoftCallback,
    *pvar_dset_asynMbboDirectUInt32Digital, *pvar_dset_devMCA_soft,
    *pvar_dset_devMcaAsyn, *pvar_dset_devPrintfSoft,
    *pvar_dset_devPrintfSoftCallback, *pvar_dset_devPrintfStdio,
    *pvar_dset_asynPfOctetWrite, *pvar_dset_devsCalcoutSoft,
    *pvar_dset_devScalerAsyn, *pvar_dset_devSiSoft,
    *pvar_dset_devSiSoftCallback, *pvar_dset_devTimestampSI,
    *pvar_dset_devSiGeneralTime, *pvar_dset_devSiEnviron,
    *pvar_dset_asynSiOctetCmdResponse, *pvar_dset_asynSiOctetWriteRead,
    *pvar_dset_asynSiOctetRead, *pvar_dset_devSoSoft,
    *pvar_dset_devSoSoftCallback, *pvar_dset_devSoStdio,
    *pvar_dset_asynSoOctetWrite, *pvar_dset_devSASoft,
    *pvar_dset_devSWaitIoEvent, *pvar_dset_devWfSoft,
    *pvar_dset_asynWfOctetCmdResponse, *pvar_dset_asynWfOctetWriteRead,
    *pvar_dset_asynWfOctetRead, *pvar_dset_asynWfOctetWrite,
    *pvar_dset_asynWfOctetWriteBinary, *pvar_dset_asynInt8ArrayWfIn,
    *pvar_dset_asynInt8ArrayWfOut, *pvar_dset_asynInt16ArrayWfIn,
    *pvar_dset_asynInt16ArrayWfOut, *pvar_dset_asynInt32ArrayWfIn,
    *pvar_dset_asynInt32ArrayWfOut, *pvar_dset_asynFloat32ArrayWfIn,
    *pvar_dset_asynFloat32ArrayWfOut, *pvar_dset_asynFloat64ArrayWfIn,
    *pvar_dset_asynFloat64ArrayWfOut, *pvar_dset_asynInt32TimeSeries,
    *pvar_dset_asynFloat64TimeSeries, *pvar_dset_asynInt64ArrayWfIn,
    *pvar_dset_asynInt64ArrayWfOut, *pvar_dset_asynInt64TimeSeries;

static const char * const deviceSupportNames[] = {
    "devAaiSoft", "asynInt8ArrayAai", "asynInt16ArrayAai",
    "asynInt32ArrayAai", "asynFloat32ArrayAai", "asynFloat64ArrayAai",
    "asynInt64ArrayAai", "devAaoSoft", "asynInt8ArrayAao",
    "asynInt16ArrayAao", "asynInt32ArrayAao", "asynFloat32ArrayAao",
    "asynFloat64ArrayAao", "asynInt64ArrayAao", "devaCalcoutSoft",
    "devAiSoft", "devAiSoftRaw", "devAiSoftCallback", "devTimestampAI",
    "devAiGeneralTime", "asynAiInt32", "asynAiInt32Average",
    "asynAiFloat64", "asynAiFloat64Average", "asynAiInt64", "devAoSoft",
    "devAoSoftRaw", "devAoSoftCallback", "asynAoInt32", "asynAoFloat64",
    "asynAoInt64", "asynRecordDevice", "devBiSoft", "devBiSoftRaw",
    "devBiSoftCallback", "devBiDbState", "asynBiInt32",
    "asynBiUInt32Digital", "devBoSoft", "devBoSoftRaw",
    "devBoSoftCallback", "devBoGeneralTime", "devBoDbState",
    "asynBoInt32", "asynBoUInt32Digital", "devBusySoft", "devBusySoftRaw",
    "asynBusyInt32", "devCalcoutSoft", "devCalcoutSoftCallback",
    "devEventSoft", "devHistogramSoft", "devI64inSoft",
    "devI64inSoftCallback", "asynInt64In", "devI64outSoft",
    "devI64outSoftCallback", "asynInt64Out", "devLiSoft",
    "devLiSoftCallback", "devLiGeneralTime", "asynLiInt32",
    "asynLiUInt32Digital", "asynLiInt64", "devLoSoft",
    "devLoSoftCallback", "asynLoInt32", "asynLoUInt32Digital",
    "asynLoInt64", "devLsiSoft", "devLsiEnviron",
    "asynLsiOctetCmdResponse", "asynLsiOctetWriteRead",
    "asynLsiOctetRead", "devLsoSoft", "devLsoSoftCallback", "devLsoStdio",
    "asynLsoOctetWrite", "devMbbiSoft", "devMbbiSoftRaw",
    "devMbbiSoftCallback", "asynMbbiInt32", "asynMbbiUInt32Digital",
    "devMbbiDirectSoft", "devMbbiDirectSoftRaw",
    "devMbbiDirectSoftCallback", "asynMbbiDirectUInt32Digital",
    "devMbboSoft", "devMbboSoftRaw", "devMbboSoftCallback",
    "asynMbboInt32", "asynMbboUInt32Digital", "devMbboDirectSoft",
    "devMbboDirectSoftRaw", "devMbboDirectSoftCallback",
    "asynMbboDirectUInt32Digital", "devMCA_soft", "devMcaAsyn",
    "devPrintfSoft", "devPrintfSoftCallback", "devPrintfStdio",
    "asynPfOctetWrite", "devsCalcoutSoft", "devScalerAsyn", "devSiSoft",
    "devSiSoftCallback", "devTimestampSI", "devSiGeneralTime",
    "devSiEnviron", "asynSiOctetCmdResponse", "asynSiOctetWriteRead",
    "asynSiOctetRead", "devSoSoft", "devSoSoftCallback", "devSoStdio",
    "asynSoOctetWrite", "devSASoft", "devSWaitIoEvent", "devWfSoft",
    "asynWfOctetCmdResponse", "asynWfOctetWriteRead", "asynWfOctetRead",
    "asynWfOctetWrite", "asynWfOctetWriteBinary", "asynInt8ArrayWfIn",
    "asynInt8ArrayWfOut", "asynInt16ArrayWfIn", "asynInt16ArrayWfOut",
    "asynInt32ArrayWfIn", "asynInt32ArrayWfOut", "asynFloat32ArrayWfIn",
    "asynFloat32ArrayWfOut", "asynFloat64ArrayWfIn",
    "asynFloat64ArrayWfOut", "asynInt32TimeSeries",
    "asynFloat64TimeSeries", "asynInt64ArrayWfIn", "asynInt64ArrayWfOut",
    "asynInt64TimeSeries"
};

static const dset * const devsl[] = {
    pvar_dset_devAaiSoft, pvar_dset_asynInt8ArrayAai,
    pvar_dset_asynInt16ArrayAai, pvar_dset_asynInt32ArrayAai,
    pvar_dset_asynFloat32ArrayAai, pvar_dset_asynFloat64ArrayAai,
    pvar_dset_asynInt64ArrayAai, pvar_dset_devAaoSoft,
    pvar_dset_asynInt8ArrayAao, pvar_dset_asynInt16ArrayAao,
    pvar_dset_asynInt32ArrayAao, pvar_dset_asynFloat32ArrayAao,
    pvar_dset_asynFloat64ArrayAao, pvar_dset_asynInt64ArrayAao,
    pvar_dset_devaCalcoutSoft, pvar_dset_devAiSoft,
    pvar_dset_devAiSoftRaw, pvar_dset_devAiSoftCallback,
    pvar_dset_devTimestampAI, pvar_dset_devAiGeneralTime,
    pvar_dset_asynAiInt32, pvar_dset_asynAiInt32Average,
    pvar_dset_asynAiFloat64, pvar_dset_asynAiFloat64Average,
    pvar_dset_asynAiInt64, pvar_dset_devAoSoft, pvar_dset_devAoSoftRaw,
    pvar_dset_devAoSoftCallback, pvar_dset_asynAoInt32,
    pvar_dset_asynAoFloat64, pvar_dset_asynAoInt64,
    pvar_dset_asynRecordDevice, pvar_dset_devBiSoft,
    pvar_dset_devBiSoftRaw, pvar_dset_devBiSoftCallback,
    pvar_dset_devBiDbState, pvar_dset_asynBiInt32,
    pvar_dset_asynBiUInt32Digital, pvar_dset_devBoSoft,
    pvar_dset_devBoSoftRaw, pvar_dset_devBoSoftCallback,
    pvar_dset_devBoGeneralTime, pvar_dset_devBoDbState,
    pvar_dset_asynBoInt32, pvar_dset_asynBoUInt32Digital,
    pvar_dset_devBusySoft, pvar_dset_devBusySoftRaw,
    pvar_dset_asynBusyInt32, pvar_dset_devCalcoutSoft,
    pvar_dset_devCalcoutSoftCallback, pvar_dset_devEventSoft,
    pvar_dset_devHistogramSoft, pvar_dset_devI64inSoft,
    pvar_dset_devI64inSoftCallback, pvar_dset_asynInt64In,
    pvar_dset_devI64outSoft, pvar_dset_devI64outSoftCallback,
    pvar_dset_asynInt64Out, pvar_dset_devLiSoft,
    pvar_dset_devLiSoftCallback, pvar_dset_devLiGeneralTime,
    pvar_dset_asynLiInt32, pvar_dset_asynLiUInt32Digital,
    pvar_dset_asynLiInt64, pvar_dset_devLoSoft,
    pvar_dset_devLoSoftCallback, pvar_dset_asynLoInt32,
    pvar_dset_asynLoUInt32Digital, pvar_dset_asynLoInt64,
    pvar_dset_devLsiSoft, pvar_dset_devLsiEnviron,
    pvar_dset_asynLsiOctetCmdResponse, pvar_dset_asynLsiOctetWriteRead,
    pvar_dset_asynLsiOctetRead, pvar_dset_devLsoSoft,
    pvar_dset_devLsoSoftCallback, pvar_dset_devLsoStdio,
    pvar_dset_asynLsoOctetWrite, pvar_dset_devMbbiSoft,
    pvar_dset_devMbbiSoftRaw, pvar_dset_devMbbiSoftCallback,
    pvar_dset_asynMbbiInt32, pvar_dset_asynMbbiUInt32Digital,
    pvar_dset_devMbbiDirectSoft, pvar_dset_devMbbiDirectSoftRaw,
    pvar_dset_devMbbiDirectSoftCallback,
    pvar_dset_asynMbbiDirectUInt32Digital, pvar_dset_devMbboSoft,
    pvar_dset_devMbboSoftRaw, pvar_dset_devMbboSoftCallback,
    pvar_dset_asynMbboInt32, pvar_dset_asynMbboUInt32Digital,
    pvar_dset_devMbboDirectSoft, pvar_dset_devMbboDirectSoftRaw,
    pvar_dset_devMbboDirectSoftCallback,
    pvar_dset_asynMbboDirectUInt32Digital, pvar_dset_devMCA_soft,
    pvar_dset_devMcaAsyn, pvar_dset_devPrintfSoft,
    pvar_dset_devPrintfSoftCallback, pvar_dset_devPrintfStdio,
    pvar_dset_asynPfOctetWrite, pvar_dset_devsCalcoutSoft,
    pvar_dset_devScalerAsyn, pvar_dset_devSiSoft,
    pvar_dset_devSiSoftCallback, pvar_dset_devTimestampSI,
    pvar_dset_devSiGeneralTime, pvar_dset_devSiEnviron,
    pvar_dset_asynSiOctetCmdResponse, pvar_dset_asynSiOctetWriteRead,
    pvar_dset_asynSiOctetRead, pvar_dset_devSoSoft,
    pvar_dset_devSoSoftCallback, pvar_dset_devSoStdio,
    pvar_dset_asynSoOctetWrite, pvar_dset_devSASoft,
    pvar_dset_devSWaitIoEvent, pvar_dset_devWfSoft,
    pvar_dset_asynWfOctetCmdResponse, pvar_dset_asynWfOctetWriteRead,
    pvar_dset_asynWfOctetRead, pvar_dset_asynWfOctetWrite,
    pvar_dset_asynWfOctetWriteBinary, pvar_dset_asynInt8ArrayWfIn,
    pvar_dset_asynInt8ArrayWfOut, pvar_dset_asynInt16ArrayWfIn,
    pvar_dset_asynInt16ArrayWfOut, pvar_dset_asynInt32ArrayWfIn,
    pvar_dset_asynInt32ArrayWfOut, pvar_dset_asynFloat32ArrayWfIn,
    pvar_dset_asynFloat32ArrayWfOut, pvar_dset_asynFloat64ArrayWfIn,
    pvar_dset_asynFloat64ArrayWfOut, pvar_dset_asynInt32TimeSeries,
    pvar_dset_asynFloat64TimeSeries, pvar_dset_asynInt64ArrayWfIn,
    pvar_dset_asynInt64ArrayWfOut, pvar_dset_asynInt64TimeSeries
};

epicsShareExtern drvet *pvar_drvet_drvAsyn;

static const char *driverSupportNames[] = {
    "drvAsyn"};

static struct drvet *drvsl[] = {
    pvar_drvet_drvAsyn};

epicsShareExtern jlif *pvar_jlif_lnkCalcIf, *pvar_jlif_lnkConstIf,
    *pvar_jlif_lnkDebugIf, *pvar_jlif_lnkStateIf, *pvar_jlif_lnkTraceIf;

static struct jlif *jlifsl[] = {
    pvar_jlif_lnkCalcIf,
    pvar_jlif_lnkConstIf,
    pvar_jlif_lnkDebugIf,
    pvar_jlif_lnkStateIf,
    pvar_jlif_lnkTraceIf};

typedef void (*reg_func)(void);
epicsShareExtern reg_func pvar_func_Scaler974Register,
    pvar_func_ThresholdLogicRegister, pvar_func_USBCTR_SNLRegistrar,
    pvar_func_aCalcMonitorMemRegister,
    pvar_func_acalcTotalAllocatedMemoryRegister, pvar_func_arrInitialize,
    pvar_func_arrayTestRegister, pvar_func_asInitHooksRegister,
    pvar_func_asSub, pvar_func_asynInterposeDelayRegister,
    pvar_func_asynInterposeEchoRegister,
    pvar_func_asynInterposeEosRegister,
    pvar_func_asynInterposeFlushRegister, pvar_func_asynRegister,
    pvar_func_configMenuRegistrar, pvar_func_dbndInitialize,
    pvar_func_dbrestoreRegister, pvar_func_decInitialize,
    pvar_func_drvMultiFunctionRegister, pvar_func_drvScalerSoftRegister,
    pvar_func_drvUSBCTRRegister, pvar_func_editSseqRegistrar,
    pvar_func_fastSweepRegister, pvar_func_interpRegister,
    pvar_func_rsrvRegistrar, pvar_func_saveDataRegistrar,
    pvar_func_save_restoreRegister, pvar_func_subAveRegister,
    pvar_func_syncInitialize, pvar_func_tsInitialize,
    pvar_func_utagInitialize;

epicsShareExtern int * const pvar_int_CASDEBUG;
epicsShareExtern int * const pvar_int_aCalcAsyncThreshold;
epicsShareExtern int * const pvar_int_aCalcLoopMax;
epicsShareExtern int * const pvar_int_aCalcMonitorMem_debug;
epicsShareExtern int * const pvar_int_aCalcPerformDebug;
epicsShareExtern int * const pvar_int_aCalcPostfixDebug;
epicsShareExtern int * const pvar_int_aCalcoutRecordDebug;
epicsShareExtern int * const pvar_int_arrayTestDebug;
epicsShareExtern int * const pvar_int_asCaDebug;
epicsShareExtern int * const pvar_int_atExitDebug;
epicsShareExtern double * const pvar_double_boHIGHlimit;
epicsShareExtern int * const pvar_int_boHIGHprecision;
epicsShareExtern double * const pvar_double_calcoutODLYlimit;
epicsShareExtern int * const pvar_int_calcoutODLYprecision;
epicsShareExtern int * const pvar_int_callbackParallelThreadsDefault;
epicsShareExtern int * const pvar_int_configMenuDebug;
epicsShareExtern int * const pvar_int_dbAccessDebugPUTF;
epicsShareExtern int * const pvar_int_dbBptNotMonotonic;
epicsShareExtern int * const pvar_int_dbConvertStrict;
epicsShareExtern int * const pvar_int_dbJLinkDebug;
epicsShareExtern int * const pvar_int_dbQuietMacroWarnings;
epicsShareExtern int * const pvar_int_dbRecordsAbcSorted;
epicsShareExtern int * const pvar_int_dbRecordsOnceOnly;
epicsShareExtern int * const pvar_int_dbTemplateMaxVars;
epicsShareExtern int * const pvar_int_dbThreadRealtimeLock;
epicsShareExtern int * const pvar_int_debugSubAve;
epicsShareExtern int * const pvar_int_debug_saveData;
epicsShareExtern int * const pvar_int_debug_saveDataMsg;
epicsShareExtern int * const pvar_int_devaCalcoutSoftDebug;
epicsShareExtern int * const pvar_int_devsCalcoutSoftDebug;
epicsShareExtern int * const pvar_int_histogramSDELprecision;
epicsShareExtern int * const pvar_int_interpDebug;
epicsShareExtern int * const pvar_int_lnkDebug_debug;
epicsShareExtern int * const pvar_int_logClientDebug;
epicsShareExtern int * const pvar_int_mcaRecordDebug;
epicsShareExtern int * const pvar_int_recDynLinkDebug;
epicsShareExtern int * const pvar_int_recDynLinkQsize;
epicsShareExtern int * const pvar_int_sCalcLoopMax;
epicsShareExtern int * const pvar_int_sCalcPerformDebug;
epicsShareExtern int * const pvar_int_sCalcPostfixDebug;
epicsShareExtern int * const pvar_int_sCalcStackHW;
epicsShareExtern int * const pvar_int_sCalcStackLW;
epicsShareExtern int * const pvar_int_sCalcoutRecordDebug;
epicsShareExtern int * const pvar_int_saveData_MessagePolicy;
epicsShareExtern int * const pvar_int_save_restoreDatedBackupFiles;
epicsShareExtern int * const pvar_int_save_restoreDebug;
epicsShareExtern int * const pvar_int_save_restoreIncompleteSetsOk;
epicsShareExtern int * const pvar_int_save_restoreNumSeqFiles;
epicsShareExtern int * const pvar_int_save_restoreRemountThreshold;
epicsShareExtern int * const pvar_int_save_restoreSeqPeriodInSeconds;
epicsShareExtern int * const pvar_int_scalerRecordDebug;
epicsShareExtern int * const pvar_int_scaler_wait_time;
epicsShareExtern int * const pvar_int_scanparmRecordDebug;
epicsShareExtern double * const pvar_double_seqDLYlimit;
epicsShareExtern int * const pvar_int_seqDLYprecision;
epicsShareExtern int * const pvar_int_sscanRecordConnectWaitSeconds;
epicsShareExtern int * const pvar_int_sscanRecordDebug;
epicsShareExtern int * const pvar_int_sscanRecordDontCheckLimits;
epicsShareExtern int * const pvar_int_sscanRecordLookupTime;
epicsShareExtern int * const pvar_int_sscanRecordViewPos;
epicsShareExtern int * const pvar_int_sseqRecDebug;
epicsShareExtern int * const pvar_int_swaitRecordDebug;
epicsShareExtern int * const pvar_int_transformRecordDebug;

static struct iocshVarDef vardefs[] = {
    {"CASDEBUG", iocshArgInt, pvar_int_CASDEBUG},
    {"aCalcAsyncThreshold", iocshArgInt, pvar_int_aCalcAsyncThreshold},
    {"aCalcLoopMax", iocshArgInt, pvar_int_aCalcLoopMax},
    {"aCalcMonitorMem_debug", iocshArgInt, pvar_int_aCalcMonitorMem_debug},
    {"aCalcPerformDebug", iocshArgInt, pvar_int_aCalcPerformDebug},
    {"aCalcPostfixDebug", iocshArgInt, pvar_int_aCalcPostfixDebug},
    {"aCalcoutRecordDebug", iocshArgInt, pvar_int_aCalcoutRecordDebug},
    {"arrayTestDebug", iocshArgInt, pvar_int_arrayTestDebug},
    {"asCaDebug", iocshArgInt, pvar_int_asCaDebug},
    {"atExitDebug", iocshArgInt, pvar_int_atExitDebug},
    {"boHIGHlimit", iocshArgDouble, pvar_double_boHIGHlimit},
    {"boHIGHprecision", iocshArgInt, pvar_int_boHIGHprecision},
    {"calcoutODLYlimit", iocshArgDouble, pvar_double_calcoutODLYlimit},
    {"calcoutODLYprecision", iocshArgInt, pvar_int_calcoutODLYprecision},
    {"callbackParallelThreadsDefault", iocshArgInt, pvar_int_callbackParallelThreadsDefault},
    {"configMenuDebug", iocshArgInt, pvar_int_configMenuDebug},
    {"dbAccessDebugPUTF", iocshArgInt, pvar_int_dbAccessDebugPUTF},
    {"dbBptNotMonotonic", iocshArgInt, pvar_int_dbBptNotMonotonic},
    {"dbConvertStrict", iocshArgInt, pvar_int_dbConvertStrict},
    {"dbJLinkDebug", iocshArgInt, pvar_int_dbJLinkDebug},
    {"dbQuietMacroWarnings", iocshArgInt, pvar_int_dbQuietMacroWarnings},
    {"dbRecordsAbcSorted", iocshArgInt, pvar_int_dbRecordsAbcSorted},
    {"dbRecordsOnceOnly", iocshArgInt, pvar_int_dbRecordsOnceOnly},
    {"dbTemplateMaxVars", iocshArgInt, pvar_int_dbTemplateMaxVars},
    {"dbThreadRealtimeLock", iocshArgInt, pvar_int_dbThreadRealtimeLock},
    {"debugSubAve", iocshArgInt, pvar_int_debugSubAve},
    {"debug_saveData", iocshArgInt, pvar_int_debug_saveData},
    {"debug_saveDataMsg", iocshArgInt, pvar_int_debug_saveDataMsg},
    {"devaCalcoutSoftDebug", iocshArgInt, pvar_int_devaCalcoutSoftDebug},
    {"devsCalcoutSoftDebug", iocshArgInt, pvar_int_devsCalcoutSoftDebug},
    {"histogramSDELprecision", iocshArgInt, pvar_int_histogramSDELprecision},
    {"interpDebug", iocshArgInt, pvar_int_interpDebug},
    {"lnkDebug_debug", iocshArgInt, pvar_int_lnkDebug_debug},
    {"logClientDebug", iocshArgInt, pvar_int_logClientDebug},
    {"mcaRecordDebug", iocshArgInt, pvar_int_mcaRecordDebug},
    {"recDynLinkDebug", iocshArgInt, pvar_int_recDynLinkDebug},
    {"recDynLinkQsize", iocshArgInt, pvar_int_recDynLinkQsize},
    {"sCalcLoopMax", iocshArgInt, pvar_int_sCalcLoopMax},
    {"sCalcPerformDebug", iocshArgInt, pvar_int_sCalcPerformDebug},
    {"sCalcPostfixDebug", iocshArgInt, pvar_int_sCalcPostfixDebug},
    {"sCalcStackHW", iocshArgInt, pvar_int_sCalcStackHW},
    {"sCalcStackLW", iocshArgInt, pvar_int_sCalcStackLW},
    {"sCalcoutRecordDebug", iocshArgInt, pvar_int_sCalcoutRecordDebug},
    {"saveData_MessagePolicy", iocshArgInt, pvar_int_saveData_MessagePolicy},
    {"save_restoreDatedBackupFiles", iocshArgInt, pvar_int_save_restoreDatedBackupFiles},
    {"save_restoreDebug", iocshArgInt, pvar_int_save_restoreDebug},
    {"save_restoreIncompleteSetsOk", iocshArgInt, pvar_int_save_restoreIncompleteSetsOk},
    {"save_restoreNumSeqFiles", iocshArgInt, pvar_int_save_restoreNumSeqFiles},
    {"save_restoreRemountThreshold", iocshArgInt, pvar_int_save_restoreRemountThreshold},
    {"save_restoreSeqPeriodInSeconds", iocshArgInt, pvar_int_save_restoreSeqPeriodInSeconds},
    {"scalerRecordDebug", iocshArgInt, pvar_int_scalerRecordDebug},
    {"scaler_wait_time", iocshArgInt, pvar_int_scaler_wait_time},
    {"scanparmRecordDebug", iocshArgInt, pvar_int_scanparmRecordDebug},
    {"seqDLYlimit", iocshArgDouble, pvar_double_seqDLYlimit},
    {"seqDLYprecision", iocshArgInt, pvar_int_seqDLYprecision},
    {"sscanRecordConnectWaitSeconds", iocshArgInt, pvar_int_sscanRecordConnectWaitSeconds},
    {"sscanRecordDebug", iocshArgInt, pvar_int_sscanRecordDebug},
    {"sscanRecordDontCheckLimits", iocshArgInt, pvar_int_sscanRecordDontCheckLimits},
    {"sscanRecordLookupTime", iocshArgInt, pvar_int_sscanRecordLookupTime},
    {"sscanRecordViewPos", iocshArgInt, pvar_int_sscanRecordViewPos},
    {"sseqRecDebug", iocshArgInt, pvar_int_sseqRecDebug},
    {"swaitRecordDebug", iocshArgInt, pvar_int_swaitRecordDebug},
    {"transformRecordDebug", iocshArgInt, pvar_int_transformRecordDebug},
    {NULL, iocshArgInt, NULL}
};

int USB1608G_2AO_V2_registerRecordDeviceDriver(DBBASE *pbase)
{
    static int executed = 0;
    const char *bldTop = "/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2";
    const char *envTop = getenv("TOP");

    if (envTop && strcmp(envTop, bldTop)) {
        printf("Warning: IOC is booting with TOP = \"%s\"\n"
               "          but was built with TOP = \"%s\"\n",
               envTop, bldTop);
    }

    if (!pbase) {
        printf("pdbbase is NULL; you must load a DBD file first.\n");
        return -1;
    }

    if (executed) {
        printf("Warning: Registration already done.\n");
    }
    executed = 1;

    registerRecordTypes(pbase, NELEMENTS(rtl), recordTypeNames, rtl);
    registerDevices(pbase, NELEMENTS(devsl), deviceSupportNames, devsl);
    registerDrivers(pbase, NELEMENTS(drvsl), driverSupportNames, drvsl);
    registerJLinks(pbase, NELEMENTS(jlifsl), jlifsl);
    runRegistrarOnce(pvar_func_Scaler974Register);
    runRegistrarOnce(pvar_func_ThresholdLogicRegister);
    runRegistrarOnce(pvar_func_USBCTR_SNLRegistrar);
    runRegistrarOnce(pvar_func_aCalcMonitorMemRegister);
    runRegistrarOnce(pvar_func_acalcTotalAllocatedMemoryRegister);
    runRegistrarOnce(pvar_func_arrInitialize);
    runRegistrarOnce(pvar_func_arrayTestRegister);
    runRegistrarOnce(pvar_func_asInitHooksRegister);
    runRegistrarOnce(pvar_func_asSub);
    runRegistrarOnce(pvar_func_asynInterposeDelayRegister);
    runRegistrarOnce(pvar_func_asynInterposeEchoRegister);
    runRegistrarOnce(pvar_func_asynInterposeEosRegister);
    runRegistrarOnce(pvar_func_asynInterposeFlushRegister);
    runRegistrarOnce(pvar_func_asynRegister);
    runRegistrarOnce(pvar_func_configMenuRegistrar);
    runRegistrarOnce(pvar_func_dbndInitialize);
    runRegistrarOnce(pvar_func_dbrestoreRegister);
    runRegistrarOnce(pvar_func_decInitialize);
    runRegistrarOnce(pvar_func_drvMultiFunctionRegister);
    runRegistrarOnce(pvar_func_drvScalerSoftRegister);
    runRegistrarOnce(pvar_func_drvUSBCTRRegister);
    runRegistrarOnce(pvar_func_editSseqRegistrar);
    runRegistrarOnce(pvar_func_fastSweepRegister);
    runRegistrarOnce(pvar_func_interpRegister);
    runRegistrarOnce(pvar_func_rsrvRegistrar);
    runRegistrarOnce(pvar_func_saveDataRegistrar);
    runRegistrarOnce(pvar_func_save_restoreRegister);
    runRegistrarOnce(pvar_func_subAveRegister);
    runRegistrarOnce(pvar_func_syncInitialize);
    runRegistrarOnce(pvar_func_tsInitialize);
    runRegistrarOnce(pvar_func_utagInitialize);
    iocshRegisterVariable(vardefs);
    return 0;
}

/* USB1608G_2AO_V2_registerRecordDeviceDriver */
static const iocshArg rrddArg0 = {"pdbbase", iocshArgPdbbase};
static const iocshArg *rrddArgs[] = {&rrddArg0};
static const iocshFuncDef rrddFuncDef = {
    "USB1608G_2AO_V2_registerRecordDeviceDriver",
    1,
    rrddArgs,
    "Register the various records, devices, for this DBD.\n\n"
    "These are registered into the database given as first argument,\n"
    "which should always be 'pdbbase'.\n\n"
    "Example: USB1608G_2AO_V2_registerRecordDeviceDriver pdbbase\n",
};
static void rrddCallFunc(const iocshArgBuf *)
{
    iocshSetError(USB1608G_2AO_V2_registerRecordDeviceDriver(*iocshPpdbbase));
}

} // extern "C"

/*
 * Register commands on application startup
 */
static int Registration() {
    iocshRegisterCommon();
    iocshRegister(&rrddFuncDef, rrddCallFunc);
    return 0;
}

static int done EPICS_UNUSED = Registration();











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.c
=================================================
/* C code for program USBCTR_SNL, generated by snc from ../USBCTR_SNL.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 17 "../USBCTR_SNL.st"
#include <stdlib.h>
# line 18 "../USBCTR_SNL.st"
#include <errlog.h>
# line 19 "../USBCTR_SNL.st"
#include <string.h>
# line 36 "../USBCTR_SNL.st"
static const EF_ID ReadArraysMon = 1;
# line 39 "../USBCTR_SNL.st"
static const EF_ID HardwareAcquiringMon = 2;

/* Variable declarations */
struct seqg_vars {
# line 24 "../USBCTR_SNL.st"
	int i;
# line 25 "../USBCTR_SNL.st"
	int n;
# line 26 "../USBCTR_SNL.st"
	int numCounters;
# line 27 "../USBCTR_SNL.st"
	char temp[100];
# line 29 "../USBCTR_SNL.st"
	char *prefix;
# line 30 "../USBCTR_SNL.st"
	char *record;
# line 31 "../USBCTR_SNL.st"
	char *field;
# line 33 "../USBCTR_SNL.st"
	int ReadArray[9];
# line 35 "../USBCTR_SNL.st"
	int ReadArrays;
# line 38 "../USBCTR_SNL.st"
	int HardwareAcquiring;
# line 41 "../USBCTR_SNL.st"
	int MCSAbsTimeWF;
# line 43 "../USBCTR_SNL.st"
	int SNL_Connected;
# line 44 "../USBCTR_SNL.st"
	int AsynDebug;
# line 47 "../USBCTR_SNL.st"
	int Acquiring;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "mca_control" ******/

/* Event function for state "init" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "mca_control" */
static void seqg_action_mca_control_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 52 "../USBCTR_SNL.st"
			seqg_var->prefix = seq_macValueGet(seqg_env, "P");
# line 53 "../USBCTR_SNL.st"
			seqg_var->record = seq_macValueGet(seqg_env, "R");
# line 54 "../USBCTR_SNL.st"
			seqg_var->field = seq_macValueGet(seqg_env, "FIELD");
# line 55 "../USBCTR_SNL.st"
			seqg_var->numCounters = atoi(seq_macValueGet(seqg_env, "NUM_COUNTERS"));
# line 56 "../USBCTR_SNL.st"
			if ((seqg_var->numCounters <= 0) || (seqg_var->numCounters > 9))
			{
# line 57 "../USBCTR_SNL.st"
				printf("NUM_COUNTERS is illegal.\n");
# line 58 "../USBCTR_SNL.st"
				seqg_var->numCounters = 0;
			}
# line 60 "../USBCTR_SNL.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
			{
# line 61 "../USBCTR_SNL.st"
				seqg_var->n = seqg_var->i + 1;
# line 62 "../USBCTR_SNL.st"
				sprintf(seqg_var->temp, "%s%s%d.%s", seqg_var->prefix, seqg_var->record, seqg_var->n, seqg_var->field);
# line 63 "../USBCTR_SNL.st"
				seq_pvAssign(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), seqg_var->temp);
			}
		}
		return;
	}
}

/****** Code for state "waitConnected" in state set "mca_control" ******/

/* Event function for state "waitConnected" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_waitConnected(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 69 "../USBCTR_SNL.st"
	if (seqg_var->numCounters <= 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 73 "../USBCTR_SNL.st"
	if (seq_pvAssignCount(seqg_env) == seq_pvConnectCount(seqg_env))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitConnected" in state set "mca_control" */
static void seqg_action_mca_control_0_waitConnected(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 70 "../USBCTR_SNL.st"
			printf(">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
		}
		return;
	case 1:
		{
# line 74 "../USBCTR_SNL.st"
			printf("USBCTR: All channels connected.\n");
# line 75 "../USBCTR_SNL.st"
			seqg_var->SNL_Connected = 1;
# line 76 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 12/*SNL_Connected*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "dead" in state set "mca_control" ******/

/* Event function for state "dead" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_dead(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 81 "../USBCTR_SNL.st"
	if (seq_delay(seqg_env, 3600.0))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "dead" in state set "mca_control" */
static void seqg_action_mca_control_0_dead(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "monitor_changes" in state set "mca_control" ******/

/* Event function for state "monitor_changes" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_monitor_changes(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 86 "../USBCTR_SNL.st"
	if (seq_pvAssignCount(seqg_env) != seq_pvConnectCount(seqg_env))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 90 "../USBCTR_SNL.st"
	if (seq_efTestAndClear(seqg_env, ReadArraysMon) && (seqg_var->ReadArrays == 1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 102 "../USBCTR_SNL.st"
	if (seq_efTestAndClear(seqg_env, HardwareAcquiringMon))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_changes" in state set "mca_control" */
static void seqg_action_mca_control_0_monitor_changes(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 87 "../USBCTR_SNL.st"
			printf("USBCTR: Not all channels connected.\n");
		}
		return;
	case 1:
		{
# line 91 "../USBCTR_SNL.st"
			if (seqg_var->AsynDebug)
# line 91 "../USBCTR_SNL.st"
				printf("USBCTR.st: Read array data\n");
# line 92 "../USBCTR_SNL.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
			{
# line 93 "../USBCTR_SNL.st"
				seqg_var->ReadArray[seqg_var->i] = 1;
# line 94 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 96 "../USBCTR_SNL.st"
			seqg_var->MCSAbsTimeWF = 1;
# line 97 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 11/*MCSAbsTimeWF*/, DEFAULT, DEFAULT_TIMEOUT);
# line 98 "../USBCTR_SNL.st"
			seqg_var->ReadArrays = 0;
# line 99 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 9/*ReadArrays*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 103 "../USBCTR_SNL.st"
			if (seqg_var->AsynDebug)
# line 103 "../USBCTR_SNL.st"
				printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", seqg_var->HardwareAcquiring);
# line 105 "../USBCTR_SNL.st"
			if (!seqg_var->HardwareAcquiring)
			{
# line 107 "../USBCTR_SNL.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
				{
# line 108 "../USBCTR_SNL.st"
					seqg_var->ReadArray[seqg_var->i] = 1;
# line 109 "../USBCTR_SNL.st"
					seq_pvPutTmo(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
				}
# line 111 "../USBCTR_SNL.st"
				seqg_var->MCSAbsTimeWF = 1;
# line 112 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 11/*MCSAbsTimeWF*/, DEFAULT, DEFAULT_TIMEOUT);
# line 114 "../USBCTR_SNL.st"
				seqg_var->Acquiring = 0;
# line 115 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 14/*Acquiring*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"", offsetof(struct seqg_vars, ReadArray[0]), "ReadArray[0]", P_INT, 1, 3, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[1]), "ReadArray[1]", P_INT, 1, 4, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[2]), "ReadArray[2]", P_INT, 1, 5, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[3]), "ReadArray[3]", P_INT, 1, 6, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[4]), "ReadArray[4]", P_INT, 1, 7, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[5]), "ReadArray[5]", P_INT, 1, 8, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[6]), "ReadArray[6]", P_INT, 1, 9, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[7]), "ReadArray[7]", P_INT, 1, 10, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[8]), "ReadArray[8]", P_INT, 1, 11, 0, 0, 0, 0},
	{"{P}DoReadAll", offsetof(struct seqg_vars, ReadArrays), "ReadArrays", P_INT, 1, 12, 1, 1, 0, 0},
	{"{P}HardwareAcquiring", offsetof(struct seqg_vars, HardwareAcquiring), "HardwareAcquiring", P_INT, 1, 13, 2, 1, 0, 0},
	{"{P}AbsTimeWF.PROC", offsetof(struct seqg_vars, MCSAbsTimeWF), "MCSAbsTimeWF", P_INT, 1, 14, 0, 0, 0, 0},
	{"{P}SNL_Connected", offsetof(struct seqg_vars, SNL_Connected), "SNL_Connected", P_INT, 1, 15, 0, 0, 0, 0},
	{"{P}Asyn.TB1", offsetof(struct seqg_vars, AsynDebug), "AsynDebug", P_INT, 1, 16, 0, 1, 0, 0},
	{"{P}Acquiring", offsetof(struct seqg_vars, Acquiring), "Acquiring", P_INT, 1, 17, 0, 0, 0, 0},
};

/* Event masks for state set "mca_control" */
static const seqMask seqg_mask_mca_control_0_init[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_waitConnected[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_dead[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_monitor_changes[] = {
	0x00001006,
};

/* State table for state set "mca_control" */
static seqState seqg_states_mca_control[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_mca_control_0_init,
	/* event function */    seqg_event_mca_control_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "waitConnected",
	/* action function */   seqg_action_mca_control_0_waitConnected,
	/* event function */    seqg_event_mca_control_0_waitConnected,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_waitConnected,
	/* state options */     (0)
	},
	{
	/* state name */        "dead",
	/* action function */   seqg_action_mca_control_0_dead,
	/* event function */    seqg_event_mca_control_0_dead,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_dead,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_changes",
	/* action function */   seqg_action_mca_control_0_monitor_changes,
	/* event function */    seqg_event_mca_control_0_monitor_changes,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_monitor_changes,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "mca_control",
	/* states */            seqg_states_mca_control,
	/* number of states */  4
	},
};

/* Program table (global) */
seqProgram USBCTR_SNL = {
	/* magic number */      2002009,
	/* program name */      "USBCTR_SNL",
	/* channels */          seqg_chans,
	/* num. channels */     15,
	/* state sets */        seqg_statesets,
	/* num. state sets */   1,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ",
	/* num. event flags */  2,
	/* encoded options */   (0 | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};

/* Register sequencer commands and program */
#include "epicsExport.h"
static void USBCTR_SNLRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&USBCTR_SNL);
}
epicsExportRegistrar(USBCTR_SNLRegistrar);











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2.dbd.d
=================================================
../O.Common/USB1608G_2AO_V2.dbd: /usr/local/epics/EPICS_R7.0/base/dbd/base.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuGlobal.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmSevr.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmStat.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuFtype.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuIvoa.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuOmsl.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPini.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPost.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPriority.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuYesNo.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuSimm.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuConvert.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuScan.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stdRecords.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aaiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dbCommon.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aaoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aSubRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/biRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/boRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/calcRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/calcoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/compressRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dfanoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/eventRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/fanoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/histogramRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/int64inRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/int64outRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/longinRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/longoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/lsiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/lsoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbbiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbbiDirectRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbboRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbboDirectRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/permissiveRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/printfRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/selRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/seqRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stateRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stringinRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stringoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/subRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/subArrayRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/waveformRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/filters.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/links.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/devSoft.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/asSub.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dbCore.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/rsrv.dbd \
    /usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2/dbd/measCompApp.dbd \
    ../measCompSupport.dbd \
    ../thresholdLogicSupport.dbd

/usr/local/epics/EPICS_R7.0/base/dbd/base.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuGlobal.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmSevr.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmStat.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuFtype.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuIvoa.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuOmsl.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPini.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPost.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPriority.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuYesNo.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuSimm.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuConvert.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuScan.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stdRecords.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aaiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dbCommon.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aaoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aSubRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/biRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/boRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/calcRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/calcoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/compressRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dfanoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/eventRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/fanoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/histogramRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/int64inRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/int64outRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/longinRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/longoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/lsiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/lsoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbbiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbbiDirectRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbboRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbboDirectRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/permissiveRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/printfRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/selRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/seqRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stateRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stringinRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stringoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/subRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/subArrayRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/waveformRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/filters.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/links.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/devSoft.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/asSub.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dbCore.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/rsrv.dbd:
/usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2/dbd/measCompApp.dbd:
../measCompSupport.dbd:
../thresholdLogicSupport.dbd:
../O.Common/USB1608G_2AO_V2.dbd: ../Makefile











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.i
=================================================
# 0 "../USBCTR_SNL.st"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "../USBCTR_SNL.st"
program USBCTR_SNL("P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ")
# 11 "../USBCTR_SNL.st"
option +r;



option -c;

%%#include <stdlib.h>
%%#include <errlog.h>
%%#include <string.h>




int i;
int n;
int numCounters;
char temp[100];

char *prefix;
char *record;
char *field;

int ReadArray[9];
assign ReadArray to {};
int ReadArrays; assign ReadArrays to "{P}DoReadAll";
monitor ReadArrays; evflag ReadArraysMon; sync ReadArrays ReadArraysMon;

int HardwareAcquiring; assign HardwareAcquiring to "{P}HardwareAcquiring";
monitor HardwareAcquiring; evflag HardwareAcquiringMon; sync HardwareAcquiring HardwareAcquiringMon;

int MCSAbsTimeWF; assign MCSAbsTimeWF to "{P}AbsTimeWF.PROC";

int SNL_Connected; assign SNL_Connected to "{P}SNL_Connected";
int AsynDebug; assign AsynDebug to "{P}Asyn.TB1";
monitor AsynDebug;

int Acquiring; assign Acquiring to "{P}Acquiring";

ss mca_control {
  state init {
    when() {
      prefix = macValueGet("P");
      record = macValueGet("R");
      field = macValueGet("FIELD");
      numCounters = atoi(macValueGet("NUM_COUNTERS"));
      if ((numCounters <= 0) || (numCounters > 9)) {
        printf ("NUM_COUNTERS is illegal.\n");
        numCounters = 0;
      }
      for (i=0; i<numCounters; i++) {
        n = i+1;
        sprintf(temp, "%s%s%d.%s", prefix, record, n, field);
        pvAssign(ReadArray[i], temp);
       }
    } state waitConnected
  }

  state waitConnected {
    when (numCounters <= 0) {
      printf (">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
    } state dead

    when (pvAssignCount () == pvConnectCount ()) {
      printf ("USBCTR: All channels connected.\n");
      SNL_Connected = 1;
      pvPut(SNL_Connected);
    } state monitor_changes
  }

  state dead {
    when (delay (3600.0)) {
    } state dead
  }

  state monitor_changes {
    when (pvAssignCount () != pvConnectCount ()) {
      printf ("USBCTR: Not all channels connected.\n");
    } state waitConnected

    when(efTestAndClear(ReadArraysMon) && (ReadArrays == 1)) {
      if (AsynDebug) printf("USBCTR.st: Read array data\n");
      for (i=0; i<numCounters; i++) {
        ReadArray[i] = 1;
        pvPut(ReadArray[i]);
      }
      MCSAbsTimeWF = 1;
      pvPut(MCSAbsTimeWF);
      ReadArrays = 0;
      pvPut(ReadArrays);
    } state monitor_changes

    when(efTestAndClear(HardwareAcquiringMon)) {
      if (AsynDebug) printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", HardwareAcquiring);

      if (!HardwareAcquiring) {

        for (i=0; i<numCounters; i++) {
          ReadArray[i] = 1;
          pvPut(ReadArray[i], SYNC);
        }
        MCSAbsTimeWF = 1;
        pvPut(MCSAbsTimeWF);

        Acquiring = 0;
        pvPut(Acquiring);
      }
    } state monitor_changes
  }
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.st.d
=================================================
# DO NOT EDIT: This file created by mkmf.pl














ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.d
=================================================
USB1608G_2AO_V2Main.o: ../USB1608G_2AO_V2Main.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExit.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/Makefile
=================================================
#This Makefile created by makeMakefile.pl


all :
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

.DEFAULT: force
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

force:  ;











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.d
=================================================
drvUSBCTR.o: ../drvUSBCTR.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/mca-R7-10/include/drvMca.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/scaler-4-1/include/devScalerAsyn.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 ../measCompDiscover.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.d
=================================================
drvMultiFunction.o: ../drvMultiFunction.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 ../measCompDiscover.h











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.o
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/threshold_logic.template
=================================================
# ThresholdLogic.template
# EPICS ë°ì´í„°ë² ì´ìŠ¤ í…œí”Œë¦¿ - ì„ê³„ê°’ ê¸°ë°˜ ë¡œì§ ì œì–´
# ë§¤ê°œë³€ìˆ˜:
#   P     - PV ì ‘ë‘ì‚¬ (ì˜ˆ: "USB1608G_2AO_cpp:")
#   R     - ë ˆì½”ë“œ ì´ë¦„ ì ‘ë¯¸ì‚¬ (ì˜ˆ: "ThresholdLogic")
#   PORT  - asyn í¬íŠ¸ ì´ë¦„
#   ADDR  - asyn ì£¼ì†Œ (ê¸°ë³¸ê°’: 0)
#   PREC  - ì†Œìˆ˜ì  ìë¦¿ìˆ˜ (ê¸°ë³¸ê°’: 3)
#   EGU   - ì—”ì§€ë‹ˆì–´ë§ ë‹¨ìœ„ (ê¸°ë³¸ê°’: "V")
#   SCAN  - ìŠ¤ìº” ì£¼ê¸° (ê¸°ë³¸ê°’: "1 second")

# ì„ê³„ê°’ ì„¤ì • ë ˆì½”ë“œ (ì•„ë‚ ë¡œê·¸ ì¶œë ¥)
record(ao, "$(P)$(R)Threshold") {
    field(DESC, "Threshold Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))THRESHOLD_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(THRESHOLD=0.0)")
    field(DRVL, "$(DRVL=-10.0)")
    field(DRVH, "$(DRVH=10.0)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
}

# íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì„¤ì • ë ˆì½”ë“œ (ì•„ë‚ ë¡œê·¸ ì¶œë ¥)
record(ao, "$(P)$(R)Hysteresis") {
    field(DESC, "Hysteresis Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))HYSTERESIS_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(HYSTERESIS=0.1)")
    field(DRVL, "0.0")
    field(DRVH, "1.0")
    field(LOPR, "0.0")
    field(HOPR, "1.0")
}

# í˜„ì¬ ê°’ ëª¨ë‹ˆí„°ë§ ë ˆì½”ë“œ (ì‹¤ì œ ì•„ë‚ ë¡œê·¸ ì…ë ¥ ì±„ë„ì—ì„œ ê°’ ì½ê¸°)
record(ai, "$(P)$(R)CurrentValue") {
    field(DESC, "Current Input Value from $(IN_CH)")
    field(INP,  "$(P)$(IN_CH) CP")
    field(SCAN, "Passive")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
    field(HIHI, "$(HIHI=9.0)")
    field(HIGH, "$(HIGH=8.0)")
    field(LOW,  "$(LOW=-8.0)")
    field(LOLO, "$(LOLO=-9.0)")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(LSV,  "MINOR")
    field(LLSV, "MAJOR")
    field(FLNK, "$(P)$(R)Compare")
}

# ì„ê³„ê°’ ë¹„êµ ê³„ì‚° ë ˆì½”ë“œ
record(calcout, "$(P)$(R)Compare") {
    field(DESC, "Threshold Comparison :  $(IN_CH) -> $(OUT_CH)")
    field(CALC, "A>=(B+C)?1:(A<=(B-C)?0:D)")
    field(INPA, "$(P)$(IN_CH) CP")
    field(INPB, "$(P)$(R)Threshold")
    field(INPC, "$(P)$(R)Hysteresis")
    field(INPD, "$(P)$(R)OutputState")
    field(OUT,  "$(P)$(OUT_CH) PP")
    field(OOPT, "Every Time")
    field(DOPT, "Use CALC")
    field(SCAN, "Passive")
}

# ì¶œë ¥ ìƒíƒœ ë ˆì½”ë“œ (ì‹¤ì œ ë°”ì´ë„ˆë¦¬ ì¶œë ¥ ì±„ë„ ìƒíƒœ ëª¨ë‹ˆí„°ë§)
record(bi, "$(P)$(R)OutputState") {
    field(DESC, "Current Output State of $(OUT_CH)")
    field(INP,  "$(P)$(OUT_CH) CP")
    field(SCAN, "Passive")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# í™œì„±í™” ì œì–´ ë ˆì½”ë“œ (ë°”ì´ë„ˆë¦¬ ì¶œë ¥)
record(bo, "$(P)$(R)Enable") {
    field(DESC, "Enable/Disable Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))ENABLE")
    field(PINI, "YES")
    field(VAL,  "$(ENABLE=0)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# ìƒíƒœ ëª¨ë‹ˆí„°ë§ ë ˆì½”ë“œ (ë‹¤ì¤‘ ë°”ì´ë„ˆë¦¬ ì…ë ¥)
record(mbbi, "$(P)$(R)Status") {
    field(DESC, "Threshold Logic Status")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))STATUS")
    field(SCAN, "I/O Intr")
    field(ZRST, "Idle")
    field(ONST, "Active")
    field(TWST, "Error")
    field(THST, "Disabled")
    field(ZRSV, "NO_ALARM")
    field(ONSV, "NO_ALARM")
    field(TWSV, "MAJOR")
    field(THSV, "NO_ALARM")
}

# ë¦¬ì…‹ ëª…ë ¹ ë ˆì½”ë“œ (ë°”ì´ë„ˆë¦¬ ì¶œë ¥)
record(bo, "$(P)$(R)Reset") {
    field(DESC, "Reset Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))RESET")
    field(ZNAM, "Normal")
    field(ONAM, "Reset")
    field(HIGH, "1")
    field(PINI, "NO")
}

# ì—…ë°ì´íŠ¸ ì£¼ê¸° ì„¤ì • ë ˆì½”ë“œ (ì•„ë‚ ë¡œê·¸ ì¶œë ¥)
record(ao, "$(P)$(R)UpdateRate") {
    field(DESC, "Update Rate in Hz")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))UPDATE_RATE")
    field(PREC, "1")
    field(EGU,  "Hz")
    field(PINI, "YES")
    field(VAL,  "$(UPDATE_RATE=10.0)")
    field(DRVL, "0.1")
    field(DRVH, "1000.0")
    field(LOPR, "0.1")
    field(HOPR, "1000.0")
}

# ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ ë ˆì½”ë“œ (ë¬¸ìì—´ ì…ë ¥)
record(stringin, "$(P)$(R)LastUpdate") {
    field(DESC, "Last Update Timestamp")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR=0))LAST_UPDATE")
    field(SCAN, "I/O Intr")
    field(VAL,  "Never")
}

# ì•ŒëŒ ìƒíƒœ ë ˆì½”ë“œ (ë°”ì´ë„ˆë¦¬ ì…ë ¥)
record(bi, "$(P)$(R)AlarmState") {
    field(DESC, "Alarm State")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))ALARM_STATE")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Normal")
    field(ONAM, "Alarm")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MAJOR")
}

# íŠ¸ë¦¬ê±° ì¹´ìš´í„° ë ˆì½”ë“œ (ë¡± ì…ë ¥)
record(longin, "$(P)$(R)TriggerCount") {
    field(DESC, "Number of Threshold Triggers")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))TRIGGER_COUNT")
    field(SCAN, "I/O Intr")
    field(EGU,  "counts")
}










ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompUSBTempConfig_settings.req
=================================================
$(P)$(R)TemperatureSensor
$(P)$(R)TemperatureWiring











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompMCSWaveform.template
=================================================
# Waveform record to be used for MCS data, rather than MCA record.

record(waveform, "$(P)$(R)") {
  field(DTYP, "asynInt32ArrayIn")
  field(INP,  "$(INP)MCA_DATA")
  field(FTVL, "LONG")
  field(NELM, "$(NUM_POINTS)")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompAnalogOut_settings.req
=================================================
$(P)$(R)Pulse
$(P)$(R)Range
$(P)$(R)TweakVal
$(P)$(R).DRVL
$(P)$(R).DRVH
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).EGUF
$(P)$(R).EGUL
$(P)$(R).PREC
$(P)$(R)Return.DRVL
$(P)$(R)Return.DRVH
$(P)$(R)Return.LOPR
$(P)$(R)Return.HOPR
$(P)$(R)Return.EGUF
$(P)$(R)Return.EGUL
$(P)$(R)Return.PREC











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompVoltageIn_settings.req
=================================================
$(P)$(R)Range
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).PREC
$(P)$(R).SCAN












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompWaveformGen.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longin, "$(P)$(R)NumPoints")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_NUM_POINTS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Number of points to use for user-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)UserNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Number of points to use for pre-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)IntNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Timebase waveform record for user waveforms                    #
###################################################################
record(waveform, "$(P)$(R)UserTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Timebase waveform record for predefined waveforms              #
###################################################################
record(waveform, "$(P)$(R)IntTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Waveform frequency                                             # 
###################################################################
record(ai, "$(P)$(R)Frequency")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_FREQ")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point readback, based on UserDwell or IntDwell        # 
###################################################################
record(ai, "$(P)$(R)Dwell")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

# Needed?
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Internal waveform dwell                                        # 
###################################################################
record(ao, "$(P)$(R)IntDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcIntFrequency")
}

###################################################################
#  Calculate internal frequency based on new dwell                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntFrequency")
{
    field(INPA, "$(P)$(R)IntDwell")
    field(INPB, "$(P)$(R)IntNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntDwell.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntFrequency PP MS")
}

###################################################################
#  Internal waveform frequency                                    # 
###################################################################
record(ao, "$(P)$(R)IntFrequency")
{
    field(PREC, "$(PREC)")
    field(OUT,  "$(P)$(R)CalcIntDwell PP MS")
}

###################################################################
#  Calculate internal dwell based on new frequency                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntDwell")
{
    field(INPA, "$(P)$(R)IntFrequency")
    field(INPB, "$(P)$(R)IntNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntFrequency.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntDwell PP MS")
}

###################################################################
#  User waveform dwell                                            # 
###################################################################
record(ao, "$(P)$(R)UserDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserFrequency")
}

###################################################################
#  Calculate user frequency based on new dwell                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserFrequency")
{
    field(INPA, "$(P)$(R)UserDwell")
    field(INPB, "$(P)$(R)UserNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserDwell.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserFrequency PP MS")
}

###################################################################
#  User waveform frequency                                        # 
###################################################################
record(ao, "$(P)$(R)UserFrequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserDwell PP MS")
}

###################################################################
#  Calculate user dwell based on new frequency                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserDwell")
{
    field(INPA, "$(P)$(R)UserFrequency")
    field(INPB, "$(P)$(R)UserNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserFrequency.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserDwell PP MS")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}













ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompMCS.template
=================================================
# measCompMCS.template
# Mark Rivers
# June 2, 2014

record(bi,"$(P)SNL_Connected") {
  field(ZNAM, "Not connected")
  field(ZSV,  "MAJOR")
  field(ONAM, "Connected")
  field(OSV,  "NO_ALARM")
}

record(bo,"$(P)EraseAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)EraseStart") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)StartAll.PROC")
}

record(bo,"$(P)StartAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_START_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Start")
  field(VAL,  "1")
  field(FLNK, "$(P)SetAcquiring.PROC")
}

record(bo,"$(P)SetAcquiring") {
  field(OUT,  "$(P)Acquiring PP MS")
  field(ZNAM, "Done")
  field(ONAM, "Set")
  field(VAL,  "1")
  field(FLNK, "$(P)SetClientWait.PROC")
}

record(busy,"$(P)Acquiring") {
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
}

record(bo,"$(P)StopAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_STOP_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Stop")
  field(VAL,  "1")
}

record(ao,"$(P)PresetReal") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESET_REAL")
  field(VAL,  "0.0")
  field(PREC, "3")
}

record(bi,"$(P)HardwareAcquiring") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCA_ACQUIRING")
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
  field(SCAN, "I/O Intr")
}

record(ai,"$(P)ElapsedReal") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_ELAPSED_REAL")
  field(PREC, "3")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ReadAll") {
  field(SCAN, "1 second")
  field(DISV, "0")
  field(SDIS, "$(P)Acquiring NPP NMS")
  field(ZNAM, "Done")
  field(ONAM, "Read")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)ReadAllOnce") {
  field(VAL,  "1")
  field(OUT,  "$(P)DoReadAll.VAL PP MS")
}

record(bo,"$(P)DoReadAll") {
  field(ZNAM, "Done")
  field(ONAM, "Read")
}

record(longout,"$(P)NuseAll") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_NUM_CHANNELS")
}

record(longin,"$(P)CurrentChannel") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_CURRENT_POINT")
  field(SCAN, "I/O Intr")
}

record(ao,"$(P)Dwell") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(VAL,  "0.1")
  field(PREC, "4")
}

record(ai,"$(P)Dwell_RBV") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(PREC, "4")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ChannelAdvance") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_CH_ADV_SOURCE")
  field(ZNAM, "Internal")
  field(ONAM, "External")
}

record(longout,"$(P)Prescale") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESCALE")
  field(VAL,  "1")
}

record(bo,"$(P)EnableClientWait") {
  field(PINI, "YES")
  field(ZNAM, "Disable")
  field(ONAM, "Enable")
}

record(bo,"$(P)SetClientWait") {
  field(DISV, "0")
  field(SDIS, "$(P)EnableClientWait NPP NMS")
  field(OMSL, "closed_loop")
  field(DOL,  "1")
  field(OUT,  "$(P)ClientWait PP MS")
  field(ONAM, "SetClientWait")
  field(ZNAM, "Done")
}

record(busy,"$(P)ClientWait") {
}

record(mbboDirect,"$(P)MCSCounterEnable") {
  field(PINI, "YES")
  field(DTYP, "asynUInt32Digital")
  field(OUT,  "@asynMask($(PORT),0,0xFFFFFFFF)MCS_COUNTER_ENABLE")
  field(VAL, "0x1FF")
}

record(bo, "$(P)MCSCounter1Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B0 PP")
}

record(bo, "$(P)MCSCounter2Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B1 PP")
}

record(bo, "$(P)MCSCounter3Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B2 PP")
}

record(bo, "$(P)MCSCounter4Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B3 PP")
}

record(bo, "$(P)MCSCounter5Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B4 PP")
}

record(bo, "$(P)MCSCounter6Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B5 PP")
}

record(bo, "$(P)MCSCounter7Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B6 PP")
}

record(bo, "$(P)MCSCounter8Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B7 PP")
}

record(bo, "$(P)MCSDIOEnable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B8 PP")
}

record(mbbo,"$(P)PrescaleCounter") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_PRESCALE_COUNTER")
  field(ZRVL, "0")
  field(ZRST, "CTR0")
  field(ONVL, "1")
  field(ONST, "CTR1")
  field(TWVL, "2")
  field(TWST, "CTR2")
  field(THVL, "3")
  field(THST, "CTR3")
  field(FRVL, "4")
  field(FRST, "CTR4")
  field(FVVL, "5")
  field(FVST, "CTR5")
  field(SXVL, "6")
  field(SXST, "CTR6")
  field(SVVL, "7")
  field(SVST, "CTR7")
}

record(mbbo,"$(P)Point0Action") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_POINT0_ACTION")
  field(ZRVL, "0")
  field(ZRST, "Clear")
  field(ONVL, "1")
  field(ONST, "No clear")
  field(TWVL, "2")
  field(TWST, "Skip")
}

record(longin,"$(P)MaxChannels") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_MAX_POINTS")
}

record(mbbi, "$(P)Model") {
  field(PINI, "YES")
  field(DESC, "Model")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT) 0)MODEL")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "USB-CTR08")
  field(ONST, "USB-CTR04")
}

record(mbbo,"$(P)TrigMode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TRIGGER_MODE")
    field(ZRVL, "0")
    field(ZRST, "Rising edge")
    field(ONVL, "1")
    field(ONST, "Falling edge")
    field(TWVL, "6")
    field(TWST, "High level")
    field(THVL, "7")
    field(THST, "Low level")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)MCS_ABS_TIME_WF")
    field(NELM, "$(MAX_POINTS)")
    field(SCAN, "I/O Intr")
}

# asyn record for debugging
record(asyn, "$(P)Asyn") {
  field(PORT, "$(PORT)")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompBinaryDir_settings.req
=================================================
$(P)$(R)











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompBinaryOut.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Direction record will process before this record during iocInit
    field(PHAS, "2")
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
}

record(bi, "$(P)$(R)_RBV")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/USB1608G_2AO_settings.req
=================================================
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd1
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd2
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd3
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd4
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd5
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd6
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd7
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd8
file "measCompPulseGen_settings.req",     P=$(P), R=PulseGen1
file "measCompAnalogInMode_settings.req", P=$(P), R=AiMode
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai1
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai2
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai3
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai4
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai5
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai6
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai7
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai8
file "measCompAnalogOut_settings.req",    P=$(P), R=Ao1
file "measCompAnalogOut_settings.req",    P=$(P), R=Ao2
file "measCompWaveformDig_settings.req",  P=$(P), R=WaveDig
file "measCompWaveformGen_settings.req",  P=$(P), R=WaveGen
file "measCompWaveformGenN_settings.req", P=$(P), R=WaveGen1
file "measCompWaveformGenN_settings.req", P=$(P), R=WaveGen2
file "measCompTrigger_settings.req",      P=$(P), R=Trig











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompWaveformGen_settings.req
=================================================
$(P)$(R)UserNumPoints
$(P)$(R)IntNumPoints
$(P)$(R)UserDwell
$(P)$(R)IntDwell
$(P)$(R)ExtTrigger
$(P)$(R)ExtClock
$(P)$(R)Continuous
$(P)$(R)Retrigger
$(P)$(R)TriggerCount











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompAnalogIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynInt32Average")
    field(INP,  "@asyn($(PORT),$(ADDR))ANALOG_IN_VALUE")
    field(LINR, "LINEAR")
    field(EGUF, "$(EGUF)")
    field(EGUL, "$(EGUL)")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RANGE")
    field(VAL,  "$(RANGE)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_TYPE")
}

record(ao,"$(P)$(R)Rate")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RATE")
    field(VAL,  "60")
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompWaveformDig_settings.req
=================================================
$(P)$(R)NumPoints
$(P)$(R)FirstChan
$(P)$(R)NumChans
$(P)$(R)Dwell
$(P)$(R)ExtTrigger
$(P)$(R)ExtClock
$(P)$(R)Continuous
$(P)$(R)AutoRestart
$(P)$(R)Retrigger
$(P)$(R)TriggerCount
$(P)$(R)BurstMode
$(P)$(R)ReadWF.SCAN











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions
=================================================
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompDevice.template"
{pattern {} {} }

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongIn.template"
{
pattern
{ R,   MASK, ADDR}
{Li,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryIn.template"
{
pattern
{ R,   MASK, ADDR}
{Bi1,  0x01     0}
{Bi2,  0x02     0}
{Bi3,  0x04     0}
{Bi4,  0x08     0}
{Bi5,  0x10     0}
{Bi6,  0x20     0}
{Bi7,  0x40     0}
{Bi8,  0x80     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongOut.template"
{
pattern
{ R,   MASK, ADDR}
{Lo,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryOut.template"
{
pattern
{ R,   MASK, ADDR}
{Bo1,  0x01     0}
{Bo2,  0x02     0}
{Bo3,  0x04     0}
{Bo4,  0x08     0}
{Bo5,  0x10     0}
{Bo6,  0x20     0}
{Bo7,  0x40     0}
{Bo8,  0x80     0}
}

# Direction bits on binary I/O
#  VAL 0=input, 1=output
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryDir.template"
{
pattern
{ R,   MASK,  VAL, ADDR}
{Bd1,  0x01    0,     0}
{Bd2,  0x02    0,     0}
{Bd3,  0x04    0,     0}
{Bd4,  0x08    0,     0}
{Bd5,  0x10    1,     0}
{Bd6,  0x20    1,     0}
{Bd7,  0x40    1,     0}
{Bd8,  0x80    1,     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompPulseGen.template"
{
pattern
{    R,      ADDR,  PREC}
{PulseGen1,     0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompCounter.template"
{
pattern
{    R,     ADDR}
{Counter1,     0}
{Counter2,     1}
}

# Analog input mode
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogInMode.template"
{
pattern
{  R,       ADDR,   MODE}
{AiMode,       0,      0}
}

# Analog inputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogIn.template"
{
pattern
{  R, ADDR, EGUL, LOPR, EGUF, HOPR,  RANGE,   SCAN,   PREC}
{Ai1,   0,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai2,   1,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai3,   2,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai4,   3,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai5,   4,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai6,   5,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai7,   6,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
{Ai8,   7,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
}

# Waveform digitzer
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDig.template"
{
pattern
{  R,     ADDR,  PREC}
{WaveDig,    0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDigN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveDig1,     0,      4}
{WaveDig2,     1,      4}
{WaveDig3,     2,      4}
{WaveDig4,     3,      4}
{WaveDig5,     4,      4}
{WaveDig6,     5,      4}
{WaveDig7,     6,      4}
{WaveDig8,     7,      4}
}


# Analog outputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogOut.template"
{
pattern
{ R,   VAL, ADDR, EGUL, DRVL, LOPR, EGUF, DRVH, HOPR, PREC}
{Ao1,   0,    0,  -10., -10., -10.,  10.,  10.,  10.,    4}
{Ao2,   0,    1,  -10., -10., -10.,  10.,  10.,  10.,    4}
}

# Waveform generator
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGen.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen,      0,      4}
}
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGenN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen1,     0,      4}
{WaveGen2,     1,      4}
}

# Trigger
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompTrigger.template"
{
pattern
{  R,   ADDR}
{Trig,     0}
}


# Threshold Logic Controller ì¸ìŠ¤í„´ìŠ¤
# ê° ì•„ë‚ ë¡œê·¸ ì…ë ¥ ì±„ë„ì— ëŒ€í•œ ì„ê³„ê°’ ë¡œì§ ì œì–´
# ThresholdLogic1: ai1 -> bo5
# ThresholdLogic2: ai2 -> bo6
# ThresholdLogic3: ai4 -> bo7
# ThresholdLogic4: ai5 -> bo8
file "$(TOP)/USB1608G_2AO_V2App/Db/threshold_logic.template"
{
pattern
{ R,               IN_CH,  OUT_CH, THRESHOLD, HYSTERESIS, ENABLE, UPDATE_RATE, PREC, EGU }
{ ThresholdLogic1, "Ai1",   "Bo5",     2.5,       0.1,        1,      10.0,        3,   "V" }
{ ThresholdLogic2, "Ai2",   "Bo6",     5.0,       0.2,        1,      10.0,        3,   "V" }
{ ThresholdLogic3, "Ai3",   "Bo7",     1.0,       0.05,       0,      5.0,         3,   "V" }
{ ThresholdLogic4, "Ai4",   "Bo8",     7.5,       0.3,        0,      20.0,        3,   "V" }
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompLongOut.template
=================================================
###################################################################
#  Binary output as longout                                       # 
###################################################################
record(longout, "$(P)$(R)")
{
    field(PINI, "$(PINI=NO)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
}

record(longin, "$(P)$(R)_RBV")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(SCAN, "I/O Intr")
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompTrigger.template
=================================================
record(mbbo,"$(P)$(R)Mode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TRIGGER_MODE")
    field(ZRVL, "12")
    field(ZRST, "Positive edge")
    field(ONVL, "13")
    field(ONST, "Negative edge")
    field(TWVL, "10")
    field(TWST, "High")
    field(THVL, "11")
    field(THST, "Low")
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompDevice.template
=================================================
# Device settings
record(stringin,"$(P)ModelName") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)MODEL_NAME")
}

record(longin,"$(P)ModelNumber") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT) 0)MODEL_NUMBER")
}

record(stringin,"$(P)FirmwareVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)FIRMWARE_VERSION")
}

record(stringin,"$(P)UniqueID") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UNIQUE_ID")
}

record(stringin,"$(P)ULVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UL_VERSION")
}

record(stringin,"$(P)DriverVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)DRIVER_VERSION")
}

record(ai,"$(P)PollTimeMS") {
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT) 0)POLL_TIME_MS")
    field(PREC, "1")
    field(SCAN, "I/O Intr")
}

record(ao,"$(P)PollSleepMS") {
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT) 0)POLL_SLEEP_MS")
    field(VAL,  "50")
    field(PREC, "1")
}

record(waveform, "$(P)LastErrorMessage") {
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)LAST_ERROR_MESSAGE")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompAnalogOut.template
=================================================
record(ao,"$(P)$(R)") {
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Range record will process before this record during iocInit
    field(PHAS, "2")
    field(DTYP, "asynInt32")
    field(FLNK, "$(P)$(R)Return.PROC  PP MS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_RANGE")
}

record(ao,"$(P)$(R)Return") {
    field(DTYP, "asynInt32")
    field(DISV, "0")
    field(SDIS, "$(P)$(R)Pulse.VAL  NPP NMS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(OMSL, "closed_loop")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

record(bo,"$(P)$(R)Pulse") {
    field(ZNAM, "Normal")
    field(ONAM, "Pulse")
}

record(ao,"$(P)$(R)TweakVal") {
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakUp") {
    field(CALC, "A+B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakDown") {
    field(CALC, "A-B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/user.substitutions
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompPulseGen_settings.req
=================================================
$(P)$(R)Period
$(P)$(R)Width
$(P)$(R)Delay
$(P)$(R)Count
$(P)$(R)IdleState
$(P)$(R)Run











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompAnalogInMode_settings.req
=================================================
$(P)$(R)












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompWaveformGenN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)UserWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayOut")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_WF")
    field(NELM, "$(WGEN_POINTS)")
}

###################################################################
#  Internally defined waveform record                             #
###################################################################
record(waveform, "$(P)$(R)InternalWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Enable this channel                                            # 
###################################################################
record(bo, "$(P)$(R)Enable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Waveform type                                                  # 
###################################################################
record(mbbo, "$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_WAVE_TYPE")
    field(ZRVL, "0")
    field(ZRST, "User-defined")
    field(ONVL, "1")
    field(ONST, "Sin wave")
    field(TWVL, "2")
    field(TWST, "Square wave")
    field(THVL, "3")
    field(THST, "Sawtooth")
    field(FRVL, "4")
    field(FRST, "Pulse")
    field(FVVL, "5")
    field(FVST, "Random")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)PulseWidth")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_PULSE_WIDTH")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}

###################################################################
#  Amplitude                                                      # 
###################################################################
record(ao, "$(P)$(R)Amplitude")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_AMPLITUDE")
    field(VAL,  "1.0")
    field(PREC, "4")
}

###################################################################
#  Offset                                                         # 
###################################################################
record(ao, "$(P)$(R)Offset")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_OFFSET")
    field(VAL,  "0.0")
    field(PREC, "4")
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompWaveformDig.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longout, "$(P)$(R)NumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WDIG_POINTS)")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)FirstChan")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_FIRST_CHAN")
    field(ZRVL, "0")
    field(ZRST, "1")
    field(ONVL, "1")
    field(ONST, "2")
    field(TWVL, "2")
    field(TWST, "3")
    field(THVL, "3")
    field(THST, "4")
    field(FRVL, "4")
    field(FRST, "5")
    field(FVVL, "5")
    field(FVST, "6")
    field(SXVL, "6")
    field(SXST, "7")
    field(SVVL, "7")
    field(SVST, "8")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)NumChans")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_CHANS")
    field(ZRVL, "1")
    field(ZRST, "1")
    field(ONVL, "2")
    field(ONST, "2")
    field(TWVL, "3")
    field(TWST, "3")
    field(THVL, "4")
    field(THST, "4")
    field(FRVL, "5")
    field(FRST, "5")
    field(FVVL, "6")
    field(FVST, "6")
    field(SXVL, "7")
    field(SXST, "7")
    field(SVVL, "8")
    field(SVST, "8")
}
###################################################################
#  Timebase waveform record                                       #
###################################################################
record(waveform, "$(P)$(R)TimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)$(R)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_ABS_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point                                                 # 
###################################################################
record(ao, "$(P)$(R)Dwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  One-shot / continuous                                          # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Auto restart                                                   # 
###################################################################
record(bo, "$(P)$(R)AutoRestart")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_AUTO_RESTART")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Burst mode                                                     # 
###################################################################
record(bo, "$(P)$(R)BurstMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_BURST_MODE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}

###################################################################
#  Read waveforms                                                 # 
###################################################################
# This tells the driver to read, which then does callbacks to the
# input waveform records which are I/O Intr scanned
# The driver always reads the waveforms when acquisition completes,
# so this record can be passive for fast scans
record(busy, "$(P)$(R)ReadWF")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_READ_WF")
    field(ZNAM, "Done")
    field(ONAM, "Read")
    field(SCAN, "1 second")
    field(SDIS, "$(P)$(R)Run")
    field(DISV, "0")
}













ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompUSBTempConfig.template
=================================================
# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)TemperatureSensor")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SENSOR")
}

record(mbbo,"$(P)$(R)TemperatureWiring")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_WIRING")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompLongIn.template
=================================================
record(longin, "$(P)$(R)")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompVoltageIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_VALUE")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_RANGE")
    field(VAL,  "$(RANGE)")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompWaveformDigN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)VoltWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_VOLT_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompCounter.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompMCS_settings.req
=================================================
$(P)PresetReal
$(P)Dwell
$(P)Prescale
$(P)ChannelAdvance
$(P)MCSCounter1Enable
$(P)MCSCounter2Enable
$(P)MCSCounter3Enable
$(P)MCSCounter4Enable
$(P)MCSCounter5Enable
$(P)MCSCounter6Enable
$(P)MCSCounter7Enable
$(P)MCSCounter8Enable
$(P)MCSDIOEnable
$(P)PrescaleCounter
$(P)Point0Action
$(P)ReadAll.SCAN
$(P)NuseAll
$(P)EnableClientWait
$(P)TrigMode











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompTrigger_settings.req
=================================================
$(P)$(R)Mode











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompBinaryIn.template
=================================================
record(bi, "$(P)$(R)")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/user.proto
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/Makefile
=================================================
TOP=../..
include $(TOP)/configure/CONFIG

#  Optimization of db files using dbst (DEFAULT: NO)
#DB_OPT = YES

#----------------------------------------------------
# Create and install (or just install)
# databases, templates, substitutions like this

DB += $(patsubst ../%, %, $(wildcard ../*.template))
DB += $(patsubst ../%, %, $(wildcard ../*.db))
DB += $(patsubst ../%, %, $(wildcard ../*.vdb))
DB += $(patsubst ../%, %, $(wildcard ../*.substitutions))

REQ += $(patsubst ../%, %, $(wildcard ../*.req))

#----------------------------------------------------
# If <anyname>.db template is not named <anyname>*.template add
# <anyname>_TEMPLATE = <templatename>

include $(TOP)/configure/RULES
#----------------------------------------
#  ADD RULES AFTER THIS LINE











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompPulseGen.template
=================================================
# This database is loaded for each pulse generator
# Mark Rivers
# July 26, 2011

###################################################################
#  Pulse start/stop                                               # 
###################################################################
record(bo, "$(P)$(R)Run")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_RUN")
    field(ZNAM, "Stop")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Run")
    field(OSV,  "MINOR")
}

# NOTE: The records for the period and the frequency are a bit
# complex because we want to be able to change either ao record
# and have the other one update

###################################################################
#  Pulse period                                                   # 
###################################################################
record(ao, "$(P)$(R)Period")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcFrequency")
}

record(ai, "$(P)$(R)Period_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate frequency based on new period                        # 
###################################################################
record(calcout, "$(P)$(R)CalcFrequency")
{
    field(INPA, "$(P)$(R)Period")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Frequency.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Frequency PP MS")
}

###################################################################
#  Pulse frequency                                                # 
###################################################################
record(ao, "$(P)$(R)Frequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcPeriod PP MS")
}

record(calc, "$(P)$(R)Frequency_RBV")
{
    field(INPA, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "1/A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate period based on new frequency                        # 
###################################################################
record(calcout, "$(P)$(R)CalcPeriod")
{
    field(INPA, "$(P)$(R)Frequency")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Period.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Period PP MS")
}

###################################################################
#  Pulse duty cycle                                               # 
###################################################################
record(ao, "$(P)$(R)DutyCycle")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(VAL,  "0.5")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcWidth")
}

record(ai, "$(P)$(R)DutyCycle_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate width based on new duty cycle                        # 
###################################################################
record(calcout, "$(P)$(R)CalcWidth")
{
    field(INPA, "$(P)$(R)DutyCycle")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A*B")
    field(SDIS, "$(P)$(R)Width.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Width PP MS")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)Width")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcDutyCycle PP MS")
}

record(calc, "$(P)$(R)Width_RBV")
{
    field(INPA, "$(P)$(R)DutyCycle_RBV CP MS")
    field(INPB, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "B*A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate duty cycle based on new width                        # 
###################################################################
record(calcout, "$(P)$(R)CalcDutyCycle")
{
    field(INPA, "$(P)$(R)Width")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A/B")
    field(SDIS, "$(P)$(R)DutyCycle.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)DutyCycle PP MS")
}

###################################################################
#  Pulse delay                                                    # 
###################################################################
record(ao, "$(P)$(R)Delay")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(VAL,  "0.")
    field(PREC, "$(PREC)")
}

record(ai, "$(P)$(R)Delay_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Pulse count                                                    # 
###################################################################
record(longout, "$(P)$(R)Count")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_COUNT")
}

###################################################################
#  Pulse idle state                                               # 
###################################################################
record(bo, "$(P)$(R)IdleState")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_IDLE_STATE")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(VAL,  "0")
}













ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompWaveformGenN_settings.req
=================================================
$(P)$(R)Enable
$(P)$(R)Type
$(P)$(R)PulseWidth
$(P)$(R)Amplitude
$(P)$(R)Offset











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompBinaryDir.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_DIRECTION")
    field(ZNAM, "In")
    field(ONAM, "Out")
    field(VAL,  "$(VAL)")
    field(PINI, "YES")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompTemperatureIn_settings.req
=================================================
$(P)$(R)Scale
$(P)$(R)TCType
$(P)$(R)OpenTCDetect
$(P)$(R)Filter
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).PREC
$(P)$(R).SCAN











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompTemperatureIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))TEMPERATURE_IN_VALUE")
    field(PREC, "$(PREC)")
}

record(mbbo,"$(P)$(R)Scale")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SCALE")
    field(ZRVL, "0")
    field(ZRST, "Celsius")
    field(ONVL, "1")
    field(ONST, "Fahrenheit")
    field(TWVL, "2")
    field(TWST, "Kelvin")
    field(THVL, "4")
    field(THST, "Volts")
    field(FRVL, "5")
    field(FRST, "Noscale")
}

record(mbbo,"$(P)$(R)TCType")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_TYPE")
    field(ZRVL, "1")
    field(ZRST, "Type J")
    field(ONVL, "2")
    field(ONST, "Type K")
    field(TWVL, "3")
    field(TWST, "Type T")
    field(THVL, "4")
    field(THST, "Type E")
    field(FRVL, "5")
    field(FRST, "Type R")
    field(FVVL, "6")
    field(FVST, "Type S")
    field(SXVL, "7")
    field(SXST, "Type B")
    field(SVVL, "8")
    field(SVST, "Type N")
}

record(mbbo,"$(P)$(R)Filter")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_FILTER")
    field(ZRVL, "0")
    field(ZRST, "Filter")
    field(ONVL, "0x400")
    field(ONST, "No filter")
}

record(bo,"$(P)$(R)OpenTCDetect")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_OPEN_DETECT")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompEncoder.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompAnalogIn_settings.req
=================================================
$(P)$(R)Range
$(P)$(R)Type
$(P)$(R)Rate
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).EGUF
$(P)$(R).EGUL
$(P)$(R).PREC
$(P)$(R).SCAN












ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/user.db
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/O.linux-x86_64/Makefile
=================================================
#This Makefile created by makeMakefile.pl


all :
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

.DEFAULT: force
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

force:  ;











ğŸ”¥ File: ./USB1608G_2AO_V2App/Db/measCompAnalogInMode.template
=================================================
record(mbbo,"$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_MODE")
    field(VAL,  "$(MODE)")
    field(ZRVL, "0")
    field(ZRST, "Differential")
    field(ONVL, "1")
    field(ONST, "Single-ended")
}











ğŸ”¥ File: ./USB1608G_2AO_V2App/Makefile
=================================================
# Makefile at top of application tree
TOP = ..
include $(TOP)/configure/CONFIG

# Directories to be built, in any order.
# You can replace these wildcards with an explicit list
DIRS += $(wildcard src* *Src*)
DIRS += $(wildcard db* *Db*)

# If the build order matters, add dependency rules like this,
# which specifies that xxxSrc must be built after src:
#xxxSrc_DEPEND_DIRS += src

include $(TOP)/configure/RULES_DIRS




















































ğŸŸ¦ 04_SUBDIRECTORY: bin
ğŸ“ tree -L 2 of bin/
./bin
â””â”€â”€ linux-x86_64
    â””â”€â”€ USB1608G_2AO_V2

1 directory, 1 file

ğŸ“„ All files under bin/:
./bin/linux-x86_64/USB1608G_2AO_V2

ğŸ“„ Contents of files under bin/:











ğŸ”¥ File: ./bin/linux-x86_64/USB1608G_2AO_V2
=================================================
[SKIPPED: binary or unreadable file]




















































ğŸŸ¦ 05_SUBDIRECTORY: configure
ğŸ“ tree -L 2 of configure/
./configure
â”œâ”€â”€ CONFIG
â”œâ”€â”€ CONFIG_SITE
â”œâ”€â”€ Makefile
â”œâ”€â”€ O.Common
â”œâ”€â”€ O.linux-x86_64
â”‚Â Â  â””â”€â”€ Makefile
â”œâ”€â”€ RELEASE
â”œâ”€â”€ RULES
â”œâ”€â”€ RULES.ioc
â”œâ”€â”€ RULES_DIRS
â””â”€â”€ RULES_TOP

2 directories, 9 files

ğŸ“„ All files under configure/:
./configure/CONFIG
./configure/CONFIG_SITE
./configure/Makefile
./configure/O.linux-x86_64/Makefile
./configure/RELEASE
./configure/RULES
./configure/RULES.ioc
./configure/RULES_DIRS
./configure/RULES_TOP

ğŸ“„ Contents of files under configure/:











ğŸ”¥ File: ./configure/RULES.ioc
=================================================
#RULES.ioc
include $(CONFIG)/RULES.ioc











ğŸ”¥ File: ./configure/RULES_TOP
=================================================
#RULES_TOP
include $(CONFIG)/RULES_TOP












ğŸ”¥ File: ./configure/Makefile
=================================================
TOP=..

include $(TOP)/configure/CONFIG

TARGETS = $(CONFIG_TARGETS)
CONFIGS += $(subst ../,,$(wildcard $(CONFIG_INSTALLS)))

include $(TOP)/configure/RULES











ğŸ”¥ File: ./configure/RULES
=================================================
# RULES

include $(CONFIG)/RULES

# Library should be rebuilt because LIBOBJS may have changed.
$(LIBNAME): ../Makefile











ğŸ”¥ File: ./configure/RELEASE
=================================================
# RELEASE - Location of external support modules

# EPICS_BASE should appear last so earlier modules can override stuff:
EPICS_BASE = /usr/local/epics/EPICS_R7.0/base

SUPPORT=/usr/local/epics/EPICS_R7.0/modules/synApps/support

ASYN=$(SUPPORT)/asyn-R4-44-2
CALC=$(SUPPORT)/calc-R3-7-5
SCALER=$(SUPPORT)/scaler-4-1
MCA=$(SUPPORT)/mca-R7-10
BUSY=$(SUPPORT)/busy-R1-7-4
SSCAN=$(SUPPORT)/sscan-R2-11-6
AUTOSAVE=$(SUPPORT)/autosave-R5-11
SNCSEQ=$(SUPPORT)/sequencer-mirror-R2-2-9
MEASCOMP=$(SUPPORT)/measComp-R4-2


# Set RULES here if you want to use build rules from somewhere
# other than EPICS_BASE:
#RULES = $(MODULES)/build-rules

# These lines allow developers to override these RELEASE settings
# without having to modify this file directly.
-include $(TOP)/../RELEASE.local
-include $(TOP)/../RELEASE.$(EPICS_HOST_ARCH).local
-include $(TOP)/configure/RELEASE.local











ğŸ”¥ File: ./configure/CONFIG
=================================================
# CONFIG - Load build configuration data
#
# Do not make changes to this file!

# Allow user to override where the build rules come from
RULES = $(EPICS_BASE)

# RELEASE files point to other application tops
include $(TOP)/configure/RELEASE
-include $(TOP)/configure/RELEASE.$(EPICS_HOST_ARCH).Common

ifdef T_A
  -include $(TOP)/configure/RELEASE.Common.$(T_A)
  -include $(TOP)/configure/RELEASE.$(EPICS_HOST_ARCH).$(T_A)
endif

# Check EPICS_BASE is set properly
ifneq (file,$(origin EPICS_BASE))
  $(error EPICS_BASE must be set in a configure/RELEASE file)
else
  ifeq ($(wildcard $(EPICS_BASE)/configure/CONFIG_BASE),)
    $(error EPICS_BASE does not point to an EPICS installation)
  endif
endif

CONFIG = $(RULES)/configure
include $(CONFIG)/CONFIG

# Override the Base definition:
INSTALL_LOCATION = $(TOP)

# CONFIG_SITE files contain local build configuration settings
include $(TOP)/configure/CONFIG_SITE

# Host-arch specific settings
-include $(TOP)/configure/CONFIG_SITE.$(EPICS_HOST_ARCH).Common

ifdef T_A
  # Target-arch specific settings
 -include $(TOP)/configure/CONFIG_SITE.Common.$(T_A)

  #  Host & target specific settings
 -include $(TOP)/configure/CONFIG_SITE.$(EPICS_HOST_ARCH).$(T_A)
endif












ğŸ”¥ File: ./configure/RULES_DIRS
=================================================
#RULES_DIRS
include $(CONFIG)/RULES_DIRS











ğŸ”¥ File: ./configure/CONFIG_SITE
=================================================
# CONFIG_SITE

# Make any application-specific changes to the EPICS build
#   configuration variables in this file.
#
# Host/target specific settings can be specified in files named
#   CONFIG_SITE.$(EPICS_HOST_ARCH).Common
#   CONFIG_SITE.Common.$(T_A)
#   CONFIG_SITE.$(EPICS_HOST_ARCH).$(T_A)

# CHECK_RELEASE controls the consistency checking of the support
#   applications pointed to by the RELEASE* files.
# Normally CHECK_RELEASE should be set to YES.
# Set CHECK_RELEASE to NO to disable checking completely.
# Set CHECK_RELEASE to WARN to perform consistency checking but
#   continue building even if conflicts are found.
CHECK_RELEASE = YES

# Set this when you only want to compile this application
#   for a subset of the cross-compiled target architectures
#   that Base is built for.
#CROSS_COMPILER_TARGET_ARCHS = vxWorks-ppc32

# To install files into a location other than $(TOP) define
#   INSTALL_LOCATION here.
#INSTALL_LOCATION=</absolute/path/to/install/top>

# Set this when the IOC and build host use different paths
#   to the install location. This may be needed to boot from
#   a Microsoft FTP server say, or on some NFS configurations.
#IOCS_APPL_TOP = </IOC's/absolute/path/to/install/top>

# For application debugging purposes, override the HOST_OPT and/
#   or CROSS_OPT settings from base/configure/CONFIG_SITE
#HOST_OPT = NO
#CROSS_OPT = NO

# These allow developers to override the CONFIG_SITE variable
# settings without having to modify the configure/CONFIG_SITE
# file itself.
-include $(TOP)/../CONFIG_SITE.local
-include $(TOP)/configure/CONFIG_SITE.local












ğŸ”¥ File: ./configure/O.linux-x86_64/Makefile
=================================================
#This Makefile created by makeMakefile.pl


all :
	$(MAKE) -f ../Makefile TOP=../.. T_A=linux-x86_64  $@

.DEFAULT: force
	$(MAKE) -f ../Makefile TOP=../.. T_A=linux-x86_64  $@

force:  ;




















































ğŸŸ¦ 06_SUBDIRECTORY: db
ğŸ“ tree -L 2 of db/
./db
â”œâ”€â”€ USB1608G_2AO.substitutions
â”œâ”€â”€ measCompAnalogIn.template
â”œâ”€â”€ measCompAnalogInMode.template
â”œâ”€â”€ measCompAnalogOut.template
â”œâ”€â”€ measCompBinaryDir.template
â”œâ”€â”€ measCompBinaryIn.template
â”œâ”€â”€ measCompBinaryOut.template
â”œâ”€â”€ measCompCounter.template
â”œâ”€â”€ measCompDevice.template
â”œâ”€â”€ measCompEncoder.template
â”œâ”€â”€ measCompLongIn.template
â”œâ”€â”€ measCompLongOut.template
â”œâ”€â”€ measCompMCS.template
â”œâ”€â”€ measCompMCSWaveform.template
â”œâ”€â”€ measCompPulseGen.template
â”œâ”€â”€ measCompTemperatureIn.template
â”œâ”€â”€ measCompTrigger.template
â”œâ”€â”€ measCompUSBTempConfig.template
â”œâ”€â”€ measCompVoltageIn.template
â”œâ”€â”€ measCompWaveformDig.template
â”œâ”€â”€ measCompWaveformDigN.template
â”œâ”€â”€ measCompWaveformGen.template
â”œâ”€â”€ measCompWaveformGenN.template
â”œâ”€â”€ threshold_logic.template
â”œâ”€â”€ user.db
â””â”€â”€ user.substitutions

0 directories, 26 files

ğŸ“„ All files under db/:
./db/USB1608G_2AO.substitutions
./db/measCompAnalogIn.template
./db/measCompAnalogInMode.template
./db/measCompAnalogOut.template
./db/measCompBinaryDir.template
./db/measCompBinaryIn.template
./db/measCompBinaryOut.template
./db/measCompCounter.template
./db/measCompDevice.template
./db/measCompEncoder.template
./db/measCompLongIn.template
./db/measCompLongOut.template
./db/measCompMCS.template
./db/measCompMCSWaveform.template
./db/measCompPulseGen.template
./db/measCompTemperatureIn.template
./db/measCompTrigger.template
./db/measCompUSBTempConfig.template
./db/measCompVoltageIn.template
./db/measCompWaveformDig.template
./db/measCompWaveformDigN.template
./db/measCompWaveformGen.template
./db/measCompWaveformGenN.template
./db/threshold_logic.template
./db/user.db
./db/user.substitutions

ğŸ“„ Contents of files under db/:











ğŸ”¥ File: ./db/threshold_logic.template
=================================================
# ThresholdLogic.template
# EPICS ë°ì´í„°ë² ì´ìŠ¤ í…œí”Œë¦¿ - ì„ê³„ê°’ ê¸°ë°˜ ë¡œì§ ì œì–´
# ë§¤ê°œë³€ìˆ˜:
#   P     - PV ì ‘ë‘ì‚¬ (ì˜ˆ: "USB1608G_2AO_cpp:")
#   R     - ë ˆì½”ë“œ ì´ë¦„ ì ‘ë¯¸ì‚¬ (ì˜ˆ: "ThresholdLogic")
#   PORT  - asyn í¬íŠ¸ ì´ë¦„
#   ADDR  - asyn ì£¼ì†Œ (ê¸°ë³¸ê°’: 0)
#   PREC  - ì†Œìˆ˜ì  ìë¦¿ìˆ˜ (ê¸°ë³¸ê°’: 3)
#   EGU   - ì—”ì§€ë‹ˆì–´ë§ ë‹¨ìœ„ (ê¸°ë³¸ê°’: "V")
#   SCAN  - ìŠ¤ìº” ì£¼ê¸° (ê¸°ë³¸ê°’: "1 second")

# ì„ê³„ê°’ ì„¤ì • ë ˆì½”ë“œ (ì•„ë‚ ë¡œê·¸ ì¶œë ¥)
record(ao, "$(P)$(R)Threshold") {
    field(DESC, "Threshold Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))THRESHOLD_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(THRESHOLD=0.0)")
    field(DRVL, "$(DRVL=-10.0)")
    field(DRVH, "$(DRVH=10.0)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
}

# íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì„¤ì • ë ˆì½”ë“œ (ì•„ë‚ ë¡œê·¸ ì¶œë ¥)
record(ao, "$(P)$(R)Hysteresis") {
    field(DESC, "Hysteresis Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))HYSTERESIS_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(HYSTERESIS=0.1)")
    field(DRVL, "0.0")
    field(DRVH, "1.0")
    field(LOPR, "0.0")
    field(HOPR, "1.0")
}

# í˜„ì¬ ê°’ ëª¨ë‹ˆí„°ë§ ë ˆì½”ë“œ (ì‹¤ì œ ì•„ë‚ ë¡œê·¸ ì…ë ¥ ì±„ë„ì—ì„œ ê°’ ì½ê¸°)
record(ai, "$(P)$(R)CurrentValue") {
    field(DESC, "Current Input Value from $(IN_CH)")
    field(INP,  "$(P)$(IN_CH) CP")
    field(SCAN, "Passive")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
    field(HIHI, "$(HIHI=9.0)")
    field(HIGH, "$(HIGH=8.0)")
    field(LOW,  "$(LOW=-8.0)")
    field(LOLO, "$(LOLO=-9.0)")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(LSV,  "MINOR")
    field(LLSV, "MAJOR")
    field(FLNK, "$(P)$(R)Compare")
}

# ì„ê³„ê°’ ë¹„êµ ê³„ì‚° ë ˆì½”ë“œ
record(calcout, "$(P)$(R)Compare") {
    field(DESC, "Threshold Comparison :  $(IN_CH) -> $(OUT_CH)")
    field(CALC, "A>=(B+C)?1:(A<=(B-C)?0:D)")
    field(INPA, "$(P)$(IN_CH) CP")
    field(INPB, "$(P)$(R)Threshold")
    field(INPC, "$(P)$(R)Hysteresis")
    field(INPD, "$(P)$(R)OutputState")
    field(OUT,  "$(P)$(OUT_CH) PP")
    field(OOPT, "Every Time")
    field(DOPT, "Use CALC")
    field(SCAN, "Passive")
}

# ì¶œë ¥ ìƒíƒœ ë ˆì½”ë“œ (ì‹¤ì œ ë°”ì´ë„ˆë¦¬ ì¶œë ¥ ì±„ë„ ìƒíƒœ ëª¨ë‹ˆí„°ë§)
record(bi, "$(P)$(R)OutputState") {
    field(DESC, "Current Output State of $(OUT_CH)")
    field(INP,  "$(P)$(OUT_CH) CP")
    field(SCAN, "Passive")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# í™œì„±í™” ì œì–´ ë ˆì½”ë“œ (ë°”ì´ë„ˆë¦¬ ì¶œë ¥)
record(bo, "$(P)$(R)Enable") {
    field(DESC, "Enable/Disable Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))ENABLE")
    field(PINI, "YES")
    field(VAL,  "$(ENABLE=0)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# ìƒíƒœ ëª¨ë‹ˆí„°ë§ ë ˆì½”ë“œ (ë‹¤ì¤‘ ë°”ì´ë„ˆë¦¬ ì…ë ¥)
record(mbbi, "$(P)$(R)Status") {
    field(DESC, "Threshold Logic Status")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))STATUS")
    field(SCAN, "I/O Intr")
    field(ZRST, "Idle")
    field(ONST, "Active")
    field(TWST, "Error")
    field(THST, "Disabled")
    field(ZRSV, "NO_ALARM")
    field(ONSV, "NO_ALARM")
    field(TWSV, "MAJOR")
    field(THSV, "NO_ALARM")
}

# ë¦¬ì…‹ ëª…ë ¹ ë ˆì½”ë“œ (ë°”ì´ë„ˆë¦¬ ì¶œë ¥)
record(bo, "$(P)$(R)Reset") {
    field(DESC, "Reset Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))RESET")
    field(ZNAM, "Normal")
    field(ONAM, "Reset")
    field(HIGH, "1")
    field(PINI, "NO")
}

# ì—…ë°ì´íŠ¸ ì£¼ê¸° ì„¤ì • ë ˆì½”ë“œ (ì•„ë‚ ë¡œê·¸ ì¶œë ¥)
record(ao, "$(P)$(R)UpdateRate") {
    field(DESC, "Update Rate in Hz")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))UPDATE_RATE")
    field(PREC, "1")
    field(EGU,  "Hz")
    field(PINI, "YES")
    field(VAL,  "$(UPDATE_RATE=10.0)")
    field(DRVL, "0.1")
    field(DRVH, "1000.0")
    field(LOPR, "0.1")
    field(HOPR, "1000.0")
}

# ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸ ì‹œê°„ ë ˆì½”ë“œ (ë¬¸ìì—´ ì…ë ¥)
record(stringin, "$(P)$(R)LastUpdate") {
    field(DESC, "Last Update Timestamp")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR=0))LAST_UPDATE")
    field(SCAN, "I/O Intr")
    field(VAL,  "Never")
}

# ì•ŒëŒ ìƒíƒœ ë ˆì½”ë“œ (ë°”ì´ë„ˆë¦¬ ì…ë ¥)
record(bi, "$(P)$(R)AlarmState") {
    field(DESC, "Alarm State")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))ALARM_STATE")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Normal")
    field(ONAM, "Alarm")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MAJOR")
}

# íŠ¸ë¦¬ê±° ì¹´ìš´í„° ë ˆì½”ë“œ (ë¡± ì…ë ¥)
record(longin, "$(P)$(R)TriggerCount") {
    field(DESC, "Number of Threshold Triggers")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))TRIGGER_COUNT")
    field(SCAN, "I/O Intr")
    field(EGU,  "counts")
}










ğŸ”¥ File: ./db/measCompMCSWaveform.template
=================================================
# Waveform record to be used for MCS data, rather than MCA record.

record(waveform, "$(P)$(R)") {
  field(DTYP, "asynInt32ArrayIn")
  field(INP,  "$(INP)MCA_DATA")
  field(FTVL, "LONG")
  field(NELM, "$(NUM_POINTS)")
}











ğŸ”¥ File: ./db/measCompWaveformGen.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longin, "$(P)$(R)NumPoints")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_NUM_POINTS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Number of points to use for user-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)UserNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Number of points to use for pre-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)IntNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Timebase waveform record for user waveforms                    #
###################################################################
record(waveform, "$(P)$(R)UserTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Timebase waveform record for predefined waveforms              #
###################################################################
record(waveform, "$(P)$(R)IntTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Waveform frequency                                             # 
###################################################################
record(ai, "$(P)$(R)Frequency")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_FREQ")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point readback, based on UserDwell or IntDwell        # 
###################################################################
record(ai, "$(P)$(R)Dwell")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

# Needed?
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Internal waveform dwell                                        # 
###################################################################
record(ao, "$(P)$(R)IntDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcIntFrequency")
}

###################################################################
#  Calculate internal frequency based on new dwell                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntFrequency")
{
    field(INPA, "$(P)$(R)IntDwell")
    field(INPB, "$(P)$(R)IntNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntDwell.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntFrequency PP MS")
}

###################################################################
#  Internal waveform frequency                                    # 
###################################################################
record(ao, "$(P)$(R)IntFrequency")
{
    field(PREC, "$(PREC)")
    field(OUT,  "$(P)$(R)CalcIntDwell PP MS")
}

###################################################################
#  Calculate internal dwell based on new frequency                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntDwell")
{
    field(INPA, "$(P)$(R)IntFrequency")
    field(INPB, "$(P)$(R)IntNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntFrequency.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntDwell PP MS")
}

###################################################################
#  User waveform dwell                                            # 
###################################################################
record(ao, "$(P)$(R)UserDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserFrequency")
}

###################################################################
#  Calculate user frequency based on new dwell                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserFrequency")
{
    field(INPA, "$(P)$(R)UserDwell")
    field(INPB, "$(P)$(R)UserNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserDwell.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserFrequency PP MS")
}

###################################################################
#  User waveform frequency                                        # 
###################################################################
record(ao, "$(P)$(R)UserFrequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserDwell PP MS")
}

###################################################################
#  Calculate user dwell based on new frequency                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserDwell")
{
    field(INPA, "$(P)$(R)UserFrequency")
    field(INPB, "$(P)$(R)UserNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserFrequency.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserDwell PP MS")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}













ğŸ”¥ File: ./db/measCompMCS.template
=================================================
# measCompMCS.template
# Mark Rivers
# June 2, 2014

record(bi,"$(P)SNL_Connected") {
  field(ZNAM, "Not connected")
  field(ZSV,  "MAJOR")
  field(ONAM, "Connected")
  field(OSV,  "NO_ALARM")
}

record(bo,"$(P)EraseAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)EraseStart") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)StartAll.PROC")
}

record(bo,"$(P)StartAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_START_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Start")
  field(VAL,  "1")
  field(FLNK, "$(P)SetAcquiring.PROC")
}

record(bo,"$(P)SetAcquiring") {
  field(OUT,  "$(P)Acquiring PP MS")
  field(ZNAM, "Done")
  field(ONAM, "Set")
  field(VAL,  "1")
  field(FLNK, "$(P)SetClientWait.PROC")
}

record(busy,"$(P)Acquiring") {
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
}

record(bo,"$(P)StopAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_STOP_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Stop")
  field(VAL,  "1")
}

record(ao,"$(P)PresetReal") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESET_REAL")
  field(VAL,  "0.0")
  field(PREC, "3")
}

record(bi,"$(P)HardwareAcquiring") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCA_ACQUIRING")
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
  field(SCAN, "I/O Intr")
}

record(ai,"$(P)ElapsedReal") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_ELAPSED_REAL")
  field(PREC, "3")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ReadAll") {
  field(SCAN, "1 second")
  field(DISV, "0")
  field(SDIS, "$(P)Acquiring NPP NMS")
  field(ZNAM, "Done")
  field(ONAM, "Read")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)ReadAllOnce") {
  field(VAL,  "1")
  field(OUT,  "$(P)DoReadAll.VAL PP MS")
}

record(bo,"$(P)DoReadAll") {
  field(ZNAM, "Done")
  field(ONAM, "Read")
}

record(longout,"$(P)NuseAll") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_NUM_CHANNELS")
}

record(longin,"$(P)CurrentChannel") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_CURRENT_POINT")
  field(SCAN, "I/O Intr")
}

record(ao,"$(P)Dwell") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(VAL,  "0.1")
  field(PREC, "4")
}

record(ai,"$(P)Dwell_RBV") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(PREC, "4")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ChannelAdvance") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_CH_ADV_SOURCE")
  field(ZNAM, "Internal")
  field(ONAM, "External")
}

record(longout,"$(P)Prescale") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESCALE")
  field(VAL,  "1")
}

record(bo,"$(P)EnableClientWait") {
  field(PINI, "YES")
  field(ZNAM, "Disable")
  field(ONAM, "Enable")
}

record(bo,"$(P)SetClientWait") {
  field(DISV, "0")
  field(SDIS, "$(P)EnableClientWait NPP NMS")
  field(OMSL, "closed_loop")
  field(DOL,  "1")
  field(OUT,  "$(P)ClientWait PP MS")
  field(ONAM, "SetClientWait")
  field(ZNAM, "Done")
}

record(busy,"$(P)ClientWait") {
}

record(mbboDirect,"$(P)MCSCounterEnable") {
  field(PINI, "YES")
  field(DTYP, "asynUInt32Digital")
  field(OUT,  "@asynMask($(PORT),0,0xFFFFFFFF)MCS_COUNTER_ENABLE")
  field(VAL, "0x1FF")
}

record(bo, "$(P)MCSCounter1Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B0 PP")
}

record(bo, "$(P)MCSCounter2Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B1 PP")
}

record(bo, "$(P)MCSCounter3Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B2 PP")
}

record(bo, "$(P)MCSCounter4Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B3 PP")
}

record(bo, "$(P)MCSCounter5Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B4 PP")
}

record(bo, "$(P)MCSCounter6Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B5 PP")
}

record(bo, "$(P)MCSCounter7Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B6 PP")
}

record(bo, "$(P)MCSCounter8Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B7 PP")
}

record(bo, "$(P)MCSDIOEnable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B8 PP")
}

record(mbbo,"$(P)PrescaleCounter") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_PRESCALE_COUNTER")
  field(ZRVL, "0")
  field(ZRST, "CTR0")
  field(ONVL, "1")
  field(ONST, "CTR1")
  field(TWVL, "2")
  field(TWST, "CTR2")
  field(THVL, "3")
  field(THST, "CTR3")
  field(FRVL, "4")
  field(FRST, "CTR4")
  field(FVVL, "5")
  field(FVST, "CTR5")
  field(SXVL, "6")
  field(SXST, "CTR6")
  field(SVVL, "7")
  field(SVST, "CTR7")
}

record(mbbo,"$(P)Point0Action") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_POINT0_ACTION")
  field(ZRVL, "0")
  field(ZRST, "Clear")
  field(ONVL, "1")
  field(ONST, "No clear")
  field(TWVL, "2")
  field(TWST, "Skip")
}

record(longin,"$(P)MaxChannels") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_MAX_POINTS")
}

record(mbbi, "$(P)Model") {
  field(PINI, "YES")
  field(DESC, "Model")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT) 0)MODEL")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "USB-CTR08")
  field(ONST, "USB-CTR04")
}

record(mbbo,"$(P)TrigMode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TRIGGER_MODE")
    field(ZRVL, "0")
    field(ZRST, "Rising edge")
    field(ONVL, "1")
    field(ONST, "Falling edge")
    field(TWVL, "6")
    field(TWST, "High level")
    field(THVL, "7")
    field(THST, "Low level")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)MCS_ABS_TIME_WF")
    field(NELM, "$(MAX_POINTS)")
    field(SCAN, "I/O Intr")
}

# asyn record for debugging
record(asyn, "$(P)Asyn") {
  field(PORT, "$(PORT)")
}











ğŸ”¥ File: ./db/measCompBinaryOut.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Direction record will process before this record during iocInit
    field(PHAS, "2")
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
}

record(bi, "$(P)$(R)_RBV")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./db/measCompAnalogIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynInt32Average")
    field(INP,  "@asyn($(PORT),$(ADDR))ANALOG_IN_VALUE")
    field(LINR, "LINEAR")
    field(EGUF, "$(EGUF)")
    field(EGUL, "$(EGUL)")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RANGE")
    field(VAL,  "$(RANGE)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_TYPE")
}

record(ao,"$(P)$(R)Rate")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RATE")
    field(VAL,  "60")
}












ğŸ”¥ File: ./db/USB1608G_2AO.substitutions
=================================================
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompDevice.template"
{pattern {} {} }

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongIn.template"
{
pattern
{ R,   MASK, ADDR}
{Li,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryIn.template"
{
pattern
{ R,   MASK, ADDR}
{Bi1,  0x01     0}
{Bi2,  0x02     0}
{Bi3,  0x04     0}
{Bi4,  0x08     0}
{Bi5,  0x10     0}
{Bi6,  0x20     0}
{Bi7,  0x40     0}
{Bi8,  0x80     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongOut.template"
{
pattern
{ R,   MASK, ADDR}
{Lo,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryOut.template"
{
pattern
{ R,   MASK, ADDR}
{Bo1,  0x01     0}
{Bo2,  0x02     0}
{Bo3,  0x04     0}
{Bo4,  0x08     0}
{Bo5,  0x10     0}
{Bo6,  0x20     0}
{Bo7,  0x40     0}
{Bo8,  0x80     0}
}

# Direction bits on binary I/O
#  VAL 0=input, 1=output
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryDir.template"
{
pattern
{ R,   MASK,  VAL, ADDR}
{Bd1,  0x01    0,     0}
{Bd2,  0x02    0,     0}
{Bd3,  0x04    0,     0}
{Bd4,  0x08    0,     0}
{Bd5,  0x10    1,     0}
{Bd6,  0x20    1,     0}
{Bd7,  0x40    1,     0}
{Bd8,  0x80    1,     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompPulseGen.template"
{
pattern
{    R,      ADDR,  PREC}
{PulseGen1,     0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompCounter.template"
{
pattern
{    R,     ADDR}
{Counter1,     0}
{Counter2,     1}
}

# Analog input mode
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogInMode.template"
{
pattern
{  R,       ADDR,   MODE}
{AiMode,       0,      0}
}

# Analog inputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogIn.template"
{
pattern
{  R, ADDR, EGUL, LOPR, EGUF, HOPR,  RANGE,   SCAN,   PREC}
{Ai1,   0,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai2,   1,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai3,   2,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai4,   3,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai5,   4,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai6,   5,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai7,   6,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
{Ai8,   7,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
}

# Waveform digitzer
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDig.template"
{
pattern
{  R,     ADDR,  PREC}
{WaveDig,    0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDigN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveDig1,     0,      4}
{WaveDig2,     1,      4}
{WaveDig3,     2,      4}
{WaveDig4,     3,      4}
{WaveDig5,     4,      4}
{WaveDig6,     5,      4}
{WaveDig7,     6,      4}
{WaveDig8,     7,      4}
}


# Analog outputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogOut.template"
{
pattern
{ R,   VAL, ADDR, EGUL, DRVL, LOPR, EGUF, DRVH, HOPR, PREC}
{Ao1,   0,    0,  -10., -10., -10.,  10.,  10.,  10.,    4}
{Ao2,   0,    1,  -10., -10., -10.,  10.,  10.,  10.,    4}
}

# Waveform generator
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGen.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen,      0,      4}
}
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGenN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen1,     0,      4}
{WaveGen2,     1,      4}
}

# Trigger
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompTrigger.template"
{
pattern
{  R,   ADDR}
{Trig,     0}
}


# Threshold Logic Controller ì¸ìŠ¤í„´ìŠ¤
# ê° ì•„ë‚ ë¡œê·¸ ì…ë ¥ ì±„ë„ì— ëŒ€í•œ ì„ê³„ê°’ ë¡œì§ ì œì–´
# ThresholdLogic1: ai1 -> bo5
# ThresholdLogic2: ai2 -> bo6
# ThresholdLogic3: ai4 -> bo7
# ThresholdLogic4: ai5 -> bo8
file "$(TOP)/USB1608G_2AO_V2App/Db/threshold_logic.template"
{
pattern
{ R,               IN_CH,  OUT_CH, THRESHOLD, HYSTERESIS, ENABLE, UPDATE_RATE, PREC, EGU }
{ ThresholdLogic1, "Ai1",   "Bo5",     2.5,       0.1,        1,      10.0,        3,   "V" }
{ ThresholdLogic2, "Ai2",   "Bo6",     5.0,       0.2,        1,      10.0,        3,   "V" }
{ ThresholdLogic3, "Ai3",   "Bo7",     1.0,       0.05,       0,      5.0,         3,   "V" }
{ ThresholdLogic4, "Ai4",   "Bo8",     7.5,       0.3,        0,      20.0,        3,   "V" }
}












ğŸ”¥ File: ./db/measCompLongOut.template
=================================================
###################################################################
#  Binary output as longout                                       # 
###################################################################
record(longout, "$(P)$(R)")
{
    field(PINI, "$(PINI=NO)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
}

record(longin, "$(P)$(R)_RBV")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(SCAN, "I/O Intr")
}












ğŸ”¥ File: ./db/measCompTrigger.template
=================================================
record(mbbo,"$(P)$(R)Mode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TRIGGER_MODE")
    field(ZRVL, "12")
    field(ZRST, "Positive edge")
    field(ONVL, "13")
    field(ONST, "Negative edge")
    field(TWVL, "10")
    field(TWST, "High")
    field(THVL, "11")
    field(THST, "Low")
}












ğŸ”¥ File: ./db/measCompDevice.template
=================================================
# Device settings
record(stringin,"$(P)ModelName") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)MODEL_NAME")
}

record(longin,"$(P)ModelNumber") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT) 0)MODEL_NUMBER")
}

record(stringin,"$(P)FirmwareVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)FIRMWARE_VERSION")
}

record(stringin,"$(P)UniqueID") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UNIQUE_ID")
}

record(stringin,"$(P)ULVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UL_VERSION")
}

record(stringin,"$(P)DriverVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)DRIVER_VERSION")
}

record(ai,"$(P)PollTimeMS") {
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT) 0)POLL_TIME_MS")
    field(PREC, "1")
    field(SCAN, "I/O Intr")
}

record(ao,"$(P)PollSleepMS") {
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT) 0)POLL_SLEEP_MS")
    field(VAL,  "50")
    field(PREC, "1")
}

record(waveform, "$(P)LastErrorMessage") {
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)LAST_ERROR_MESSAGE")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./db/measCompAnalogOut.template
=================================================
record(ao,"$(P)$(R)") {
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Range record will process before this record during iocInit
    field(PHAS, "2")
    field(DTYP, "asynInt32")
    field(FLNK, "$(P)$(R)Return.PROC  PP MS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_RANGE")
}

record(ao,"$(P)$(R)Return") {
    field(DTYP, "asynInt32")
    field(DISV, "0")
    field(SDIS, "$(P)$(R)Pulse.VAL  NPP NMS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(OMSL, "closed_loop")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

record(bo,"$(P)$(R)Pulse") {
    field(ZNAM, "Normal")
    field(ONAM, "Pulse")
}

record(ao,"$(P)$(R)TweakVal") {
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakUp") {
    field(CALC, "A+B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakDown") {
    field(CALC, "A-B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}











ğŸ”¥ File: ./db/user.substitutions
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./db/measCompWaveformGenN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)UserWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayOut")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_WF")
    field(NELM, "$(WGEN_POINTS)")
}

###################################################################
#  Internally defined waveform record                             #
###################################################################
record(waveform, "$(P)$(R)InternalWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Enable this channel                                            # 
###################################################################
record(bo, "$(P)$(R)Enable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Waveform type                                                  # 
###################################################################
record(mbbo, "$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_WAVE_TYPE")
    field(ZRVL, "0")
    field(ZRST, "User-defined")
    field(ONVL, "1")
    field(ONST, "Sin wave")
    field(TWVL, "2")
    field(TWST, "Square wave")
    field(THVL, "3")
    field(THST, "Sawtooth")
    field(FRVL, "4")
    field(FRST, "Pulse")
    field(FVVL, "5")
    field(FVST, "Random")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)PulseWidth")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_PULSE_WIDTH")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}

###################################################################
#  Amplitude                                                      # 
###################################################################
record(ao, "$(P)$(R)Amplitude")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_AMPLITUDE")
    field(VAL,  "1.0")
    field(PREC, "4")
}

###################################################################
#  Offset                                                         # 
###################################################################
record(ao, "$(P)$(R)Offset")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_OFFSET")
    field(VAL,  "0.0")
    field(PREC, "4")
}












ğŸ”¥ File: ./db/measCompWaveformDig.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longout, "$(P)$(R)NumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WDIG_POINTS)")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)FirstChan")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_FIRST_CHAN")
    field(ZRVL, "0")
    field(ZRST, "1")
    field(ONVL, "1")
    field(ONST, "2")
    field(TWVL, "2")
    field(TWST, "3")
    field(THVL, "3")
    field(THST, "4")
    field(FRVL, "4")
    field(FRST, "5")
    field(FVVL, "5")
    field(FVST, "6")
    field(SXVL, "6")
    field(SXST, "7")
    field(SVVL, "7")
    field(SVST, "8")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)NumChans")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_CHANS")
    field(ZRVL, "1")
    field(ZRST, "1")
    field(ONVL, "2")
    field(ONST, "2")
    field(TWVL, "3")
    field(TWST, "3")
    field(THVL, "4")
    field(THST, "4")
    field(FRVL, "5")
    field(FRST, "5")
    field(FVVL, "6")
    field(FVST, "6")
    field(SXVL, "7")
    field(SXST, "7")
    field(SVVL, "8")
    field(SVST, "8")
}
###################################################################
#  Timebase waveform record                                       #
###################################################################
record(waveform, "$(P)$(R)TimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)$(R)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_ABS_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point                                                 # 
###################################################################
record(ao, "$(P)$(R)Dwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  One-shot / continuous                                          # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Auto restart                                                   # 
###################################################################
record(bo, "$(P)$(R)AutoRestart")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_AUTO_RESTART")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Burst mode                                                     # 
###################################################################
record(bo, "$(P)$(R)BurstMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_BURST_MODE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}

###################################################################
#  Read waveforms                                                 # 
###################################################################
# This tells the driver to read, which then does callbacks to the
# input waveform records which are I/O Intr scanned
# The driver always reads the waveforms when acquisition completes,
# so this record can be passive for fast scans
record(busy, "$(P)$(R)ReadWF")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_READ_WF")
    field(ZNAM, "Done")
    field(ONAM, "Read")
    field(SCAN, "1 second")
    field(SDIS, "$(P)$(R)Run")
    field(DISV, "0")
}













ğŸ”¥ File: ./db/measCompUSBTempConfig.template
=================================================
# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)TemperatureSensor")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SENSOR")
}

record(mbbo,"$(P)$(R)TemperatureWiring")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_WIRING")
}











ğŸ”¥ File: ./db/measCompLongIn.template
=================================================
record(longin, "$(P)$(R)")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./db/measCompVoltageIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_VALUE")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_RANGE")
    field(VAL,  "$(RANGE)")
}











ğŸ”¥ File: ./db/measCompWaveformDigN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)VoltWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_VOLT_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./db/measCompCounter.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












ğŸ”¥ File: ./db/measCompBinaryIn.template
=================================================
record(bi, "$(P)$(R)")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











ğŸ”¥ File: ./db/measCompPulseGen.template
=================================================
# This database is loaded for each pulse generator
# Mark Rivers
# July 26, 2011

###################################################################
#  Pulse start/stop                                               # 
###################################################################
record(bo, "$(P)$(R)Run")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_RUN")
    field(ZNAM, "Stop")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Run")
    field(OSV,  "MINOR")
}

# NOTE: The records for the period and the frequency are a bit
# complex because we want to be able to change either ao record
# and have the other one update

###################################################################
#  Pulse period                                                   # 
###################################################################
record(ao, "$(P)$(R)Period")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcFrequency")
}

record(ai, "$(P)$(R)Period_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate frequency based on new period                        # 
###################################################################
record(calcout, "$(P)$(R)CalcFrequency")
{
    field(INPA, "$(P)$(R)Period")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Frequency.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Frequency PP MS")
}

###################################################################
#  Pulse frequency                                                # 
###################################################################
record(ao, "$(P)$(R)Frequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcPeriod PP MS")
}

record(calc, "$(P)$(R)Frequency_RBV")
{
    field(INPA, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "1/A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate period based on new frequency                        # 
###################################################################
record(calcout, "$(P)$(R)CalcPeriod")
{
    field(INPA, "$(P)$(R)Frequency")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Period.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Period PP MS")
}

###################################################################
#  Pulse duty cycle                                               # 
###################################################################
record(ao, "$(P)$(R)DutyCycle")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(VAL,  "0.5")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcWidth")
}

record(ai, "$(P)$(R)DutyCycle_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate width based on new duty cycle                        # 
###################################################################
record(calcout, "$(P)$(R)CalcWidth")
{
    field(INPA, "$(P)$(R)DutyCycle")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A*B")
    field(SDIS, "$(P)$(R)Width.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Width PP MS")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)Width")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcDutyCycle PP MS")
}

record(calc, "$(P)$(R)Width_RBV")
{
    field(INPA, "$(P)$(R)DutyCycle_RBV CP MS")
    field(INPB, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "B*A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate duty cycle based on new width                        # 
###################################################################
record(calcout, "$(P)$(R)CalcDutyCycle")
{
    field(INPA, "$(P)$(R)Width")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A/B")
    field(SDIS, "$(P)$(R)DutyCycle.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)DutyCycle PP MS")
}

###################################################################
#  Pulse delay                                                    # 
###################################################################
record(ao, "$(P)$(R)Delay")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(VAL,  "0.")
    field(PREC, "$(PREC)")
}

record(ai, "$(P)$(R)Delay_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Pulse count                                                    # 
###################################################################
record(longout, "$(P)$(R)Count")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_COUNT")
}

###################################################################
#  Pulse idle state                                               # 
###################################################################
record(bo, "$(P)$(R)IdleState")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_IDLE_STATE")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(VAL,  "0")
}













ğŸ”¥ File: ./db/measCompBinaryDir.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_DIRECTION")
    field(ZNAM, "In")
    field(ONAM, "Out")
    field(VAL,  "$(VAL)")
    field(PINI, "YES")
}











ğŸ”¥ File: ./db/measCompTemperatureIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))TEMPERATURE_IN_VALUE")
    field(PREC, "$(PREC)")
}

record(mbbo,"$(P)$(R)Scale")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SCALE")
    field(ZRVL, "0")
    field(ZRST, "Celsius")
    field(ONVL, "1")
    field(ONST, "Fahrenheit")
    field(TWVL, "2")
    field(TWST, "Kelvin")
    field(THVL, "4")
    field(THST, "Volts")
    field(FRVL, "5")
    field(FRST, "Noscale")
}

record(mbbo,"$(P)$(R)TCType")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_TYPE")
    field(ZRVL, "1")
    field(ZRST, "Type J")
    field(ONVL, "2")
    field(ONST, "Type K")
    field(TWVL, "3")
    field(TWST, "Type T")
    field(THVL, "4")
    field(THST, "Type E")
    field(FRVL, "5")
    field(FRST, "Type R")
    field(FVVL, "6")
    field(FVST, "Type S")
    field(SXVL, "7")
    field(SXST, "Type B")
    field(SVVL, "8")
    field(SVST, "Type N")
}

record(mbbo,"$(P)$(R)Filter")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_FILTER")
    field(ZRVL, "0")
    field(ZRST, "Filter")
    field(ONVL, "0x400")
    field(ONST, "No filter")
}

record(bo,"$(P)$(R)OpenTCDetect")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_OPEN_DETECT")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}












ğŸ”¥ File: ./db/measCompEncoder.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












ğŸ”¥ File: ./db/user.db
=================================================
[SKIPPED: binary or unreadable file]











ğŸ”¥ File: ./db/measCompAnalogInMode.template
=================================================
record(mbbo,"$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_MODE")
    field(VAL,  "$(MODE)")
    field(ZRVL, "0")
    field(ZRST, "Differential")
    field(ONVL, "1")
    field(ONST, "Single-ended")
}




















































ğŸŸ¦ 07_SUBDIRECTORY: dbd
ğŸ“ tree -L 2 of dbd/
./dbd
â””â”€â”€ USB1608G_2AO_V2.dbd

0 directories, 1 file

ğŸ“„ All files under dbd/:
./dbd/USB1608G_2AO_V2.dbd

ğŸ“„ Contents of files under dbd/:











ğŸ”¥ File: ./dbd/USB1608G_2AO_V2.dbd
=================================================
[SKIPPED: ğŸš‹ ê±´ë„ˆë›¸ íŒŒì¼ (*.dbd)]




















































ğŸŸ¦ 08_SUBDIRECTORY: iocBoot
ğŸ“ tree -L 2 of iocBoot/
./iocBoot
â”œâ”€â”€ Makefile
â””â”€â”€ iocUSB1608G_2AO_V2
    â”œâ”€â”€ Log_stCmd.log
    â”œâ”€â”€ Makefile
    â”œâ”€â”€ README_ThresholdLogic.md
    â”œâ”€â”€ auto_settings.req
    â”œâ”€â”€ autosave
    â”œâ”€â”€ catest_ThresholdLogic.sh
    â”œâ”€â”€ catest_USB1608G_2AO.sh
    â”œâ”€â”€ cleanup_USB1608G_2AO.sh
    â”œâ”€â”€ envPaths
    â”œâ”€â”€ medm_USB1608G_2AO.sh
    â”œâ”€â”€ save_restore.cmd
    â””â”€â”€ st.cmd

2 directories, 12 files

ğŸ“„ All files under iocBoot/:
./iocBoot/Makefile
./iocBoot/iocUSB1608G_2AO_V2/Log_stCmd.log
./iocBoot/iocUSB1608G_2AO_V2/Makefile
./iocBoot/iocUSB1608G_2AO_V2/README_ThresholdLogic.md
./iocBoot/iocUSB1608G_2AO_V2/auto_settings.req
./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav
./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav0
./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav1
./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav2
./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.savB
./iocBoot/iocUSB1608G_2AO_V2/catest_ThresholdLogic.sh
./iocBoot/iocUSB1608G_2AO_V2/catest_USB1608G_2AO.sh
./iocBoot/iocUSB1608G_2AO_V2/cleanup_USB1608G_2AO.sh
./iocBoot/iocUSB1608G_2AO_V2/envPaths
./iocBoot/iocUSB1608G_2AO_V2/medm_USB1608G_2AO.sh
./iocBoot/iocUSB1608G_2AO_V2/save_restore.cmd
./iocBoot/iocUSB1608G_2AO_V2/st.cmd

ğŸ“„ Contents of files under iocBoot/:











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/cleanup_USB1608G_2AO.sh
=================================================
#!/bin/bash

# EPICS ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” íŒŒì¼ ë° ë¹Œë“œ ì•„í‹°íŒ©íŠ¸ë¥¼ ì •ë¦¬í•˜ëŠ” ìŠ¤í¬ë¦½íŠ¸

# í•¨ìˆ˜: ì§€ì •ëœ íŒ¨í„´ì˜ íŒŒì¼/ë””ë ‰í† ë¦¬ë¥¼ ì°¾ì•„ ì‚­ì œë¥¼ í™•ì¸í•˜ê³  ì‹¤í–‰
# ì‚¬ìš©ë²•: cleanup_items "ì„¤ëª…" <find ëª…ë ¹ì–´ ì¸ìë“¤>
cleanup_items() {
    local description="$1"
    shift
    local find_args=("$@")

    echo "--- $description ê²€ìƒ‰ ì¤‘..."
    # find ëª…ë ¹ì„ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°°ì—´ì— ì €ì¥
    # -print0ê³¼ read -d ''ë¥¼ ì‚¬ìš©í•˜ì—¬ ê³µë°±ì´ í¬í•¨ëœ íŒŒì¼ ì´ë¦„ ì²˜ë¦¬
    local items_to_delete=()
    while IFS= read -r -d $'\0'; do
        items_to_delete+=("$REPLY")
    done < <(find . -depth "${find_args[@]}" -print0 2>/dev/null)


    if [ ${#items_to_delete[@]} -eq 0 ]; then
        echo " -> ì‚­ì œí•  í•­ëª© ì—†ìŒ."
        echo ""
        return
    fi

    echo " -> ë‹¤ìŒ í•­ëª©ë“¤ì„ ì‚­ì œí• ê¹Œìš”?"
    printf '    - %s\n' "${items_to_delete[@]}"

    read -p "   ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): " confirm
    if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
        # ë°°ì—´ì˜ ê° í•­ëª©ì— ëŒ€í•´ rm -rf ì‹¤í–‰
        for item in "${items_to_delete[@]}"; do
            if [ -e "$item" ]; then # í•­ëª©ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                echo "    -> ì‚­ì œ ì¤‘: $item"
                rm -rf "$item"
            fi
        done
        echo " -> ì™„ë£Œ."
    else
        echo " -> ì‚­ì œë¥¼ ê±´ë„ˆëœë‹ˆë‹¤."
    fi
    echo ""
}

# ë©”ì¸ ì •ë¦¬ í•¨ìˆ˜
main_cleanup() {
    echo "================================================="
    echo "EPICS ì• í”Œë¦¬ì¼€ì´ì…˜ ì •ë¦¬ ìŠ¤í¬ë¦½íŠ¸"
    echo "================================================="
    echo "í˜„ì¬ ë””ë ‰í† ë¦¬: $(pwd)"
    echo ""

    # 1. ë¹Œë“œ ì¶œë ¥ ë””ë ‰í† ë¦¬ (O.*)
    cleanup_items "ë¹Œë“œ ì¶œë ¥ ë””ë ‰í† ë¦¬ (O.*)" -type d -name "O.*"

    # 2. ë°±ì—… íŒŒì¼ (*.bak, *_BAK.adl)
    cleanup_items "ë°±ì—… íŒŒì¼ (*.bak, *_BAK.adl)" -type f \( -name "*.bak" -o -name "*_BAK.adl" \)

    # 3. EPICS autosave ë°±ì—… íŒŒì¼ (*.sav[0-9], *.savB)
    cleanup_items "EPICS autosave ë°±ì—… íŒŒì¼" -type f \( -name "*.sav[0-9]" -o -name "*.savB" \)

    # 4. ì»´íŒŒì¼ëœ ì‹¤í–‰ íŒŒì¼ (bin/*)
    cleanup_items "ì»´íŒŒì¼ëœ ì‹¤í–‰ íŒŒì¼" -path "./bin/*" -type f

    # 5. ì´ IOCì—ì„œ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ë‹¤ë¥¸ ëª¨ë¸ìš© ì„¤ì • íŒŒì¼ (*_settings.req)
    cleanup_items "ë‹¤ë¥¸ ëª¨ë¸ìš© ì„¤ì • íŒŒì¼" -type f -name "*_settings.req" \
        -not -name "measComp*" \
        -not -name "USB1608G_2AO_settings.req"

    echo "================================================="
    echo "ì •ë¦¬ ì™„ë£Œ."
    echo "================================================="
}

# ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
main_cleanup











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav
=================================================
# autosave R5.3	Automatically generated - DO NOT MODIFY - 250830-215736
! 2 channel(s) not connected - or not all gets were successful
#file Search Issued
#file Search Issued
<END>











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.savB
=================================================
# autosave R5.3	Automatically generated - DO NOT MODIFY - 250830-215736
! 2 channel(s) not connected - or not all gets were successful
#file Search Issued
#file Search Issued
<END>











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav1
=================================================
# autosave R5.3	Automatically generated - DO NOT MODIFY - 250830-215736
! 2 channel(s) not connected - or not all gets were successful
#file Search Issued
#file Search Issued
<END>











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav0
=================================================
# autosave R5.3	Automatically generated - DO NOT MODIFY - 250830-214735
! 2 channel(s) not connected - or not all gets were successful
#file Search Issued
#file Search Issued
<END>











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/autosave/auto_settings.sav2
=================================================
# autosave R5.3	Automatically generated - DO NOT MODIFY - 250830-214735
! 2 channel(s) not connected - or not all gets were successful
#file Search Issued
#file Search Issued
<END>











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/medm_USB1608G_2AO.sh
=================================================
#!/bin/bash

# ========== Logging ==========
LOG_DIR="/root/log"
script_name="${0##*/}";
script_name="${script_name%.*}"
LOG_FILE="$LOG_DIR/$script_name.log"

APPNAME="USB1608G_2AO_V2"

init_log() {
    mkdir -p "$LOG_DIR"
    {
        echo "========================================="
        echo " Log File: $LOG_FILE"
        echo " Created: $(date '+%Y-%m-%d %H:%M:%S')"
        echo " User: $(whoami)"
        echo " Host: $(hostname)"
        echo "========================================="
    } > "$LOG_FILE"
}


export EPICS_SITE=${EPICS_PATH}/siteApp
# ========== Functions ==========
# /usr/local/epics/EPICS_R7.0/siteApp/USB1608G/USB1608GApp/op/USB1608G.adl

USB1608G_2AO_exec() {
    local OPDIR=${EPICS_SITE}/${APPNAME}/${APPNAME}App/op

    cd ${OPDIR}
    # args="P=USB1608G_2AO:,Bi=Bi,Li=Li,Bo=Bo,Lo=Lo,Bd=Bd,Ai=Ai,Ao=Ao,Ct=Counter,Wd=WaveDig,Wg=WaveGen,Pg=PulseGen,Tg=Trig"

    # Build macro string
    local MACRO_STR="P=USB1608G_2AO:,Bi=Bi,Li=Li,Bo=Bo,Lo=Lo,Bd=Bd,Ai=Ai,Ao=Ao,Ct=Counter,Wd=WaveDig,Wg=WaveGen,Pg=PulseGen,Tg=Trig"    

    # Call medm with explicit options, properly quoted. / ëª…ì‹œì  ì˜µì…˜ê³¼ ì˜¬ë°”ë¥¸ ë”°ì˜´í‘œ
    medm -x -macro "$MACRO_STR" -displayFont fixed "${APPNAME}.adl" &
    echo " - cd ${OPDIR}"
}

USB1608G_2AO_edit() {
    local OPDIR=${EPICS_SITE}/${APPNAME}/${APPNAME}App/op

    cd ${OPDIR}
    # args="P=USB1608G_2AO:,Bi=Bi,Li=Li,Bo=Bo,Lo=Lo,Bd=Bd,Ai=Ai,Ao=Ao,Ct=Counter,Wd=WaveDig,Wg=WaveGen,Pg=PulseGen,Tg=Trig"
    export MEDM_MACRO="-macro P=USB1608G_2AO:,Bi=Bi,Li=Li,Bo=Bo,Lo=Lo,Bd=Bd,Ai=Ai,Ao=Ao,Ct=Counter,Wd=WaveDig,Wg=WaveGen,Pg=PulseGen,Tg=Trig"
    export MEDM_FONT='-displayFont fixed'
    medm $MEDM_MACRO $MEDM_FONT ${APPNAME}.adl &
    echo " - cd ${OPDIR}"
}


measCompDigitalIO8_exec() {
    local OPDIR=${EPICS_SITE}/${APPNAME}/${APPNAME}App/op

    cd ${OPDIR}    
    export MEDM_MACRO="-macro P=USB1608G_2AO:,Bi=Bi,Li=Li,Bo=Bo,Lo=Lo,Bd=Bd"
    export MEDM_FONT='-displayFont fixed'
    medm -x $MEDM_MACRO $MEDM_FONT measCompDigitalIO8.adl &
    echo " - cd ${OPDIR}"
}

measCompDigitalIO8_edit() {
    local OPDIR=${EPICS_SITE}/${APPNAME}/${APPNAME}App/op

    cd ${OPDIR}    
    export MEDM_MACRO="-macro P=USB1608G_2AO:,Bi=Bi,Li=Li,Bo=Bo,Lo=Lo,Bd=Bd"
    export MEDM_FONT='-displayFont fixed'
    medm $MEDM_MACRO $MEDM_FONT measCompDigitalIO8.adl &
    echo " - cd ${OPDIR}"
}






# ========== Common function ==========
kill_medm() {
    echo "[INFO] Checking for existing medm processes..."

    local medm_pids
    medm_pids=$(pgrep -x medm)

    if [[ -z "$medm_pids" ]]; then
        printf "%7s%s\n" "" "- No medm process found. Nothing to kill."
    else
        printf "%7s%s\n" "" "- Found medm process(es): $medm_pids"
        printf "%7s%s\n" "" "- Killing medm process(es)..."
        kill $medm_pids
        sleep 0.5

        if pgrep -x medm >/dev/null; then
            printf "%7s%s\n" "" "- [WARN] Some medm process(es) may still be running."
        else
            printf "%7s%s\n" "" "- All medm process(es) terminated successfully."
        fi
    fi
}













# ========== Main ==========
handle_selection() {
	case "$1" in
			1) USB1608G_2AO_exec ;;
			2) USB1608G_2AO_edit ;;
            3) measCompDigitalIO8_exec ;;
            4) measCompDigitalIO8_edit ;;
			0)
					echo "Exit the script"
					return 0  # << exit ëŒ€ì‹  return
					;;
			*)
					echo ""
					echo "You have entered '${1}'"
					echo "Please select the number in the list..."
					echo "Exit the script"
					echo ""
					return 1
					;;
	esac

	echo -e "\n========================================"
	echo "[DONE] All tasks completed"
}


main() {
    #init_log
    #printf '\n%.0s' {1..3}
    kill_medm

    echo ""
    echo "Enter the number of you want to script"
    echo "1 : USB1608G_2AO_exec (with ThresholdLogic)"
    echo "2 : USB1608G_2AO_edit (with ThresholdLogic)"
    echo ""
    echo "3 : measCompDigitalIO8_exec"
    echo "4 : measCompDigitalIO8_edit"
    echo ""
    echo "0 : Exit script"
    echo -n "Enter the number : "
    read answer

    handle_selection "$answer"
    if [[ $? -ne 0 ]]; then
        exit 1
    fi
}
main












ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/envPaths
=================================================
epicsEnvSet("IOC","iocUSB1608G_2AO_V2")
epicsEnvSet("TOP","/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2")
epicsEnvSet("EPICS_BASE","/usr/local/epics/EPICS_R7.0/base")
epicsEnvSet("SUPPORT","/usr/local/epics/EPICS_R7.0/modules/synApps/support")
epicsEnvSet("ASYN","/usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2")
epicsEnvSet("CALC","/usr/local/epics/EPICS_R7.0/modules/synApps/support/calc-R3-7-5")
epicsEnvSet("SCALER","/usr/local/epics/EPICS_R7.0/modules/synApps/support/scaler-4-1")
epicsEnvSet("MCA","/usr/local/epics/EPICS_R7.0/modules/synApps/support/mca-R7-10")
epicsEnvSet("BUSY","/usr/local/epics/EPICS_R7.0/modules/synApps/support/busy-R1-7-4")
epicsEnvSet("SSCAN","/usr/local/epics/EPICS_R7.0/modules/synApps/support/sscan-R2-11-6")
epicsEnvSet("AUTOSAVE","/usr/local/epics/EPICS_R7.0/modules/synApps/support/autosave-R5-11")
epicsEnvSet("SNCSEQ","/usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9")
epicsEnvSet("MEASCOMP","/usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2")











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/save_restore.cmd
=================================================
# Debug-output level
save_restoreSet_Debug(0)

# Ok to save/restore save sets with missing values (no CA connection to PV)?
save_restoreSet_IncompleteSetsOk(1)
# Save dated backup files?
save_restoreSet_DatedBackupFiles(1)

# Number of sequenced backup files to write
save_restoreSet_NumSeqFiles(3)
# Time interval between sequenced backups
save_restoreSet_SeqPeriodInSeconds(300)

# specify where save files should be
set_savefile_path(".", "autosave")

# specify what save files should be restored.  Note these files must be
# in the directory specified in set_savefile_path(), or, if that function
# has not been called, from the directory current when iocInit is invoked0
set_pass0_restoreFile("auto_settings.sav")
set_pass1_restoreFile("auto_settings.sav")

# specify directories in which to to search for included request files
# Note cdCommands defines 'startup', but envPaths does not
set_requestfile_path(".",         "")
set_requestfile_path(".",         "autosave")
set_requestfile_path($(AUTOSAVE), "db")
set_requestfile_path($(CALC),     "db")
set_requestfile_path($(SCALER),   "db")
set_requestfile_path($(SSCAN),    "db")
set_requestfile_path($(MEASCOMP), "db")











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/catest_USB1608G_2AO.sh
=================================================
#!/bin/bash

# ===== í•¨ìˆ˜ ì •ì˜ =====

function set_automode() {
  echo "==========[ ì´ˆê¸°í™”: AutoMode ON ]=========="
  caput USB1608G_2AO:AiMode 1
  for i in {5..8}; do
    caput USB1608G_2AO:Threshold:Ai1-Bo$i:AutoMode 1
  done
  sleep 2
}



function set_voltage_and_read() {
  local voltage=$1
  echo ""
  echo "--------- Ao1 = ${voltage}V"
  caput USB1608G_2AO:Ao1 "$voltage"
  sleep 3
  caget USB1608G_2AO:Ai1
  for i in {5..8}; do
    caget USB1608G_2AO:Threshold:Ai1-Bo$i:Calc
  done
  for i in {5..8}; do
    caget USB1608G_2AO:Bo$i
  done
}



function manual_calc_test() {
  echo ""
  echo "==========[ CALCì— ê³ ì •ê°’ìœ¼ë¡œ ì§ì ‘ ë„£ì–´ì„œ í™•ì¸ ]=========="

  # CALC, OUT í•„ë“œ ìˆ˜ë™ ì„¤ì •
  caput USB1608G_2AO:Threshold:Ai1-Bo6:Calc.CALC "B?(A>=2):C"
  caput USB1608G_2AO:Threshold:Ai1-Bo6:Calc.OUT "USB1608G_2AO:Bo6 PP"

  # í…ŒìŠ¤íŠ¸ ì „ì•• ì„¤ì •
  caput -t USB1608G_2AO:Ao1 2.5
  sleep 3
  caget USB1608G_2AO:Ai1

  # PROC ê°•ì œ ì‹¤í–‰
  caput USB1608G_2AO:Threshold:Ai1-Bo6:Calc.PROC 1

  # ê²°ê³¼ í™•ì¸
  caget USB1608G_2AO:Threshold:Ai1-Bo6:Calc
  caget USB1608G_2AO:Bo5
  caget USB1608G_2AO:Bo6

  # ë‹¤ì‹œ 0Vë¡œ ì„¤ì •
  caput -t USB1608G_2AO:Ao1 0
  sleep 3
  caget USB1608G_2AO:Ai1
}





# í˜•ì‹: sine_wave_ao1 <ì§„í­> <ì£¼íŒŒìˆ˜> <ìƒ˜í”Œìˆ˜> <ì§€ì—°ì‹œê°„>
# ì˜ˆì‹œ: sine_wave_ao1 5 1 100 0.1   â†’ 5V ì‚¬ì¸íŒŒ, 1Hz, 100í¬ì¸íŠ¸, 0.1ì´ˆ ê°„ê²© ì¶œë ¥

function sine_wave_ao1() {
  local amplitude=$1   # ìµœëŒ€ ì „ì•• (ì˜ˆ: 5V)
  local samples=$2     # ì „ì²´ ìƒ˜í”Œ ìˆ˜
  local duration=$3    # ì „ì²´ ì‹œê°„ (ì´ˆ)

  # delay = duration / samples
  local delay=$(echo "scale=6; $duration / $samples" | bc -l)

  # frequency = 1 / duration
  local freq=$(echo "scale=6; 1 / $duration" | bc -l)

  echo "===== Ao1ì— Sine Wave ì¶œë ¥ ì‹œì‘ ====="
  echo "ì§„í­=${amplitude}V, ìƒ˜í”Œìˆ˜=${samples}, ì „ì²´ì‹œê°„=${duration}s, ì£¼ê¸°=${freq}Hz, delay=${delay}s"

  for ((i = 0; i < samples; i++)); do
    # ì‹œê°„ t
    t=$(echo "$i * $delay" | bc -l)

    # ê°ë„ theta = 2Ï€ft
    theta=$(echo "2 * 3.141592 * $freq * $t" | bc -l)

    # ì‚¬ì¸ê°’ ê³„ì‚°
    sin_val=$(python3 -c "import math; print(math.sin($theta))")

    # ì „ì•• = A * sin(theta)
    voltage=$(echo "$amplitude * $sin_val" | bc -l)

    # ì¶œë ¥
    printf "[%03d] Ao1 = %.3f V\n" "$i" "$voltage"
    caput -t USB1608G_2AO:Ao1 "$voltage"

    sleep "$delay"
  done

  echo "===== Sine Wave ì¶œë ¥ ì¢…ë£Œ ====="
}














# ===== main í•¨ìˆ˜ ì •ì˜ =====

function main() {
  set_automode

  local voltages=(0.0 1.11 2.22 3.33 4.44 3.33 2.22 1.11 0.0)

  for v in "${voltages[@]}"; do
    set_voltage_and_read "$v"
  done

  # manual_calc_test
  
  # ì§„í­ 5V, 100 ìƒ˜í”Œ, 50ì´ˆ ë™ì•ˆ ì‚¬ì¸íŒŒ 1ì£¼ê¸° ì¶œë ¥
  sine_wave_ao1 5 100 30

}

# ===== ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ ì‹œì‘ =====
main











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/catest_ThresholdLogic.sh
=================================================
#!/bin/bash

# ThresholdLogic Controller í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
# ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ThresholdLogicControllerì˜ ëª¨ë“  ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤.

# ===== ìƒ‰ìƒ ì •ì˜ =====
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# ===== PV ì´ë¦„ ì •ì˜ =====
PREFIX="USB1608G_2AO:"
CONTROLLER="ThresholdLogic1"

THRESHOLD_PV="${PREFIX}${CONTROLLER}Threshold"
HYSTERESIS_PV="${PREFIX}${CONTROLLER}Hysteresis"
CURRENT_VALUE_PV="${PREFIX}${CONTROLLER}CurrentValue"
OUTPUT_STATE_PV="${PREFIX}${CONTROLLER}OutputState"
ENABLE_PV="${PREFIX}${CONTROLLER}Enable"
UPDATE_RATE_PV="${PREFIX}${CONTROLLER}UpdateRate"
ALARM_STATE_PV="${PREFIX}${CONTROLLER}AlarmState"
RESET_PV="${PREFIX}${CONTROLLER}Reset"

# í…ŒìŠ¤íŠ¸ìš© ì•„ë‚ ë¡œê·¸ ì¶œë ¥ (ì…ë ¥ ì‹œë®¬ë ˆì´ì…˜ìš©)
AO_PV="${PREFIX}Ao1"

# ===== ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ =====

function print_header() {
    echo -e "${CYAN}========================================${NC}"
    echo -e "${CYAN}$1${NC}"
    echo -e "${CYAN}========================================${NC}"
}

function print_section() {
    echo -e "\n${YELLOW}--- $1 ---${NC}"
}

function print_success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

function print_error() {
    echo -e "${RED}âœ— $1${NC}"
}

function print_info() {
    echo -e "${BLUE}â„¹ $1${NC}"
}

function wait_for_user() {
    echo -e "${PURPLE}Press Enter to continue...${NC}"
    read
}

function check_pv_connection() {
    local pv=$1
    local timeout=5
    
    if timeout $timeout caget "$pv" > /dev/null 2>&1; then
        print_success "PV ì—°ê²° ì„±ê³µ: $pv"
        return 0
    else
        print_error "PV ì—°ê²° ì‹¤íŒ¨: $pv"
        return 1
    fi
}

function get_pv_value() {
    local pv=$1
    caget -t "$pv" 2>/dev/null
}

function set_pv_value() {
    local pv=$1
    local value=$2
    caput -t "$pv" "$value" > /dev/null 2>&1
}

function monitor_pvs() {
    local duration=$1
    print_info "ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (${duration}ì´ˆê°„)..."
    timeout "$duration" camonitor "$CURRENT_VALUE_PV" "$OUTPUT_STATE_PV" "$THRESHOLD_PV" 2>/dev/null || true
}

# ===== í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ë“¤ =====

function test_pv_connections() {
    print_header "1. PV ì—°ê²° í…ŒìŠ¤íŠ¸"
    
    local pvs=(
        "$THRESHOLD_PV"
        "$HYSTERESIS_PV"
        "$CURRENT_VALUE_PV"
        "$OUTPUT_STATE_PV"
        "$ENABLE_PV"
        "$UPDATE_RATE_PV"
        "$ALARM_STATE_PV"
        "$AO_PV"
    )
    
    local failed=0
    for pv in "${pvs[@]}"; do
        if ! check_pv_connection "$pv"; then
            ((failed++))
        fi
    done
    
    if [ $failed -eq 0 ]; then
        print_success "ëª¨ë“  PV ì—°ê²° ì„±ê³µ!"
    else
        print_error "$failed ê°œì˜ PV ì—°ê²° ì‹¤íŒ¨"
        echo "IOCê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•˜ì„¸ìš”."
        exit 1
    fi
}

function test_initial_setup() {
    print_header "2. ì´ˆê¸° ì„¤ì • í…ŒìŠ¤íŠ¸"
    
    print_section "ê¸°ë³¸ ì„¤ì •ê°’ í™•ì¸"
    echo "ì„ê³„ê°’: $(get_pv_value $THRESHOLD_PV) V"
    echo "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: $(get_pv_value $HYSTERESIS_PV) V"
    echo "ì—…ë°ì´íŠ¸ ì£¼ê¸°: $(get_pv_value $UPDATE_RATE_PV) Hz"
    echo "í™œì„±í™” ìƒíƒœ: $(get_pv_value $ENABLE_PV)"
    echo "í˜„ì¬ê°’: $(get_pv_value $CURRENT_VALUE_PV) V"
    echo "ì¶œë ¥ ìƒíƒœ: $(get_pv_value $OUTPUT_STATE_PV)"
    
    print_section "í…ŒìŠ¤íŠ¸ìš© ì„¤ì • ì ìš©"
    set_pv_value "$THRESHOLD_PV" "2.5"
    set_pv_value "$HYSTERESIS_PV" "0.2"
    set_pv_value "$UPDATE_RATE_PV" "10.0"
    
    sleep 1
    
    print_success "í…ŒìŠ¤íŠ¸ ì„¤ì • ì™„ë£Œ:"
    echo "  - ì„ê³„ê°’: 2.5V"
    echo "  - íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: 0.2V"
    echo "  - ì—…ë°ì´íŠ¸ ì£¼ê¸°: 10Hz"
}

function test_enable_disable() {
    print_header "3. í™œì„±í™”/ë¹„í™œì„±í™” í…ŒìŠ¤íŠ¸"
    
    print_section "ì»¨íŠ¸ë¡¤ëŸ¬ ë¹„í™œì„±í™”"
    set_pv_value "$ENABLE_PV" "0"
    sleep 1
    local enable_state=$(get_pv_value $ENABLE_PV)
    if [ "$enable_state" = "0" ]; then
        print_success "ë¹„í™œì„±í™” ì„±ê³µ"
    else
        print_error "ë¹„í™œì„±í™” ì‹¤íŒ¨"
    fi
    
    print_section "ì»¨íŠ¸ë¡¤ëŸ¬ í™œì„±í™”"
    set_pv_value "$ENABLE_PV" "1"
    sleep 2
    enable_state=$(get_pv_value $ENABLE_PV)
    if [ "$enable_state" = "1" ]; then
        print_success "í™œì„±í™” ì„±ê³µ"
    else
        print_error "í™œì„±í™” ì‹¤íŒ¨"
    fi
    
    print_info "í™œì„±í™” í›„ í˜„ì¬ ìƒíƒœ:"
    echo "  - í˜„ì¬ê°’: $(get_pv_value $CURRENT_VALUE_PV) V"
    echo "  - ì¶œë ¥ ìƒíƒœ: $(get_pv_value $OUTPUT_STATE_PV)"
}

function test_threshold_logic() {
    print_header "4. ì„ê³„ê°’ ë¡œì§ í…ŒìŠ¤íŠ¸"
    
    # ì»¨íŠ¸ë¡¤ëŸ¬ê°€ í™œì„±í™”ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
    if [ "$(get_pv_value $ENABLE_PV)" != "1" ]; then
        print_info "ì»¨íŠ¸ë¡¤ëŸ¬ í™œì„±í™” ì¤‘..."
        set_pv_value "$ENABLE_PV" "1"
        sleep 2
    fi
    
    local test_voltages=(0.0 1.0 2.0 2.5 3.0 4.0 3.0 2.3 2.0 1.0 0.0)
    
    print_section "ì„ê³„ê°’ ë¡œì§ í…ŒìŠ¤íŠ¸ ì‹œì‘"
    print_info "ì„ê³„ê°’: 2.5V, íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: 0.2V"
    print_info "ì˜ˆìƒ ë™ì‘:"
    print_info "  - ì…ë ¥ > 2.5V â†’ ì¶œë ¥ HIGH"
    print_info "  - ì…ë ¥ < 2.3V (2.5-0.2) â†’ ì¶œë ¥ LOW"
    echo
    
    for voltage in "${test_voltages[@]}"; do
        print_section "í…ŒìŠ¤íŠ¸ ì „ì••: ${voltage}V"
        
        # ì•„ë‚ ë¡œê·¸ ì¶œë ¥ìœ¼ë¡œ ì…ë ¥ ì‹œë®¬ë ˆì´ì…˜
        set_pv_value "$AO_PV" "$voltage"
        sleep 3
        
        # í˜„ì¬ ìƒíƒœ í™•ì¸
        local current_val=$(get_pv_value $CURRENT_VALUE_PV)
        local output_state=$(get_pv_value $OUTPUT_STATE_PV)
        local output_text="LOW"
        if [ "$output_state" = "1" ]; then
            output_text="HIGH"
        fi
        
        echo "  ì„¤ì •ê°’: ${voltage}V â†’ ì¸¡ì •ê°’: ${current_val}V â†’ ì¶œë ¥: ${output_text}"
        
        # ë¡œì§ ê²€ì¦
        if (( $(echo "$voltage > 2.5" | bc -l) )); then
            if [ "$output_state" = "1" ]; then
                print_success "  ë¡œì§ ì •ìƒ: ì„ê³„ê°’ ì´ˆê³¼ â†’ HIGH"
            else
                print_error "  ë¡œì§ ì˜¤ë¥˜: ì„ê³„ê°’ ì´ˆê³¼í–ˆì§€ë§Œ LOW"
            fi
        elif (( $(echo "$voltage < 2.3" | bc -l) )); then
            if [ "$output_state" = "0" ]; then
                print_success "  ë¡œì§ ì •ìƒ: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ë¯¸ë§Œ â†’ LOW"
            else
                print_error "  ë¡œì§ ì˜¤ë¥˜: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ë¯¸ë§Œì´ì§€ë§Œ HIGH"
            fi
        else
            print_info "  íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ êµ¬ê°„: ì´ì „ ìƒíƒœ ìœ ì§€"
        fi
        
        sleep 1
    done
}

function test_hysteresis() {
    print_header "5. íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸"
    
    print_section "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ í…ŒìŠ¤íŠ¸ ì¤€ë¹„"
    set_pv_value "$THRESHOLD_PV" "3.0"
    set_pv_value "$HYSTERESIS_PV" "0.5"
    sleep 1
    
    print_info "ì„¤ì •: ì„ê³„ê°’=3.0V, íˆìŠ¤í…Œë¦¬ì‹œìŠ¤=0.5V"
    print_info "ì˜ˆìƒ ë™ì‘: 3.0Vì—ì„œ HIGH, 2.5Vì—ì„œ LOW"
    
    # íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ í…ŒìŠ¤íŠ¸ ì‹œí€€ìŠ¤
    local hyst_voltages=(0.0 2.0 2.8 3.2 2.8 2.3 3.5 2.0)
    
    for voltage in "${hyst_voltages[@]}"; do
        print_section "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ í…ŒìŠ¤íŠ¸: ${voltage}V"
        set_pv_value "$AO_PV" "$voltage"
        sleep 3
        
        local current_val=$(get_pv_value $CURRENT_VALUE_PV)
        local output_state=$(get_pv_value $OUTPUT_STATE_PV)
        local output_text="LOW"
        if [ "$output_state" = "1" ]; then
            output_text="HIGH"
        fi
        
        echo "  ${voltage}V â†’ ì¸¡ì •: ${current_val}V â†’ ì¶œë ¥: ${output_text}"
        sleep 1
    done
    
    # ì›ë˜ ì„¤ì •ìœ¼ë¡œ ë³µì›
    set_pv_value "$THRESHOLD_PV" "2.5"
    set_pv_value "$HYSTERESIS_PV" "0.2"
}

function test_update_rate() {
    print_header "6. ì—…ë°ì´íŠ¸ ì£¼ê¸° í…ŒìŠ¤íŠ¸"
    
    local rates=(1.0 5.0 20.0 10.0)
    
    for rate in "${rates[@]}"; do
        print_section "ì—…ë°ì´íŠ¸ ì£¼ê¸°: ${rate}Hz"
        set_pv_value "$UPDATE_RATE_PV" "$rate"
        sleep 1
        
        local actual_rate=$(get_pv_value $UPDATE_RATE_PV)
        echo "  ì„¤ì •: ${rate}Hz â†’ ì‹¤ì œ: ${actual_rate}Hz"
        
        print_info "5ì´ˆê°„ ëª¨ë‹ˆí„°ë§..."
        monitor_pvs 5
    done
}

function test_alarm_conditions() {
    print_header "7. ì•ŒëŒ ì¡°ê±´ í…ŒìŠ¤íŠ¸"
    
    print_section "ì •ìƒ ë²”ìœ„ í…ŒìŠ¤íŠ¸"
    set_pv_value "$AO_PV" "2.0"
    sleep 3
    echo "ì•ŒëŒ ìƒíƒœ: $(get_pv_value $ALARM_STATE_PV)"
    
    print_section "ë²”ìœ„ ì´ˆê³¼ í…ŒìŠ¤íŠ¸"
    set_pv_value "$AO_PV" "9.5"
    sleep 3
    echo "ì•ŒëŒ ìƒíƒœ: $(get_pv_value $ALARM_STATE_PV)"
    
    # ì •ìƒ ë²”ìœ„ë¡œ ë³µì›
    set_pv_value "$AO_PV" "2.0"
    sleep 2
}

function test_reset_function() {
    print_header "8. ë¦¬ì…‹ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸"
    
    print_section "ë¦¬ì…‹ ëª…ë ¹ ì „ì†¡"
    if check_pv_connection "$RESET_PV"; then
        set_pv_value "$RESET_PV" "1"
        sleep 2
        print_success "ë¦¬ì…‹ ëª…ë ¹ ì „ì†¡ ì™„ë£Œ"
        
        print_info "ë¦¬ì…‹ í›„ ìƒíƒœ:"
        echo "  - í˜„ì¬ê°’: $(get_pv_value $CURRENT_VALUE_PV) V"
        echo "  - ì¶œë ¥ ìƒíƒœ: $(get_pv_value $OUTPUT_STATE_PV)"
        echo "  - ì•ŒëŒ ìƒíƒœ: $(get_pv_value $ALARM_STATE_PV)"
    else
        print_error "ë¦¬ì…‹ PVë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤"
    fi
}

function test_continuous_monitoring() {
    print_header "9. ì—°ì† ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸"
    
    print_section "ì‚¬ì¸íŒŒ ì…ë ¥ìœ¼ë¡œ ì—°ì† í…ŒìŠ¤íŠ¸"
    print_info "30ì´ˆê°„ ì‚¬ì¸íŒŒ ì…ë ¥ì„ ìƒì„±í•˜ì—¬ ThresholdLogic ë™ì‘ì„ í™•ì¸í•©ë‹ˆë‹¤"
    print_info "ì„ê³„ê°’: 2.5V, ì§„í­: 4V (0V ~ 4V)"
    
    # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ëª¨ë‹ˆí„°ë§ ì‹œì‘
    timeout 35 camonitor "$CURRENT_VALUE_PV" "$OUTPUT_STATE_PV" > /tmp/threshold_monitor.log 2>&1 &
    local monitor_pid=$!
    
    # ì‚¬ì¸íŒŒ ìƒì„± (30ì´ˆ, 0.5Hz)
    local samples=60
    local duration=30
    local amplitude=2.0
    local offset=2.0
    
    for ((i = 0; i < samples; i++)); do
        local t=$(echo "$i * $duration / $samples" | bc -l)
        local theta=$(echo "2 * 3.141592 * 0.5 * $t" | bc -l)
        local sin_val=$(python3 -c "import math; print(math.sin($theta))" 2>/dev/null || echo "0")
        local voltage=$(echo "$offset + $amplitude * $sin_val" | bc -l)
        
        set_pv_value "$AO_PV" "$voltage"
        printf "ì‹œê°„: %2ds, ì…ë ¥: %.2fV\r" "$((i/2))" "$voltage"
        sleep 0.5
    done
    
    echo
    wait $monitor_pid 2>/dev/null || true
    
    print_success "ì—°ì† ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ ì™„ë£Œ"
    if [ -f /tmp/threshold_monitor.log ]; then
        local transitions=$(grep -c "High\|Low" /tmp/threshold_monitor.log 2>/dev/null || echo "0")
        print_info "ì¶œë ¥ ìƒíƒœ ë³€í™” íšŸìˆ˜: $transitions"
        rm -f /tmp/threshold_monitor.log
    fi
}

function test_performance() {
    print_header "10. ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"
    
    print_section "ë¹ ë¥¸ ë³€í™” í…ŒìŠ¤íŠ¸"
    set_pv_value "$UPDATE_RATE_PV" "50.0"
    sleep 1
    
    print_info "ë¹ ë¥¸ ì „ì•• ë³€í™”ë¡œ ì‘ë‹µì„± í…ŒìŠ¤íŠ¸ (50Hz ì—…ë°ì´íŠ¸)"
    local fast_voltages=(1.0 3.0 1.0 3.0 1.0 3.0 1.0 3.0)
    
    for voltage in "${fast_voltages[@]}"; do
        set_pv_value "$AO_PV" "$voltage"
        sleep 0.2
        local output=$(get_pv_value $OUTPUT_STATE_PV)
        printf "%.1fV â†’ %s  " "$voltage" "$output"
    done
    echo
    
    # ì›ë˜ ì„¤ì •ìœ¼ë¡œ ë³µì›
    set_pv_value "$UPDATE_RATE_PV" "10.0"
    set_pv_value "$AO_PV" "0.0"
}

function generate_test_report() {
    print_header "í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½"
    
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local report_file="/tmp/threshold_logic_test_report.txt"
    
    {
        echo "ThresholdLogic Controller í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œ"
        echo "ìƒì„± ì‹œê°„: $timestamp"
        echo "========================================"
        echo
        echo "ìµœì¢… ì„¤ì • ìƒíƒœ:"
        echo "  ì„ê³„ê°’: $(get_pv_value $THRESHOLD_PV) V"
        echo "  íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: $(get_pv_value $HYSTERESIS_PV) V"
        echo "  ì—…ë°ì´íŠ¸ ì£¼ê¸°: $(get_pv_value $UPDATE_RATE_PV) Hz"
        echo "  í™œì„±í™” ìƒíƒœ: $(get_pv_value $ENABLE_PV)"
        echo
        echo "ìµœì¢… ë™ì‘ ìƒíƒœ:"
        echo "  í˜„ì¬ê°’: $(get_pv_value $CURRENT_VALUE_PV) V"
        echo "  ì¶œë ¥ ìƒíƒœ: $(get_pv_value $OUTPUT_STATE_PV)"
        echo "  ì•ŒëŒ ìƒíƒœ: $(get_pv_value $ALARM_STATE_PV)"
        echo
        echo "í…ŒìŠ¤íŠ¸ ì™„ë£Œ í•­ëª©:"
        echo "  âœ“ PV ì—°ê²° í…ŒìŠ¤íŠ¸"
        echo "  âœ“ ì´ˆê¸° ì„¤ì • í…ŒìŠ¤íŠ¸"
        echo "  âœ“ í™œì„±í™”/ë¹„í™œì„±í™” í…ŒìŠ¤íŠ¸"
        echo "  âœ“ ì„ê³„ê°’ ë¡œì§ í…ŒìŠ¤íŠ¸"
        echo "  âœ“ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸"
        echo "  âœ“ ì—…ë°ì´íŠ¸ ì£¼ê¸° í…ŒìŠ¤íŠ¸"
        echo "  âœ“ ì•ŒëŒ ì¡°ê±´ í…ŒìŠ¤íŠ¸"
        echo "  âœ“ ì—°ì† ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸"
        echo "  âœ“ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"
    } > "$report_file"
    
    cat "$report_file"
    print_success "í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: $report_file"
}

function cleanup() {
    print_header "ì •ë¦¬ ì‘ì—…"
    
    print_section "ì„¤ì • ì´ˆê¸°í™”"
    set_pv_value "$AO_PV" "0.0"
    set_pv_value "$THRESHOLD_PV" "2.5"
    set_pv_value "$HYSTERESIS_PV" "0.1"
    set_pv_value "$UPDATE_RATE_PV" "10.0"
    set_pv_value "$ENABLE_PV" "0"
    
    print_success "ì •ë¦¬ ì‘ì—… ì™„ë£Œ"
}

# ===== ë©”ì¸ í•¨ìˆ˜ =====

function show_menu() {
    echo -e "\n${CYAN}ThresholdLogic Controller í…ŒìŠ¤íŠ¸ ë©”ë‰´${NC}"
    echo "1) ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"
    echo "2) PV ì—°ê²° í…ŒìŠ¤íŠ¸ë§Œ"
    echo "3) ì„ê³„ê°’ ë¡œì§ í…ŒìŠ¤íŠ¸ë§Œ"
    echo "4) íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ í…ŒìŠ¤íŠ¸ë§Œ"
    echo "5) ì—°ì† ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ë§Œ"
    echo "6) ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ (Ctrl+Cë¡œ ì¤‘ì§€)"
    echo "7) í˜„ì¬ ìƒíƒœ í™•ì¸"
    echo "8) ì„¤ì • ì´ˆê¸°í™”"
    echo "9) ì¢…ë£Œ"
    echo -n "ì„ íƒí•˜ì„¸ìš” (1-9): "
}

function interactive_mode() {
    while true; do
        show_menu
        read choice
        
        case $choice in
            1)
                run_all_tests
                ;;
            2)
                test_pv_connections
                ;;
            3)
                test_threshold_logic
                ;;
            4)
                test_hysteresis
                ;;
            5)
                test_continuous_monitoring
                ;;
            6)
                print_info "ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (Ctrl+Cë¡œ ì¤‘ì§€)..."
                camonitor "$CURRENT_VALUE_PV" "$OUTPUT_STATE_PV" "$THRESHOLD_PV" "$ENABLE_PV"
                ;;
            7)
                print_header "í˜„ì¬ ìƒíƒœ"
                echo "ì„ê³„ê°’: $(get_pv_value $THRESHOLD_PV) V"
                echo "íˆìŠ¤í…Œë¦¬ì‹œìŠ¤: $(get_pv_value $HYSTERESIS_PV) V"
                echo "í˜„ì¬ê°’: $(get_pv_value $CURRENT_VALUE_PV) V"
                echo "ì¶œë ¥ ìƒíƒœ: $(get_pv_value $OUTPUT_STATE_PV)"
                echo "í™œì„±í™” ìƒíƒœ: $(get_pv_value $ENABLE_PV)"
                echo "ì—…ë°ì´íŠ¸ ì£¼ê¸°: $(get_pv_value $UPDATE_RATE_PV) Hz"
                ;;
            8)
                cleanup
                ;;
            9)
                print_info "í…ŒìŠ¤íŠ¸ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤."
                exit 0
                ;;
            *)
                print_error "ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤."
                ;;
        esac
        
        wait_for_user
    done
}

function run_all_tests() {
    print_header "ThresholdLogic Controller ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹œì‘"
    
    test_pv_connections
    test_initial_setup
    test_enable_disable
    test_threshold_logic
    test_hysteresis
    test_update_rate
    test_alarm_conditions
    test_reset_function
    test_continuous_monitoring
    test_performance
    generate_test_report
    cleanup
    
    print_header "ëª¨ë“  í…ŒìŠ¤íŠ¸ ì™„ë£Œ!"
}

# ===== ìŠ¤í¬ë¦½íŠ¸ ì‹œì‘ =====

function main() {
    print_header "ThresholdLogic Controller í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸"
    print_info "ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ThresholdLogicControllerì˜ ëª¨ë“  ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•©ë‹ˆë‹¤."
    print_info "IOCê°€ ì‹¤í–‰ ì¤‘ì´ê³  ThresholdLogicì´ ì„¤ì •ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”."
    echo
    
    # ëª…ë ¹í–‰ ì¸ìˆ˜ í™•ì¸
    if [ "$1" = "--auto" ] || [ "$1" = "-a" ]; then
        print_info "ìë™ ëª¨ë“œë¡œ ì „ì²´ í…ŒìŠ¤íŠ¸ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤..."
        run_all_tests
    else
        print_info "ëŒ€í™”í˜• ëª¨ë“œë¡œ ì‹œì‘í•©ë‹ˆë‹¤..."
        interactive_mode
    fi
}

# ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
main "$@"










ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/st.cmd
=================================================
#!../../bin/linux-x86_64/USB1608G_2AO_V2
< envPaths

## Register all support components
dbLoadDatabase("$(TOP)/dbd/USB1608G_2AO_V2.dbd")
USB1608G_2AO_V2_registerRecordDeviceDriver(pdbbase)

## Environment variable setup
epicsEnvSet("PREFIX", "USB1608G_2AO:")
epicsEnvSet("PORT", "USB1608G_2AO_PORT")
epicsEnvSet("WDIG_POINTS", "1048576")
epicsEnvSet("WGEN_POINTS", "1048576")
epicsEnvSet("UNIQUE_ID", "01D97CFA")

## Configure port driver
MultiFunctionConfig("$(PORT)", "$(UNIQUE_ID)", $(WDIG_POINTS), $(WGEN_POINTS))

## Configure threshold logic controller
epicsEnvSet("THRESHOLD_PORT", "THRESHOLD_LOGIC_PORT")
ThresholdLogicConfig("$(THRESHOLD_PORT)", "$(PORT)", 0)

## Load database templates
dbLoadTemplate("$(TOP)/USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions", "P=$(PREFIX),PORT=$(PORT),WDIG_POINTS=$(WDIG_POINTS),WGEN_POINTS=$(WGEN_POINTS)")

## Load save/restore configuration
< save_restore.cmd

## Initialize IOC
iocInit

## Setup autosave monitoring
create_monitor_set("auto_settings.req",30,"P=$(PREFIX)")












ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/README_ThresholdLogic.md
=================================================
# ThresholdLogic Controller MEDM ë° í…ŒìŠ¤íŠ¸ ê°€ì´ë“œ

## ê°œìš”

ì´ ë¬¸ì„œëŠ” USB1608G-2AO IOCì— ì¶”ê°€ëœ ThresholdLogicControllerì˜ MEDM í™”ë©´ê³¼ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ì‚¬ìš©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤.

## íŒŒì¼ êµ¬ì„±

### MEDM í™”ë©´
- `USB1608G_2AO_cpp.adl` - ê¸°ì¡´ í™”ë©´ì— ThresholdLogic ì„¹ì…˜ ì¶”ê°€
- `medm_ThresholdLogic.sh` - ThresholdLogic ì „ìš© MEDM ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
- `medm_USB1608G_2AO.sh` - ê¸°ì¡´ ìŠ¤í¬ë¦½íŠ¸ì— ThresholdLogic ì˜µì…˜ ì¶”ê°€

### í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
- `catest_ThresholdLogic.sh` - í¬ê´„ì ì¸ ThresholdLogic í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
- `catest_USB1608G_2AO.sh` - ê¸°ì¡´ USB1608G-2AO í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸

## MEDM í™”ë©´ ì‚¬ìš©ë²•

### 1. ì „ì²´ ì‹œìŠ¤í…œ MEDM í™”ë©´ ì‹¤í–‰

```bash
# ë°©ë²• 1: ê¸°ì¡´ ìŠ¤í¬ë¦½íŠ¸ ì‚¬ìš© (ë©”ë‰´ì—ì„œ ì„ íƒ)
./medm_USB1608G_2AO.sh
# ë©”ë‰´ì—ì„œ 1ë²ˆ ë˜ëŠ” 2ë²ˆ ì„ íƒ

# ë°©ë²• 2: ì§ì ‘ ì‹¤í–‰
./medm_ThresholdLogic.sh
```

### 2. MEDM í™”ë©´ êµ¬ì„±

#### ê¸°ì¡´ ì„¹ì…˜ (ìƒë‹¨)
- **ì¥ì¹˜ ì •ë³´**: ëª¨ë¸ëª…, ê³ ìœ  ID, ë“œë¼ì´ë²„ ë²„ì „
- **ë””ì§€í„¸ I/O**: 8ì±„ë„ ë””ì§€í„¸ ì…ì¶œë ¥ ì œì–´
- **ì•„ë‚ ë¡œê·¸ ì…ë ¥**: 8ì±„ë„ ì•„ë‚ ë¡œê·¸ ì…ë ¥ ëª¨ë‹ˆí„°ë§
- **ì•„ë‚ ë¡œê·¸ ì¶œë ¥**: 2ì±„ë„ ì•„ë‚ ë¡œê·¸ ì¶œë ¥ ì œì–´
- **íŠ¸ë Œë“œ ì°¨íŠ¸**: ì‹¤ì‹œê°„ ë°ì´í„° ì‹œê°í™”

#### ìƒˆë¡œ ì¶”ê°€ëœ ThresholdLogic ì„¹ì…˜ (í•˜ë‹¨)

**ì„¤ì • ì»¨íŠ¸ë¡¤ (ì¢Œì¸¡)**:
- **Threshold**: ì„ê³„ê°’ ì„¤ì • (V ë‹¨ìœ„)
- **Hysteresis**: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê°’ ì„¤ì • (V ë‹¨ìœ„)
- **Update Rate**: ì—…ë°ì´íŠ¸ ì£¼ê¸° ì„¤ì • (Hz ë‹¨ìœ„)
- **Logic Status**: í˜„ì¬ ë¡œì§ ìƒíƒœ í‘œì‹œ
- **Reset**: ì‹œìŠ¤í…œ ë¦¬ì…‹ ë²„íŠ¼

**ìƒíƒœ ëª¨ë‹ˆí„°ë§ (ì¤‘ì•™)**:
- **Current Value**: í˜„ì¬ ì…ë ¥ê°’ ì‹¤ì‹œê°„ í‘œì‹œ
- **Output State**: ì¶œë ¥ ìƒíƒœ (LED í‘œì‹œ)
- **Enable**: ì»¨íŠ¸ë¡¤ëŸ¬ í™œì„±í™”/ë¹„í™œì„±í™” ë²„íŠ¼
- **Alarm Status**: ì•ŒëŒ ìƒíƒœ í‘œì‹œ

**ì‹œê°í™” (ìš°ì¸¡)**:
- **Meter**: í˜„ì¬ê°’ì„ ì•„ë‚ ë¡œê·¸ ë¯¸í„°ë¡œ í‘œì‹œ
- **Trend Chart**: í˜„ì¬ê°’ê³¼ ì„ê³„ê°’ì˜ ì‹œê°„ ì¶”ì´

**ë¡œì§ ì„¤ëª… ë°•ìŠ¤**:
- ì„ê³„ê°’ ë¡œì§ì˜ ë™ì‘ ì›ë¦¬ ì„¤ëª…
- íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê¸°ëŠ¥ ì„¤ëª…

### 3. ì‚¬ìš© ì ˆì°¨

1. **IOC ì‹œì‘ í™•ì¸**
   ```bash
   # IOCê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸
   ps aux | grep USB1608G_2AO_cpp
   ```

2. **MEDM í™”ë©´ ì‹¤í–‰**
   ```bash
   ./medm_ThresholdLogic.sh
   ```

3. **ThresholdLogic ì„¤ì •**
   - Threshold í•„ë“œì— ì›í•˜ëŠ” ì„ê³„ê°’ ì…ë ¥ (ì˜ˆ: 2.5)
   - Hysteresis í•„ë“œì— íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê°’ ì…ë ¥ (ì˜ˆ: 0.1)
   - Update Rate ì„¤ì • (ê¸°ë³¸ê°’: 10Hz)

4. **ì»¨íŠ¸ë¡¤ëŸ¬ í™œì„±í™”**
   - Enable ë²„íŠ¼ì„ í´ë¦­í•˜ì—¬ "Enabled"ë¡œ ë³€ê²½

5. **ë™ì‘ í™•ì¸**
   - Current Valueê°€ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ëŠ”ì§€ í™•ì¸
   - ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ Output Stateê°€ "High"ë¡œ ë³€ê²½ë˜ëŠ”ì§€ í™•ì¸
   - íŠ¸ë Œë“œ ì°¨íŠ¸ì—ì„œ ì‹œê°„ì— ë”°ë¥¸ ë³€í™” ê´€ì°°

## í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ì‚¬ìš©ë²•

### 1. ìë™ ì „ì²´ í…ŒìŠ¤íŠ¸

```bash
# ëª¨ë“  í…ŒìŠ¤íŠ¸ë¥¼ ìë™ìœ¼ë¡œ ì‹¤í–‰
./catest_ThresholdLogic.sh --auto
```

### 2. ëŒ€í™”í˜• í…ŒìŠ¤íŠ¸

```bash
# ëŒ€í™”í˜• ë©”ë‰´ë¡œ ì‹¤í–‰
./catest_ThresholdLogic.sh
```

ë©”ë‰´ ì˜µì…˜:
1. **ì „ì²´ í…ŒìŠ¤íŠ¸ ì‹¤í–‰** - ëª¨ë“  í…ŒìŠ¤íŠ¸ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì‹¤í–‰
2. **PV ì—°ê²° í…ŒìŠ¤íŠ¸ë§Œ** - PV ì—°ê²° ìƒíƒœë§Œ í™•ì¸
3. **ì„ê³„ê°’ ë¡œì§ í…ŒìŠ¤íŠ¸ë§Œ** - ì„ê³„ê°’ ë¹„êµ ë¡œì§ë§Œ í…ŒìŠ¤íŠ¸
4. **íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ í…ŒìŠ¤íŠ¸ë§Œ** - íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê¸°ëŠ¥ë§Œ í…ŒìŠ¤íŠ¸
5. **ì—°ì† ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸ë§Œ** - ì‚¬ì¸íŒŒ ì…ë ¥ìœ¼ë¡œ ì—°ì† í…ŒìŠ¤íŠ¸
6. **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§** - ì‹¤ì‹œê°„ PV ê°’ ëª¨ë‹ˆí„°ë§
7. **í˜„ì¬ ìƒíƒœ í™•ì¸** - í˜„ì¬ ì„¤ì • ë° ìƒíƒœ í™•ì¸
8. **ì„¤ì • ì´ˆê¸°í™”** - ëª¨ë“  ì„¤ì •ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì´ˆê¸°í™”
9. **ì¢…ë£Œ** - ìŠ¤í¬ë¦½íŠ¸ ì¢…ë£Œ

### 3. í…ŒìŠ¤íŠ¸ ë‚´ìš©

#### PV ì—°ê²° í…ŒìŠ¤íŠ¸
- ëª¨ë“  ThresholdLogic PVì˜ ì—°ê²° ìƒíƒœ í™•ì¸
- IOC ì‹¤í–‰ ìƒíƒœ ê²€ì¦

#### ì„ê³„ê°’ ë¡œì§ í…ŒìŠ¤íŠ¸
- ë‹¤ì–‘í•œ ì…ë ¥ ì „ì••ì— ëŒ€í•œ ì¶œë ¥ ìƒíƒœ í™•ì¸
- ì„ê³„ê°’ ì´ˆê³¼/ë¯¸ë§Œ ì‹œ ë™ì‘ ê²€ì¦
- ë¡œì§ ì •í™•ì„± ê²€ì¦

#### íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ í…ŒìŠ¤íŠ¸
- íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ê¸°ëŠ¥ ë™ì‘ í™•ì¸
- ì¶œë ¥ ì§„ë™ ë°©ì§€ ê¸°ëŠ¥ ê²€ì¦
- ìƒí–¥/í•˜í–¥ ì„ê³„ê°’ ë™ì‘ í™•ì¸

#### ì—°ì† ëª¨ë‹ˆí„°ë§ í…ŒìŠ¤íŠ¸
- ì‚¬ì¸íŒŒ ì…ë ¥ìœ¼ë¡œ 30ì´ˆê°„ ì—°ì† í…ŒìŠ¤íŠ¸
- ì¶œë ¥ ìƒíƒœ ë³€í™” íšŸìˆ˜ ì¹´ìš´íŠ¸
- ì‹¤ì‹œê°„ ì‘ë‹µì„± í™•ì¸

#### ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
- ë¹ ë¥¸ ì…ë ¥ ë³€í™”ì— ëŒ€í•œ ì‘ë‹µì„± í…ŒìŠ¤íŠ¸
- ë‹¤ì–‘í•œ ì—…ë°ì´íŠ¸ ì£¼ê¸°ì—ì„œì˜ ë™ì‘ í™•ì¸
- CPU ì‚¬ìš©ë¥  ë° ì•ˆì •ì„± ê²€ì¦

## ë¬¸ì œ í•´ê²°

### 1. MEDM ì‹¤í–‰ ì˜¤ë¥˜

**ì¦ìƒ**: MEDMì´ ì‹œì‘ë˜ì§€ ì•ŠìŒ
```bash
medm: command not found
```

**í•´ê²° ë°©ë²•**:
```bash
# MEDM ì„¤ì¹˜ í™•ì¸
which medm

# EPICS Extensions ê²½ë¡œ í™•ì¸
echo $PATH | grep -i medm

# í•„ìš”ì‹œ PATH ì¶”ê°€
export PATH=$PATH:/usr/local/epics/extensions/bin/$EPICS_HOST_ARCH
```

### 2. PV ì—°ê²° ì‹¤íŒ¨

**ì¦ìƒ**: PV ì—°ê²° íƒ€ì„ì•„ì›ƒ
```bash
Channel connect timed out
```

**í•´ê²° ë°©ë²•**:
```bash
# IOC ì‹¤í–‰ ìƒíƒœ í™•ì¸
ps aux | grep USB1608G_2AO_cpp

# IOC ì¬ì‹œì‘
cd iocBoot/iocUSB1608G_2AO_cpp
../../bin/linux-x86_64/USB1608G_2AO_cpp st.cmd

# ë„¤íŠ¸ì›Œí¬ ì„¤ì • í™•ì¸
echo $EPICS_CA_ADDR_LIST
echo $EPICS_CA_AUTO_ADDR_LIST
```

### 3. ThresholdLogic ë™ì‘ ì•ˆí•¨

**ì¦ìƒ**: ì„ê³„ê°’ì„ ì´ˆê³¼í•´ë„ ì¶œë ¥ì´ ë³€ê²½ë˜ì§€ ì•ŠìŒ

**í•´ê²° ë°©ë²•**:
```bash
# ì»¨íŠ¸ë¡¤ëŸ¬ í™œì„±í™” ìƒíƒœ í™•ì¸
caget USB1608G_2AO_cpp:ThresholdLogic1Enable

# í™œì„±í™”
caput USB1608G_2AO_cpp:ThresholdLogic1Enable 1

# í˜„ì¬ê°’ í™•ì¸
caget USB1608G_2AO_cpp:ThresholdLogic1CurrentValue

# ì„ê³„ê°’ í™•ì¸
caget USB1608G_2AO_cpp:ThresholdLogic1Threshold
```

### 4. í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ ê¶Œí•œ ì˜¤ë¥˜

**ì¦ìƒ**: Permission denied

**í•´ê²° ë°©ë²•**:
```bash
# ì‹¤í–‰ ê¶Œí•œ ë¶€ì—¬
chmod +x catest_ThresholdLogic.sh
chmod +x medm_ThresholdLogic.sh

# ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰
./catest_ThresholdLogic.sh
```

## ê³ ê¸‰ ì‚¬ìš©ë²•

### 1. ì‚¬ìš©ì ì •ì˜ í…ŒìŠ¤íŠ¸

í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ìˆ˜ì •í•˜ì—¬ íŠ¹ì • ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” í…ŒìŠ¤íŠ¸ ì¶”ê°€:

```bash
# ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬
cp catest_ThresholdLogic.sh my_custom_test.sh

# ì‚¬ìš©ì ì •ì˜ í…ŒìŠ¤íŠ¸ í•¨ìˆ˜ ì¶”ê°€
function my_custom_test() {
    print_header "ì‚¬ìš©ì ì •ì˜ í…ŒìŠ¤íŠ¸"
    # ì—¬ê¸°ì— ì‚¬ìš©ì ì •ì˜ í…ŒìŠ¤íŠ¸ ë¡œì§ ì¶”ê°€
}
```

### 2. ìë™í™”ëœ ëª¨ë‹ˆí„°ë§

ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ì„ ìœ„í•œ ìë™í™” ìŠ¤í¬ë¦½íŠ¸:

```bash
# ì£¼ê¸°ì  ìƒíƒœ í™•ì¸
while true; do
    echo "$(date): $(caget -t USB1608G_2AO_cpp:ThresholdLogic1CurrentValue) V"
    sleep 10
done
```

### 3. ë¡œê·¸ ë¶„ì„

í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë¡œê·¸ ë¶„ì„:

```bash
# í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œ í™•ì¸
cat /tmp/threshold_logic_test_report.txt

# íŠ¹ì • íŒ¨í„´ ê²€ìƒ‰
grep -i "error\|fail" /tmp/threshold_logic_test_report.txt
```

## ì°¸ê³  ìë£Œ

- [EPICS MEDM ì‚¬ìš©ì ê°€ì´ë“œ](https://epics.anl.gov/EpicsDocumentation/ExtensionsManuals/MEDM/MEDM.html)
- [Channel Access í´ë¼ì´ì–¸íŠ¸ ë„êµ¬](https://epics.anl.gov/base/R7-0/8-docs/CAref.html)
- [ThresholdLogicController API ë¬¸ì„œ](../../docs/ThresholdLogicController_API_Documentation.md)
- [ë¬¸ì œ í•´ê²° ê°€ì´ë“œ](../../docs/ThresholdLogicController_Troubleshooting_Guide.md)

## ë²„ì „ ì •ë³´

- ìƒì„±ì¼: 2025ë…„ 8ì›” 20ì¼
- ThresholdLogicController ë²„ì „: 1.0.0
- EPICS Base í˜¸í™˜ì„±: R7.0+
- í…ŒìŠ¤íŠ¸ í™˜ê²½: Linux x86_64










ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/Makefile
=================================================
TOP = ../..
include $(TOP)/configure/CONFIG
ARCH = $(EPICS_HOST_ARCH)
TARGETS = envPaths
include $(TOP)/configure/RULES.ioc











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/auto_settings.req
=================================================
    file "/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2/USB1608G_2AO_V2App/Db/USB1608G_2AO_settings.req", P=$(P)
    file "/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2/USB1608G_2AO_V2App/Db/threshold_logic_settings.req", P=$(P)











ğŸ”¥ File: ./iocBoot/iocUSB1608G_2AO_V2/Log_stCmd.log
=================================================
#!../../bin/linux-x86_64/USB1608G_2AO_V2
< envPaths
epicsEnvSet("IOC","iocUSB1608G_2AO_V2")
epicsEnvSet("TOP","/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2")
epicsEnvSet("EPICS_BASE","/usr/local/epics/EPICS_R7.0/base")
epicsEnvSet("SUPPORT","/usr/local/epics/EPICS_R7.0/modules/synApps/support")
epicsEnvSet("ASYN","/usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2")
epicsEnvSet("CALC","/usr/local/epics/EPICS_R7.0/modules/synApps/support/calc-R3-7-5")
epicsEnvSet("SCALER","/usr/local/epics/EPICS_R7.0/modules/synApps/support/scaler-4-1")
epicsEnvSet("MCA","/usr/local/epics/EPICS_R7.0/modules/synApps/support/mca-R7-10")
epicsEnvSet("BUSY","/usr/local/epics/EPICS_R7.0/modules/synApps/support/busy-R1-7-4")
epicsEnvSet("SSCAN","/usr/local/epics/EPICS_R7.0/modules/synApps/support/sscan-R2-11-6")
epicsEnvSet("AUTOSAVE","/usr/local/epics/EPICS_R7.0/modules/synApps/support/autosave-R5-11")
epicsEnvSet("SNCSEQ","/usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9")
epicsEnvSet("MEASCOMP","/usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2")
## Register all support components
dbLoadDatabase("/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2/dbd/USB1608G_2AO_V2.dbd")
USB1608G_2AO_V2_registerRecordDeviceDriver(pdbbase)
ThresholdLogicRegister: IOC ì‰˜ ëª…ë ¹ì–´ ë“±ë¡ ì™„ë£Œ
  - ThresholdLogicConfig: ì„ê³„ê°’ ë¡œì§ ì»¨íŠ¸ë¡¤ëŸ¬ ìƒì„±
  - ThresholdLogicHelp: ì‚¬ìš©ë²• ë„ì›€ë§ í‘œì‹œ
ë„ì›€ë§ì„ ë³´ë ¤ë©´ 'ThresholdLogicHelp'ë¥¼ ì…ë ¥í•˜ì„¸ìš”.
## Environment variable setup
epicsEnvSet("PREFIX", "USB1608G_2AO:")
epicsEnvSet("PORT", "USB1608G_2AO_PORT")
epicsEnvSet("WDIG_POINTS", "1048576")
epicsEnvSet("WGEN_POINTS", "1048576")
epicsEnvSet("UNIQUE_ID", "01D97CFA")
## Configure port driver
MultiFunctionConfig("USB1608G_2AO_PORT", "01D97CFA", 1048576, 1048576)
## Configure threshold logic controller
epicsEnvSet("THRESHOLD_PORT", "THRESHOLD_LOGIC_PORT")
ThresholdLogicConfig("THRESHOLD_LOGIC_PORT", "USB1608G_2AO_PORT", 0)
[2025-08-30 15:17:31.899114] [ê²½ê³ ] validateConfigurationWithErrorHandler: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ê°€ ì„ê³„ê°’ë³´ë‹¤ í½ë‹ˆë‹¤
[2025-08-30 15:17:31.899126] [ì •ë³´] validateConfigurationWithErrorHandler: íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ë¥¼ ì„ê³„ê°’ ì ˆëŒ“ê°’ë³´ë‹¤ ì‘ê²Œ ì„¤ì •í•˜ì„¸ìš”
[2025-08-30 15:17:31.899129] [ì •ë³´] ThresholdLogicController: í¬íŠ¸=THRESHOLD_LOGIC_PORT, ì¥ì¹˜í¬íŠ¸=USB1608G_2AO_PORT, ì£¼ì†Œ=0ë¡œ ThresholdLogicController ìƒì„±ë¨
ThresholdLogicConfig: ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë¨ - í¬íŠ¸: THRESHOLD_LOGIC_PORT, ì¥ì¹˜í¬íŠ¸: USB1608G_2AO_PORT, ì£¼ì†Œ: 0
## Load database templates
dbLoadTemplate("/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2/USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions", "P=USB1608G_2AO:,PORT=USB1608G_2AO_PORT,WDIG_POINTS=1048576,WGEN_POINTS=1048576")
## Load save/restore configuration
< save_restore.cmd
# Debug-output level
save_restoreSet_Debug(0)
# Ok to save/restore save sets with missing values (no CA connection to PV)?
save_restoreSet_IncompleteSetsOk(1)
# Save dated backup files?
save_restoreSet_DatedBackupFiles(1)
# Number of sequenced backup files to write
save_restoreSet_NumSeqFiles(3)
# Time interval between sequenced backups
save_restoreSet_SeqPeriodInSeconds(300)
# specify where save files should be
set_savefile_path(".", "autosave")
# specify what save files should be restored.  Note these files must be
# in the directory specified in set_savefile_path(), or, if that function
# has not been called, from the directory current when iocInit is invoked0
set_pass0_restoreFile("auto_settings.sav")
set_pass1_restoreFile("auto_settings.sav")
# specify directories in which to to search for included request files
# Note cdCommands defines 'startup', but envPaths does not
set_requestfile_path(".",         "")
set_requestfile_path(".",         "autosave")
set_requestfile_path(/usr/local/epics/EPICS_R7.0/modules/synApps/support/autosave-R5-11, "db")
set_requestfile_path(/usr/local/epics/EPICS_R7.0/modules/synApps/support/calc-R3-7-5,     "db")
set_requestfile_path(/usr/local/epics/EPICS_R7.0/modules/synApps/support/scaler-4-1,   "db")
set_requestfile_path(/usr/local/epics/EPICS_R7.0/modules/synApps/support/sscan-R2-11-6,    "db")
set_requestfile_path(/usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2, "db")
## Initialize IOC
iocInit
############################################################################
## EPICS R7.0.7
## Rev. 2025-08-12T12:26+0900
## Rev. Date build date/time: 
############################################################################
save_restore: **********************************

USB1608G_2AO:ThresholdLogic1Threshold devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1Hysteresis devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1UpdateRate devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2Threshold devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2Hysteresis devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2UpdateRate devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3Threshold devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3Hysteresis devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3UpdateRate devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4Threshold devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4Hysteresis devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4UpdateRate devAsynFloat64::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1AlarmState devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2AlarmState devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3AlarmState devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4AlarmState devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1Enable devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1Reset devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2Enable devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2Reset devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3Enable devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3Reset devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4Enable devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4Reset devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1TriggerCount devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2TriggerCount devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3TriggerCount devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4TriggerCount devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1Status devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic2Status devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic3Status devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic4Status devAsynInt32::initCommon drvUserCreate 
USB1608G_2AO:ThresholdLogic1LastUpdate devAsynOctet::initDrvUser drvUserCreate failed 
USB1608G_2AO:ThresholdLogic2LastUpdate devAsynOctet::initDrvUser drvUserCreate failed 
USB1608G_2AO:ThresholdLogic3LastUpdate devAsynOctet::initDrvUser drvUserCreate failed 
USB1608G_2AO:ThresholdLogic4LastUpdate devAsynOctet::initDrvUser drvUserCreate failed 
save_restore: **********************************

## Setup autosave monitoring
create_monitor_set("auto_settings.req",30,"P=USB1608G_2AO:")
save_restore: connect failed for channel 'file'
save_restore: connect failed for channel 'file'
auto_settings.sav: 0 of 2 PV's connected
[?2004hepics> 
[?2004l[?2004hepics> 
[?2004l[?2004hepics> 
[?2004l[?2004hepics> dbl
[?2004lUSB1608G_2AO:PollTimeMS
USB1608G_2AO:PulseGen1Period_RBV
USB1608G_2AO:PulseGen1DutyCycle_RBV
USB1608G_2AO:PulseGen1Delay_RBV
USB1608G_2AO:Ai1
USB1608G_2AO:Ai2
USB1608G_2AO:Ai3
USB1608G_2AO:Ai4
USB1608G_2AO:Ai5
USB1608G_2AO:Ai6
USB1608G_2AO:Ai7
USB1608G_2AO:Ai8
USB1608G_2AO:WaveDigDwellActual
USB1608G_2AO:WaveDigTotalTime
USB1608G_2AO:WaveGenFrequency
USB1608G_2AO:WaveGenDwell
USB1608G_2AO:WaveGenDwellActual
USB1608G_2AO:WaveGenTotalTime
USB1608G_2AO:ThresholdLogic1CurrentValue
USB1608G_2AO:ThresholdLogic2CurrentValue
USB1608G_2AO:ThresholdLogic3CurrentValue
USB1608G_2AO:ThresholdLogic4CurrentValue
USB1608G_2AO:PollSleepMS
USB1608G_2AO:PulseGen1Period
USB1608G_2AO:PulseGen1Frequency
USB1608G_2AO:PulseGen1DutyCycle
USB1608G_2AO:PulseGen1Width
USB1608G_2AO:PulseGen1Delay
USB1608G_2AO:Ai1Rate
USB1608G_2AO:Ai2Rate
USB1608G_2AO:Ai3Rate
USB1608G_2AO:Ai4Rate
USB1608G_2AO:Ai5Rate
USB1608G_2AO:Ai6Rate
USB1608G_2AO:Ai7Rate
USB1608G_2AO:Ai8Rate
USB1608G_2AO:WaveDigDwell
USB1608G_2AO:Ao1
USB1608G_2AO:Ao1Return
USB1608G_2AO:Ao1TweakVal
USB1608G_2AO:Ao2
USB1608G_2AO:Ao2Return
USB1608G_2AO:Ao2TweakVal
USB1608G_2AO:WaveGenIntDwell
USB1608G_2AO:WaveGenIntFrequency
USB1608G_2AO:WaveGenUserDwell
USB1608G_2AO:WaveGenUserFrequency
USB1608G_2AO:WaveGen1PulseWidth
USB1608G_2AO:WaveGen1Amplitude
USB1608G_2AO:WaveGen1Offset
USB1608G_2AO:WaveGen2PulseWidth
USB1608G_2AO:WaveGen2Amplitude
USB1608G_2AO:WaveGen2Offset
USB1608G_2AO:ThresholdLogic1Threshold
USB1608G_2AO:ThresholdLogic1Hysteresis
USB1608G_2AO:ThresholdLogic1UpdateRate
USB1608G_2AO:ThresholdLogic2Threshold
USB1608G_2AO:ThresholdLogic2Hysteresis
USB1608G_2AO:ThresholdLogic2UpdateRate
USB1608G_2AO:ThresholdLogic3Threshold
USB1608G_2AO:ThresholdLogic3Hysteresis
USB1608G_2AO:ThresholdLogic3UpdateRate
USB1608G_2AO:ThresholdLogic4Threshold
USB1608G_2AO:ThresholdLogic4Hysteresis
USB1608G_2AO:ThresholdLogic4UpdateRate
USB1608G_2AO:Bi1
USB1608G_2AO:Bi2
USB1608G_2AO:Bi3
USB1608G_2AO:Bi4
USB1608G_2AO:Bi5
USB1608G_2AO:Bi6
USB1608G_2AO:Bi7
USB1608G_2AO:Bi8
USB1608G_2AO:Bo1_RBV
USB1608G_2AO:Bo2_RBV
USB1608G_2AO:Bo3_RBV
USB1608G_2AO:Bo4_RBV
USB1608G_2AO:Bo5_RBV
USB1608G_2AO:Bo6_RBV
USB1608G_2AO:Bo7_RBV
USB1608G_2AO:Bo8_RBV
USB1608G_2AO:ThresholdLogic1OutputState
USB1608G_2AO:ThresholdLogic1AlarmState
USB1608G_2AO:ThresholdLogic2OutputState
USB1608G_2AO:ThresholdLogic2AlarmState
USB1608G_2AO:ThresholdLogic3OutputState
USB1608G_2AO:ThresholdLogic3AlarmState
USB1608G_2AO:ThresholdLogic4OutputState
USB1608G_2AO:ThresholdLogic4AlarmState
USB1608G_2AO:Bo1
USB1608G_2AO:Bo2
USB1608G_2AO:Bo3
USB1608G_2AO:Bo4
USB1608G_2AO:Bo5
USB1608G_2AO:Bo6
USB1608G_2AO:Bo7
USB1608G_2AO:Bo8
USB1608G_2AO:Bd1
USB1608G_2AO:Bd2
USB1608G_2AO:Bd3
USB1608G_2AO:Bd4
USB1608G_2AO:Bd5
USB1608G_2AO:Bd6
USB1608G_2AO:Bd7
USB1608G_2AO:Bd8
USB1608G_2AO:PulseGen1Run
USB1608G_2AO:PulseGen1IdleState
USB1608G_2AO:Counter1Reset
USB1608G_2AO:Counter2Reset
USB1608G_2AO:WaveDigExtTrigger
USB1608G_2AO:WaveDigExtClock
USB1608G_2AO:WaveDigContinuous
USB1608G_2AO:WaveDigAutoRestart
USB1608G_2AO:WaveDigRetrigger
USB1608G_2AO:WaveDigBurstMode
USB1608G_2AO:Ao1Pulse
USB1608G_2AO:Ao2Pulse
USB1608G_2AO:WaveGenExtTrigger
USB1608G_2AO:WaveGenExtClock
USB1608G_2AO:WaveGenContinuous
USB1608G_2AO:WaveGenRetrigger
USB1608G_2AO:WaveGen1Enable
USB1608G_2AO:WaveGen2Enable
USB1608G_2AO:ThresholdLogic1Enable
USB1608G_2AO:ThresholdLogic1Reset
USB1608G_2AO:ThresholdLogic2Enable
USB1608G_2AO:ThresholdLogic2Reset
USB1608G_2AO:ThresholdLogic3Enable
USB1608G_2AO:ThresholdLogic3Reset
USB1608G_2AO:ThresholdLogic4Enable
USB1608G_2AO:ThresholdLogic4Reset
USB1608G_2AO:WaveDigRun
USB1608G_2AO:WaveDigReadWF
USB1608G_2AO:WaveGenRun
USB1608G_2AO:PulseGen1Frequency_RBV
USB1608G_2AO:PulseGen1Width_RBV
USB1608G_2AO:PulseGen1CalcFrequency
USB1608G_2AO:PulseGen1CalcPeriod
USB1608G_2AO:PulseGen1CalcWidth
USB1608G_2AO:PulseGen1CalcDutyCycle
USB1608G_2AO:Ao1TweakUp
USB1608G_2AO:Ao1TweakDown
USB1608G_2AO:Ao2TweakUp
USB1608G_2AO:Ao2TweakDown
USB1608G_2AO:WaveGenCalcIntFrequency
USB1608G_2AO:WaveGenCalcIntDwell
USB1608G_2AO:WaveGenCalcUserFrequency
USB1608G_2AO:WaveGenCalcUserDwell
USB1608G_2AO:ThresholdLogic1Compare
USB1608G_2AO:ThresholdLogic2Compare
USB1608G_2AO:ThresholdLogic3Compare
USB1608G_2AO:ThresholdLogic4Compare
USB1608G_2AO:ModelNumber
USB1608G_2AO:Li
USB1608G_2AO:Lo_RBV
USB1608G_2AO:Counter1Counts
USB1608G_2AO:Counter2Counts
USB1608G_2AO:WaveDigCurrentPoint
USB1608G_2AO:WaveGenNumPoints
USB1608G_2AO:WaveGenCurrentPoint
USB1608G_2AO:ThresholdLogic1TriggerCount
USB1608G_2AO:ThresholdLogic2TriggerCount
USB1608G_2AO:ThresholdLogic3TriggerCount
USB1608G_2AO:ThresholdLogic4TriggerCount
USB1608G_2AO:Lo
USB1608G_2AO:PulseGen1Count
USB1608G_2AO:WaveDigNumPoints
USB1608G_2AO:WaveDigTriggerCount
USB1608G_2AO:WaveGenUserNumPoints
USB1608G_2AO:WaveGenIntNumPoints
USB1608G_2AO:WaveGenTriggerCount
USB1608G_2AO:ThresholdLogic1Status
USB1608G_2AO:ThresholdLogic2Status
USB1608G_2AO:ThresholdLogic3Status
USB1608G_2AO:ThresholdLogic4Status
USB1608G_2AO:AiMode
USB1608G_2AO:Ai1Range
USB1608G_2AO:Ai1Type
USB1608G_2AO:Ai2Range
USB1608G_2AO:Ai2Type
USB1608G_2AO:Ai3Range
USB1608G_2AO:Ai3Type
USB1608G_2AO:Ai4Range
USB1608G_2AO:Ai4Type
USB1608G_2AO:Ai5Range
USB1608G_2AO:Ai5Type
USB1608G_2AO:Ai6Range
USB1608G_2AO:Ai6Type
USB1608G_2AO:Ai7Range
USB1608G_2AO:Ai7Type
USB1608G_2AO:Ai8Range
USB1608G_2AO:Ai8Type
USB1608G_2AO:WaveDigFirstChan
USB1608G_2AO:WaveDigNumChans
USB1608G_2AO:Ao1Range
USB1608G_2AO:Ao2Range
USB1608G_2AO:WaveGen1Type
USB1608G_2AO:WaveGen2Type
USB1608G_2AO:TrigMode
USB1608G_2AO:ModelName
USB1608G_2AO:FirmwareVersion
USB1608G_2AO:UniqueID
USB1608G_2AO:ULVersion
USB1608G_2AO:DriverVersion
USB1608G_2AO:ThresholdLogic1LastUpdate
USB1608G_2AO:ThresholdLogic2LastUpdate
USB1608G_2AO:ThresholdLogic3LastUpdate
USB1608G_2AO:ThresholdLogic4LastUpdate
USB1608G_2AO:LastErrorMessage
USB1608G_2AO:WaveDigTimeWF
USB1608G_2AO:WaveDigAbsTimeWF
USB1608G_2AO:WaveDig1VoltWF
USB1608G_2AO:WaveDig2VoltWF
USB1608G_2AO:WaveDig3VoltWF
USB1608G_2AO:WaveDig4VoltWF
USB1608G_2AO:WaveDig5VoltWF
USB1608G_2AO:WaveDig6VoltWF
USB1608G_2AO:WaveDig7VoltWF
USB1608G_2AO:WaveDig8VoltWF
USB1608G_2AO:WaveGenUserTimeWF
USB1608G_2AO:WaveGenIntTimeWF
USB1608G_2AO:WaveGen1UserWF
USB1608G_2AO:WaveGen1InternalWF
USB1608G_2AO:WaveGen2UserWF
USB1608G_2AO:WaveGen2InternalWF
[?2004hepics> 
[?2004l[?2004hepics> 
[?2004l[?2004hepics> 
[?2004l[?2004hepics> save_restore:write_save_file: Backup file (./autosave/auto_settings.savB) bad or not found.  Writing a new one. [250830-151833]
[Kepics> [Kepics> [Kepics> [?2004l










ğŸ”¥ File: ./iocBoot/Makefile
=================================================
TOP = ..
include $(TOP)/configure/CONFIG
DIRS += $(wildcard *ioc*)
DIRS += $(wildcard as*)
include $(CONFIG)/RULES_DIRS





















































ğŸŸ¦ 09_SUBDIRECTORY: lib
ğŸ“ tree -L 2 of lib/
./lib
â””â”€â”€ linux-x86_64

1 directory, 0 files

ğŸ“„ All files under lib/:

ğŸ“„ Contents of files under lib/:
