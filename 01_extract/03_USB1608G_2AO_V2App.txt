📁 tree of USB1608G_2AO_V2App/
./USB1608G_2AO_V2App
├── Db
│   ├── Makefile
│   ├── O.Common
│   ├── O.linux-x86_64
│   │   └── Makefile
│   ├── USB1608G_2AO.substitutions
│   ├── USB1608G_2AO_settings.req
│   ├── measCompAnalogIn.template
│   ├── measCompAnalogInMode.template
│   ├── measCompAnalogInMode_settings.req
│   ├── measCompAnalogIn_settings.req
│   ├── measCompAnalogOut.template
│   ├── measCompAnalogOut_settings.req
│   ├── measCompBinaryDir.template
│   ├── measCompBinaryDir_settings.req
│   ├── measCompBinaryIn.template
│   ├── measCompBinaryOut.template
│   ├── measCompCounter.template
│   ├── measCompDevice.template
│   ├── measCompEncoder.template
│   ├── measCompLongIn.template
│   ├── measCompLongOut.template
│   ├── measCompMCS.template
│   ├── measCompMCSWaveform.template
│   ├── measCompMCS_settings.req
│   ├── measCompPulseGen.template
│   ├── measCompPulseGen_settings.req
│   ├── measCompTemperatureIn.template
│   ├── measCompTemperatureIn_settings.req
│   ├── measCompTrigger.template
│   ├── measCompTrigger_settings.req
│   ├── measCompUSBTempConfig.template
│   ├── measCompUSBTempConfig_settings.req
│   ├── measCompVoltageIn.template
│   ├── measCompVoltageIn_settings.req
│   ├── measCompWaveformDig.template
│   ├── measCompWaveformDigN.template
│   ├── measCompWaveformDig_settings.req
│   ├── measCompWaveformGen.template
│   ├── measCompWaveformGenN.template
│   ├── measCompWaveformGenN_settings.req
│   ├── measCompWaveformGen_settings.req
│   ├── threshold_logic.template
│   ├── user.db
│   ├── user.proto
│   └── user.substitutions
├── Makefile
├── op
│   ├── USB1608G_2AO_V2.adl
│   ├── USB1608G_2AO_V2.opi
│   ├── measCompADCStripChart.adl
│   ├── measCompAiSetup.adl
│   ├── measCompAnalogIn8.adl
│   ├── measCompAnalogIn8.opi
│   ├── measCompAnalogOut2.adl
│   ├── measCompAnalogOut2.opi
│   ├── measCompAoSetup2.adl
│   ├── measCompDigitalIO8.adl
│   └── measCompDigitalIO8.opi
└── src
    ├── ErrorHandler.cpp
    ├── ErrorHandler.h
    ├── Makefile
    ├── O.Common
    │   └── USB1608G_2AO_V2.dbd
    ├── O.linux-x86_64
    │   ├── ErrorHandler.d
    │   ├── ErrorHandler.o
    │   ├── Makefile
    │   ├── ThresholdLogicController.d
    │   ├── ThresholdLogicController.o
    │   ├── USB1608G_2AO_V2
    │   ├── USB1608G_2AO_V2.dbd.d
    │   ├── USB1608G_2AO_V2Main.d
    │   ├── USB1608G_2AO_V2Main.o
    │   ├── USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
    │   ├── USB1608G_2AO_V2_registerRecordDeviceDriver.d
    │   ├── USB1608G_2AO_V2_registerRecordDeviceDriver.o
    │   ├── USBCTR_SNL.c
    │   ├── USBCTR_SNL.d
    │   ├── USBCTR_SNL.i
    │   ├── USBCTR_SNL.o
    │   ├── USBCTR_SNL.st.d
    │   ├── drvMultiFunction.d
    │   ├── drvMultiFunction.o
    │   ├── drvUSBCTR.d
    │   ├── drvUSBCTR.o
    │   ├── measCompDiscover.d
    │   └── measCompDiscover.o
    ├── ThresholdLogicController.cpp
    ├── ThresholdLogicController.h
    ├── USB1608G_2AO_V2Main.cpp
    ├── USBCTR_SNL.st
    ├── drvMultiFunction.cpp
    ├── drvUSBCTR.cpp
    ├── measCompAppMain.cpp
    ├── measCompDiscover.cpp
    ├── measCompDiscover.h
    ├── measCompSupport.dbd
    └── thresholdLogicSupport.dbd

7 directories, 93 files










📄 All files under USB1608G_2AO_V2App/:
./USB1608G_2AO_V2App/Db/Makefile
./USB1608G_2AO_V2App/Db/O.linux-x86_64/Makefile
./USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions
./USB1608G_2AO_V2App/Db/USB1608G_2AO_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogIn.template
./USB1608G_2AO_V2App/Db/measCompAnalogInMode.template
./USB1608G_2AO_V2App/Db/measCompAnalogInMode_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogIn_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogOut.template
./USB1608G_2AO_V2App/Db/measCompAnalogOut_settings.req
./USB1608G_2AO_V2App/Db/measCompBinaryDir.template
./USB1608G_2AO_V2App/Db/measCompBinaryDir_settings.req
./USB1608G_2AO_V2App/Db/measCompBinaryIn.template
./USB1608G_2AO_V2App/Db/measCompBinaryOut.template
./USB1608G_2AO_V2App/Db/measCompCounter.template
./USB1608G_2AO_V2App/Db/measCompDevice.template
./USB1608G_2AO_V2App/Db/measCompEncoder.template
./USB1608G_2AO_V2App/Db/measCompLongIn.template
./USB1608G_2AO_V2App/Db/measCompLongOut.template
./USB1608G_2AO_V2App/Db/measCompMCS.template
./USB1608G_2AO_V2App/Db/measCompMCSWaveform.template
./USB1608G_2AO_V2App/Db/measCompMCS_settings.req
./USB1608G_2AO_V2App/Db/measCompPulseGen.template
./USB1608G_2AO_V2App/Db/measCompPulseGen_settings.req
./USB1608G_2AO_V2App/Db/measCompTemperatureIn.template
./USB1608G_2AO_V2App/Db/measCompTemperatureIn_settings.req
./USB1608G_2AO_V2App/Db/measCompTrigger.template
./USB1608G_2AO_V2App/Db/measCompTrigger_settings.req
./USB1608G_2AO_V2App/Db/measCompUSBTempConfig.template
./USB1608G_2AO_V2App/Db/measCompUSBTempConfig_settings.req
./USB1608G_2AO_V2App/Db/measCompVoltageIn.template
./USB1608G_2AO_V2App/Db/measCompVoltageIn_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformDig.template
./USB1608G_2AO_V2App/Db/measCompWaveformDigN.template
./USB1608G_2AO_V2App/Db/measCompWaveformDig_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformGen.template
./USB1608G_2AO_V2App/Db/measCompWaveformGenN.template
./USB1608G_2AO_V2App/Db/measCompWaveformGenN_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformGen_settings.req
./USB1608G_2AO_V2App/Db/threshold_logic.template
./USB1608G_2AO_V2App/Db/user.db
./USB1608G_2AO_V2App/Db/user.proto
./USB1608G_2AO_V2App/Db/user.substitutions
./USB1608G_2AO_V2App/Makefile
./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.adl
./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.opi
./USB1608G_2AO_V2App/op/measCompADCStripChart.adl
./USB1608G_2AO_V2App/op/measCompAiSetup.adl
./USB1608G_2AO_V2App/op/measCompAnalogIn8.adl
./USB1608G_2AO_V2App/op/measCompAnalogIn8.opi
./USB1608G_2AO_V2App/op/measCompAnalogOut2.adl
./USB1608G_2AO_V2App/op/measCompAnalogOut2.opi
./USB1608G_2AO_V2App/op/measCompAoSetup2.adl
./USB1608G_2AO_V2App/op/measCompDigitalIO8.adl
./USB1608G_2AO_V2App/op/measCompDigitalIO8.opi
./USB1608G_2AO_V2App/src/ErrorHandler.cpp
./USB1608G_2AO_V2App/src/ErrorHandler.h
./USB1608G_2AO_V2App/src/Makefile
./USB1608G_2AO_V2App/src/O.Common/USB1608G_2AO_V2.dbd
./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/Makefile
./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2.dbd.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.c
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.i
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.st.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.o
./USB1608G_2AO_V2App/src/ThresholdLogicController.cpp
./USB1608G_2AO_V2App/src/ThresholdLogicController.h
./USB1608G_2AO_V2App/src/USB1608G_2AO_V2Main.cpp
./USB1608G_2AO_V2App/src/USBCTR_SNL.st
./USB1608G_2AO_V2App/src/drvMultiFunction.cpp
./USB1608G_2AO_V2App/src/drvUSBCTR.cpp
./USB1608G_2AO_V2App/src/measCompAppMain.cpp
./USB1608G_2AO_V2App/src/measCompDiscover.cpp
./USB1608G_2AO_V2App/src/measCompDiscover.h
./USB1608G_2AO_V2App/src/measCompSupport.dbd
./USB1608G_2AO_V2App/src/thresholdLogicSupport.dbd










📄 Contents of files under USB1608G_2AO_V2App/:











🔥 File: ./USB1608G_2AO_V2App/Db/Makefile
=================================================
TOP=../..
include $(TOP)/configure/CONFIG

#  Optimization of db files using dbst (DEFAULT: NO)
#DB_OPT = YES

#----------------------------------------------------
# Create and install (or just install)
# databases, templates, substitutions like this

DB += $(patsubst ../%, %, $(wildcard ../*.template))
DB += $(patsubst ../%, %, $(wildcard ../*.db))
DB += $(patsubst ../%, %, $(wildcard ../*.vdb))
DB += $(patsubst ../%, %, $(wildcard ../*.substitutions))

REQ += $(patsubst ../%, %, $(wildcard ../*.req))

#----------------------------------------------------
# If <anyname>.db template is not named <anyname>*.template add
# <anyname>_TEMPLATE = <templatename>

include $(TOP)/configure/RULES
#----------------------------------------
#  ADD RULES AFTER THIS LINE











🔥 File: ./USB1608G_2AO_V2App/Db/O.linux-x86_64/Makefile
=================================================
#This Makefile created by makeMakefile.pl


all :
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

.DEFAULT: force
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

force:  ;











🔥 File: ./USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions
=================================================
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompDevice.template"
{pattern {} {} }

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongIn.template"
{
pattern
{ R,   MASK, ADDR}
{Li,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryIn.template"
{
pattern
{ R,   MASK, ADDR}
{Bi1,  0x01     0}
{Bi2,  0x02     0}
{Bi3,  0x04     0}
{Bi4,  0x08     0}
{Bi5,  0x10     0}
{Bi6,  0x20     0}
{Bi7,  0x40     0}
{Bi8,  0x80     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongOut.template"
{
pattern
{ R,   MASK, ADDR}
{Lo,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryOut.template"
{
pattern
{ R,   MASK, ADDR}
{Bo1,  0x01     0}
{Bo2,  0x02     0}
{Bo3,  0x04     0}
{Bo4,  0x08     0}
{Bo5,  0x10     0}
{Bo6,  0x20     0}
{Bo7,  0x40     0}
{Bo8,  0x80     0}
}

# Direction bits on binary I/O
#  VAL 0=input, 1=output
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryDir.template"
{
pattern
{ R,   MASK,  VAL, ADDR}
{Bd1,  0x01    0,     0}
{Bd2,  0x02    0,     0}
{Bd3,  0x04    0,     0}
{Bd4,  0x08    0,     0}
{Bd5,  0x10    1,     0}
{Bd6,  0x20    1,     0}
{Bd7,  0x40    1,     0}
{Bd8,  0x80    1,     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompPulseGen.template"
{
pattern
{    R,      ADDR,  PREC}
{PulseGen1,     0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompCounter.template"
{
pattern
{    R,     ADDR}
{Counter1,     0}
{Counter2,     1}
}

# Analog input mode
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogInMode.template"
{
pattern
{  R,       ADDR,   MODE}
{AiMode,       0,      0}
}

# Analog inputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogIn.template"
{
pattern
{  R, ADDR, EGUL, LOPR, EGUF, HOPR,  RANGE,   SCAN,   PREC}
{Ai1,   0,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai2,   1,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai3,   2,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai4,   3,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai5,   4,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai6,   5,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai7,   6,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
{Ai8,   7,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
}

# Waveform digitzer
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDig.template"
{
pattern
{  R,     ADDR,  PREC}
{WaveDig,    0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDigN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveDig1,     0,      4}
{WaveDig2,     1,      4}
{WaveDig3,     2,      4}
{WaveDig4,     3,      4}
{WaveDig5,     4,      4}
{WaveDig6,     5,      4}
{WaveDig7,     6,      4}
{WaveDig8,     7,      4}
}


# Analog outputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogOut.template"
{
pattern
{ R,   VAL, ADDR, EGUL, DRVL, LOPR, EGUF, DRVH, HOPR, PREC}
{Ao1,   0,    0,  -10., -10., -10.,  10.,  10.,  10.,    4}
{Ao2,   0,    1,  -10., -10., -10.,  10.,  10.,  10.,    4}
}

# Waveform generator
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGen.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen,      0,      4}
}
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGenN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen1,     0,      4}
{WaveGen2,     1,      4}
}

# Trigger
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompTrigger.template"
{
pattern
{  R,   ADDR}
{Trig,     0}
}


# Threshold Logic Controller 인스턴스
# 각 아날로그 입력 채널에 대한 임계값 로직 제어
# ThresholdLogic1: ai1 -> bo5
# ThresholdLogic2: ai2 -> bo6
# ThresholdLogic3: ai4 -> bo7
# ThresholdLogic4: ai5 -> bo8
file "$(TOP)/USB1608G_2AO_V2App/Db/threshold_logic.template"
{
pattern
{ R,               IN_CH,  OUT_CH, THRESHOLD, HYSTERESIS, ENABLE, UPDATE_RATE, PREC, EGU }
{ ThresholdLogic1, "Ai1",   "Bo5",     2.5,       0.1,        1,      10.0,        3,   "V" }
{ ThresholdLogic2, "Ai2",   "Bo6",     5.0,       0.2,        1,      10.0,        3,   "V" }
{ ThresholdLogic3, "Ai3",   "Bo7",     1.0,       0.05,       0,      5.0,         3,   "V" }
{ ThresholdLogic4, "Ai4",   "Bo8",     7.5,       0.3,        0,      20.0,        3,   "V" }
}












🔥 File: ./USB1608G_2AO_V2App/Db/USB1608G_2AO_settings.req
=================================================
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd1
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd2
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd3
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd4
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd5
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd6
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd7
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd8
file "measCompPulseGen_settings.req",     P=$(P), R=PulseGen1
file "measCompAnalogInMode_settings.req", P=$(P), R=AiMode
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai1
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai2
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai3
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai4
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai5
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai6
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai7
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai8
file "measCompAnalogOut_settings.req",    P=$(P), R=Ao1
file "measCompAnalogOut_settings.req",    P=$(P), R=Ao2
file "measCompWaveformDig_settings.req",  P=$(P), R=WaveDig
file "measCompWaveformGen_settings.req",  P=$(P), R=WaveGen
file "measCompWaveformGenN_settings.req", P=$(P), R=WaveGen1
file "measCompWaveformGenN_settings.req", P=$(P), R=WaveGen2
file "measCompTrigger_settings.req",      P=$(P), R=Trig











🔥 File: ./USB1608G_2AO_V2App/Db/measCompAnalogIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynInt32Average")
    field(INP,  "@asyn($(PORT),$(ADDR))ANALOG_IN_VALUE")
    field(LINR, "LINEAR")
    field(EGUF, "$(EGUF)")
    field(EGUL, "$(EGUL)")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RANGE")
    field(VAL,  "$(RANGE)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_TYPE")
}

record(ao,"$(P)$(R)Rate")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RATE")
    field(VAL,  "60")
}












🔥 File: ./USB1608G_2AO_V2App/Db/measCompAnalogInMode.template
=================================================
record(mbbo,"$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_MODE")
    field(VAL,  "$(MODE)")
    field(ZRVL, "0")
    field(ZRST, "Differential")
    field(ONVL, "1")
    field(ONST, "Single-ended")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompAnalogInMode_settings.req
=================================================
$(P)$(R)












🔥 File: ./USB1608G_2AO_V2App/Db/measCompAnalogIn_settings.req
=================================================
$(P)$(R)Range
$(P)$(R)Type
$(P)$(R)Rate
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).EGUF
$(P)$(R).EGUL
$(P)$(R).PREC
$(P)$(R).SCAN












🔥 File: ./USB1608G_2AO_V2App/Db/measCompAnalogOut.template
=================================================
record(ao,"$(P)$(R)") {
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Range record will process before this record during iocInit
    field(PHAS, "2")
    field(DTYP, "asynInt32")
    field(FLNK, "$(P)$(R)Return.PROC  PP MS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_RANGE")
}

record(ao,"$(P)$(R)Return") {
    field(DTYP, "asynInt32")
    field(DISV, "0")
    field(SDIS, "$(P)$(R)Pulse.VAL  NPP NMS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(OMSL, "closed_loop")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

record(bo,"$(P)$(R)Pulse") {
    field(ZNAM, "Normal")
    field(ONAM, "Pulse")
}

record(ao,"$(P)$(R)TweakVal") {
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakUp") {
    field(CALC, "A+B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakDown") {
    field(CALC, "A-B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompAnalogOut_settings.req
=================================================
$(P)$(R)Pulse
$(P)$(R)Range
$(P)$(R)TweakVal
$(P)$(R).DRVL
$(P)$(R).DRVH
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).EGUF
$(P)$(R).EGUL
$(P)$(R).PREC
$(P)$(R)Return.DRVL
$(P)$(R)Return.DRVH
$(P)$(R)Return.LOPR
$(P)$(R)Return.HOPR
$(P)$(R)Return.EGUF
$(P)$(R)Return.EGUL
$(P)$(R)Return.PREC











🔥 File: ./USB1608G_2AO_V2App/Db/measCompBinaryDir.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_DIRECTION")
    field(ZNAM, "In")
    field(ONAM, "Out")
    field(VAL,  "$(VAL)")
    field(PINI, "YES")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompBinaryDir_settings.req
=================================================
$(P)$(R)











🔥 File: ./USB1608G_2AO_V2App/Db/measCompBinaryIn.template
=================================================
record(bi, "$(P)$(R)")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompBinaryOut.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Direction record will process before this record during iocInit
    field(PHAS, "2")
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
}

record(bi, "$(P)$(R)_RBV")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompCounter.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












🔥 File: ./USB1608G_2AO_V2App/Db/measCompDevice.template
=================================================
# Device settings
record(stringin,"$(P)ModelName") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)MODEL_NAME")
}

record(longin,"$(P)ModelNumber") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT) 0)MODEL_NUMBER")
}

record(stringin,"$(P)FirmwareVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)FIRMWARE_VERSION")
}

record(stringin,"$(P)UniqueID") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UNIQUE_ID")
}

record(stringin,"$(P)ULVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UL_VERSION")
}

record(stringin,"$(P)DriverVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)DRIVER_VERSION")
}

record(ai,"$(P)PollTimeMS") {
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT) 0)POLL_TIME_MS")
    field(PREC, "1")
    field(SCAN, "I/O Intr")
}

record(ao,"$(P)PollSleepMS") {
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT) 0)POLL_SLEEP_MS")
    field(VAL,  "50")
    field(PREC, "1")
}

record(waveform, "$(P)LastErrorMessage") {
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)LAST_ERROR_MESSAGE")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(SCAN, "I/O Intr")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompEncoder.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












🔥 File: ./USB1608G_2AO_V2App/Db/measCompLongIn.template
=================================================
record(longin, "$(P)$(R)")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(SCAN, "I/O Intr")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompLongOut.template
=================================================
###################################################################
#  Binary output as longout                                       # 
###################################################################
record(longout, "$(P)$(R)")
{
    field(PINI, "$(PINI=NO)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
}

record(longin, "$(P)$(R)_RBV")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(SCAN, "I/O Intr")
}












🔥 File: ./USB1608G_2AO_V2App/Db/measCompMCS.template
=================================================
# measCompMCS.template
# Mark Rivers
# June 2, 2014

record(bi,"$(P)SNL_Connected") {
  field(ZNAM, "Not connected")
  field(ZSV,  "MAJOR")
  field(ONAM, "Connected")
  field(OSV,  "NO_ALARM")
}

record(bo,"$(P)EraseAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)EraseStart") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)StartAll.PROC")
}

record(bo,"$(P)StartAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_START_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Start")
  field(VAL,  "1")
  field(FLNK, "$(P)SetAcquiring.PROC")
}

record(bo,"$(P)SetAcquiring") {
  field(OUT,  "$(P)Acquiring PP MS")
  field(ZNAM, "Done")
  field(ONAM, "Set")
  field(VAL,  "1")
  field(FLNK, "$(P)SetClientWait.PROC")
}

record(busy,"$(P)Acquiring") {
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
}

record(bo,"$(P)StopAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_STOP_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Stop")
  field(VAL,  "1")
}

record(ao,"$(P)PresetReal") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESET_REAL")
  field(VAL,  "0.0")
  field(PREC, "3")
}

record(bi,"$(P)HardwareAcquiring") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCA_ACQUIRING")
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
  field(SCAN, "I/O Intr")
}

record(ai,"$(P)ElapsedReal") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_ELAPSED_REAL")
  field(PREC, "3")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ReadAll") {
  field(SCAN, "1 second")
  field(DISV, "0")
  field(SDIS, "$(P)Acquiring NPP NMS")
  field(ZNAM, "Done")
  field(ONAM, "Read")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)ReadAllOnce") {
  field(VAL,  "1")
  field(OUT,  "$(P)DoReadAll.VAL PP MS")
}

record(bo,"$(P)DoReadAll") {
  field(ZNAM, "Done")
  field(ONAM, "Read")
}

record(longout,"$(P)NuseAll") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_NUM_CHANNELS")
}

record(longin,"$(P)CurrentChannel") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_CURRENT_POINT")
  field(SCAN, "I/O Intr")
}

record(ao,"$(P)Dwell") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(VAL,  "0.1")
  field(PREC, "4")
}

record(ai,"$(P)Dwell_RBV") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(PREC, "4")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ChannelAdvance") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_CH_ADV_SOURCE")
  field(ZNAM, "Internal")
  field(ONAM, "External")
}

record(longout,"$(P)Prescale") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESCALE")
  field(VAL,  "1")
}

record(bo,"$(P)EnableClientWait") {
  field(PINI, "YES")
  field(ZNAM, "Disable")
  field(ONAM, "Enable")
}

record(bo,"$(P)SetClientWait") {
  field(DISV, "0")
  field(SDIS, "$(P)EnableClientWait NPP NMS")
  field(OMSL, "closed_loop")
  field(DOL,  "1")
  field(OUT,  "$(P)ClientWait PP MS")
  field(ONAM, "SetClientWait")
  field(ZNAM, "Done")
}

record(busy,"$(P)ClientWait") {
}

record(mbboDirect,"$(P)MCSCounterEnable") {
  field(PINI, "YES")
  field(DTYP, "asynUInt32Digital")
  field(OUT,  "@asynMask($(PORT),0,0xFFFFFFFF)MCS_COUNTER_ENABLE")
  field(VAL, "0x1FF")
}

record(bo, "$(P)MCSCounter1Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B0 PP")
}

record(bo, "$(P)MCSCounter2Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B1 PP")
}

record(bo, "$(P)MCSCounter3Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B2 PP")
}

record(bo, "$(P)MCSCounter4Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B3 PP")
}

record(bo, "$(P)MCSCounter5Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B4 PP")
}

record(bo, "$(P)MCSCounter6Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B5 PP")
}

record(bo, "$(P)MCSCounter7Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B6 PP")
}

record(bo, "$(P)MCSCounter8Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B7 PP")
}

record(bo, "$(P)MCSDIOEnable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B8 PP")
}

record(mbbo,"$(P)PrescaleCounter") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_PRESCALE_COUNTER")
  field(ZRVL, "0")
  field(ZRST, "CTR0")
  field(ONVL, "1")
  field(ONST, "CTR1")
  field(TWVL, "2")
  field(TWST, "CTR2")
  field(THVL, "3")
  field(THST, "CTR3")
  field(FRVL, "4")
  field(FRST, "CTR4")
  field(FVVL, "5")
  field(FVST, "CTR5")
  field(SXVL, "6")
  field(SXST, "CTR6")
  field(SVVL, "7")
  field(SVST, "CTR7")
}

record(mbbo,"$(P)Point0Action") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_POINT0_ACTION")
  field(ZRVL, "0")
  field(ZRST, "Clear")
  field(ONVL, "1")
  field(ONST, "No clear")
  field(TWVL, "2")
  field(TWST, "Skip")
}

record(longin,"$(P)MaxChannels") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_MAX_POINTS")
}

record(mbbi, "$(P)Model") {
  field(PINI, "YES")
  field(DESC, "Model")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT) 0)MODEL")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "USB-CTR08")
  field(ONST, "USB-CTR04")
}

record(mbbo,"$(P)TrigMode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TRIGGER_MODE")
    field(ZRVL, "0")
    field(ZRST, "Rising edge")
    field(ONVL, "1")
    field(ONST, "Falling edge")
    field(TWVL, "6")
    field(TWST, "High level")
    field(THVL, "7")
    field(THST, "Low level")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)MCS_ABS_TIME_WF")
    field(NELM, "$(MAX_POINTS)")
    field(SCAN, "I/O Intr")
}

# asyn record for debugging
record(asyn, "$(P)Asyn") {
  field(PORT, "$(PORT)")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompMCSWaveform.template
=================================================
# Waveform record to be used for MCS data, rather than MCA record.

record(waveform, "$(P)$(R)") {
  field(DTYP, "asynInt32ArrayIn")
  field(INP,  "$(INP)MCA_DATA")
  field(FTVL, "LONG")
  field(NELM, "$(NUM_POINTS)")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompMCS_settings.req
=================================================
$(P)PresetReal
$(P)Dwell
$(P)Prescale
$(P)ChannelAdvance
$(P)MCSCounter1Enable
$(P)MCSCounter2Enable
$(P)MCSCounter3Enable
$(P)MCSCounter4Enable
$(P)MCSCounter5Enable
$(P)MCSCounter6Enable
$(P)MCSCounter7Enable
$(P)MCSCounter8Enable
$(P)MCSDIOEnable
$(P)PrescaleCounter
$(P)Point0Action
$(P)ReadAll.SCAN
$(P)NuseAll
$(P)EnableClientWait
$(P)TrigMode











🔥 File: ./USB1608G_2AO_V2App/Db/measCompPulseGen.template
=================================================
# This database is loaded for each pulse generator
# Mark Rivers
# July 26, 2011

###################################################################
#  Pulse start/stop                                               # 
###################################################################
record(bo, "$(P)$(R)Run")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_RUN")
    field(ZNAM, "Stop")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Run")
    field(OSV,  "MINOR")
}

# NOTE: The records for the period and the frequency are a bit
# complex because we want to be able to change either ao record
# and have the other one update

###################################################################
#  Pulse period                                                   # 
###################################################################
record(ao, "$(P)$(R)Period")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcFrequency")
}

record(ai, "$(P)$(R)Period_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate frequency based on new period                        # 
###################################################################
record(calcout, "$(P)$(R)CalcFrequency")
{
    field(INPA, "$(P)$(R)Period")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Frequency.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Frequency PP MS")
}

###################################################################
#  Pulse frequency                                                # 
###################################################################
record(ao, "$(P)$(R)Frequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcPeriod PP MS")
}

record(calc, "$(P)$(R)Frequency_RBV")
{
    field(INPA, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "1/A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate period based on new frequency                        # 
###################################################################
record(calcout, "$(P)$(R)CalcPeriod")
{
    field(INPA, "$(P)$(R)Frequency")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Period.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Period PP MS")
}

###################################################################
#  Pulse duty cycle                                               # 
###################################################################
record(ao, "$(P)$(R)DutyCycle")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(VAL,  "0.5")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcWidth")
}

record(ai, "$(P)$(R)DutyCycle_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate width based on new duty cycle                        # 
###################################################################
record(calcout, "$(P)$(R)CalcWidth")
{
    field(INPA, "$(P)$(R)DutyCycle")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A*B")
    field(SDIS, "$(P)$(R)Width.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Width PP MS")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)Width")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcDutyCycle PP MS")
}

record(calc, "$(P)$(R)Width_RBV")
{
    field(INPA, "$(P)$(R)DutyCycle_RBV CP MS")
    field(INPB, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "B*A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate duty cycle based on new width                        # 
###################################################################
record(calcout, "$(P)$(R)CalcDutyCycle")
{
    field(INPA, "$(P)$(R)Width")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A/B")
    field(SDIS, "$(P)$(R)DutyCycle.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)DutyCycle PP MS")
}

###################################################################
#  Pulse delay                                                    # 
###################################################################
record(ao, "$(P)$(R)Delay")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(VAL,  "0.")
    field(PREC, "$(PREC)")
}

record(ai, "$(P)$(R)Delay_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Pulse count                                                    # 
###################################################################
record(longout, "$(P)$(R)Count")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_COUNT")
}

###################################################################
#  Pulse idle state                                               # 
###################################################################
record(bo, "$(P)$(R)IdleState")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_IDLE_STATE")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(VAL,  "0")
}













🔥 File: ./USB1608G_2AO_V2App/Db/measCompPulseGen_settings.req
=================================================
$(P)$(R)Period
$(P)$(R)Width
$(P)$(R)Delay
$(P)$(R)Count
$(P)$(R)IdleState
$(P)$(R)Run











🔥 File: ./USB1608G_2AO_V2App/Db/measCompTemperatureIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))TEMPERATURE_IN_VALUE")
    field(PREC, "$(PREC)")
}

record(mbbo,"$(P)$(R)Scale")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SCALE")
    field(ZRVL, "0")
    field(ZRST, "Celsius")
    field(ONVL, "1")
    field(ONST, "Fahrenheit")
    field(TWVL, "2")
    field(TWST, "Kelvin")
    field(THVL, "4")
    field(THST, "Volts")
    field(FRVL, "5")
    field(FRST, "Noscale")
}

record(mbbo,"$(P)$(R)TCType")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_TYPE")
    field(ZRVL, "1")
    field(ZRST, "Type J")
    field(ONVL, "2")
    field(ONST, "Type K")
    field(TWVL, "3")
    field(TWST, "Type T")
    field(THVL, "4")
    field(THST, "Type E")
    field(FRVL, "5")
    field(FRST, "Type R")
    field(FVVL, "6")
    field(FVST, "Type S")
    field(SXVL, "7")
    field(SXST, "Type B")
    field(SVVL, "8")
    field(SVST, "Type N")
}

record(mbbo,"$(P)$(R)Filter")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_FILTER")
    field(ZRVL, "0")
    field(ZRST, "Filter")
    field(ONVL, "0x400")
    field(ONST, "No filter")
}

record(bo,"$(P)$(R)OpenTCDetect")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_OPEN_DETECT")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}












🔥 File: ./USB1608G_2AO_V2App/Db/measCompTemperatureIn_settings.req
=================================================
$(P)$(R)Scale
$(P)$(R)TCType
$(P)$(R)OpenTCDetect
$(P)$(R)Filter
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).PREC
$(P)$(R).SCAN











🔥 File: ./USB1608G_2AO_V2App/Db/measCompTrigger.template
=================================================
record(mbbo,"$(P)$(R)Mode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TRIGGER_MODE")
    field(ZRVL, "12")
    field(ZRST, "Positive edge")
    field(ONVL, "13")
    field(ONST, "Negative edge")
    field(TWVL, "10")
    field(TWST, "High")
    field(THVL, "11")
    field(THST, "Low")
}












🔥 File: ./USB1608G_2AO_V2App/Db/measCompTrigger_settings.req
=================================================
$(P)$(R)Mode











🔥 File: ./USB1608G_2AO_V2App/Db/measCompUSBTempConfig.template
=================================================
# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)TemperatureSensor")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SENSOR")
}

record(mbbo,"$(P)$(R)TemperatureWiring")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_WIRING")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompUSBTempConfig_settings.req
=================================================
$(P)$(R)TemperatureSensor
$(P)$(R)TemperatureWiring











🔥 File: ./USB1608G_2AO_V2App/Db/measCompVoltageIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_VALUE")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_RANGE")
    field(VAL,  "$(RANGE)")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompVoltageIn_settings.req
=================================================
$(P)$(R)Range
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).PREC
$(P)$(R).SCAN












🔥 File: ./USB1608G_2AO_V2App/Db/measCompWaveformDig.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longout, "$(P)$(R)NumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WDIG_POINTS)")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)FirstChan")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_FIRST_CHAN")
    field(ZRVL, "0")
    field(ZRST, "1")
    field(ONVL, "1")
    field(ONST, "2")
    field(TWVL, "2")
    field(TWST, "3")
    field(THVL, "3")
    field(THST, "4")
    field(FRVL, "4")
    field(FRST, "5")
    field(FVVL, "5")
    field(FVST, "6")
    field(SXVL, "6")
    field(SXST, "7")
    field(SVVL, "7")
    field(SVST, "8")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)NumChans")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_CHANS")
    field(ZRVL, "1")
    field(ZRST, "1")
    field(ONVL, "2")
    field(ONST, "2")
    field(TWVL, "3")
    field(TWST, "3")
    field(THVL, "4")
    field(THST, "4")
    field(FRVL, "5")
    field(FRST, "5")
    field(FVVL, "6")
    field(FVST, "6")
    field(SXVL, "7")
    field(SXST, "7")
    field(SVVL, "8")
    field(SVST, "8")
}
###################################################################
#  Timebase waveform record                                       #
###################################################################
record(waveform, "$(P)$(R)TimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)$(R)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_ABS_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point                                                 # 
###################################################################
record(ao, "$(P)$(R)Dwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  One-shot / continuous                                          # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Auto restart                                                   # 
###################################################################
record(bo, "$(P)$(R)AutoRestart")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_AUTO_RESTART")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Burst mode                                                     # 
###################################################################
record(bo, "$(P)$(R)BurstMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_BURST_MODE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}

###################################################################
#  Read waveforms                                                 # 
###################################################################
# This tells the driver to read, which then does callbacks to the
# input waveform records which are I/O Intr scanned
# The driver always reads the waveforms when acquisition completes,
# so this record can be passive for fast scans
record(busy, "$(P)$(R)ReadWF")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_READ_WF")
    field(ZNAM, "Done")
    field(ONAM, "Read")
    field(SCAN, "1 second")
    field(SDIS, "$(P)$(R)Run")
    field(DISV, "0")
}













🔥 File: ./USB1608G_2AO_V2App/Db/measCompWaveformDigN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)VoltWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_VOLT_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}











🔥 File: ./USB1608G_2AO_V2App/Db/measCompWaveformDig_settings.req
=================================================
$(P)$(R)NumPoints
$(P)$(R)FirstChan
$(P)$(R)NumChans
$(P)$(R)Dwell
$(P)$(R)ExtTrigger
$(P)$(R)ExtClock
$(P)$(R)Continuous
$(P)$(R)AutoRestart
$(P)$(R)Retrigger
$(P)$(R)TriggerCount
$(P)$(R)BurstMode
$(P)$(R)ReadWF.SCAN











🔥 File: ./USB1608G_2AO_V2App/Db/measCompWaveformGen.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longin, "$(P)$(R)NumPoints")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_NUM_POINTS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Number of points to use for user-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)UserNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Number of points to use for pre-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)IntNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Timebase waveform record for user waveforms                    #
###################################################################
record(waveform, "$(P)$(R)UserTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Timebase waveform record for predefined waveforms              #
###################################################################
record(waveform, "$(P)$(R)IntTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Waveform frequency                                             # 
###################################################################
record(ai, "$(P)$(R)Frequency")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_FREQ")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point readback, based on UserDwell or IntDwell        # 
###################################################################
record(ai, "$(P)$(R)Dwell")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

# Needed?
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Internal waveform dwell                                        # 
###################################################################
record(ao, "$(P)$(R)IntDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcIntFrequency")
}

###################################################################
#  Calculate internal frequency based on new dwell                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntFrequency")
{
    field(INPA, "$(P)$(R)IntDwell")
    field(INPB, "$(P)$(R)IntNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntDwell.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntFrequency PP MS")
}

###################################################################
#  Internal waveform frequency                                    # 
###################################################################
record(ao, "$(P)$(R)IntFrequency")
{
    field(PREC, "$(PREC)")
    field(OUT,  "$(P)$(R)CalcIntDwell PP MS")
}

###################################################################
#  Calculate internal dwell based on new frequency                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntDwell")
{
    field(INPA, "$(P)$(R)IntFrequency")
    field(INPB, "$(P)$(R)IntNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntFrequency.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntDwell PP MS")
}

###################################################################
#  User waveform dwell                                            # 
###################################################################
record(ao, "$(P)$(R)UserDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserFrequency")
}

###################################################################
#  Calculate user frequency based on new dwell                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserFrequency")
{
    field(INPA, "$(P)$(R)UserDwell")
    field(INPB, "$(P)$(R)UserNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserDwell.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserFrequency PP MS")
}

###################################################################
#  User waveform frequency                                        # 
###################################################################
record(ao, "$(P)$(R)UserFrequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserDwell PP MS")
}

###################################################################
#  Calculate user dwell based on new frequency                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserDwell")
{
    field(INPA, "$(P)$(R)UserFrequency")
    field(INPB, "$(P)$(R)UserNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserFrequency.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserDwell PP MS")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}













🔥 File: ./USB1608G_2AO_V2App/Db/measCompWaveformGenN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)UserWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayOut")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_WF")
    field(NELM, "$(WGEN_POINTS)")
}

###################################################################
#  Internally defined waveform record                             #
###################################################################
record(waveform, "$(P)$(R)InternalWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Enable this channel                                            # 
###################################################################
record(bo, "$(P)$(R)Enable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Waveform type                                                  # 
###################################################################
record(mbbo, "$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_WAVE_TYPE")
    field(ZRVL, "0")
    field(ZRST, "User-defined")
    field(ONVL, "1")
    field(ONST, "Sin wave")
    field(TWVL, "2")
    field(TWST, "Square wave")
    field(THVL, "3")
    field(THST, "Sawtooth")
    field(FRVL, "4")
    field(FRST, "Pulse")
    field(FVVL, "5")
    field(FVST, "Random")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)PulseWidth")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_PULSE_WIDTH")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}

###################################################################
#  Amplitude                                                      # 
###################################################################
record(ao, "$(P)$(R)Amplitude")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_AMPLITUDE")
    field(VAL,  "1.0")
    field(PREC, "4")
}

###################################################################
#  Offset                                                         # 
###################################################################
record(ao, "$(P)$(R)Offset")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_OFFSET")
    field(VAL,  "0.0")
    field(PREC, "4")
}












🔥 File: ./USB1608G_2AO_V2App/Db/measCompWaveformGenN_settings.req
=================================================
$(P)$(R)Enable
$(P)$(R)Type
$(P)$(R)PulseWidth
$(P)$(R)Amplitude
$(P)$(R)Offset











🔥 File: ./USB1608G_2AO_V2App/Db/measCompWaveformGen_settings.req
=================================================
$(P)$(R)UserNumPoints
$(P)$(R)IntNumPoints
$(P)$(R)UserDwell
$(P)$(R)IntDwell
$(P)$(R)ExtTrigger
$(P)$(R)ExtClock
$(P)$(R)Continuous
$(P)$(R)Retrigger
$(P)$(R)TriggerCount











🔥 File: ./USB1608G_2AO_V2App/Db/threshold_logic.template
=================================================
# ThresholdLogic.template
# EPICS 데이터베이스 템플릿 - 임계값 기반 로직 제어
# 매개변수:
#   P     - PV 접두사 (예: "USB1608G_2AO_cpp:")
#   R     - 레코드 이름 접미사 (예: "ThresholdLogic")
#   PORT  - asyn 포트 이름
#   ADDR  - asyn 주소 (기본값: 0)
#   PREC  - 소수점 자릿수 (기본값: 3)
#   EGU   - 엔지니어링 단위 (기본값: "V")
#   SCAN  - 스캔 주기 (기본값: "1 second")

# 임계값 설정 레코드 (아날로그 출력)
record(ao, "$(P)$(R)Threshold") {
    field(DESC, "Threshold Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))THRESHOLD_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(THRESHOLD=0.0)")
    field(DRVL, "$(DRVL=-10.0)")
    field(DRVH, "$(DRVH=10.0)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
}

# 히스테리시스 설정 레코드 (아날로그 출력)
record(ao, "$(P)$(R)Hysteresis") {
    field(DESC, "Hysteresis Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))HYSTERESIS_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(HYSTERESIS=0.1)")
    field(DRVL, "0.0")
    field(DRVH, "1.0")
    field(LOPR, "0.0")
    field(HOPR, "1.0")
}

# 현재 값 모니터링 레코드 (실제 아날로그 입력 채널에서 값 읽기)
record(ai, "$(P)$(R)CurrentValue") {
    field(DESC, "Current Input Value from $(IN_CH)")
    field(INP,  "$(P)$(IN_CH) CP")
    field(SCAN, "Passive")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
    field(HIHI, "$(HIHI=9.0)")
    field(HIGH, "$(HIGH=8.0)")
    field(LOW,  "$(LOW=-8.0)")
    field(LOLO, "$(LOLO=-9.0)")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(LSV,  "MINOR")
    field(LLSV, "MAJOR")
    field(FLNK, "$(P)$(R)Compare")
}

# 임계값 비교 계산 레코드
record(calcout, "$(P)$(R)Compare") {
    field(DESC, "Threshold Comparison :  $(IN_CH) -> $(OUT_CH)")
    field(CALC, "A>=(B+C)?1:(A<=(B-C)?0:D)")
    field(INPA, "$(P)$(IN_CH) CP")
    field(INPB, "$(P)$(R)Threshold")
    field(INPC, "$(P)$(R)Hysteresis")
    field(INPD, "$(P)$(R)OutputState")
    field(OUT,  "$(P)$(OUT_CH) PP")
    field(OOPT, "Every Time")
    field(DOPT, "Use CALC")
    field(SCAN, "Passive")
}

# 출력 상태 레코드 (실제 바이너리 출력 채널 상태 모니터링)
record(bi, "$(P)$(R)OutputState") {
    field(DESC, "Current Output State of $(OUT_CH)")
    field(INP,  "$(P)$(OUT_CH) CP")
    field(SCAN, "Passive")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# 활성화 제어 레코드 (바이너리 출력)
record(bo, "$(P)$(R)Enable") {
    field(DESC, "Enable/Disable Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))ENABLE")
    field(PINI, "YES")
    field(VAL,  "$(ENABLE=0)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# 상태 모니터링 레코드 (다중 바이너리 입력)
record(mbbi, "$(P)$(R)Status") {
    field(DESC, "Threshold Logic Status")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))STATUS")
    field(SCAN, "I/O Intr")
    field(ZRST, "Idle")
    field(ONST, "Active")
    field(TWST, "Error")
    field(THST, "Disabled")
    field(ZRSV, "NO_ALARM")
    field(ONSV, "NO_ALARM")
    field(TWSV, "MAJOR")
    field(THSV, "NO_ALARM")
}

# 리셋 명령 레코드 (바이너리 출력)
record(bo, "$(P)$(R)Reset") {
    field(DESC, "Reset Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))RESET")
    field(ZNAM, "Normal")
    field(ONAM, "Reset")
    field(HIGH, "1")
    field(PINI, "NO")
}

# 업데이트 주기 설정 레코드 (아날로그 출력)
record(ao, "$(P)$(R)UpdateRate") {
    field(DESC, "Update Rate in Hz")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))UPDATE_RATE")
    field(PREC, "1")
    field(EGU,  "Hz")
    field(PINI, "YES")
    field(VAL,  "$(UPDATE_RATE=10.0)")
    field(DRVL, "0.1")
    field(DRVH, "1000.0")
    field(LOPR, "0.1")
    field(HOPR, "1000.0")
}

# 마지막 업데이트 시간 레코드 (문자열 입력)
record(stringin, "$(P)$(R)LastUpdate") {
    field(DESC, "Last Update Timestamp")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR=0))LAST_UPDATE")
    field(SCAN, "I/O Intr")
    field(VAL,  "Never")
}

# 알람 상태 레코드 (바이너리 입력)
record(bi, "$(P)$(R)AlarmState") {
    field(DESC, "Alarm State")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))ALARM_STATE")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Normal")
    field(ONAM, "Alarm")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MAJOR")
}

# 트리거 카운터 레코드 (롱 입력)
record(longin, "$(P)$(R)TriggerCount") {
    field(DESC, "Number of Threshold Triggers")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))TRIGGER_COUNT")
    field(SCAN, "I/O Intr")
    field(EGU,  "counts")
}










🔥 File: ./USB1608G_2AO_V2App/Db/user.db
=================================================
[SKIPPED: ⭕ empty file]











🔥 File: ./USB1608G_2AO_V2App/Db/user.proto
=================================================
[SKIPPED: ⭕ empty file]











🔥 File: ./USB1608G_2AO_V2App/Db/user.substitutions
=================================================
[SKIPPED: ⭕ empty file]











🔥 File: ./USB1608G_2AO_V2App/Makefile
=================================================
# Makefile at top of application tree
TOP = ..
include $(TOP)/configure/CONFIG

# Directories to be built, in any order.
# You can replace these wildcards with an explicit list
DIRS += $(wildcard src* *Src*)
DIRS += $(wildcard db* *Db*)

# If the build order matters, add dependency rules like this,
# which specifies that xxxSrc must be built after src:
#xxxSrc_DEPEND_DIRS += src

include $(TOP)/configure/RULES_DIRS











🔥 File: ./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.adl
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.adl)]











🔥 File: ./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.opi
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.opi)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompADCStripChart.adl
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.adl)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompAiSetup.adl
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.adl)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompAnalogIn8.adl
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.adl)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompAnalogIn8.opi
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.opi)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompAnalogOut2.adl
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.adl)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompAnalogOut2.opi
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.opi)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompAoSetup2.adl
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.adl)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompDigitalIO8.adl
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.adl)]











🔥 File: ./USB1608G_2AO_V2App/op/measCompDigitalIO8.opi
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.opi)]











🔥 File: ./USB1608G_2AO_V2App/src/ErrorHandler.cpp
=================================================
/* ErrorHandler.cpp
 *
 * 오류 처리 및 로깅을 위한 유틸리티 클래스 구현
 * 
 * 이 클래스는 EPICS IOC 애플리케이션에서 발생하는 다양한 오류를 
 * 분류하고 로깅하며, EPICS 알람 시스템과 통합하여 상태를 보고합니다.
 *
 * Author: EPICS IOC Development Guide
 * Date: 2025
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include <epicsTime.h>
#include <epicsString.h>
#include <epicsThread.h>
#include <epicsMutex.h>
#include <asynDriver.h>

#include "ErrorHandler.h"

// 정적 멤버 변수 초기화
int ErrorHandler::infoCount_ = 0;
int ErrorHandler::warningCount_ = 0;
int ErrorHandler::errorCount_ = 0;
int ErrorHandler::fatalCount_ = 0;

// 스레드 안전성을 위한 뮤텍스
static epicsMutexId errorStatsMutex = NULL;

// 뮤텍스 초기화 (한 번만 실행)
static void initializeMutex() {
    if (errorStatsMutex == NULL) {
        errorStatsMutex = epicsMutexCreate();
    }
}

/** 오류 로깅 메서드 */
void ErrorHandler::logError(ErrorLevel level, const char* source, const char* message, 
                           asynUser* pasynUser)
{
    if (source == NULL || message == NULL) {
        printf("ErrorHandler::logError: NULL 포인터가 전달됨\n");
        return;
    }
    
    // 뮤텍스 초기화 확인
    initializeMutex();
    
    // 통계 업데이트 (스레드 안전)
    epicsMutexLock(errorStatsMutex);
    switch (level) {
        case INFO:    infoCount_++;    break;
        case WARNING: warningCount_++; break;
        case ERROR:   errorCount_++;   break;
        case FATAL:   fatalCount_++;   break;
    }
    epicsMutexUnlock(errorStatsMutex);
    
    // 내부 로깅 호출
    internalLog(level, source, message, pasynUser);
}

/** 상세 오류 로깅 메서드 */
void ErrorHandler::logDetailedError(ErrorLevel level, const char* source, const char* message,
                                   const char* details, int errorCode, asynUser* pasynUser)
{
    if (source == NULL || message == NULL) {
        printf("ErrorHandler::logDetailedError: NULL 포인터가 전달됨\n");
        return;
    }
    
    // 상세 메시지 구성
    char detailedMessage[512];
    if (details != NULL && strlen(details) > 0) {
        snprintf(detailedMessage, sizeof(detailedMessage), 
                "%s [상세: %s] [오류코드: %d]", message, details, errorCode);
    } else {
        snprintf(detailedMessage, sizeof(detailedMessage), 
                "%s [오류코드: %d]", message, errorCode);
    }
    
    // 일반 로깅 메서드 호출
    logError(level, source, detailedMessage, pasynUser);
}

/** EPICS 알람 상태 설정 */
asynStatus ErrorHandler::setAlarmStatus(asynUser* pasynUser, AlarmStatus status, AlarmSeverity severity)
{
    if (pasynUser == NULL) {
        logError(ERROR, "ErrorHandler::setAlarmStatus", "NULL asynUser 포인터");
        return asynError;
    }
    
    // EPICS 알람 설정 (실제 구현에서는 asynPortDriver의 setParamAlarmStatus 사용)
    // 여기서는 로깅만 수행
    char alarmMessage[256];
    snprintf(alarmMessage, sizeof(alarmMessage),
            "알람 설정 - 상태: %s, 심각도: %s",
            alarmStatusToString(status), alarmSeverityToString(severity));
    
    ErrorLevel logLevel = INFO;
    switch (severity) {
        case NO_ALARM:      logLevel = INFO;    break;
        case MINOR_ALARM:   logLevel = WARNING; break;
        case MAJOR_ALARM:   logLevel = ERROR;   break;
        case INVALID_ALARM: logLevel = FATAL;   break;
    }
    
    logError(logLevel, "ErrorHandler::setAlarmStatus", alarmMessage, pasynUser);
    
    return asynSuccess;
}

/** ThresholdLogicController 구성 유효성 검사 */
ErrorHandler::ValidationResult ErrorHandler::validateConfiguration(const ThresholdConfig& config)
{
    ValidationResult result;
    result.isValid = true;
    result.errorLevel = INFO;
    strcpy(result.errorMessage, "");
    strcpy(result.suggestion, "");
    
    // 포트 이름 검사
    if (!validateStringParameter("portName", config.portName, sizeof(config.portName), 
                                false, "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "포트 이름이 유효하지 않습니다");
        strcpy(result.suggestion, "1-63자의 영숫자와 언더스코어만 사용하세요");
        return result;
    }
    
    // 장치 포트 이름 검사
    if (!validateStringParameter("devicePort", config.devicePort, sizeof(config.devicePort), 
                                false, "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "장치 포트 이름이 유효하지 않습니다");
        strcpy(result.suggestion, "유효한 asyn 포트 이름을 지정하세요");
        return result;
    }
    
    // 장치 주소 검사
    if (!validateIntParameter("deviceAddr", config.deviceAddr, 0, 255, 
                             "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "장치 주소가 유효 범위를 벗어났습니다");
        strcpy(result.suggestion, "0-255 범위의 값을 사용하세요");
        return result;
    }
    
    // 업데이트 주기 검사
    if (!validateParameter("updateRate", config.updateRate, 0.1, 1000.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "업데이트 주기가 유효 범위를 벗어났습니다");
        strcpy(result.suggestion, "0.1-1000.0 Hz 범위의 값을 사용하세요");
        return result;
    }
    
    // 스레드 우선순위 검사
    if (!validateIntParameter("priority", config.priority, 0, 99, 
                             "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = WARNING;
        strcpy(result.errorMessage, "스레드 우선순위가 권장 범위를 벗어났습니다");
        strcpy(result.suggestion, "0-99 범위의 값을 사용하세요 (기본값: 50)");
        // 경고이므로 계속 검사
    }
    
    // 임계값 검사
    if (!validateParameter("thresholdValue", config.thresholdValue, -10.0, 10.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "임계값이 유효 범위를 벗어났습니다");
        strcpy(result.suggestion, "-10.0V ~ +10.0V 범위의 값을 사용하세요");
        return result;
    }
    
    // 히스테리시스 검사
    if (!validateParameter("hysteresis", config.hysteresis, 0.0, 5.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "히스테리시스가 유효 범위를 벗어났습니다");
        strcpy(result.suggestion, "0.0V ~ 5.0V 범위의 값을 사용하세요");
        return result;
    }
    
    // 임계값과 히스테리시스 관계 검사
    if (config.hysteresis > fabs(config.thresholdValue)) {
        result.isValid = false;
        result.errorLevel = WARNING;
        strcpy(result.errorMessage, "히스테리시스가 임계값보다 큽니다");
        strcpy(result.suggestion, "히스테리시스를 임계값 절댓값보다 작게 설정하세요");
        // 경고이므로 유효성은 통과로 처리
        result.isValid = true;
    }
    
    // 모든 검사 통과
    if (result.isValid && result.errorLevel == INFO) {
        strcpy(result.errorMessage, "구성이 유효합니다");
        strcpy(result.suggestion, "");
    }
    
    return result;
}

/** 런타임 오류 처리 */
bool ErrorHandler::handleRuntimeError(const char* source, const char* errorType, 
                                     int errorCode, asynUser* pasynUser)
{
    if (source == NULL || errorType == NULL) {
        logError(ERROR, "ErrorHandler::handleRuntimeError", "NULL 포인터가 전달됨");
        return false;
    }
    
    char errorMessage[256];
    snprintf(errorMessage, sizeof(errorMessage), 
            "런타임 오류 발생 - 유형: %s, 코드: %d", errorType, errorCode);
    
    ErrorLevel level = ERROR;
    bool recoverable = true;
    
    // 오류 유형별 처리
    if (strcmp(errorType, "MEMORY_ALLOCATION") == 0) {
        level = FATAL;
        recoverable = false;
        logError(level, source, "메모리 할당 실패 - 시스템 재시작 필요", pasynUser);
    }
    else if (strcmp(errorType, "THREAD_CREATION") == 0) {
        level = ERROR;
        recoverable = true;
        logError(level, source, "스레드 생성 실패 - 재시도 가능", pasynUser);
    }
    else if (strcmp(errorType, "PARAMETER_VALIDATION") == 0) {
        level = WARNING;
        recoverable = true;
        logError(level, source, "매개변수 유효성 검사 실패 - 기본값 사용", pasynUser);
    }
    else if (strcmp(errorType, "DEVICE_COMMUNICATION") == 0) {
        level = ERROR;
        recoverable = true;
        logError(level, source, "장치 통신 오류 - 연결 확인 필요", pasynUser);
    }
    else if (strcmp(errorType, "TIMEOUT") == 0) {
        level = WARNING;
        recoverable = true;
        logError(level, source, "타임아웃 발생 - 재시도 권장", pasynUser);
    }
    else {
        // 알 수 없는 오류 유형
        logError(level, source, errorMessage, pasynUser);
    }
    
    return recoverable;
}

/** 통신 오류 처리 */
bool ErrorHandler::handleCommunicationError(const char* source, const char* devicePort,
                                           int deviceAddr, const char* operation,
                                           asynUser* pasynUser)
{
    if (source == NULL || devicePort == NULL || operation == NULL) {
        logError(ERROR, "ErrorHandler::handleCommunicationError", "NULL 포인터가 전달됨");
        return false;
    }
    
    char errorMessage[256];
    snprintf(errorMessage, sizeof(errorMessage),
            "통신 오류 - 포트: %s, 주소: %d, 작업: %s", 
            devicePort, deviceAddr, operation);
    
    logError(ERROR, source, errorMessage, pasynUser);
    
    // 알람 설정
    if (pasynUser != NULL) {
        setAlarmStatus(pasynUser, COMM_ALARM, MAJOR_ALARM);
    }
    
    // 통신 오류는 일반적으로 재시도 가능
    return true;
}

/** 스레드 오류 처리 */
bool ErrorHandler::handleThreadError(const char* source, const char* threadName,
                                    const char* errorMessage, asynUser* pasynUser)
{
    if (source == NULL || threadName == NULL || errorMessage == NULL) {
        logError(ERROR, "ErrorHandler::handleThreadError", "NULL 포인터가 전달됨");
        return false;
    }
    
    char fullMessage[256];
    snprintf(fullMessage, sizeof(fullMessage),
            "스레드 오류 - 이름: %s, 메시지: %s", threadName, errorMessage);
    
    logError(ERROR, source, fullMessage, pasynUser);
    
    // 스레드 오류는 대부분 재시작 가능
    bool restartRecommended = true;
    
    // 특정 오류 유형에 따른 처리
    if (strstr(errorMessage, "FATAL") != NULL || strstr(errorMessage, "SEGFAULT") != NULL) {
        restartRecommended = false;
        logError(FATAL, source, "치명적 스레드 오류 - 재시작 불가", pasynUser);
    }
    
    return restartRecommended;
}

/** 매개변수 유효성 검사 */
bool ErrorHandler::validateParameter(const char* paramName, double value, 
                                   double minValue, double maxValue, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateParameter", "NULL 포인터가 전달됨");
        return false;
    }
    
    if (isnan(value) || isinf(value)) {
        char message[256];
        snprintf(message, sizeof(message), 
                "매개변수 '%s'가 유효하지 않은 값입니다 (NaN 또는 Inf)", paramName);
        logError(ERROR, source, message);
        return false;
    }
    
    if (value < minValue || value > maxValue) {
        char message[256];
        snprintf(message, sizeof(message),
                "매개변수 '%s' 값 %f이 유효 범위 [%f, %f]를 벗어났습니다",
                paramName, value, minValue, maxValue);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** 정수 매개변수 유효성 검사 */
bool ErrorHandler::validateIntParameter(const char* paramName, int value, 
                                       int minValue, int maxValue, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateIntParameter", "NULL 포인터가 전달됨");
        return false;
    }
    
    if (value < minValue || value > maxValue) {
        char message[256];
        snprintf(message, sizeof(message),
                "정수 매개변수 '%s' 값 %d이 유효 범위 [%d, %d]를 벗어났습니다",
                paramName, value, minValue, maxValue);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** 문자열 매개변수 유효성 검사 */
bool ErrorHandler::validateStringParameter(const char* paramName, const char* value,
                                          size_t maxLength, bool allowEmpty, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateStringParameter", "NULL 포인터가 전달됨");
        return false;
    }
    
    if (value == NULL) {
        char message[256];
        snprintf(message, sizeof(message), "문자열 매개변수 '%s'가 NULL입니다", paramName);
        logError(ERROR, source, message);
        return false;
    }
    
    size_t length = strlen(value);
    
    if (!allowEmpty && length == 0) {
        char message[256];
        snprintf(message, sizeof(message), "문자열 매개변수 '%s'가 비어있습니다", paramName);
        logError(WARNING, source, message);
        return false;
    }
    
    if (length >= maxLength) {
        char message[256];
        snprintf(message, sizeof(message),
                "문자열 매개변수 '%s' 길이 %zu가 최대 길이 %zu를 초과했습니다",
                paramName, length, maxLength - 1);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** 오류 통계 정보 가져오기 */
void ErrorHandler::getErrorStatistics(int* infoCount, int* warningCount, 
                                     int* errorCount, int* fatalCount)
{
    initializeMutex();
    
    epicsMutexLock(errorStatsMutex);
    if (infoCount)    *infoCount = infoCount_;
    if (warningCount) *warningCount = warningCount_;
    if (errorCount)   *errorCount = errorCount_;
    if (fatalCount)   *fatalCount = fatalCount_;
    epicsMutexUnlock(errorStatsMutex);
}

/** 오류 통계 초기화 */
void ErrorHandler::resetErrorStatistics()
{
    initializeMutex();
    
    epicsMutexLock(errorStatsMutex);
    infoCount_ = 0;
    warningCount_ = 0;
    errorCount_ = 0;
    fatalCount_ = 0;
    epicsMutexUnlock(errorStatsMutex);
    
    logError(INFO, "ErrorHandler::resetErrorStatistics", "오류 통계가 초기화되었습니다");
}

/** 오류 레벨을 문자열로 변환 */
const char* ErrorHandler::errorLevelToString(ErrorLevel level)
{
    switch (level) {
        case INFO:    return "정보";
        case WARNING: return "경고";
        case ERROR:   return "오류";
        case FATAL:   return "치명적";
        default:      return "알수없음";
    }
}

/** 알람 심각도를 문자열로 변환 */
const char* ErrorHandler::alarmSeverityToString(AlarmSeverity severity)
{
    switch (severity) {
        case NO_ALARM:      return "알람없음";
        case MINOR_ALARM:   return "경미한알람";
        case MAJOR_ALARM:   return "주요알람";
        case INVALID_ALARM: return "유효하지않음";
        default:            return "알수없음";
    }
}

/** 알람 상태를 문자열로 변환 */
const char* ErrorHandler::alarmStatusToString(AlarmStatus status)
{
    switch (status) {
        case NO_ALARM_STATUS:     return "정상";
        case READ_ALARM:          return "읽기오류";
        case WRITE_ALARM:         return "쓰기오류";
        case HIHI_ALARM:          return "상한상한";
        case HIGH_ALARM:          return "상한";
        case LOLO_ALARM:          return "하한하한";
        case LOW_ALARM:           return "하한";
        case STATE_ALARM:         return "상태오류";
        case COS_ALARM:           return "변화알람";
        case COMM_ALARM:          return "통신오류";
        case TIMEOUT_ALARM:       return "타임아웃";
        case HW_LIMIT_ALARM:      return "하드웨어제한";
        case CALC_ALARM:          return "계산오류";
        case SCAN_ALARM:          return "스캔오류";
        case LINK_ALARM:          return "링크오류";
        case SOFT_ALARM:          return "소프트웨어알람";
        case BAD_SUB_ALARM:       return "잘못된서브레코드";
        case UDF_ALARM:           return "정의되지않은값";
        case DISABLE_ALARM:       return "비활성화";
        case SIMM_ALARM:          return "시뮬레이션";
        case READ_ACCESS_ALARM:   return "읽기접근오류";
        case WRITE_ACCESS_ALARM:  return "쓰기접근오류";
        default:                  return "알수없음";
    }
}

/** 내부 로깅 메서드 */
void ErrorHandler::internalLog(ErrorLevel level, const char* source, const char* message,
                              asynUser* pasynUser)
{
    // 타임스탬프 생성
    char timestamp[64];
    getTimestampString(timestamp, sizeof(timestamp));
    
    // 로그 메시지 구성
    char logMessage[512];
    snprintf(logMessage, sizeof(logMessage),
            "[%s] [%s] %s: %s",
            timestamp, errorLevelToString(level), source, message);
    
    // 콘솔 출력
    printf("%s\n", logMessage);
    
    // asyn 트레이스 출력 (pasynUser가 있는 경우)
    if (pasynUser != NULL) {
        int traceLevel = convertToAsynTraceLevel(level);
        asynPrint(pasynUser, traceLevel, "%s\n", logMessage);
    }
}

/** 타임스탬프 문자열 생성 */
void ErrorHandler::getTimestampString(char* buffer, size_t bufferSize)
{
    if (buffer == NULL || bufferSize == 0) {
        return;
    }
    
    epicsTimeStamp currentTime;
    epicsTimeGetCurrent(&currentTime);
    
    // EPICS 시간을 문자열로 변환
    char epicsTimeStr[64];
    epicsTimeToStrftime(epicsTimeStr, sizeof(epicsTimeStr), "%Y-%m-%d %H:%M:%S.%06f", &currentTime);
    
    strncpy(buffer, epicsTimeStr, bufferSize - 1);
    buffer[bufferSize - 1] = '\0';
}

/** asyn 트레이스 레벨 변환 */
int ErrorHandler::convertToAsynTraceLevel(ErrorLevel level)
{
    switch (level) {
        case INFO:    return ASYN_TRACE_FLOW;
        case WARNING: return ASYN_TRACE_WARNING;
        case ERROR:   return ASYN_TRACE_ERROR;
        case FATAL:   return ASYN_TRACE_ERROR;
        default:      return ASYN_TRACE_ERROR;
    }
}










🔥 File: ./USB1608G_2AO_V2App/src/ErrorHandler.h
=================================================
#ifndef ErrorHandlerInclude
#define ErrorHandlerInclude

#include <epicsTime.h>
#include <asynDriver.h>
#include <shareLib.h>

/** 오류 처리 및 로깅을 위한 유틸리티 클래스
 * 
 * 이 클래스는 EPICS IOC 애플리케이션에서 발생하는 다양한 오류를 
 * 분류하고 로깅하며, EPICS 알람 시스템과 통합하여 상태를 보고합니다.
 */
class epicsShareClass ErrorHandler {
public:
    /** 오류 레벨 정의 */
    enum ErrorLevel {
        INFO = 0,       ///< 정보성 메시지
        WARNING = 1,    ///< 경고 - 동작에 영향 없음
        ERROR = 2,      ///< 오류 - 기능에 영향 있음
        FATAL = 3       ///< 치명적 오류 - 시스템 중단 필요
    };
    
    /** EPICS 알람 심각도 정의 */
    enum AlarmSeverity {
        NO_ALARM = 0,       ///< 알람 없음
        MINOR_ALARM = 1,    ///< 경미한 알람
        MAJOR_ALARM = 2,    ///< 주요 알람
        INVALID_ALARM = 3   ///< 유효하지 않은 상태
    };
    
    /** EPICS 알람 상태 정의 */
    enum AlarmStatus {
        NO_ALARM_STATUS = 0,    ///< 정상 상태
        READ_ALARM = 1,         ///< 읽기 오류
        WRITE_ALARM = 2,        ///< 쓰기 오류
        HIHI_ALARM = 3,         ///< 상한 상한 알람
        HIGH_ALARM = 4,         ///< 상한 알람
        LOLO_ALARM = 5,         ///< 하한 하한 알람
        LOW_ALARM = 6,          ///< 하한 알람
        STATE_ALARM = 7,        ///< 상태 알람
        COS_ALARM = 8,          ///< 변화 알람
        COMM_ALARM = 9,         ///< 통신 알람
        TIMEOUT_ALARM = 10,     ///< 타임아웃 알람
        HW_LIMIT_ALARM = 11,    ///< 하드웨어 제한 알람
        CALC_ALARM = 12,        ///< 계산 오류 알람
        SCAN_ALARM = 13,        ///< 스캔 오류 알람
        LINK_ALARM = 14,        ///< 링크 오류 알람
        SOFT_ALARM = 15,        ///< 소프트웨어 알람
        BAD_SUB_ALARM = 16,     ///< 잘못된 서브레코드 알람
        UDF_ALARM = 17,         ///< 정의되지 않은 값 알람
        DISABLE_ALARM = 18,     ///< 비활성화 알람
        SIMM_ALARM = 19,        ///< 시뮬레이션 알람
        READ_ACCESS_ALARM = 20, ///< 읽기 접근 알람
        WRITE_ACCESS_ALARM = 21 ///< 쓰기 접근 알람
    };
    
    /** 구성 유효성 검사 결과 */
    struct ValidationResult {
        bool isValid;               ///< 유효성 검사 통과 여부
        ErrorLevel errorLevel;      ///< 오류 레벨
        char errorMessage[256];     ///< 오류 메시지
        char suggestion[256];       ///< 해결 방안 제안
    };
    
    /** ThresholdLogicController 구성 매개변수 */
    struct ThresholdConfig {
        char portName[64];          ///< 포트 이름
        char devicePort[64];        ///< 장치 포트 이름
        int deviceAddr;             ///< 장치 주소
        double updateRate;          ///< 업데이트 주기 (Hz)
        int priority;               ///< 스레드 우선순위
        double thresholdValue;      ///< 임계값
        double hysteresis;          ///< 히스테리시스 값
    };

public:
    /** 오류 로깅 메서드
     * \param[in] level 오류 레벨
     * \param[in] source 오류 발생 소스 (클래스명::메서드명)
     * \param[in] message 오류 메시지
     * \param[in] pasynUser asyn 사용자 포인터 (선택사항)
     */
    static void logError(ErrorLevel level, const char* source, const char* message, 
                        asynUser* pasynUser = NULL);
    
    /** 상세 오류 로깅 메서드 (추가 정보 포함)
     * \param[in] level 오류 레벨
     * \param[in] source 오류 발생 소스
     * \param[in] message 오류 메시지
     * \param[in] details 상세 정보
     * \param[in] errorCode 오류 코드
     * \param[in] pasynUser asyn 사용자 포인터 (선택사항)
     */
    static void logDetailedError(ErrorLevel level, const char* source, const char* message,
                               const char* details, int errorCode, asynUser* pasynUser = NULL);
    
    /** EPICS 알람 상태 설정
     * \param[in] pasynUser asyn 사용자 포인터
     * \param[in] status 알람 상태
     * \param[in] severity 알람 심각도
     * \return asynStatus 결과
     */
    static asynStatus setAlarmStatus(asynUser* pasynUser, AlarmStatus status, AlarmSeverity severity);
    
    /** ThresholdLogicController 구성 유효성 검사
     * \param[in] config 검사할 구성
     * \return ValidationResult 검사 결과
     */
    static ValidationResult validateConfiguration(const ThresholdConfig& config);
    
    /** 런타임 오류 처리
     * \param[in] source 오류 발생 소스
     * \param[in] errorType 오류 유형
     * \param[in] errorCode 오류 코드
     * \param[in] pasynUser asyn 사용자 포인터 (선택사항)
     * \return 복구 가능 여부
     */
    static bool handleRuntimeError(const char* source, const char* errorType, 
                                 int errorCode, asynUser* pasynUser = NULL);
    
    /** 통신 오류 처리
     * \param[in] source 오류 발생 소스
     * \param[in] devicePort 장치 포트 이름
     * \param[in] deviceAddr 장치 주소
     * \param[in] operation 수행 중이던 작업
     * \param[in] pasynUser asyn 사용자 포인터 (선택사항)
     * \return 재시도 권장 여부
     */
    static bool handleCommunicationError(const char* source, const char* devicePort,
                                       int deviceAddr, const char* operation,
                                       asynUser* pasynUser = NULL);
    
    /** 스레드 오류 처리
     * \param[in] source 오류 발생 소스
     * \param[in] threadName 스레드 이름
     * \param[in] errorMessage 오류 메시지
     * \param[in] pasynUser asyn 사용자 포인터 (선택사항)
     * \return 스레드 재시작 권장 여부
     */
    static bool handleThreadError(const char* source, const char* threadName,
                                const char* errorMessage, asynUser* pasynUser = NULL);
    
    /** 매개변수 유효성 검사
     * \param[in] paramName 매개변수 이름
     * \param[in] value 검사할 값
     * \param[in] minValue 최소값
     * \param[in] maxValue 최대값
     * \param[in] source 호출 소스
     * \return 유효성 검사 통과 여부
     */
    static bool validateParameter(const char* paramName, double value, 
                                double minValue, double maxValue, const char* source);
    
    /** 정수 매개변수 유효성 검사
     * \param[in] paramName 매개변수 이름
     * \param[in] value 검사할 값
     * \param[in] minValue 최소값
     * \param[in] maxValue 최대값
     * \param[in] source 호출 소스
     * \return 유효성 검사 통과 여부
     */
    static bool validateIntParameter(const char* paramName, int value, 
                                   int minValue, int maxValue, const char* source);
    
    /** 문자열 매개변수 유효성 검사
     * \param[in] paramName 매개변수 이름
     * \param[in] value 검사할 문자열
     * \param[in] maxLength 최대 길이
     * \param[in] allowEmpty 빈 문자열 허용 여부
     * \param[in] source 호출 소스
     * \return 유효성 검사 통과 여부
     */
    static bool validateStringParameter(const char* paramName, const char* value,
                                      size_t maxLength, bool allowEmpty, const char* source);
    
    /** 오류 통계 정보 가져오기
     * \param[out] infoCount 정보 메시지 수
     * \param[out] warningCount 경고 메시지 수
     * \param[out] errorCount 오류 메시지 수
     * \param[out] fatalCount 치명적 오류 메시지 수
     */
    static void getErrorStatistics(int* infoCount, int* warningCount, 
                                 int* errorCount, int* fatalCount);
    
    /** 오류 통계 초기화 */
    static void resetErrorStatistics();
    
    /** 오류 레벨을 문자열로 변환
     * \param[in] level 오류 레벨
     * \return 오류 레벨 문자열
     */
    static const char* errorLevelToString(ErrorLevel level);
    
    /** 알람 심각도를 문자열로 변환
     * \param[in] severity 알람 심각도
     * \return 알람 심각도 문자열
     */
    static const char* alarmSeverityToString(AlarmSeverity severity);
    
    /** 알람 상태를 문자열로 변환
     * \param[in] status 알람 상태
     * \return 알람 상태 문자열
     */
    static const char* alarmStatusToString(AlarmStatus status);

private:
    // 정적 멤버 변수들 (오류 통계)
    static int infoCount_;      ///< 정보 메시지 카운터
    static int warningCount_;   ///< 경고 메시지 카운터
    static int errorCount_;     ///< 오류 메시지 카운터
    static int fatalCount_;     ///< 치명적 오류 메시지 카운터
    
    /** 내부 로깅 메서드
     * \param[in] level 오류 레벨
     * \param[in] source 오류 발생 소스
     * \param[in] message 메시지
     * \param[in] pasynUser asyn 사용자 포인터
     */
    static void internalLog(ErrorLevel level, const char* source, const char* message,
                          asynUser* pasynUser);
    
    /** 타임스탬프 문자열 생성
     * \param[out] buffer 출력 버퍼
     * \param[in] bufferSize 버퍼 크기
     */
    static void getTimestampString(char* buffer, size_t bufferSize);
    
    /** asyn 트레이스 레벨 변환
     * \param[in] level ErrorHandler 오류 레벨
     * \return asyn 트레이스 레벨
     */
    static int convertToAsynTraceLevel(ErrorLevel level);
};

#endif /* ErrorHandlerInclude */










🔥 File: ./USB1608G_2AO_V2App/src/Makefile
=================================================
TOP=../..

include $(TOP)/configure/CONFIG
#----------------------------------------
# Build the IOC application


PROD_IOC = USB1608G_2AO_V2
# USB1608G_2AO_V2.dbd will be created and installed
DBD += USB1608G_2AO_V2.dbd


# USB1608G_2AO_V2.dbd will be made up from these files:
USB1608G_2AO_V2_DBD += base.dbd
USB1608G_2AO_V2_DBD += measCompApp.dbd
USB1608G_2AO_V2_DBD += measCompSupport.dbd
USB1608G_2AO_V2_DBD += thresholdLogicSupport.dbd


# Include dbd files from all support applications:
#USB1608G_2AO_V2_DBD += xxx.dbd

# Add all the support libraries needed by this IOC
#USB1608G_2AO_V2_LIBS += xxx

# #USB1608G_2AO_V2_registerRecordDeviceDriver.cpp derives from #USB1608G_2AO_V2.dbd
USB1608G_2AO_V2_SRCS += USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
USB1608G_2AO_V2_SRCS += drvMultiFunction.cpp
USB1608G_2AO_V2_SRCS += drvUSBCTR.cpp
USB1608G_2AO_V2_SRCS += measCompDiscover.cpp
USB1608G_2AO_V2_SRCS += ThresholdLogicController.cpp
USB1608G_2AO_V2_SRCS += ErrorHandler.cpp
USB1608G_2AO_V2_SRCS += USBCTR_SNL.st


# Build the main IOC entry point on workstation OSs.
USB1608G_2AO_V2_SRCS_DEFAULT += USB1608G_2AO_V2Main.cpp
USB1608G_2AO_V2_SRCS_vxWorks += -nil-

# Add support from base/src/vxWorks if needed
#USB1608G_2AO_V2_OBJS_vxWorks += $(EPICS_BASE_BIN)/vxComLibrary

# Finally link to the EPICS Base libraries
USB1608G_2AO_V2_LIBS += $(EPICS_BASE_IOC_LIBS)
USB1608G_2AO_V2_LIBS += measComp
USB1608G_2AO_V2_LIBS += scaler
USB1608G_2AO_V2_LIBS += busy
USB1608G_2AO_V2_LIBS += calc
USB1608G_2AO_V2_LIBS += mca
USB1608G_2AO_V2_LIBS += sscan
USB1608G_2AO_V2_LIBS += autosave
USB1608G_2AO_V2_LIBS += asyn
USB1608G_2AO_V2_LIBS += seq pv

USB1608G_2AO_V2_SYS_LIBS_Linux += uldaq
USB1608G_2AO_V2_SYS_LIBS_Linux += usb-1.0
#===========================

include $(TOP)/configure/RULES
#----------------------------------------
#  ADD RULES AFTER THIS LINE











🔥 File: ./USB1608G_2AO_V2App/src/O.Common/USB1608G_2AO_V2.dbd
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.dbd)]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.d
=================================================
ErrorHandler.o: ../ErrorHandler.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 ../ErrorHandler.h /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/Makefile
=================================================
#This Makefile created by makeMakefile.pl


all :
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

.DEFAULT: force
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

force:  ;











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.d
=================================================
ThresholdLogicController.o: ../ThresholdLogicController.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctetSyncIO.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 ../ThresholdLogicController.h ../ErrorHandler.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2.dbd.d
=================================================
../O.Common/USB1608G_2AO_V2.dbd: /usr/local/epics/EPICS_R7.0/base/dbd/base.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuGlobal.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmSevr.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmStat.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuFtype.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuIvoa.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuOmsl.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPini.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPost.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPriority.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuYesNo.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuSimm.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuConvert.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuScan.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stdRecords.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aaiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dbCommon.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aaoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aSubRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/biRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/boRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/calcRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/calcoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/compressRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dfanoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/eventRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/fanoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/histogramRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/int64inRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/int64outRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/longinRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/longoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/lsiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/lsoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbbiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbbiDirectRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbboRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbboDirectRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/permissiveRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/printfRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/selRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/seqRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stateRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stringinRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stringoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/subRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/subArrayRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/waveformRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/filters.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/links.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/devSoft.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/asSub.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dbCore.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/rsrv.dbd \
    /usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2/dbd/measCompApp.dbd \
    ../measCompSupport.dbd \
    ../thresholdLogicSupport.dbd

/usr/local/epics/EPICS_R7.0/base/dbd/base.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuGlobal.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmSevr.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmStat.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuFtype.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuIvoa.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuOmsl.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPini.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPost.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPriority.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuYesNo.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuSimm.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuConvert.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuScan.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stdRecords.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aaiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dbCommon.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aaoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aSubRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/biRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/boRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/calcRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/calcoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/compressRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dfanoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/eventRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/fanoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/histogramRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/int64inRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/int64outRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/longinRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/longoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/lsiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/lsoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbbiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbbiDirectRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbboRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbboDirectRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/permissiveRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/printfRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/selRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/seqRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stateRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stringinRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stringoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/subRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/subArrayRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/waveformRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/filters.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/links.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/devSoft.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/asSub.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dbCore.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/rsrv.dbd:
/usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2/dbd/measCompApp.dbd:
../measCompSupport.dbd:
../thresholdLogicSupport.dbd:
../O.Common/USB1608G_2AO_V2.dbd: ../Makefile











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.d
=================================================
USB1608G_2AO_V2Main.o: ../USB1608G_2AO_V2Main.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExit.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
=================================================
/* THIS IS A GENERATED FILE. DO NOT EDIT! */
/* Generated from ../O.Common/USB1608G_2AO_V2.dbd */

#include <string.h>
#ifndef USE_TYPED_RSET
#  define USE_TYPED_RSET
#endif
#include "compilerDependencies.h"
#include "epicsStdlib.h"
#include "iocsh.h"
#include "iocshRegisterCommon.h"
#include "registryCommon.h"
#include "recSup.h"
#include "shareLib.h"

extern "C" {

epicsShareExtern typed_rset *pvar_rset_aSubRSET, *pvar_rset_aaiRSET,
    *pvar_rset_aaoRSET, *pvar_rset_acalcoutRSET, *pvar_rset_aiRSET,
    *pvar_rset_aoRSET, *pvar_rset_asynRSET, *pvar_rset_biRSET,
    *pvar_rset_boRSET, *pvar_rset_busyRSET, *pvar_rset_calcRSET,
    *pvar_rset_calcoutRSET, *pvar_rset_compressRSET,
    *pvar_rset_dfanoutRSET, *pvar_rset_eventRSET, *pvar_rset_fanoutRSET,
    *pvar_rset_histogramRSET, *pvar_rset_int64inRSET,
    *pvar_rset_int64outRSET, *pvar_rset_longinRSET,
    *pvar_rset_longoutRSET, *pvar_rset_lsiRSET, *pvar_rset_lsoRSET,
    *pvar_rset_mbbiRSET, *pvar_rset_mbbiDirectRSET, *pvar_rset_mbboRSET,
    *pvar_rset_mbboDirectRSET, *pvar_rset_mcaRSET,
    *pvar_rset_permissiveRSET, *pvar_rset_printfRSET,
    *pvar_rset_scalcoutRSET, *pvar_rset_scalerRSET,
    *pvar_rset_scanparmRSET, *pvar_rset_selRSET, *pvar_rset_seqRSET,
    *pvar_rset_sscanRSET, *pvar_rset_sseqRSET, *pvar_rset_stateRSET,
    *pvar_rset_stringinRSET, *pvar_rset_stringoutRSET, *pvar_rset_subRSET,
    *pvar_rset_subArrayRSET, *pvar_rset_swaitRSET,
    *pvar_rset_transformRSET, *pvar_rset_waveformRSET;

typedef int (*rso_func)(dbRecordType *pdbRecordType);
epicsShareExtern rso_func pvar_func_aSubRecordSizeOffset,
    pvar_func_aaiRecordSizeOffset, pvar_func_aaoRecordSizeOffset,
    pvar_func_acalcoutRecordSizeOffset, pvar_func_aiRecordSizeOffset,
    pvar_func_aoRecordSizeOffset, pvar_func_asynRecordSizeOffset,
    pvar_func_biRecordSizeOffset, pvar_func_boRecordSizeOffset,
    pvar_func_busyRecordSizeOffset, pvar_func_calcRecordSizeOffset,
    pvar_func_calcoutRecordSizeOffset, pvar_func_compressRecordSizeOffset,
    pvar_func_dfanoutRecordSizeOffset, pvar_func_eventRecordSizeOffset,
    pvar_func_fanoutRecordSizeOffset, pvar_func_histogramRecordSizeOffset,
    pvar_func_int64inRecordSizeOffset, pvar_func_int64outRecordSizeOffset,
    pvar_func_longinRecordSizeOffset, pvar_func_longoutRecordSizeOffset,
    pvar_func_lsiRecordSizeOffset, pvar_func_lsoRecordSizeOffset,
    pvar_func_mbbiRecordSizeOffset, pvar_func_mbbiDirectRecordSizeOffset,
    pvar_func_mbboRecordSizeOffset, pvar_func_mbboDirectRecordSizeOffset,
    pvar_func_mcaRecordSizeOffset, pvar_func_permissiveRecordSizeOffset,
    pvar_func_printfRecordSizeOffset, pvar_func_scalcoutRecordSizeOffset,
    pvar_func_scalerRecordSizeOffset, pvar_func_scanparmRecordSizeOffset,
    pvar_func_selRecordSizeOffset, pvar_func_seqRecordSizeOffset,
    pvar_func_sscanRecordSizeOffset, pvar_func_sseqRecordSizeOffset,
    pvar_func_stateRecordSizeOffset, pvar_func_stringinRecordSizeOffset,
    pvar_func_stringoutRecordSizeOffset, pvar_func_subRecordSizeOffset,
    pvar_func_subArrayRecordSizeOffset, pvar_func_swaitRecordSizeOffset,
    pvar_func_transformRecordSizeOffset,
    pvar_func_waveformRecordSizeOffset;

static const char * const recordTypeNames[] = {
    "aSub", "aai", "aao", "acalcout", "ai", "ao", "asyn", "bi", "bo",
    "busy", "calc", "calcout", "compress", "dfanout", "event", "fanout",
    "histogram", "int64in", "int64out", "longin", "longout", "lsi", "lso",
    "mbbi", "mbbiDirect", "mbbo", "mbboDirect", "mca", "permissive",
    "printf", "scalcout", "scaler", "scanparm", "sel", "seq", "sscan",
    "sseq", "state", "stringin", "stringout", "sub", "subArray", "swait",
    "transform", "waveform"
};

static const recordTypeLocation rtl[] = {
    {(struct typed_rset *)pvar_rset_aSubRSET, pvar_func_aSubRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aaiRSET, pvar_func_aaiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aaoRSET, pvar_func_aaoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_acalcoutRSET, pvar_func_acalcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aiRSET, pvar_func_aiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aoRSET, pvar_func_aoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_asynRSET, pvar_func_asynRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_biRSET, pvar_func_biRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_boRSET, pvar_func_boRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_busyRSET, pvar_func_busyRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_calcRSET, pvar_func_calcRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_calcoutRSET, pvar_func_calcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_compressRSET, pvar_func_compressRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_dfanoutRSET, pvar_func_dfanoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_eventRSET, pvar_func_eventRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_fanoutRSET, pvar_func_fanoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_histogramRSET, pvar_func_histogramRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_int64inRSET, pvar_func_int64inRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_int64outRSET, pvar_func_int64outRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_longinRSET, pvar_func_longinRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_longoutRSET, pvar_func_longoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_lsiRSET, pvar_func_lsiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_lsoRSET, pvar_func_lsoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbbiRSET, pvar_func_mbbiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbbiDirectRSET, pvar_func_mbbiDirectRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbboRSET, pvar_func_mbboRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbboDirectRSET, pvar_func_mbboDirectRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mcaRSET, pvar_func_mcaRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_permissiveRSET, pvar_func_permissiveRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_printfRSET, pvar_func_printfRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scalcoutRSET, pvar_func_scalcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scalerRSET, pvar_func_scalerRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scanparmRSET, pvar_func_scanparmRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_selRSET, pvar_func_selRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_seqRSET, pvar_func_seqRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_sscanRSET, pvar_func_sscanRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_sseqRSET, pvar_func_sseqRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stateRSET, pvar_func_stateRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stringinRSET, pvar_func_stringinRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stringoutRSET, pvar_func_stringoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_subRSET, pvar_func_subRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_subArrayRSET, pvar_func_subArrayRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_swaitRSET, pvar_func_swaitRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_transformRSET, pvar_func_transformRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_waveformRSET, pvar_func_waveformRecordSizeOffset}
};

epicsShareExtern dset *pvar_dset_devAaiSoft, *pvar_dset_asynInt8ArrayAai,
    *pvar_dset_asynInt16ArrayAai, *pvar_dset_asynInt32ArrayAai,
    *pvar_dset_asynFloat32ArrayAai, *pvar_dset_asynFloat64ArrayAai,
    *pvar_dset_asynInt64ArrayAai, *pvar_dset_devAaoSoft,
    *pvar_dset_asynInt8ArrayAao, *pvar_dset_asynInt16ArrayAao,
    *pvar_dset_asynInt32ArrayAao, *pvar_dset_asynFloat32ArrayAao,
    *pvar_dset_asynFloat64ArrayAao, *pvar_dset_asynInt64ArrayAao,
    *pvar_dset_devaCalcoutSoft, *pvar_dset_devAiSoft,
    *pvar_dset_devAiSoftRaw, *pvar_dset_devAiSoftCallback,
    *pvar_dset_devTimestampAI, *pvar_dset_devAiGeneralTime,
    *pvar_dset_asynAiInt32, *pvar_dset_asynAiInt32Average,
    *pvar_dset_asynAiFloat64, *pvar_dset_asynAiFloat64Average,
    *pvar_dset_asynAiInt64, *pvar_dset_devAoSoft, *pvar_dset_devAoSoftRaw,
    *pvar_dset_devAoSoftCallback, *pvar_dset_asynAoInt32,
    *pvar_dset_asynAoFloat64, *pvar_dset_asynAoInt64,
    *pvar_dset_asynRecordDevice, *pvar_dset_devBiSoft,
    *pvar_dset_devBiSoftRaw, *pvar_dset_devBiSoftCallback,
    *pvar_dset_devBiDbState, *pvar_dset_asynBiInt32,
    *pvar_dset_asynBiUInt32Digital, *pvar_dset_devBoSoft,
    *pvar_dset_devBoSoftRaw, *pvar_dset_devBoSoftCallback,
    *pvar_dset_devBoGeneralTime, *pvar_dset_devBoDbState,
    *pvar_dset_asynBoInt32, *pvar_dset_asynBoUInt32Digital,
    *pvar_dset_devBusySoft, *pvar_dset_devBusySoftRaw,
    *pvar_dset_asynBusyInt32, *pvar_dset_devCalcoutSoft,
    *pvar_dset_devCalcoutSoftCallback, *pvar_dset_devEventSoft,
    *pvar_dset_devHistogramSoft, *pvar_dset_devI64inSoft,
    *pvar_dset_devI64inSoftCallback, *pvar_dset_asynInt64In,
    *pvar_dset_devI64outSoft, *pvar_dset_devI64outSoftCallback,
    *pvar_dset_asynInt64Out, *pvar_dset_devLiSoft,
    *pvar_dset_devLiSoftCallback, *pvar_dset_devLiGeneralTime,
    *pvar_dset_asynLiInt32, *pvar_dset_asynLiUInt32Digital,
    *pvar_dset_asynLiInt64, *pvar_dset_devLoSoft,
    *pvar_dset_devLoSoftCallback, *pvar_dset_asynLoInt32,
    *pvar_dset_asynLoUInt32Digital, *pvar_dset_asynLoInt64,
    *pvar_dset_devLsiSoft, *pvar_dset_devLsiEnviron,
    *pvar_dset_asynLsiOctetCmdResponse, *pvar_dset_asynLsiOctetWriteRead,
    *pvar_dset_asynLsiOctetRead, *pvar_dset_devLsoSoft,
    *pvar_dset_devLsoSoftCallback, *pvar_dset_devLsoStdio,
    *pvar_dset_asynLsoOctetWrite, *pvar_dset_devMbbiSoft,
    *pvar_dset_devMbbiSoftRaw, *pvar_dset_devMbbiSoftCallback,
    *pvar_dset_asynMbbiInt32, *pvar_dset_asynMbbiUInt32Digital,
    *pvar_dset_devMbbiDirectSoft, *pvar_dset_devMbbiDirectSoftRaw,
    *pvar_dset_devMbbiDirectSoftCallback,
    *pvar_dset_asynMbbiDirectUInt32Digital, *pvar_dset_devMbboSoft,
    *pvar_dset_devMbboSoftRaw, *pvar_dset_devMbboSoftCallback,
    *pvar_dset_asynMbboInt32, *pvar_dset_asynMbboUInt32Digital,
    *pvar_dset_devMbboDirectSoft, *pvar_dset_devMbboDirectSoftRaw,
    *pvar_dset_devMbboDirectSoftCallback,
    *pvar_dset_asynMbboDirectUInt32Digital, *pvar_dset_devMCA_soft,
    *pvar_dset_devMcaAsyn, *pvar_dset_devPrintfSoft,
    *pvar_dset_devPrintfSoftCallback, *pvar_dset_devPrintfStdio,
    *pvar_dset_asynPfOctetWrite, *pvar_dset_devsCalcoutSoft,
    *pvar_dset_devScalerAsyn, *pvar_dset_devSiSoft,
    *pvar_dset_devSiSoftCallback, *pvar_dset_devTimestampSI,
    *pvar_dset_devSiGeneralTime, *pvar_dset_devSiEnviron,
    *pvar_dset_asynSiOctetCmdResponse, *pvar_dset_asynSiOctetWriteRead,
    *pvar_dset_asynSiOctetRead, *pvar_dset_devSoSoft,
    *pvar_dset_devSoSoftCallback, *pvar_dset_devSoStdio,
    *pvar_dset_asynSoOctetWrite, *pvar_dset_devSASoft,
    *pvar_dset_devSWaitIoEvent, *pvar_dset_devWfSoft,
    *pvar_dset_asynWfOctetCmdResponse, *pvar_dset_asynWfOctetWriteRead,
    *pvar_dset_asynWfOctetRead, *pvar_dset_asynWfOctetWrite,
    *pvar_dset_asynWfOctetWriteBinary, *pvar_dset_asynInt8ArrayWfIn,
    *pvar_dset_asynInt8ArrayWfOut, *pvar_dset_asynInt16ArrayWfIn,
    *pvar_dset_asynInt16ArrayWfOut, *pvar_dset_asynInt32ArrayWfIn,
    *pvar_dset_asynInt32ArrayWfOut, *pvar_dset_asynFloat32ArrayWfIn,
    *pvar_dset_asynFloat32ArrayWfOut, *pvar_dset_asynFloat64ArrayWfIn,
    *pvar_dset_asynFloat64ArrayWfOut, *pvar_dset_asynInt32TimeSeries,
    *pvar_dset_asynFloat64TimeSeries, *pvar_dset_asynInt64ArrayWfIn,
    *pvar_dset_asynInt64ArrayWfOut, *pvar_dset_asynInt64TimeSeries;

static const char * const deviceSupportNames[] = {
    "devAaiSoft", "asynInt8ArrayAai", "asynInt16ArrayAai",
    "asynInt32ArrayAai", "asynFloat32ArrayAai", "asynFloat64ArrayAai",
    "asynInt64ArrayAai", "devAaoSoft", "asynInt8ArrayAao",
    "asynInt16ArrayAao", "asynInt32ArrayAao", "asynFloat32ArrayAao",
    "asynFloat64ArrayAao", "asynInt64ArrayAao", "devaCalcoutSoft",
    "devAiSoft", "devAiSoftRaw", "devAiSoftCallback", "devTimestampAI",
    "devAiGeneralTime", "asynAiInt32", "asynAiInt32Average",
    "asynAiFloat64", "asynAiFloat64Average", "asynAiInt64", "devAoSoft",
    "devAoSoftRaw", "devAoSoftCallback", "asynAoInt32", "asynAoFloat64",
    "asynAoInt64", "asynRecordDevice", "devBiSoft", "devBiSoftRaw",
    "devBiSoftCallback", "devBiDbState", "asynBiInt32",
    "asynBiUInt32Digital", "devBoSoft", "devBoSoftRaw",
    "devBoSoftCallback", "devBoGeneralTime", "devBoDbState",
    "asynBoInt32", "asynBoUInt32Digital", "devBusySoft", "devBusySoftRaw",
    "asynBusyInt32", "devCalcoutSoft", "devCalcoutSoftCallback",
    "devEventSoft", "devHistogramSoft", "devI64inSoft",
    "devI64inSoftCallback", "asynInt64In", "devI64outSoft",
    "devI64outSoftCallback", "asynInt64Out", "devLiSoft",
    "devLiSoftCallback", "devLiGeneralTime", "asynLiInt32",
    "asynLiUInt32Digital", "asynLiInt64", "devLoSoft",
    "devLoSoftCallback", "asynLoInt32", "asynLoUInt32Digital",
    "asynLoInt64", "devLsiSoft", "devLsiEnviron",
    "asynLsiOctetCmdResponse", "asynLsiOctetWriteRead",
    "asynLsiOctetRead", "devLsoSoft", "devLsoSoftCallback", "devLsoStdio",
    "asynLsoOctetWrite", "devMbbiSoft", "devMbbiSoftRaw",
    "devMbbiSoftCallback", "asynMbbiInt32", "asynMbbiUInt32Digital",
    "devMbbiDirectSoft", "devMbbiDirectSoftRaw",
    "devMbbiDirectSoftCallback", "asynMbbiDirectUInt32Digital",
    "devMbboSoft", "devMbboSoftRaw", "devMbboSoftCallback",
    "asynMbboInt32", "asynMbboUInt32Digital", "devMbboDirectSoft",
    "devMbboDirectSoftRaw", "devMbboDirectSoftCallback",
    "asynMbboDirectUInt32Digital", "devMCA_soft", "devMcaAsyn",
    "devPrintfSoft", "devPrintfSoftCallback", "devPrintfStdio",
    "asynPfOctetWrite", "devsCalcoutSoft", "devScalerAsyn", "devSiSoft",
    "devSiSoftCallback", "devTimestampSI", "devSiGeneralTime",
    "devSiEnviron", "asynSiOctetCmdResponse", "asynSiOctetWriteRead",
    "asynSiOctetRead", "devSoSoft", "devSoSoftCallback", "devSoStdio",
    "asynSoOctetWrite", "devSASoft", "devSWaitIoEvent", "devWfSoft",
    "asynWfOctetCmdResponse", "asynWfOctetWriteRead", "asynWfOctetRead",
    "asynWfOctetWrite", "asynWfOctetWriteBinary", "asynInt8ArrayWfIn",
    "asynInt8ArrayWfOut", "asynInt16ArrayWfIn", "asynInt16ArrayWfOut",
    "asynInt32ArrayWfIn", "asynInt32ArrayWfOut", "asynFloat32ArrayWfIn",
    "asynFloat32ArrayWfOut", "asynFloat64ArrayWfIn",
    "asynFloat64ArrayWfOut", "asynInt32TimeSeries",
    "asynFloat64TimeSeries", "asynInt64ArrayWfIn", "asynInt64ArrayWfOut",
    "asynInt64TimeSeries"
};

static const dset * const devsl[] = {
    pvar_dset_devAaiSoft, pvar_dset_asynInt8ArrayAai,
    pvar_dset_asynInt16ArrayAai, pvar_dset_asynInt32ArrayAai,
    pvar_dset_asynFloat32ArrayAai, pvar_dset_asynFloat64ArrayAai,
    pvar_dset_asynInt64ArrayAai, pvar_dset_devAaoSoft,
    pvar_dset_asynInt8ArrayAao, pvar_dset_asynInt16ArrayAao,
    pvar_dset_asynInt32ArrayAao, pvar_dset_asynFloat32ArrayAao,
    pvar_dset_asynFloat64ArrayAao, pvar_dset_asynInt64ArrayAao,
    pvar_dset_devaCalcoutSoft, pvar_dset_devAiSoft,
    pvar_dset_devAiSoftRaw, pvar_dset_devAiSoftCallback,
    pvar_dset_devTimestampAI, pvar_dset_devAiGeneralTime,
    pvar_dset_asynAiInt32, pvar_dset_asynAiInt32Average,
    pvar_dset_asynAiFloat64, pvar_dset_asynAiFloat64Average,
    pvar_dset_asynAiInt64, pvar_dset_devAoSoft, pvar_dset_devAoSoftRaw,
    pvar_dset_devAoSoftCallback, pvar_dset_asynAoInt32,
    pvar_dset_asynAoFloat64, pvar_dset_asynAoInt64,
    pvar_dset_asynRecordDevice, pvar_dset_devBiSoft,
    pvar_dset_devBiSoftRaw, pvar_dset_devBiSoftCallback,
    pvar_dset_devBiDbState, pvar_dset_asynBiInt32,
    pvar_dset_asynBiUInt32Digital, pvar_dset_devBoSoft,
    pvar_dset_devBoSoftRaw, pvar_dset_devBoSoftCallback,
    pvar_dset_devBoGeneralTime, pvar_dset_devBoDbState,
    pvar_dset_asynBoInt32, pvar_dset_asynBoUInt32Digital,
    pvar_dset_devBusySoft, pvar_dset_devBusySoftRaw,
    pvar_dset_asynBusyInt32, pvar_dset_devCalcoutSoft,
    pvar_dset_devCalcoutSoftCallback, pvar_dset_devEventSoft,
    pvar_dset_devHistogramSoft, pvar_dset_devI64inSoft,
    pvar_dset_devI64inSoftCallback, pvar_dset_asynInt64In,
    pvar_dset_devI64outSoft, pvar_dset_devI64outSoftCallback,
    pvar_dset_asynInt64Out, pvar_dset_devLiSoft,
    pvar_dset_devLiSoftCallback, pvar_dset_devLiGeneralTime,
    pvar_dset_asynLiInt32, pvar_dset_asynLiUInt32Digital,
    pvar_dset_asynLiInt64, pvar_dset_devLoSoft,
    pvar_dset_devLoSoftCallback, pvar_dset_asynLoInt32,
    pvar_dset_asynLoUInt32Digital, pvar_dset_asynLoInt64,
    pvar_dset_devLsiSoft, pvar_dset_devLsiEnviron,
    pvar_dset_asynLsiOctetCmdResponse, pvar_dset_asynLsiOctetWriteRead,
    pvar_dset_asynLsiOctetRead, pvar_dset_devLsoSoft,
    pvar_dset_devLsoSoftCallback, pvar_dset_devLsoStdio,
    pvar_dset_asynLsoOctetWrite, pvar_dset_devMbbiSoft,
    pvar_dset_devMbbiSoftRaw, pvar_dset_devMbbiSoftCallback,
    pvar_dset_asynMbbiInt32, pvar_dset_asynMbbiUInt32Digital,
    pvar_dset_devMbbiDirectSoft, pvar_dset_devMbbiDirectSoftRaw,
    pvar_dset_devMbbiDirectSoftCallback,
    pvar_dset_asynMbbiDirectUInt32Digital, pvar_dset_devMbboSoft,
    pvar_dset_devMbboSoftRaw, pvar_dset_devMbboSoftCallback,
    pvar_dset_asynMbboInt32, pvar_dset_asynMbboUInt32Digital,
    pvar_dset_devMbboDirectSoft, pvar_dset_devMbboDirectSoftRaw,
    pvar_dset_devMbboDirectSoftCallback,
    pvar_dset_asynMbboDirectUInt32Digital, pvar_dset_devMCA_soft,
    pvar_dset_devMcaAsyn, pvar_dset_devPrintfSoft,
    pvar_dset_devPrintfSoftCallback, pvar_dset_devPrintfStdio,
    pvar_dset_asynPfOctetWrite, pvar_dset_devsCalcoutSoft,
    pvar_dset_devScalerAsyn, pvar_dset_devSiSoft,
    pvar_dset_devSiSoftCallback, pvar_dset_devTimestampSI,
    pvar_dset_devSiGeneralTime, pvar_dset_devSiEnviron,
    pvar_dset_asynSiOctetCmdResponse, pvar_dset_asynSiOctetWriteRead,
    pvar_dset_asynSiOctetRead, pvar_dset_devSoSoft,
    pvar_dset_devSoSoftCallback, pvar_dset_devSoStdio,
    pvar_dset_asynSoOctetWrite, pvar_dset_devSASoft,
    pvar_dset_devSWaitIoEvent, pvar_dset_devWfSoft,
    pvar_dset_asynWfOctetCmdResponse, pvar_dset_asynWfOctetWriteRead,
    pvar_dset_asynWfOctetRead, pvar_dset_asynWfOctetWrite,
    pvar_dset_asynWfOctetWriteBinary, pvar_dset_asynInt8ArrayWfIn,
    pvar_dset_asynInt8ArrayWfOut, pvar_dset_asynInt16ArrayWfIn,
    pvar_dset_asynInt16ArrayWfOut, pvar_dset_asynInt32ArrayWfIn,
    pvar_dset_asynInt32ArrayWfOut, pvar_dset_asynFloat32ArrayWfIn,
    pvar_dset_asynFloat32ArrayWfOut, pvar_dset_asynFloat64ArrayWfIn,
    pvar_dset_asynFloat64ArrayWfOut, pvar_dset_asynInt32TimeSeries,
    pvar_dset_asynFloat64TimeSeries, pvar_dset_asynInt64ArrayWfIn,
    pvar_dset_asynInt64ArrayWfOut, pvar_dset_asynInt64TimeSeries
};

epicsShareExtern drvet *pvar_drvet_drvAsyn;

static const char *driverSupportNames[] = {
    "drvAsyn"};

static struct drvet *drvsl[] = {
    pvar_drvet_drvAsyn};

epicsShareExtern jlif *pvar_jlif_lnkCalcIf, *pvar_jlif_lnkConstIf,
    *pvar_jlif_lnkDebugIf, *pvar_jlif_lnkStateIf, *pvar_jlif_lnkTraceIf;

static struct jlif *jlifsl[] = {
    pvar_jlif_lnkCalcIf,
    pvar_jlif_lnkConstIf,
    pvar_jlif_lnkDebugIf,
    pvar_jlif_lnkStateIf,
    pvar_jlif_lnkTraceIf};

typedef void (*reg_func)(void);
epicsShareExtern reg_func pvar_func_Scaler974Register,
    pvar_func_ThresholdLogicRegister, pvar_func_USBCTR_SNLRegistrar,
    pvar_func_aCalcMonitorMemRegister,
    pvar_func_acalcTotalAllocatedMemoryRegister, pvar_func_arrInitialize,
    pvar_func_arrayTestRegister, pvar_func_asInitHooksRegister,
    pvar_func_asSub, pvar_func_asynInterposeDelayRegister,
    pvar_func_asynInterposeEchoRegister,
    pvar_func_asynInterposeEosRegister,
    pvar_func_asynInterposeFlushRegister, pvar_func_asynRegister,
    pvar_func_configMenuRegistrar, pvar_func_dbndInitialize,
    pvar_func_dbrestoreRegister, pvar_func_decInitialize,
    pvar_func_drvMultiFunctionRegister, pvar_func_drvScalerSoftRegister,
    pvar_func_drvUSBCTRRegister, pvar_func_editSseqRegistrar,
    pvar_func_fastSweepRegister, pvar_func_interpRegister,
    pvar_func_rsrvRegistrar, pvar_func_saveDataRegistrar,
    pvar_func_save_restoreRegister, pvar_func_subAveRegister,
    pvar_func_syncInitialize, pvar_func_tsInitialize,
    pvar_func_utagInitialize;

epicsShareExtern int * const pvar_int_CASDEBUG;
epicsShareExtern int * const pvar_int_aCalcAsyncThreshold;
epicsShareExtern int * const pvar_int_aCalcLoopMax;
epicsShareExtern int * const pvar_int_aCalcMonitorMem_debug;
epicsShareExtern int * const pvar_int_aCalcPerformDebug;
epicsShareExtern int * const pvar_int_aCalcPostfixDebug;
epicsShareExtern int * const pvar_int_aCalcoutRecordDebug;
epicsShareExtern int * const pvar_int_arrayTestDebug;
epicsShareExtern int * const pvar_int_asCaDebug;
epicsShareExtern int * const pvar_int_atExitDebug;
epicsShareExtern double * const pvar_double_boHIGHlimit;
epicsShareExtern int * const pvar_int_boHIGHprecision;
epicsShareExtern double * const pvar_double_calcoutODLYlimit;
epicsShareExtern int * const pvar_int_calcoutODLYprecision;
epicsShareExtern int * const pvar_int_callbackParallelThreadsDefault;
epicsShareExtern int * const pvar_int_configMenuDebug;
epicsShareExtern int * const pvar_int_dbAccessDebugPUTF;
epicsShareExtern int * const pvar_int_dbBptNotMonotonic;
epicsShareExtern int * const pvar_int_dbConvertStrict;
epicsShareExtern int * const pvar_int_dbJLinkDebug;
epicsShareExtern int * const pvar_int_dbQuietMacroWarnings;
epicsShareExtern int * const pvar_int_dbRecordsAbcSorted;
epicsShareExtern int * const pvar_int_dbRecordsOnceOnly;
epicsShareExtern int * const pvar_int_dbTemplateMaxVars;
epicsShareExtern int * const pvar_int_dbThreadRealtimeLock;
epicsShareExtern int * const pvar_int_debugSubAve;
epicsShareExtern int * const pvar_int_debug_saveData;
epicsShareExtern int * const pvar_int_debug_saveDataMsg;
epicsShareExtern int * const pvar_int_devaCalcoutSoftDebug;
epicsShareExtern int * const pvar_int_devsCalcoutSoftDebug;
epicsShareExtern int * const pvar_int_histogramSDELprecision;
epicsShareExtern int * const pvar_int_interpDebug;
epicsShareExtern int * const pvar_int_lnkDebug_debug;
epicsShareExtern int * const pvar_int_logClientDebug;
epicsShareExtern int * const pvar_int_mcaRecordDebug;
epicsShareExtern int * const pvar_int_recDynLinkDebug;
epicsShareExtern int * const pvar_int_recDynLinkQsize;
epicsShareExtern int * const pvar_int_sCalcLoopMax;
epicsShareExtern int * const pvar_int_sCalcPerformDebug;
epicsShareExtern int * const pvar_int_sCalcPostfixDebug;
epicsShareExtern int * const pvar_int_sCalcStackHW;
epicsShareExtern int * const pvar_int_sCalcStackLW;
epicsShareExtern int * const pvar_int_sCalcoutRecordDebug;
epicsShareExtern int * const pvar_int_saveData_MessagePolicy;
epicsShareExtern int * const pvar_int_save_restoreDatedBackupFiles;
epicsShareExtern int * const pvar_int_save_restoreDebug;
epicsShareExtern int * const pvar_int_save_restoreIncompleteSetsOk;
epicsShareExtern int * const pvar_int_save_restoreNumSeqFiles;
epicsShareExtern int * const pvar_int_save_restoreRemountThreshold;
epicsShareExtern int * const pvar_int_save_restoreSeqPeriodInSeconds;
epicsShareExtern int * const pvar_int_scalerRecordDebug;
epicsShareExtern int * const pvar_int_scaler_wait_time;
epicsShareExtern int * const pvar_int_scanparmRecordDebug;
epicsShareExtern double * const pvar_double_seqDLYlimit;
epicsShareExtern int * const pvar_int_seqDLYprecision;
epicsShareExtern int * const pvar_int_sscanRecordConnectWaitSeconds;
epicsShareExtern int * const pvar_int_sscanRecordDebug;
epicsShareExtern int * const pvar_int_sscanRecordDontCheckLimits;
epicsShareExtern int * const pvar_int_sscanRecordLookupTime;
epicsShareExtern int * const pvar_int_sscanRecordViewPos;
epicsShareExtern int * const pvar_int_sseqRecDebug;
epicsShareExtern int * const pvar_int_swaitRecordDebug;
epicsShareExtern int * const pvar_int_transformRecordDebug;

static struct iocshVarDef vardefs[] = {
    {"CASDEBUG", iocshArgInt, pvar_int_CASDEBUG},
    {"aCalcAsyncThreshold", iocshArgInt, pvar_int_aCalcAsyncThreshold},
    {"aCalcLoopMax", iocshArgInt, pvar_int_aCalcLoopMax},
    {"aCalcMonitorMem_debug", iocshArgInt, pvar_int_aCalcMonitorMem_debug},
    {"aCalcPerformDebug", iocshArgInt, pvar_int_aCalcPerformDebug},
    {"aCalcPostfixDebug", iocshArgInt, pvar_int_aCalcPostfixDebug},
    {"aCalcoutRecordDebug", iocshArgInt, pvar_int_aCalcoutRecordDebug},
    {"arrayTestDebug", iocshArgInt, pvar_int_arrayTestDebug},
    {"asCaDebug", iocshArgInt, pvar_int_asCaDebug},
    {"atExitDebug", iocshArgInt, pvar_int_atExitDebug},
    {"boHIGHlimit", iocshArgDouble, pvar_double_boHIGHlimit},
    {"boHIGHprecision", iocshArgInt, pvar_int_boHIGHprecision},
    {"calcoutODLYlimit", iocshArgDouble, pvar_double_calcoutODLYlimit},
    {"calcoutODLYprecision", iocshArgInt, pvar_int_calcoutODLYprecision},
    {"callbackParallelThreadsDefault", iocshArgInt, pvar_int_callbackParallelThreadsDefault},
    {"configMenuDebug", iocshArgInt, pvar_int_configMenuDebug},
    {"dbAccessDebugPUTF", iocshArgInt, pvar_int_dbAccessDebugPUTF},
    {"dbBptNotMonotonic", iocshArgInt, pvar_int_dbBptNotMonotonic},
    {"dbConvertStrict", iocshArgInt, pvar_int_dbConvertStrict},
    {"dbJLinkDebug", iocshArgInt, pvar_int_dbJLinkDebug},
    {"dbQuietMacroWarnings", iocshArgInt, pvar_int_dbQuietMacroWarnings},
    {"dbRecordsAbcSorted", iocshArgInt, pvar_int_dbRecordsAbcSorted},
    {"dbRecordsOnceOnly", iocshArgInt, pvar_int_dbRecordsOnceOnly},
    {"dbTemplateMaxVars", iocshArgInt, pvar_int_dbTemplateMaxVars},
    {"dbThreadRealtimeLock", iocshArgInt, pvar_int_dbThreadRealtimeLock},
    {"debugSubAve", iocshArgInt, pvar_int_debugSubAve},
    {"debug_saveData", iocshArgInt, pvar_int_debug_saveData},
    {"debug_saveDataMsg", iocshArgInt, pvar_int_debug_saveDataMsg},
    {"devaCalcoutSoftDebug", iocshArgInt, pvar_int_devaCalcoutSoftDebug},
    {"devsCalcoutSoftDebug", iocshArgInt, pvar_int_devsCalcoutSoftDebug},
    {"histogramSDELprecision", iocshArgInt, pvar_int_histogramSDELprecision},
    {"interpDebug", iocshArgInt, pvar_int_interpDebug},
    {"lnkDebug_debug", iocshArgInt, pvar_int_lnkDebug_debug},
    {"logClientDebug", iocshArgInt, pvar_int_logClientDebug},
    {"mcaRecordDebug", iocshArgInt, pvar_int_mcaRecordDebug},
    {"recDynLinkDebug", iocshArgInt, pvar_int_recDynLinkDebug},
    {"recDynLinkQsize", iocshArgInt, pvar_int_recDynLinkQsize},
    {"sCalcLoopMax", iocshArgInt, pvar_int_sCalcLoopMax},
    {"sCalcPerformDebug", iocshArgInt, pvar_int_sCalcPerformDebug},
    {"sCalcPostfixDebug", iocshArgInt, pvar_int_sCalcPostfixDebug},
    {"sCalcStackHW", iocshArgInt, pvar_int_sCalcStackHW},
    {"sCalcStackLW", iocshArgInt, pvar_int_sCalcStackLW},
    {"sCalcoutRecordDebug", iocshArgInt, pvar_int_sCalcoutRecordDebug},
    {"saveData_MessagePolicy", iocshArgInt, pvar_int_saveData_MessagePolicy},
    {"save_restoreDatedBackupFiles", iocshArgInt, pvar_int_save_restoreDatedBackupFiles},
    {"save_restoreDebug", iocshArgInt, pvar_int_save_restoreDebug},
    {"save_restoreIncompleteSetsOk", iocshArgInt, pvar_int_save_restoreIncompleteSetsOk},
    {"save_restoreNumSeqFiles", iocshArgInt, pvar_int_save_restoreNumSeqFiles},
    {"save_restoreRemountThreshold", iocshArgInt, pvar_int_save_restoreRemountThreshold},
    {"save_restoreSeqPeriodInSeconds", iocshArgInt, pvar_int_save_restoreSeqPeriodInSeconds},
    {"scalerRecordDebug", iocshArgInt, pvar_int_scalerRecordDebug},
    {"scaler_wait_time", iocshArgInt, pvar_int_scaler_wait_time},
    {"scanparmRecordDebug", iocshArgInt, pvar_int_scanparmRecordDebug},
    {"seqDLYlimit", iocshArgDouble, pvar_double_seqDLYlimit},
    {"seqDLYprecision", iocshArgInt, pvar_int_seqDLYprecision},
    {"sscanRecordConnectWaitSeconds", iocshArgInt, pvar_int_sscanRecordConnectWaitSeconds},
    {"sscanRecordDebug", iocshArgInt, pvar_int_sscanRecordDebug},
    {"sscanRecordDontCheckLimits", iocshArgInt, pvar_int_sscanRecordDontCheckLimits},
    {"sscanRecordLookupTime", iocshArgInt, pvar_int_sscanRecordLookupTime},
    {"sscanRecordViewPos", iocshArgInt, pvar_int_sscanRecordViewPos},
    {"sseqRecDebug", iocshArgInt, pvar_int_sseqRecDebug},
    {"swaitRecordDebug", iocshArgInt, pvar_int_swaitRecordDebug},
    {"transformRecordDebug", iocshArgInt, pvar_int_transformRecordDebug},
    {NULL, iocshArgInt, NULL}
};

int USB1608G_2AO_V2_registerRecordDeviceDriver(DBBASE *pbase)
{
    static int executed = 0;
    const char *bldTop = "/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2";
    const char *envTop = getenv("TOP");

    if (envTop && strcmp(envTop, bldTop)) {
        printf("Warning: IOC is booting with TOP = \"%s\"\n"
               "          but was built with TOP = \"%s\"\n",
               envTop, bldTop);
    }

    if (!pbase) {
        printf("pdbbase is NULL; you must load a DBD file first.\n");
        return -1;
    }

    if (executed) {
        printf("Warning: Registration already done.\n");
    }
    executed = 1;

    registerRecordTypes(pbase, NELEMENTS(rtl), recordTypeNames, rtl);
    registerDevices(pbase, NELEMENTS(devsl), deviceSupportNames, devsl);
    registerDrivers(pbase, NELEMENTS(drvsl), driverSupportNames, drvsl);
    registerJLinks(pbase, NELEMENTS(jlifsl), jlifsl);
    runRegistrarOnce(pvar_func_Scaler974Register);
    runRegistrarOnce(pvar_func_ThresholdLogicRegister);
    runRegistrarOnce(pvar_func_USBCTR_SNLRegistrar);
    runRegistrarOnce(pvar_func_aCalcMonitorMemRegister);
    runRegistrarOnce(pvar_func_acalcTotalAllocatedMemoryRegister);
    runRegistrarOnce(pvar_func_arrInitialize);
    runRegistrarOnce(pvar_func_arrayTestRegister);
    runRegistrarOnce(pvar_func_asInitHooksRegister);
    runRegistrarOnce(pvar_func_asSub);
    runRegistrarOnce(pvar_func_asynInterposeDelayRegister);
    runRegistrarOnce(pvar_func_asynInterposeEchoRegister);
    runRegistrarOnce(pvar_func_asynInterposeEosRegister);
    runRegistrarOnce(pvar_func_asynInterposeFlushRegister);
    runRegistrarOnce(pvar_func_asynRegister);
    runRegistrarOnce(pvar_func_configMenuRegistrar);
    runRegistrarOnce(pvar_func_dbndInitialize);
    runRegistrarOnce(pvar_func_dbrestoreRegister);
    runRegistrarOnce(pvar_func_decInitialize);
    runRegistrarOnce(pvar_func_drvMultiFunctionRegister);
    runRegistrarOnce(pvar_func_drvScalerSoftRegister);
    runRegistrarOnce(pvar_func_drvUSBCTRRegister);
    runRegistrarOnce(pvar_func_editSseqRegistrar);
    runRegistrarOnce(pvar_func_fastSweepRegister);
    runRegistrarOnce(pvar_func_interpRegister);
    runRegistrarOnce(pvar_func_rsrvRegistrar);
    runRegistrarOnce(pvar_func_saveDataRegistrar);
    runRegistrarOnce(pvar_func_save_restoreRegister);
    runRegistrarOnce(pvar_func_subAveRegister);
    runRegistrarOnce(pvar_func_syncInitialize);
    runRegistrarOnce(pvar_func_tsInitialize);
    runRegistrarOnce(pvar_func_utagInitialize);
    iocshRegisterVariable(vardefs);
    return 0;
}

/* USB1608G_2AO_V2_registerRecordDeviceDriver */
static const iocshArg rrddArg0 = {"pdbbase", iocshArgPdbbase};
static const iocshArg *rrddArgs[] = {&rrddArg0};
static const iocshFuncDef rrddFuncDef = {
    "USB1608G_2AO_V2_registerRecordDeviceDriver",
    1,
    rrddArgs,
    "Register the various records, devices, for this DBD.\n\n"
    "These are registered into the database given as first argument,\n"
    "which should always be 'pdbbase'.\n\n"
    "Example: USB1608G_2AO_V2_registerRecordDeviceDriver pdbbase\n",
};
static void rrddCallFunc(const iocshArgBuf *)
{
    iocshSetError(USB1608G_2AO_V2_registerRecordDeviceDriver(*iocshPpdbbase));
}

} // extern "C"

/*
 * Register commands on application startup
 */
static int Registration() {
    iocshRegisterCommon();
    iocshRegister(&rrddFuncDef, rrddCallFunc);
    return 0;
}

static int done EPICS_UNUSED = Registration();











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.d
=================================================
USB1608G_2AO_V2_registerRecordDeviceDriver.o: \
 USB1608G_2AO_V2_registerRecordDeviceDriver.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdlib.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdStrtod.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocshRegisterCommon.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbCoreAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/registryCommon.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbStaticLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbFldTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbBase.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbDefs.h \
 /usr/local/epics/EPICS_R7.0/base/include/recSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/devSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/link.h \
 /usr/local/epics/EPICS_R7.0/base/include/cantProceed.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbJLink.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbCoreAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/registryRecordType.h \
 /usr/local/epics/EPICS_R7.0/base/include/recSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.c
=================================================
/* C code for program USBCTR_SNL, generated by snc from ../USBCTR_SNL.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 17 "../USBCTR_SNL.st"
#include <stdlib.h>
# line 18 "../USBCTR_SNL.st"
#include <errlog.h>
# line 19 "../USBCTR_SNL.st"
#include <string.h>
# line 36 "../USBCTR_SNL.st"
static const EF_ID ReadArraysMon = 1;
# line 39 "../USBCTR_SNL.st"
static const EF_ID HardwareAcquiringMon = 2;

/* Variable declarations */
struct seqg_vars {
# line 24 "../USBCTR_SNL.st"
	int i;
# line 25 "../USBCTR_SNL.st"
	int n;
# line 26 "../USBCTR_SNL.st"
	int numCounters;
# line 27 "../USBCTR_SNL.st"
	char temp[100];
# line 29 "../USBCTR_SNL.st"
	char *prefix;
# line 30 "../USBCTR_SNL.st"
	char *record;
# line 31 "../USBCTR_SNL.st"
	char *field;
# line 33 "../USBCTR_SNL.st"
	int ReadArray[9];
# line 35 "../USBCTR_SNL.st"
	int ReadArrays;
# line 38 "../USBCTR_SNL.st"
	int HardwareAcquiring;
# line 41 "../USBCTR_SNL.st"
	int MCSAbsTimeWF;
# line 43 "../USBCTR_SNL.st"
	int SNL_Connected;
# line 44 "../USBCTR_SNL.st"
	int AsynDebug;
# line 47 "../USBCTR_SNL.st"
	int Acquiring;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "mca_control" ******/

/* Event function for state "init" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "mca_control" */
static void seqg_action_mca_control_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 52 "../USBCTR_SNL.st"
			seqg_var->prefix = seq_macValueGet(seqg_env, "P");
# line 53 "../USBCTR_SNL.st"
			seqg_var->record = seq_macValueGet(seqg_env, "R");
# line 54 "../USBCTR_SNL.st"
			seqg_var->field = seq_macValueGet(seqg_env, "FIELD");
# line 55 "../USBCTR_SNL.st"
			seqg_var->numCounters = atoi(seq_macValueGet(seqg_env, "NUM_COUNTERS"));
# line 56 "../USBCTR_SNL.st"
			if ((seqg_var->numCounters <= 0) || (seqg_var->numCounters > 9))
			{
# line 57 "../USBCTR_SNL.st"
				printf("NUM_COUNTERS is illegal.\n");
# line 58 "../USBCTR_SNL.st"
				seqg_var->numCounters = 0;
			}
# line 60 "../USBCTR_SNL.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
			{
# line 61 "../USBCTR_SNL.st"
				seqg_var->n = seqg_var->i + 1;
# line 62 "../USBCTR_SNL.st"
				sprintf(seqg_var->temp, "%s%s%d.%s", seqg_var->prefix, seqg_var->record, seqg_var->n, seqg_var->field);
# line 63 "../USBCTR_SNL.st"
				seq_pvAssign(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), seqg_var->temp);
			}
		}
		return;
	}
}

/****** Code for state "waitConnected" in state set "mca_control" ******/

/* Event function for state "waitConnected" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_waitConnected(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 69 "../USBCTR_SNL.st"
	if (seqg_var->numCounters <= 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 73 "../USBCTR_SNL.st"
	if (seq_pvAssignCount(seqg_env) == seq_pvConnectCount(seqg_env))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitConnected" in state set "mca_control" */
static void seqg_action_mca_control_0_waitConnected(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 70 "../USBCTR_SNL.st"
			printf(">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
		}
		return;
	case 1:
		{
# line 74 "../USBCTR_SNL.st"
			printf("USBCTR: All channels connected.\n");
# line 75 "../USBCTR_SNL.st"
			seqg_var->SNL_Connected = 1;
# line 76 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 12/*SNL_Connected*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "dead" in state set "mca_control" ******/

/* Event function for state "dead" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_dead(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 81 "../USBCTR_SNL.st"
	if (seq_delay(seqg_env, 3600.0))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "dead" in state set "mca_control" */
static void seqg_action_mca_control_0_dead(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "monitor_changes" in state set "mca_control" ******/

/* Event function for state "monitor_changes" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_monitor_changes(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 86 "../USBCTR_SNL.st"
	if (seq_pvAssignCount(seqg_env) != seq_pvConnectCount(seqg_env))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 90 "../USBCTR_SNL.st"
	if (seq_efTestAndClear(seqg_env, ReadArraysMon) && (seqg_var->ReadArrays == 1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 102 "../USBCTR_SNL.st"
	if (seq_efTestAndClear(seqg_env, HardwareAcquiringMon))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_changes" in state set "mca_control" */
static void seqg_action_mca_control_0_monitor_changes(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 87 "../USBCTR_SNL.st"
			printf("USBCTR: Not all channels connected.\n");
		}
		return;
	case 1:
		{
# line 91 "../USBCTR_SNL.st"
			if (seqg_var->AsynDebug)
# line 91 "../USBCTR_SNL.st"
				printf("USBCTR.st: Read array data\n");
# line 92 "../USBCTR_SNL.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
			{
# line 93 "../USBCTR_SNL.st"
				seqg_var->ReadArray[seqg_var->i] = 1;
# line 94 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 96 "../USBCTR_SNL.st"
			seqg_var->MCSAbsTimeWF = 1;
# line 97 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 11/*MCSAbsTimeWF*/, DEFAULT, DEFAULT_TIMEOUT);
# line 98 "../USBCTR_SNL.st"
			seqg_var->ReadArrays = 0;
# line 99 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 9/*ReadArrays*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 103 "../USBCTR_SNL.st"
			if (seqg_var->AsynDebug)
# line 103 "../USBCTR_SNL.st"
				printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", seqg_var->HardwareAcquiring);
# line 105 "../USBCTR_SNL.st"
			if (!seqg_var->HardwareAcquiring)
			{
# line 107 "../USBCTR_SNL.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
				{
# line 108 "../USBCTR_SNL.st"
					seqg_var->ReadArray[seqg_var->i] = 1;
# line 109 "../USBCTR_SNL.st"
					seq_pvPutTmo(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
				}
# line 111 "../USBCTR_SNL.st"
				seqg_var->MCSAbsTimeWF = 1;
# line 112 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 11/*MCSAbsTimeWF*/, DEFAULT, DEFAULT_TIMEOUT);
# line 114 "../USBCTR_SNL.st"
				seqg_var->Acquiring = 0;
# line 115 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 14/*Acquiring*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"", offsetof(struct seqg_vars, ReadArray[0]), "ReadArray[0]", P_INT, 1, 3, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[1]), "ReadArray[1]", P_INT, 1, 4, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[2]), "ReadArray[2]", P_INT, 1, 5, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[3]), "ReadArray[3]", P_INT, 1, 6, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[4]), "ReadArray[4]", P_INT, 1, 7, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[5]), "ReadArray[5]", P_INT, 1, 8, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[6]), "ReadArray[6]", P_INT, 1, 9, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[7]), "ReadArray[7]", P_INT, 1, 10, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[8]), "ReadArray[8]", P_INT, 1, 11, 0, 0, 0, 0},
	{"{P}DoReadAll", offsetof(struct seqg_vars, ReadArrays), "ReadArrays", P_INT, 1, 12, 1, 1, 0, 0},
	{"{P}HardwareAcquiring", offsetof(struct seqg_vars, HardwareAcquiring), "HardwareAcquiring", P_INT, 1, 13, 2, 1, 0, 0},
	{"{P}AbsTimeWF.PROC", offsetof(struct seqg_vars, MCSAbsTimeWF), "MCSAbsTimeWF", P_INT, 1, 14, 0, 0, 0, 0},
	{"{P}SNL_Connected", offsetof(struct seqg_vars, SNL_Connected), "SNL_Connected", P_INT, 1, 15, 0, 0, 0, 0},
	{"{P}Asyn.TB1", offsetof(struct seqg_vars, AsynDebug), "AsynDebug", P_INT, 1, 16, 0, 1, 0, 0},
	{"{P}Acquiring", offsetof(struct seqg_vars, Acquiring), "Acquiring", P_INT, 1, 17, 0, 0, 0, 0},
};

/* Event masks for state set "mca_control" */
static const seqMask seqg_mask_mca_control_0_init[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_waitConnected[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_dead[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_monitor_changes[] = {
	0x00001006,
};

/* State table for state set "mca_control" */
static seqState seqg_states_mca_control[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_mca_control_0_init,
	/* event function */    seqg_event_mca_control_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "waitConnected",
	/* action function */   seqg_action_mca_control_0_waitConnected,
	/* event function */    seqg_event_mca_control_0_waitConnected,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_waitConnected,
	/* state options */     (0)
	},
	{
	/* state name */        "dead",
	/* action function */   seqg_action_mca_control_0_dead,
	/* event function */    seqg_event_mca_control_0_dead,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_dead,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_changes",
	/* action function */   seqg_action_mca_control_0_monitor_changes,
	/* event function */    seqg_event_mca_control_0_monitor_changes,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_monitor_changes,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "mca_control",
	/* states */            seqg_states_mca_control,
	/* number of states */  4
	},
};

/* Program table (global) */
seqProgram USBCTR_SNL = {
	/* magic number */      2002009,
	/* program name */      "USBCTR_SNL",
	/* channels */          seqg_chans,
	/* num. channels */     15,
	/* state sets */        seqg_statesets,
	/* num. state sets */   1,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ",
	/* num. event flags */  2,
	/* encoded options */   (0 | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};

/* Register sequencer commands and program */
#include "epicsExport.h"
static void USBCTR_SNLRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&USBCTR_SNL);
}
epicsExportRegistrar(USBCTR_SNLRegistrar);











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.d
=================================================
USBCTR_SNL.o: USBCTR_SNL.c \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_snc.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seqCom.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/pvAlarm.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_release.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_prim_types.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_mask.h \
 /usr/local/epics/EPICS_R7.0/base/include/errlog.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.i
=================================================
# 0 "../USBCTR_SNL.st"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "../USBCTR_SNL.st"
program USBCTR_SNL("P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ")
# 11 "../USBCTR_SNL.st"
option +r;



option -c;

%%#include <stdlib.h>
%%#include <errlog.h>
%%#include <string.h>




int i;
int n;
int numCounters;
char temp[100];

char *prefix;
char *record;
char *field;

int ReadArray[9];
assign ReadArray to {};
int ReadArrays; assign ReadArrays to "{P}DoReadAll";
monitor ReadArrays; evflag ReadArraysMon; sync ReadArrays ReadArraysMon;

int HardwareAcquiring; assign HardwareAcquiring to "{P}HardwareAcquiring";
monitor HardwareAcquiring; evflag HardwareAcquiringMon; sync HardwareAcquiring HardwareAcquiringMon;

int MCSAbsTimeWF; assign MCSAbsTimeWF to "{P}AbsTimeWF.PROC";

int SNL_Connected; assign SNL_Connected to "{P}SNL_Connected";
int AsynDebug; assign AsynDebug to "{P}Asyn.TB1";
monitor AsynDebug;

int Acquiring; assign Acquiring to "{P}Acquiring";

ss mca_control {
  state init {
    when() {
      prefix = macValueGet("P");
      record = macValueGet("R");
      field = macValueGet("FIELD");
      numCounters = atoi(macValueGet("NUM_COUNTERS"));
      if ((numCounters <= 0) || (numCounters > 9)) {
        printf ("NUM_COUNTERS is illegal.\n");
        numCounters = 0;
      }
      for (i=0; i<numCounters; i++) {
        n = i+1;
        sprintf(temp, "%s%s%d.%s", prefix, record, n, field);
        pvAssign(ReadArray[i], temp);
       }
    } state waitConnected
  }

  state waitConnected {
    when (numCounters <= 0) {
      printf (">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
    } state dead

    when (pvAssignCount () == pvConnectCount ()) {
      printf ("USBCTR: All channels connected.\n");
      SNL_Connected = 1;
      pvPut(SNL_Connected);
    } state monitor_changes
  }

  state dead {
    when (delay (3600.0)) {
    } state dead
  }

  state monitor_changes {
    when (pvAssignCount () != pvConnectCount ()) {
      printf ("USBCTR: Not all channels connected.\n");
    } state waitConnected

    when(efTestAndClear(ReadArraysMon) && (ReadArrays == 1)) {
      if (AsynDebug) printf("USBCTR.st: Read array data\n");
      for (i=0; i<numCounters; i++) {
        ReadArray[i] = 1;
        pvPut(ReadArray[i]);
      }
      MCSAbsTimeWF = 1;
      pvPut(MCSAbsTimeWF);
      ReadArrays = 0;
      pvPut(ReadArrays);
    } state monitor_changes

    when(efTestAndClear(HardwareAcquiringMon)) {
      if (AsynDebug) printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", HardwareAcquiring);

      if (!HardwareAcquiring) {

        for (i=0; i<numCounters; i++) {
          ReadArray[i] = 1;
          pvPut(ReadArray[i], SYNC);
        }
        MCSAbsTimeWF = 1;
        pvPut(MCSAbsTimeWF);

        Acquiring = 0;
        pvPut(Acquiring);
      }
    } state monitor_changes
  }
}











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.st.d
=================================================
# DO NOT EDIT: This file created by mkmf.pl














🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.d
=================================================
drvMultiFunction.o: ../drvMultiFunction.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 ../measCompDiscover.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.d
=================================================
drvUSBCTR.o: ../drvUSBCTR.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/mca-R7-10/include/drvMca.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/scaler-4-1/include/devScalerAsyn.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 ../measCompDiscover.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.d
=================================================
measCompDiscover.o: ../measCompDiscover.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/osiSock.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdSock.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h ../measCompDiscover.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











🔥 File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.o
=================================================
[SKIPPED: ❌ binary or unreadable file]











🔥 File: ./USB1608G_2AO_V2App/src/ThresholdLogicController.cpp
=================================================
/* ThresholdLogicController.cpp
 *
 * 임계값 기반 로직 제어를 위한 asynPortDriver 구현
 * 
 * 이 드라이버는 아날로그 입력 값을 모니터링하고 설정된 임계값과 비교하여
 * 디지털 출력을 제어하는 기능을 제공합니다.
 * 히스테리시스 기능을 포함하여 안정적인 출력 제어를 보장합니다.
 *
 * Author: EPICS IOC Development Guide
 * Date: 2025
 */


/* ThresholdLogicController 구현된 내용:         */
// 1. ThresholdLogicController.cpp 파일 생성
// 2. asynPortDriver 초기화 및 매개변수 생성
//     생성자에서 asynPortDriver를 올바르게 초기화
//     9개의 매개변수를 생성 (임계값, 현재값, 출력상태, 활성화, 히스테리시스 등)
//     초기값 설정 및 매개변수 콜백 호출
// 3. 기본적인 읽기/쓰기 메서드 스켈레톤 구현
//     writeFloat64(): 임계값, 히스테리시스, 업데이트 주기 설정 처리
//     readFloat64(): 현재값 읽기 및 캐시된 값 반환
//     writeInt32(): 활성화 상태 제어 및 출력상태 보호
//     readInt32(): 정수 매개변수 읽기
// 4. 추가 구현된 기능들
//     소멸자: 리소스 정리 및 스레드 중지
//     IOC 쉘 명령어: ThresholdLogicConfig 함수 및 등록
//     내부 메서드 스켈레톤: 향후 작업에서 구현할 메서드들의 기본 틀
//     오류 처리: 매개변수 유효성 검사 및 로깅
//     한국어 주석: 모든 주요 기능에 대한 한국어 설명
// 5. 요구사항 충족 확인
//     요구사항 4.1: asynPortDriver 상속 및 매개변수 관리 구현
//     요구사항 4.2: 기본 구조 및 인터페이스 정의


#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsString.h>
#include <epicsTime.h>
#include <epicsExport.h>
#include <asynPortDriver.h>
#include <asynOctetSyncIO.h>

#include "ThresholdLogicController.h"
#include "ErrorHandler.h"

static const char *driverName = "ThresholdLogicController";

/** ThresholdLogicController 생성자
 * \param[in] portName 이 드라이버의 asyn 포트 이름
 * \param[in] devicePort 연결할 장치 포트 이름  
 * \param[in] deviceAddr 장치 주소
 */
ThresholdLogicController::ThresholdLogicController(const char* portName, const char* devicePort, int deviceAddr)
    : asynPortDriver(portName, 
                     1, /* maxAddr */ 
                     asynFloat64Mask | asynInt32Mask | asynDrvUserMask, /* Interface mask */
                     asynFloat64Mask | asynInt32Mask,  /* Interrupt mask */
                     ASYN_CANBLOCK, /* asynFlags */
                     1, /* Autoconnect */
                     0, /* Default priority */
                     0) /* Default stack size */
{
    const char* functionName = "ThresholdLogicController";
    
    // 장치 연결 정보 저장
    strncpy(devicePortName_, devicePort, sizeof(devicePortName_) - 1);
    devicePortName_[sizeof(devicePortName_) - 1] = '\0';
    deviceAddr_ = deviceAddr;
    
    // 매개변수 생성
    createParam(THRESHOLD_VALUE_STRING,  asynParamFloat64, &P_ThresholdValue);
    createParam(CURRENT_VALUE_STRING,    asynParamFloat64, &P_CurrentValue);
    createParam(OUTPUT_STATE_STRING,     asynParamInt32,   &P_OutputState);
    createParam(ENABLE_STRING,           asynParamInt32,   &P_Enable);
    createParam(HYSTERESIS_STRING,       asynParamFloat64, &P_Hysteresis);
    createParam(UPDATE_RATE_STRING,      asynParamFloat64, &P_UpdateRate);
    createParam(ALARM_STATUS_STRING,     asynParamInt32,   &P_AlarmStatus);
    createParam(DEVICE_PORT_STRING,      asynParamOctet,   &P_DevicePort);
    createParam(DEVICE_ADDR_STRING,      asynParamInt32,   &P_DeviceAddr);
    
    // 초기값 설정
    thresholdValue_ = 0.0;
    currentValue_ = 0.0;
    outputState_ = false;
    enabled_ = false;
    hysteresis_ = 0.1;  // 기본 히스테리시스 값
    updateRate_ = 10.0; // 기본 10Hz 업데이트
    alarmStatus_ = 0;   // 알람 없음
    lastOutputState_ = false;
    
    // 스레드 관리 변수 초기화
    monitorThread_ = NULL;
    threadRunning_ = false;
    threadExit_ = false;
    
    // 매개변수 초기값을 데이터베이스에 설정
    setDoubleParam(P_ThresholdValue, thresholdValue_);
    setDoubleParam(P_CurrentValue, currentValue_);
    setIntegerParam(P_OutputState, outputState_ ? 1 : 0);
    setIntegerParam(P_Enable, enabled_ ? 1 : 0);
    setDoubleParam(P_Hysteresis, hysteresis_);
    setDoubleParam(P_UpdateRate, updateRate_);
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    setStringParam(P_DevicePort, devicePortName_);
    setIntegerParam(P_DeviceAddr, deviceAddr_);
    
    // 타임스탬프 초기화
    epicsTimeGetCurrent(&lastUpdate_);
    
    // 구성 유효성 검사 (ErrorHandler 사용)
    if (!validateConfigurationWithErrorHandler()) {
        ErrorHandler::logError(ErrorHandler::WARNING, functionName, 
                              "구성 유효성 검사에서 경고가 발생했습니다", pasynUserSelf);
    }
    
    // 매개변수 변경사항을 클라이언트에 알림
    callParamCallbacks();
    
    // 성공적인 생성 로그
    char successMessage[256];
    snprintf(successMessage, sizeof(successMessage),
            "포트=%s, 장치포트=%s, 주소=%d로 ThresholdLogicController 생성됨",
            portName, devicePort, deviceAddr);
    ErrorHandler::logError(ErrorHandler::INFO, functionName, successMessage, pasynUserSelf);
}

/** ThresholdLogicController 소멸자 */
ThresholdLogicController::~ThresholdLogicController()
{
    const char* functionName = "~ThresholdLogicController";
    
    // 모니터링 스레드 중지
    stopMonitoring();
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ThresholdLogicController 소멸됨\n",
              driverName, functionName);
}

/** Float64 매개변수 쓰기 메서드 */
asynStatus ThresholdLogicController::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "writeFloat64";
    
    // 매개변수별 유효성 검사 및 처리
    if (function == P_ThresholdValue) {
        // 임계값 유효성 검사 (ErrorHandler 사용)
        if (!ErrorHandler::validateParameter("thresholdValue", value, -10.0, 10.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "임계값이 유효 범위(-10.0V ~ +10.0V)를 벗어났습니다", pasynUser);
            return asynError;
        }
        
        // 히스테리시스와의 관계 검사
        if (fabs(value) < hysteresis_) {
            char warningMsg[256];
            snprintf(warningMsg, sizeof(warningMsg),
                    "임계값이 히스테리시스보다 작음 - 임계값: %f, 히스테리시스: %f",
                    value, hysteresis_);
            ErrorHandler::logError(ErrorHandler::WARNING, functionName, warningMsg, pasynUser);
        }
        
        thresholdValue_ = value;
        status = setDoubleParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: 임계값 설정됨: %f V\n", driverName, functionName, value);
    }
    else if (function == P_Hysteresis) {
        // 히스테리시스 유효성 검사 (ErrorHandler 사용)
        if (!ErrorHandler::validateParameter("hysteresis", value, 0.0, 5.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "히스테리시스가 유효 범위(0.0V ~ 5.0V)를 벗어났습니다", pasynUser);
            return asynError;
        }
        
        // 임계값과의 관계 검사
        if (value > fabs(thresholdValue_)) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: 히스테리시스가 임계값보다 큼 - 히스테리시스: %f, 임계값: %f\n",
                      driverName, functionName, value, thresholdValue_);
        }
        
        hysteresis_ = value;
        status = setDoubleParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: 히스테리시스 설정됨: %f V\n", driverName, functionName, value);
    }
    else if (function == P_UpdateRate) {
        // 업데이트 주기 유효성 검사 (ErrorHandler 사용)
        if (!ErrorHandler::validateParameter("updateRate", value, 0.1, 1000.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "업데이트 주기가 유효 범위(0.1Hz ~ 1000Hz)를 벗어났습니다", pasynUser);
            return asynError;
        }
        
        double oldRate = updateRate_;
        updateRate_ = value;
        status = setDoubleParam(function, value);
        
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: 업데이트 주기 변경됨: %f Hz -> %f Hz\n", 
                  driverName, functionName, oldRate, value);
        
        // 스레드가 실행 중인 경우 새로운 주기가 다음 루프에서 적용됨을 알림
        if (threadRunning_) {
            asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                      "%s::%s: 새로운 업데이트 주기는 다음 루프에서 적용됩니다\n",
                      driverName, functionName);
        }
    }
    else if (function == P_CurrentValue) {
        // 현재값은 읽기 전용이므로 쓰기 거부
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: 현재값은 읽기 전용 매개변수입니다\n",
                  driverName, functionName);
        return asynError;
    }
    else {
        // 알 수 없는 매개변수에 대해서는 부모 클래스 호출
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: 알 수 없는 Float64 매개변수: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::writeFloat64(pasynUser, value);
    }
    
    // 성공한 경우에만 매개변수 변경사항을 클라이언트에 알림
    if (status == asynSuccess) {
        callParamCallbacks();
    } else {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: 매개변수 설정 실패 - function=%d, value=%f, status=%d\n",
                  driverName, functionName, function, value, status);
    }
    
    return status;
}

/** Float64 매개변수 읽기 메서드 */
asynStatus ThresholdLogicController::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "readFloat64";
    
    // 입력 매개변수 유효성 검사
    if (value == NULL) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: NULL 포인터가 전달됨\n",
                  driverName, functionName);
        return asynError;
    }
    
    // 매개변수별 읽기 처리
    if (function == P_ThresholdValue) {
        *value = thresholdValue_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 임계값 읽기: %f V\n", driverName, functionName, *value);
    }
    else if (function == P_CurrentValue) {
        // 현재값은 실시간으로 업데이트되므로 최신 값 반환
        *value = currentValue_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 현재값 읽기: %f V\n", driverName, functionName, *value);
        
        // 현재값이 유효 범위를 벗어나는 경우 경고
        if (*value < -10.0 || *value > 10.0) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: 현재값이 예상 범위를 벗어남: %f V\n",
                      driverName, functionName, *value);
        }
    }
    else if (function == P_Hysteresis) {
        *value = hysteresis_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 히스테리시스 읽기: %f V\n", driverName, functionName, *value);
    }
    else if (function == P_UpdateRate) {
        *value = updateRate_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 업데이트 주기 읽기: %f Hz\n", driverName, functionName, *value);
    }
    else {
        // 알 수 없는 매개변수에 대해서는 부모 클래스 호출
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: 알 수 없는 Float64 매개변수: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::readFloat64(pasynUser, value);
        
        if (status != asynSuccess) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: 부모 클래스에서 매개변수 읽기 실패: function=%d\n",
                      driverName, functionName, function);
        }
    }
    
    // 오류 발생 시 로깅
    if (status != asynSuccess) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: 매개변수 읽기 실패 - function=%d, status=%d\n",
                  driverName, functionName, function, status);
    }
    
    return status;
}

/** Int32 매개변수 쓰기 메서드 */
asynStatus ThresholdLogicController::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "writeInt32";
    
    // 매개변수별 유효성 검사 및 처리
    if (function == P_Enable) {
        // 활성화 상태 유효성 검사 (0 또는 1만 허용)
        if (value != 0 && value != 1) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: 활성화 값이 0 또는 1이 아님: %d (0으로 처리)\n",
                      driverName, functionName, value);
            value = (value != 0) ? 1 : 0; // 0이 아닌 값은 1로 처리
        }
        
        bool newEnabled = (value != 0);
        if (newEnabled != enabled_) {
            // 상태 변경 전 유효성 검사
            if (newEnabled) {
                // 활성화하기 전 필수 매개변수 검사
                if (!validateParameters()) {
                    asynPrint(pasynUser, ASYN_TRACE_ERROR,
                              "%s::%s: 매개변수 유효성 검사 실패 - 활성화할 수 없음\n",
                              driverName, functionName);
                    return asynError;
                }
                
                // 장치 연결 상태 확인
                if (strlen(devicePortName_) == 0) {
                    asynPrint(pasynUser, ASYN_TRACE_ERROR,
                              "%s::%s: 장치 포트가 설정되지 않음 - 활성화할 수 없음\n",
                              driverName, functionName);
                    return asynError;
                }
            }
            
            enabled_ = newEnabled;
            status = setIntegerParam(function, value);
            
            if (enabled_) {
                startMonitoring();
                asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                          "%s::%s: 임계값 로직 활성화됨 (포트: %s, 주소: %d)\n", 
                          driverName, functionName, devicePortName_, deviceAddr_);
            } else {
                stopMonitoring();
                asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                          "%s::%s: 임계값 로직 비활성화됨\n", driverName, functionName);
            }
        } else {
            // 상태 변경이 없는 경우에도 매개변수 업데이트
            status = setIntegerParam(function, value);
            asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                      "%s::%s: 활성화 상태 유지: %s\n", 
                      driverName, functionName, enabled_ ? "활성화" : "비활성화");
        }
    }
    else if (function == P_OutputState) {
        // 출력 상태는 읽기 전용이므로 쓰기 거부
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: 출력 상태는 읽기 전용 매개변수입니다 (시도된 값: %d)\n",
                  driverName, functionName, value);
        return asynError;
    }
    else if (function == P_AlarmStatus) {
        // 알람 상태도 읽기 전용이므로 쓰기 거부
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: 알람 상태는 읽기 전용 매개변수입니다 (시도된 값: %d)\n",
                  driverName, functionName, value);
        return asynError;
    }
    else if (function == P_DeviceAddr) {
        // 장치 주소 유효성 검사 (0-255 범위)
        if (value < 0 || value > 255) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: 장치 주소가 유효 범위를 벗어남: %d (범위: 0-255)\n",
                      driverName, functionName, value);
            return asynError;
        }
        
        // 활성화 상태에서는 장치 주소 변경 불가
        if (enabled_) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: 활성화 상태에서는 장치 주소를 변경할 수 없습니다\n",
                      driverName, functionName);
            return asynError;
        }
        
        deviceAddr_ = value;
        status = setIntegerParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: 장치 주소 설정됨: %d\n", driverName, functionName, value);
    }
    else {
        // 알 수 없는 매개변수에 대해서는 부모 클래스 호출
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: 알 수 없는 Int32 매개변수: function=%d, value=%d\n",
                  driverName, functionName, function, value);
        status = asynPortDriver::writeInt32(pasynUser, value);
    }
    
    // 성공한 경우에만 매개변수 변경사항을 클라이언트에 알림
    if (status == asynSuccess) {
        callParamCallbacks();
    } else {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: 매개변수 설정 실패 - function=%d, value=%d, status=%d\n",
                  driverName, functionName, function, value, status);
    }
    
    return status;
}

/** Int32 매개변수 읽기 메서드 */
asynStatus ThresholdLogicController::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "readInt32";
    
    // 입력 매개변수 유효성 검사
    if (value == NULL) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: NULL 포인터가 전달됨\n",
                  driverName, functionName);
        return asynError;
    }
    
    // 매개변수별 읽기 처리
    if (function == P_Enable) {
        *value = enabled_ ? 1 : 0;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 활성화 상태 읽기: %d (%s)\n", 
                  driverName, functionName, *value, enabled_ ? "활성화" : "비활성화");
    }
    else if (function == P_OutputState) {
        *value = outputState_ ? 1 : 0;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 출력 상태 읽기: %d (%s)\n", 
                  driverName, functionName, *value, outputState_ ? "HIGH" : "LOW");
        
        // 스레드가 실행 중이지 않은데 출력 상태가 변경된 경우 경고
        if (!threadRunning_ && outputState_) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: 모니터링 스레드가 중지된 상태에서 출력이 HIGH입니다\n",
                      driverName, functionName);
        }
    }
    else if (function == P_AlarmStatus) {
        *value = alarmStatus_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 알람 상태 읽기: %d\n", driverName, functionName, *value);
        
        // 알람 상태에 따른 추가 정보 제공
        const char* alarmDesc = "";
        switch (alarmStatus_) {
            case 0: alarmDesc = "정상"; break;
            case 1: alarmDesc = "경고"; break;
            case 2: alarmDesc = "주요 오류"; break;
            case 3: alarmDesc = "치명적 오류"; break;
            default: alarmDesc = "알 수 없음"; break;
        }
        
        if (alarmStatus_ != 0) {
            asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                      "%s::%s: 알람 상태 상세: %s\n", 
                      driverName, functionName, alarmDesc);
        }
    }
    else if (function == P_DeviceAddr) {
        *value = deviceAddr_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 장치 주소 읽기: %d\n", driverName, functionName, *value);
    }
    else {
        // 알 수 없는 매개변수에 대해서는 부모 클래스 호출
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: 알 수 없는 Int32 매개변수: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::readInt32(pasynUser, value);
        
        if (status != asynSuccess) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: 부모 클래스에서 매개변수 읽기 실패: function=%d\n",
                      driverName, functionName, function);
        }
    }
    
    // 오류 발생 시 로깅
    if (status != asynSuccess) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: 매개변수 읽기 실패 - function=%d, status=%d\n",
                  driverName, functionName, function, status);
    }
    
    return status;
}

/** 임계값 로직 처리 메서드 
 * 
 * 이 메서드는 다음 기능들을 수행합니다:
 * 1. 장치에서 현재 값을 읽어옴
 * 2. 임계값과 히스테리시스를 고려한 비교 로직 수행
 * 3. 출력 상태 변화 감지 및 제어
 * 4. 알람 상태 설정 및 타임스탬프 업데이트
 */
void ThresholdLogicController::processThresholdLogic()
{
    const char* functionName = "processThresholdLogic";
    asynStatus status = asynSuccess;
    
    // 활성화되지 않은 경우 처리하지 않음
    if (!enabled_) {
        return;
    }
    
    // 1. 장치에서 현재 값을 읽어옴
    status = readCurrentValueFromDevice();
    if (status != asynSuccess) {
        ErrorHandler::handleCommunicationError(functionName, devicePortName_, deviceAddr_, 
                                              "현재값 읽기", pasynUserSelf);
        alarmStatus_ = 2; // MAJOR 알람
        ErrorHandler::setAlarmStatus(pasynUserSelf, ErrorHandler::COMM_ALARM, 
                                   ErrorHandler::MAJOR_ALARM);
        updateAlarmStatus();
        return;
    }
    
    // 2. 임계값 비교 및 히스테리시스 로직 구현
    bool newOutputState = outputState_; // 현재 출력 상태로 초기화
    
    if (!outputState_) {
        // 현재 출력이 LOW인 경우: 임계값을 초과하면 HIGH로 변경
        if (currentValue_ > thresholdValue_) {
            newOutputState = true;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: 임계값 초과 감지 - 현재값: %f, 임계값: %f\n",
                      driverName, functionName, currentValue_, thresholdValue_);
        }
    } else {
        // 현재 출력이 HIGH인 경우: 임계값-히스테리시스 아래로 떨어지면 LOW로 변경
        double lowerThreshold = thresholdValue_ - hysteresis_;
        if (currentValue_ < lowerThreshold) {
            newOutputState = false;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: 히스테리시스 임계값 미만 감지 - 현재값: %f, 하한임계값: %f\n",
                      driverName, functionName, currentValue_, lowerThreshold);
        }
    }
    
    // 3. 상태 변화 감지 및 출력 제어
    if (newOutputState != outputState_) {
        // 상태가 변경된 경우
        lastOutputState_ = outputState_; // 이전 상태 저장
        outputState_ = newOutputState;   // 새로운 상태 설정
        
        // 장치에 새로운 출력 상태 설정
        status = writeOutputStateToDevice(outputState_);
        if (status != asynSuccess) {
            ErrorHandler::handleCommunicationError(functionName, devicePortName_, deviceAddr_, 
                                                  "출력상태 설정", pasynUserSelf);
            alarmStatus_ = 2; // MAJOR 알람
            ErrorHandler::setAlarmStatus(pasynUserSelf, ErrorHandler::WRITE_ALARM, 
                                       ErrorHandler::MAJOR_ALARM);
        } else {
            // 성공적으로 출력 상태가 변경됨
            alarmStatus_ = 0; // 알람 해제
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: 출력 상태 변경됨: %s -> %s\n",
                      driverName, functionName, 
                      lastOutputState_ ? "HIGH" : "LOW",
                      outputState_ ? "HIGH" : "LOW");
        }
        
        // 출력 상태 매개변수 업데이트
        setIntegerParam(P_OutputState, outputState_ ? 1 : 0);
    } else {
        // 상태 변화가 없는 경우 - 정상 동작
        if (alarmStatus_ == 0) {
            // 이미 알람이 없는 상태라면 그대로 유지
        } else {
            // 이전에 알람이 있었다면 해제
            alarmStatus_ = 0;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: 정상 동작 - 알람 해제\n",
                      driverName, functionName);
        }
    }
    
    // 4. 매개변수 업데이트 및 타임스탬프 갱신
    setDoubleParam(P_CurrentValue, currentValue_);
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    
    // 타임스탬프 업데이트
    epicsTimeGetCurrent(&lastUpdate_);
    
    // 5. 알람 상태 업데이트 및 클라이언트 알림
    updateAlarmStatus();
    callParamCallbacks();
    
    // 디버그 정보 출력 (TRACE_FLOW 레벨)
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: 처리 완료 - 현재값: %f, 임계값: %f, 출력: %s, 알람: %d\n",
              driverName, functionName, currentValue_, thresholdValue_,
              outputState_ ? "HIGH" : "LOW", alarmStatus_);
}

/** 모니터링 시작 메서드 */
void ThresholdLogicController::startMonitoring()
{
    const char* functionName = "startMonitoring";
    
    // 이미 스레드가 실행 중인 경우 중복 시작 방지
    if (threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: 모니터링 스레드가 이미 실행 중입니다\n",
                  driverName, functionName);
        return;
    }
    
    // 스레드 종료 플래그 초기화
    threadExit_ = false;
    
    // 업데이트 주기 유효성 검사 (0.1Hz ~ 1000Hz 범위)
    if (updateRate_ < 0.1 || updateRate_ > 1000.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: 업데이트 주기가 범위를 벗어남 (%f Hz), 기본값 10Hz로 설정\n",
                  driverName, functionName, updateRate_);
        updateRate_ = 10.0;
        setDoubleParam(P_UpdateRate, updateRate_);
    }
    
    // 스레드 이름 생성
    char threadName[64];
    snprintf(threadName, sizeof(threadName), "ThresholdMonitor_%s", portName);
    
    // epicsThread 생성 및 시작
    try {
        monitorThread_ = new epicsThread(
            *this,                      // epicsThreadRunable 객체 (this)
            threadName,                 // 스레드 이름
            epicsThreadGetStackSize(epicsThreadStackMedium), // 스택 크기
            epicsThreadPriorityMedium   // 중간 우선순위
        );
        
        if (monitorThread_ == NULL) {
            ErrorHandler::handleThreadError(functionName, threadName, 
                                           "스레드 객체 생성 실패", pasynUserSelf);
            return;
        }
        
        // 스레드 시작
        monitorThread_->start();
        threadRunning_ = true;
        
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: 모니터링 스레드 시작됨 - 업데이트 주기: %f Hz\n",
                  driverName, functionName, updateRate_);
        
    } catch (std::exception& e) {
        ErrorHandler::handleThreadError(functionName, threadName, e.what(), pasynUserSelf);
        
        // 실패 시 정리
        if (monitorThread_) {
            delete monitorThread_;
            monitorThread_ = NULL;
        }
        threadRunning_ = false;
    }
}

/** 모니터링 중지 메서드 */
void ThresholdLogicController::stopMonitoring()
{
    const char* functionName = "stopMonitoring";
    
    // 스레드가 실행 중이지 않은 경우
    if (!threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: 모니터링 스레드가 실행 중이지 않습니다\n",
                  driverName, functionName);
        return;
    }
    
    // 스레드 종료 신호 설정
    threadExit_ = true;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: 모니터링 스레드 종료 신호 전송\n",
              driverName, functionName);
    
    // 스레드가 종료될 때까지 대기 (최대 5초)
    if (monitorThread_) {
        int waitCount = 0;
        const int maxWaitCount = 50; // 5초 (100ms * 50)
        
        while (threadRunning_ && waitCount < maxWaitCount) {
            epicsThreadSleep(0.1); // 100ms 대기
            waitCount++;
        }
        
        if (threadRunning_) {
            // 스레드가 정상적으로 종료되지 않은 경우 강제 종료
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: 스레드가 정상 종료되지 않아 강제 종료합니다\n",
                      driverName, functionName);
        } else {
            asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                      "%s::%s: 스레드가 정상적으로 종료되었습니다\n",
                      driverName, functionName);
        }
        
        // 스레드 객체 삭제
        try {
            delete monitorThread_;
            monitorThread_ = NULL;
        } catch (std::exception& e) {
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: 스레드 삭제 중 예외 발생: %s\n",
                      driverName, functionName, e.what());
        }
    }
    
    // 상태 변수 초기화
    threadRunning_ = false;
    threadExit_ = false;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: 모니터링 중지 완료\n",
              driverName, functionName);
}

/** epicsThreadRunable 인터페이스 구현 - 주기적 데이터 수집 및 임계값 로직 처리 */
void ThresholdLogicController::run()
{
    const char* functionName = "run";
    
    // 스레드 시작 로그
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: 모니터링 스레드 시작 - PID: %lu\n",
              driverName, functionName, (unsigned long)epicsThreadGetIdSelf());
    
    // 업데이트 주기 계산 (Hz를 초 단위로 변환)
    double sleepTime = 1.0 / updateRate_;
    
    // 성능 모니터링 변수
    int cycleCount = 0;
    epicsTimeStamp startTime, currentTime;
    epicsTimeGetCurrent(&startTime);
    
    // 메인 모니터링 루프
    while (!threadExit_) {
        try {
            // 루프 시작 시간 기록
            epicsTimeStamp loopStart;
            epicsTimeGetCurrent(&loopStart);
            
            // 컨트롤러가 활성화된 경우에만 임계값 로직 처리
            if (enabled_) {
                // 임계값 로직 처리 (메인 기능)
                processThresholdLogic();
                
                // 처리 완료 후 매개변수 콜백 호출 (클라이언트 업데이트)
                callParamCallbacks();
            } else {
                // 비활성화 상태에서는 현재 값만 업데이트 (모니터링 유지)
                asynStatus status = readCurrentValueFromDevice();
                if (status == asynSuccess) {
                    setDoubleParam(P_CurrentValue, currentValue_);
                    callParamCallbacks();
                }
            }
            
            // 주기적 성능 리포트 (1000 사이클마다)
            cycleCount++;
            if (cycleCount % 1000 == 0) {
                epicsTimeGetCurrent(&currentTime);
                double elapsedTime = epicsTimeDiffInSeconds(&currentTime, &startTime);
                double actualRate = cycleCount / elapsedTime;
                
                asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                          "%s::%s: 성능 리포트 - 사이클: %d, 실제 주기: %.2f Hz, 목표 주기: %.2f Hz\n",
                          driverName, functionName, cycleCount, actualRate, updateRate_);
                
                // 카운터 및 시간 리셋
                cycleCount = 0;
                startTime = currentTime;
            }
            
            // 루프 처리 시간 계산
            epicsTimeStamp loopEnd;
            epicsTimeGetCurrent(&loopEnd);
            double processingTime = epicsTimeDiffInSeconds(&loopEnd, &loopStart);
            
            // 처리 시간이 업데이트 주기보다 긴 경우 경고
            if (processingTime > sleepTime) {
                asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                          "%s::%s: 처리 시간 초과 - 처리시간: %.3f초, 목표주기: %.3f초\n",
                          driverName, functionName, processingTime, sleepTime);
            }
            
            // 남은 시간만큼 대기 (정확한 주기 유지)
            double remainingSleepTime = sleepTime - processingTime;
            if (remainingSleepTime > 0.001) { // 최소 1ms 대기
                epicsThreadSleep(remainingSleepTime);
            } else {
                // 처리 시간이 너무 길어서 대기할 시간이 없는 경우 최소 대기
                epicsThreadSleep(0.001); // 1ms 최소 대기
            }
            
        } catch (std::exception& e) {
            // 예외 발생 시 로그 출력 및 계속 실행
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: 스레드 루프 중 예외 발생: %s\n",
                      driverName, functionName, e.what());
            
            // 예외 발생 시 잠시 대기 후 계속
            epicsThreadSleep(1.0);
        } catch (...) {
            // 알 수 없는 예외 처리
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: 알 수 없는 예외 발생\n",
                      driverName, functionName);
            
            // 예외 발생 시 잠시 대기 후 계속
            epicsThreadSleep(1.0);
        }
        
        // 업데이트 주기가 변경된 경우 새로운 주기로 업데이트
        double newSleepTime = 1.0 / updateRate_;
        if (fabs(newSleepTime - sleepTime) > 0.001) { // 1ms 이상 차이나는 경우
            sleepTime = newSleepTime;
            asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                      "%s::%s: 업데이트 주기 변경됨: %.2f Hz (%.3f초 간격)\n",
                      driverName, functionName, updateRate_, sleepTime);
        }
    }
    
    // 스레드 종료 처리
    threadRunning_ = false;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: 모니터링 스레드 종료 - 총 사이클: %d\n",
              driverName, functionName, cycleCount);
}

/** 정적 스레드 함수 - 호환성을 위해 유지 (사용되지 않음) */
void ThresholdLogicController::monitorThreadFunc(void* param)
{
    const char* functionName = "monitorThreadFunc";
    
    // 이 함수는 더 이상 사용되지 않음 (run() 메서드로 대체됨)
    printf("%s::%s: 경고 - 이 함수는 더 이상 사용되지 않습니다. run() 메서드를 사용하세요.\n", 
           driverName, functionName);
}

/** 장치에서 현재 값을 읽어오는 메서드 
 * 
 * 이 메서드는 연결된 장치 포트를 통해 아날로그 입력 값을 읽어옵니다.
 * 실제 구현에서는 asyn 클라이언트를 통해 장치와 통신합니다.
 */
asynStatus ThresholdLogicController::readCurrentValueFromDevice()
{
    const char* functionName = "readCurrentValueFromDevice";
    asynStatus status = asynSuccess;
    asynUser *pasynUser = NULL;
    
    // asyn 클라이언트 생성 (장치 포트에 연결)
    status = pasynOctetSyncIO->connect(devicePortName_, deviceAddr_, &pasynUser, NULL);
    if (status != asynSuccess) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 장치 포트 %s에 연결 실패\n",
                  driverName, functionName, devicePortName_);
        return status;
    }
    
    try {
        // 실제 구현에서는 여기서 장치별 프로토콜에 따라 값을 읽어옴
        // 현재는 시뮬레이션을 위해 간단한 값을 생성
        // 실제 환경에서는 measComp 드라이버를 통해 USB1608G-2AO에서 값을 읽어옴
        
        // 시뮬레이션: 시간에 따라 변화하는 사인파 값 생성 (테스트용)
        epicsTimeStamp now;
        epicsTimeGetCurrent(&now);
        double timeSeconds = now.secPastEpoch + now.nsec / 1e9;
        
        // 0.0 ~ 10.0V 범위의 사인파 + 노이즈
        currentValue_ = 5.0 + 4.0 * sin(timeSeconds * 0.1) + 0.1 * (rand() / (double)RAND_MAX - 0.5);
        
        // 값의 유효성 검사
        if (currentValue_ < -10.0 || currentValue_ > 10.0) {
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: 읽어온 값이 범위를 벗어남: %f\n",
                      driverName, functionName, currentValue_);
            currentValue_ = fmax(-10.0, fmin(10.0, currentValue_)); // 범위 제한
        }
        
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 장치에서 값 읽기 성공: %f V\n",
                  driverName, functionName, currentValue_);
        
    } catch (...) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 장치 읽기 중 예외 발생\n",
                  driverName, functionName);
        status = asynError;
    }
    
    // asyn 클라이언트 연결 해제
    if (pasynUser) {
        pasynOctetSyncIO->disconnect(pasynUser);
    }
    
    return status;
}

/** 장치에 출력 상태를 설정하는 메서드 
 * 
 * 이 메서드는 연결된 장치 포트를 통해 디지털 출력 상태를 설정합니다.
 * 실제 구현에서는 asyn 클라이언트를 통해 장치와 통신합니다.
 */
asynStatus ThresholdLogicController::writeOutputStateToDevice(bool state)
{
    const char* functionName = "writeOutputStateToDevice";
    asynStatus status = asynSuccess;
    asynUser *pasynUser = NULL;
    
    // asyn 클라이언트 생성 (장치 포트에 연결)
    status = pasynOctetSyncIO->connect(devicePortName_, deviceAddr_, &pasynUser, NULL);
    if (status != asynSuccess) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 장치 포트 %s에 연결 실패\n",
                  driverName, functionName, devicePortName_);
        return status;
    }
    
    try {
        // 실제 구현에서는 여기서 장치별 프로토콜에 따라 출력을 설정
        // 현재는 시뮬레이션을 위해 로그만 출력
        // 실제 환경에서는 measComp 드라이버를 통해 USB1608G-2AO의 디지털 출력을 제어
        
        // 시뮬레이션: 출력 상태 설정 명령 전송 (테스트용)
        const char* stateStr = state ? "HIGH" : "LOW";
        int digitalValue = state ? 1 : 0;
        
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DEVICE,
                  "%s::%s: 장치에 디지털 출력 설정 - 상태: %s (값: %d)\n",
                  driverName, functionName, stateStr, digitalValue);
        
        // 실제 구현에서는 여기서 다음과 같은 작업을 수행:
        // 1. 장치의 디지털 출력 레지스터에 값 쓰기
        // 2. 명령 전송 및 응답 확인
        // 3. 오류 상태 검사
        
        // 시뮬레이션: 성공적으로 설정되었다고 가정
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                  "%s::%s: 출력 상태 설정 완료: %s\n",
                  driverName, functionName, stateStr);
        
    } catch (...) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 장치 쓰기 중 예외 발생\n",
                  driverName, functionName);
        status = asynError;
    }
    
    // asyn 클라이언트 연결 해제
    if (pasynUser) {
        pasynOctetSyncIO->disconnect(pasynUser);
    }
    
    return status;
}

/** 알람 상태 업데이트 메서드 
 * 
 * 이 메서드는 현재 알람 상태에 따라 EPICS 알람 시스템을 업데이트합니다.
 * 알람 심각도와 상태를 설정하여 클라이언트에 알림을 제공합니다.
 */
void ThresholdLogicController::updateAlarmStatus()
{
    const char* functionName = "updateAlarmStatus";
    int alarmSeverity = 0;  // NO_ALARM
    int alarmStatus = 0;    // NO_ALARM
    
    // 알람 상태에 따른 심각도 및 상태 설정
    switch (alarmStatus_) {
        case 0:  // 정상 상태
            alarmSeverity = 0;  // NO_ALARM
            alarmStatus = 0;    // NO_ALARM
            break;
            
        case 1:  // 경고 상태 (MINOR)
            alarmSeverity = 1;  // MINOR_ALARM
            alarmStatus = 3;    // STATE_ALARM
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: MINOR 알람 설정 - 경고 상태\n",
                      driverName, functionName);
            break;
            
        case 2:  // 주요 오류 상태 (MAJOR)
            alarmSeverity = 2;  // MAJOR_ALARM
            alarmStatus = 4;    // COMM_ALARM (통신 오류)
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: MAJOR 알람 설정 - 통신 오류\n",
                      driverName, functionName);
            break;
            
        case 3:  // 치명적 오류 상태 (INVALID)
            alarmSeverity = 3;  // INVALID_ALARM
            alarmStatus = 17;   // UDF_ALARM (정의되지 않은 값)
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: INVALID 알람 설정 - 치명적 오류\n",
                      driverName, functionName);
            break;
            
        default:
            // 알 수 없는 알람 상태
            alarmSeverity = 2;  // MAJOR_ALARM
            alarmStatus = 17;   // UDF_ALARM
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: 알 수 없는 알람 상태: %d\n",
                      driverName, functionName, alarmStatus_);
            break;
    }
    
    // 주요 매개변수들에 알람 상태 설정
    // 현재 값 매개변수에 알람 설정
    setParamAlarmStatus(P_CurrentValue, alarmStatus);
    setParamAlarmSeverity(P_CurrentValue, alarmSeverity);
    
    // 출력 상태 매개변수에 알람 설정
    setParamAlarmStatus(P_OutputState, alarmStatus);
    setParamAlarmSeverity(P_OutputState, alarmSeverity);
    
    // 알람 상태 매개변수 자체 업데이트
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    setParamAlarmStatus(P_AlarmStatus, alarmStatus);
    setParamAlarmSeverity(P_AlarmStatus, alarmSeverity);
    
    // 디버그 정보 출력
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: 알람 상태 업데이트 완료 - 상태: %d, 심각도: %d, EPICS상태: %d\n",
              driverName, functionName, alarmStatus_, alarmSeverity, alarmStatus);
}

/** 매개변수 유효성 검사 메서드 */
bool ThresholdLogicController::validateParameters()
{
    const char* functionName = "validateParameters";
    bool isValid = true;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: 매개변수 유효성 검사 시작\n",
              driverName, functionName);
    
    // 1. 임계값 유효성 검사
    if (thresholdValue_ < -10.0 || thresholdValue_ > 10.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 임계값이 유효 범위를 벗어남: %f (범위: -10.0 ~ +10.0 V)\n",
                  driverName, functionName, thresholdValue_);
        isValid = false;
    }
    
    // 2. 히스테리시스 유효성 검사
    if (hysteresis_ < 0.0 || hysteresis_ > 5.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 히스테리시스가 유효 범위를 벗어남: %f (범위: 0.0 ~ 5.0 V)\n",
                  driverName, functionName, hysteresis_);
        isValid = false;
    }
    
    // 3. 임계값과 히스테리시스 관계 검사
    if (hysteresis_ > fabs(thresholdValue_)) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: 히스테리시스가 임계값의 절댓값보다 큼 - 히스테리시스: %f, 임계값: %f\n",
                  driverName, functionName, hysteresis_, thresholdValue_);
        // 경고이지만 동작은 가능하므로 isValid는 false로 설정하지 않음
    }
    
    // 4. 업데이트 주기 유효성 검사
    if (updateRate_ < 0.1 || updateRate_ > 1000.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 업데이트 주기가 유효 범위를 벗어남: %f (범위: 0.1 ~ 1000.0 Hz)\n",
                  driverName, functionName, updateRate_);
        isValid = false;
    }
    
    // 5. 장치 포트 이름 검사
    if (strlen(devicePortName_) == 0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 장치 포트 이름이 설정되지 않음\n",
                  driverName, functionName);
        isValid = false;
    } else if (strlen(devicePortName_) >= sizeof(devicePortName_)) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 장치 포트 이름이 너무 김: %s\n",
                  driverName, functionName, devicePortName_);
        isValid = false;
    }
    
    // 6. 장치 주소 유효성 검사
    if (deviceAddr_ < 0 || deviceAddr_ > 255) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 장치 주소가 유효 범위를 벗어남: %d (범위: 0-255)\n",
                  driverName, functionName, deviceAddr_);
        isValid = false;
    }
    
    // 7. 현재값 유효성 검사 (경고만 출력)
    if (currentValue_ < -10.0 || currentValue_ > 10.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: 현재값이 예상 범위를 벗어남: %f V (예상 범위: -10.0 ~ +10.0 V)\n",
                  driverName, functionName, currentValue_);
        // 현재값은 측정값이므로 유효성 검사 실패로 처리하지 않음
    }
    
    // 8. 알람 상태 유효성 검사
    if (alarmStatus_ < 0 || alarmStatus_ > 3) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 알람 상태가 유효 범위를 벗어남: %d (범위: 0-3)\n",
                  driverName, functionName, alarmStatus_);
        // 알람 상태를 정상으로 리셋
        alarmStatus_ = 0;
        setIntegerParam(P_AlarmStatus, alarmStatus_);
    }
    
    // 9. 논리적 일관성 검사
    if (enabled_ && !threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: 활성화 상태이지만 모니터링 스레드가 실행되지 않음\n",
                  driverName, functionName);
        // 이는 일시적인 상태일 수 있으므로 오류로 처리하지 않음
    }
    
    // 10. 메모리 및 리소스 상태 검사
    if (enabled_ && monitorThread_ == NULL) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 활성화 상태이지만 모니터링 스레드 객체가 NULL임\n",
                  driverName, functionName);
        isValid = false;
    }
    
    // 검사 결과 로깅
    if (isValid) {
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: 모든 매개변수가 유효함\n",
                  driverName, functionName);
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: 현재 설정 - 임계값: %f V, 히스테리시스: %f V, 주기: %f Hz\n",
                  driverName, functionName, thresholdValue_, hysteresis_, updateRate_);
    } else {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: 매개변수 유효성 검사 실패 - 설정을 확인하세요\n",
                  driverName, functionName);
    }
    
    return isValid;
}



/* IOC 쉘 명령어 구현 */

/** ThresholdLogicConfig IOC 쉘 명령어 구현
 * 
 * 새로운 ThresholdLogicController 인스턴스를 생성하고 구성합니다.
 * 
 * 매개변수:
 *   portName   - 생성할 asyn 포트의 이름 (문자열)
 *   devicePort - 연결할 장치 포트의 이름 (문자열)  
 *   deviceAddr - 장치 주소 (정수, 0-255 범위)
 * 
 * 반환값:
 *   0  - 성공
 *   -1 - 실패
 * 
 * 사용 예:
 *   ThresholdLogicConfig("THRESHOLD1", "USB1608G_2AO_cpp_PORT", 0)
 */
extern "C" int ThresholdLogicConfig(const char* portName, const char* devicePort, int deviceAddr)
{
    const char* functionName = "ThresholdLogicConfig";
    
    // 입력 매개변수 유효성 검사
    if (portName == NULL || strlen(portName) == 0) {
        printf("%s 오류: 포트 이름이 NULL이거나 비어있습니다\n", functionName);
        return -1;
    }
    
    if (devicePort == NULL || strlen(devicePort) == 0) {
        printf("%s 오류: 장치 포트 이름이 NULL이거나 비어있습니다\n", functionName);
        return -1;
    }
    
    if (deviceAddr < 0 || deviceAddr > 255) {
        printf("%s 오류: 장치 주소가 유효 범위(0-255)를 벗어났습니다: %d\n", 
               functionName, deviceAddr);
        return -1;
    }
    
    // 포트 이름 중복 검사
    if (findAsynPortDriver(portName) != NULL) {
        printf("%s 오류: 포트 이름 '%s'이 이미 사용 중입니다\n", 
               functionName, portName);
        return -1;
    }
    
    try {
        // ThresholdLogicController 인스턴스 생성
        ThresholdLogicController* pController = new ThresholdLogicController(portName, devicePort, deviceAddr);
        
        if (pController == NULL) {
            printf("%s 오류: ThresholdLogicController 생성 실패\n", functionName);
            return -1;
        }
        
        printf("%s: 성공적으로 생성됨 - 포트: %s, 장치포트: %s, 주소: %d\n",
               functionName, portName, devicePort, deviceAddr);
        
        return 0;
        
    } catch (std::bad_alloc& e) {
        printf("%s 오류: 메모리 할당 실패 - %s\n", functionName, e.what());
        return -1;
    } catch (std::exception& e) {
        printf("%s 오류: 예외 발생 - %s\n", functionName, e.what());
        return -1;
    } catch (...) {
        printf("%s 오류: 알 수 없는 예외 발생\n", functionName);
        return -1;
    }
}

/** ThresholdLogicHelp IOC 쉘 명령어 구현 - 사용법 도움말 표시 */
extern "C" void ThresholdLogicHelp(void)
{
    printf("\n=== ThresholdLogicController 사용 가이드 ===\n\n");
    
    printf("1. ThresholdLogicConfig - 임계값 로직 컨트롤러 생성\n");
    printf("   사용법: ThresholdLogicConfig(portName, devicePort, deviceAddr)\n");
    printf("   매개변수:\n");
    printf("     portName   : 생성할 asyn 포트 이름 (문자열)\n");
    printf("     devicePort : 연결할 장치 포트 이름 (문자열)\n");
    printf("     deviceAddr : 장치 주소 (정수, 0-255)\n");
    printf("   예제:\n");
    printf("     ThresholdLogicConfig(\"THRESHOLD1\", \"USB1608G_2AO_cpp_PORT\", 0)\n\n");
    
    printf("2. 주요 기능:\n");
    printf("   - 아날로그 입력 값 실시간 모니터링\n");
    printf("   - 설정 가능한 임계값과 히스테리시스\n");
    printf("   - 디지털 출력 자동 제어\n");
    printf("   - EPICS 레코드를 통한 원격 제어\n");
    printf("   - 알람 및 상태 모니터링\n\n");
    
    printf("3. 데이터베이스 레코드 접근:\n");
    printf("   $(P)$(R)Threshold     - 임계값 설정 (V)\n");
    printf("   $(P)$(R)CurrentValue  - 현재 측정값 (V)\n");
    printf("   $(P)$(R)OutputState   - 출력 상태 (0/1)\n");
    printf("   $(P)$(R)Enable        - 활성화 제어 (0/1)\n");
    printf("   $(P)$(R)Hysteresis    - 히스테리시스 값 (V)\n");
    printf("   $(P)$(R)UpdateRate    - 업데이트 주기 (Hz)\n");
    printf("   $(P)$(R)AlarmStatus   - 알람 상태\n\n");
    
    printf("4. 일반적인 사용 순서:\n");
    printf("   a) ThresholdLogicConfig로 컨트롤러 생성\n");
    printf("   b) 데이터베이스 템플릿 로드\n");
    printf("   c) 임계값 및 히스테리시스 설정\n");
    printf("   d) Enable 레코드로 모니터링 시작\n\n");
    
    printf("5. 문제 해결:\n");
    printf("   - 포트 이름 중복: 다른 포트 이름 사용\n");
    printf("   - 장치 연결 실패: 장치 포트 및 주소 확인\n");
    printf("   - 알람 발생: AlarmStatus 레코드 확인\n");
    printf("   - 성능 문제: UpdateRate 조정\n\n");
    
    printf("자세한 정보는 ThresholdLogicController 문서를 참조하세요.\n");
    printf("===============================================\n\n");
}

/* IOC 쉘 명령어 등록 구조체 정의 */

// ThresholdLogicConfig 명령어 인수 정의
static const iocshArg thresholdConfigArg0 = {
    "portName", 
    iocshArgString
};
static const iocshArg thresholdConfigArg1 = {
    "devicePort", 
    iocshArgString
};
static const iocshArg thresholdConfigArg2 = {
    "deviceAddr", 
    iocshArgInt
};

static const iocshArg *thresholdConfigArgs[] = {
    &thresholdConfigArg0,
    &thresholdConfigArg1,
    &thresholdConfigArg2
};

// ThresholdLogicConfig 명령어 정의
static const iocshFuncDef thresholdConfigFuncDef = {
    "ThresholdLogicConfig",                    // 명령어 이름
    3,                                         // 인수 개수
    thresholdConfigArgs                        // 인수 배열
};

// ThresholdLogicHelp 명령어 정의 (인수 없음)
static const iocshFuncDef thresholdHelpFuncDef = {
    "ThresholdLogicHelp",                      // 명령어 이름
    0,                                         // 인수 개수
    NULL                                       // 인수 없음
};

/* IOC 쉘 명령어 콜백 함수들 */

/** ThresholdLogicConfig 명령어 콜백 함수 */
static void thresholdConfigCallFunc(const iocshArgBuf *args)
{
    // 인수 유효성 검사
    if (args == NULL) {
        printf("ThresholdLogicConfig: 인수가 NULL입니다\n");
        return;
    }
    
    // 명령어 실행 및 결과 처리
    int result = ThresholdLogicConfig(args[0].sval, args[1].sval, args[2].ival);
    
    if (result != 0) {
        printf("ThresholdLogicConfig: 명령어 실행 실패 (반환값: %d)\n", result);
        printf("도움말을 보려면 'ThresholdLogicHelp'를 입력하세요.\n");
    }
}

/** ThresholdLogicHelp 명령어 콜백 함수 */
static void thresholdHelpCallFunc(const iocshArgBuf *args)
{
    // 인수는 사용하지 않음 (도움말 명령어)
    (void)args; // 컴파일러 경고 방지
    
    ThresholdLogicHelp();
}

/** IOC 쉘 명령어 등록 함수 
 * 
 * 이 함수는 EPICS IOC 시작 시 자동으로 호출되어
 * ThresholdLogicController 관련 명령어들을 IOC 쉘에 등록합니다.
 */
extern "C" void ThresholdLogicRegister(void)
{
    const char* functionName = "ThresholdLogicRegister";
    
    // ThresholdLogicConfig 명령어 등록
    iocshRegister(&thresholdConfigFuncDef, thresholdConfigCallFunc);
    
    // ThresholdLogicHelp 명령어 등록
    iocshRegister(&thresholdHelpFuncDef, thresholdHelpCallFunc);
    
    printf("%s: IOC 쉘 명령어 등록 완료\n", functionName);
    printf("  - ThresholdLogicConfig: 임계값 로직 컨트롤러 생성\n");
    printf("  - ThresholdLogicHelp: 사용법 도움말 표시\n");
    printf("도움말을 보려면 'ThresholdLogicHelp'를 입력하세요.\n");
}

/** 구성 유효성 검사 (ErrorHandler 사용) */
bool ThresholdLogicController::validateConfigurationWithErrorHandler()
{
    const char* functionName = "validateConfigurationWithErrorHandler";
    
    // ErrorHandler::ThresholdConfig 구조체 생성
    ErrorHandler::ThresholdConfig config;
    strncpy(config.portName, portName, sizeof(config.portName) - 1);
    config.portName[sizeof(config.portName) - 1] = '\0';
    
    strncpy(config.devicePort, devicePortName_, sizeof(config.devicePort) - 1);
    config.devicePort[sizeof(config.devicePort) - 1] = '\0';
    
    config.deviceAddr = deviceAddr_;
    config.updateRate = updateRate_;
    config.priority = 50; // 기본 우선순위
    config.thresholdValue = thresholdValue_;
    config.hysteresis = hysteresis_;
    
    // ErrorHandler를 사용한 유효성 검사
    ErrorHandler::ValidationResult result = ErrorHandler::validateConfiguration(config);
    
    if (!result.isValid) {
        ErrorHandler::logError(result.errorLevel, functionName, result.errorMessage, pasynUserSelf);
        if (strlen(result.suggestion) > 0) {
            ErrorHandler::logError(ErrorHandler::INFO, functionName, 
                                  result.suggestion, pasynUserSelf);
        }
        return false;
    }
    
    if (result.errorLevel == ErrorHandler::WARNING) {
        ErrorHandler::logError(ErrorHandler::WARNING, functionName, 
                              result.errorMessage, pasynUserSelf);
        if (strlen(result.suggestion) > 0) {
            ErrorHandler::logError(ErrorHandler::INFO, functionName, 
                                  result.suggestion, pasynUserSelf);
        }
    }
    
    return true;
}

/** 오류 로깅 (ErrorHandler 사용) */
void ThresholdLogicController::logError(const char* functionName, const char* message)
{
    if (functionName == NULL || message == NULL) {
        ErrorHandler::logError(ErrorHandler::ERROR, "ThresholdLogicController::logError", 
                              "NULL 포인터가 전달됨");
        return;
    }
    
    // 전체 함수 이름 구성
    char fullFunctionName[128];
    snprintf(fullFunctionName, sizeof(fullFunctionName), 
            "ThresholdLogicController::%s", functionName);
    
    // ErrorHandler를 통한 로깅
    ErrorHandler::logError(ErrorHandler::ERROR, fullFunctionName, message, pasynUserSelf);
}
/* EPICS 등록자 내보내기 */
epicsExportRegistrar(ThresholdLogicRegister);











🔥 File: ./USB1608G_2AO_V2App/src/ThresholdLogicController.h
=================================================
#ifndef ThresholdLogicControllerInclude
#define ThresholdLogicControllerInclude

#include <asynPortDriver.h>
#include <epicsThread.h>
#include <epicsTime.h>
#include <shareLib.h>
#include "ErrorHandler.h"

/** 임계값 기반 로직 제어를 위한 asynPortDriver 클래스
 * 
 * 이 클래스는 아날로그 입력 값을 모니터링하고 설정된 임계값과 비교하여
 * 디지털 출력을 제어하는 기능을 제공합니다.
 * 히스테리시스 기능을 포함하여 안정적인 출력 제어를 보장합니다.
 */
class epicsShareClass ThresholdLogicController : public asynPortDriver, public epicsThreadRunable {
public:
    /** 생성자
     * \param[in] portName 이 드라이버의 asyn 포트 이름
     * \param[in] devicePort 연결할 장치 포트 이름
     * \param[in] deviceAddr 장치 주소
     */
    ThresholdLogicController(const char* portName, const char* devicePort, int deviceAddr);
    
    /** 소멸자 */
    virtual ~ThresholdLogicController();
    
    // asynPortDriver에서 상속받은 메서드들
    virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
    virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
    virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
    
    /** 임계값 로직 처리 메서드 */
    void processThresholdLogic();
    
    /** 모니터링 시작 */
    void startMonitoring();
    
    /** 모니터링 중지 */
    void stopMonitoring();
    
    /** 정적 스레드 함수 (epicsThread에서 호출) */
    static void monitorThreadFunc(void* param);
    
    /** epicsThreadRunable 인터페이스 구현 */
    virtual void run();
    
    // 테스트용 public 접근자 메서드들
    /** 테스트용: 매개변수 인덱스 접근자 */
    int getThresholdValueParam() const { return P_ThresholdValue; }
    int getCurrentValueParam() const { return P_CurrentValue; }
    int getOutputStateParam() const { return P_OutputState; }
    int getEnableParam() const { return P_Enable; }
    int getHysteresisParam() const { return P_Hysteresis; }
    int getUpdateRateParam() const { return P_UpdateRate; }
    int getAlarmStatusParam() const { return P_AlarmStatus; }

protected:
    // 매개변수 인덱스들
    int P_ThresholdValue;      ///< 임계값 설정 매개변수
    int P_CurrentValue;        ///< 현재 측정값 매개변수
    int P_OutputState;         ///< 출력 상태 매개변수
    int P_Enable;              ///< 활성화 상태 매개변수
    int P_Hysteresis;          ///< 히스테리시스 값 매개변수
    int P_UpdateRate;          ///< 업데이트 주기 매개변수
    int P_AlarmStatus;         ///< 알람 상태 매개변수
    int P_DevicePort;          ///< 장치 포트 이름 매개변수
    int P_DeviceAddr;          ///< 장치 주소 매개변수

private:
    // 스레드 관리
    epicsThread *monitorThread_;    ///< 모니터링 스레드 포인터
    bool threadRunning_;            ///< 스레드 실행 상태
    bool threadExit_;               ///< 스레드 종료 플래그
    
    // 임계값 로직 상태 변수들
    double thresholdValue_;         ///< 현재 임계값
    double currentValue_;           ///< 현재 측정값
    bool outputState_;              ///< 현재 출력 상태
    bool enabled_;                  ///< 활성화 상태
    double hysteresis_;             ///< 히스테리시스 값
    double updateRate_;             ///< 업데이트 주기 (Hz)
    int alarmStatus_;               ///< 알람 상태
    
    // 장치 연결 정보
    char devicePortName_[64];       ///< 연결할 장치 포트 이름
    int deviceAddr_;                ///< 장치 주소
    
    // 상태 추적
    epicsTimeStamp lastUpdate_;     ///< 마지막 업데이트 시간
    bool lastOutputState_;          ///< 이전 출력 상태 (상태 변화 감지용)
    
    // 내부 메서드들
    /** 장치에서 현재 값을 읽어옴 */
    asynStatus readCurrentValueFromDevice();
    
    /** 장치에 출력 상태를 설정 */
    asynStatus writeOutputStateToDevice(bool state);
    
    /** 알람 상태 업데이트 */
    void updateAlarmStatus();
    
    /** 매개변수 유효성 검사 */
    bool validateParameters();
    
    /** 오류 로깅 (ErrorHandler 사용) */
    void logError(const char* functionName, const char* message);
    
    /** 구성 유효성 검사 (ErrorHandler 사용) */
    bool validateConfigurationWithErrorHandler();
};

// IOC 쉘 명령어 등록 함수
extern "C" {
    epicsShareFunc int ThresholdLogicConfig(const char* portName, const char* devicePort, int deviceAddr);
    epicsShareFunc void ThresholdLogicHelp(void);
    epicsShareFunc void ThresholdLogicRegister(void);
}

// 매개변수 문자열 정의
#define THRESHOLD_VALUE_STRING      "THRESHOLD_VALUE"
#define CURRENT_VALUE_STRING        "CURRENT_VALUE"
#define OUTPUT_STATE_STRING         "OUTPUT_STATE"
#define ENABLE_STRING               "ENABLE"
#define HYSTERESIS_STRING           "HYSTERESIS"
#define UPDATE_RATE_STRING          "UPDATE_RATE"
#define ALARM_STATUS_STRING         "ALARM_STATUS"
#define DEVICE_PORT_STRING          "DEVICE_PORT"
#define DEVICE_ADDR_STRING          "DEVICE_ADDR"

#endif /* ThresholdLogicControllerInclude */










🔥 File: ./USB1608G_2AO_V2App/src/USB1608G_2AO_V2Main.cpp
=================================================
/* USB1608G_2AO_V2Main.cpp */
/* Author:  Marty Kraimer Date:    17MAR2000 */

#include <stddef.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "epicsExit.h"
#include "epicsThread.h"
#include "iocsh.h"

int main(int argc,char *argv[])
{
    if(argc>=2) {
        iocsh(argv[1]);
        epicsThreadSleep(.2);
    }
    iocsh(NULL);
    epicsExit(0);
    return(0);
}











🔥 File: ./USB1608G_2AO_V2App/src/USBCTR_SNL.st
=================================================
program USBCTR_SNL("P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ")

/*  This sequencer program works with measCompMCS.template
 *  It supports multi-element MCA operations
 *
 *  Mark Rivers
 *  June 2, 2014
 *
 * This program must be compiled with the recursive option so that multiple copies
 * can run at once */
option +r;

/* Allow the program to start, even if not all assigned channels are connected.
 * This could be useful if the SNL is running on a different ioc. */
option -c;

%%#include <stdlib.h>
%%#include <errlog.h>
%%#include <string.h>

/* Maximum number of counters supported */
#define MAX_COUNTERS 9

int i;
int n;
int numCounters;
char temp[100];

char *prefix;
char *record;
char *field;

int     ReadArray[MAX_COUNTERS];
assign  ReadArray to {};
int     ReadArrays; assign ReadArrays to "{P}DoReadAll";
monitor ReadArrays; evflag ReadArraysMon; sync ReadArrays ReadArraysMon;

int     HardwareAcquiring; assign HardwareAcquiring to "{P}HardwareAcquiring";
monitor HardwareAcquiring; evflag HardwareAcquiringMon; sync HardwareAcquiring HardwareAcquiringMon;

int     MCSAbsTimeWF; assign MCSAbsTimeWF to "{P}AbsTimeWF.PROC";

int     SNL_Connected;  assign SNL_Connected      to "{P}SNL_Connected";
int     AsynDebug;      assign AsynDebug          to "{P}Asyn.TB1";
monitor AsynDebug;

int Acquiring; assign Acquiring to "{P}Acquiring";

ss mca_control {
  state init {
    when() {
      prefix = macValueGet("P");
      record = macValueGet("R");
      field = macValueGet("FIELD");
      numCounters = atoi(macValueGet("NUM_COUNTERS"));
      if ((numCounters <= 0) || (numCounters > MAX_COUNTERS)) {
        printf ("NUM_COUNTERS is illegal.\n");
        numCounters = 0;
      }
      for (i=0; i<numCounters; i++) {
        n = i+1;
        sprintf(temp, "%s%s%d.%s", prefix, record, n, field);
        pvAssign(ReadArray[i], temp);
       }
    } state waitConnected
  }

  state waitConnected {
    when (numCounters <= 0) {
      printf (">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
    } state dead

    when (pvAssignCount () == pvConnectCount ()) {
      printf ("USBCTR: All channels connected.\n");
      SNL_Connected = 1;
      pvPut(SNL_Connected);
    } state monitor_changes
  }

  state dead {
    when (delay (3600.0)) {
    } state dead
  }

  state monitor_changes {
    when (pvAssignCount () != pvConnectCount ()) {
      printf ("USBCTR: Not all channels connected.\n");
    } state waitConnected

    when(efTestAndClear(ReadArraysMon) && (ReadArrays == 1)) {
      if (AsynDebug) printf("USBCTR.st: Read array data\n");
      for (i=0; i<numCounters; i++) {
        ReadArray[i] = 1;
        pvPut(ReadArray[i]);
      }
      MCSAbsTimeWF = 1;
      pvPut(MCSAbsTimeWF);
      ReadArrays = 0;
      pvPut(ReadArrays);
    } state monitor_changes

    when(efTestAndClear(HardwareAcquiringMon)) {
      if (AsynDebug) printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", HardwareAcquiring);
      /* If the detector is acquiring then force each record to read status */
      if (!HardwareAcquiring) {
        /* If the detector is done then force each record to read data */
        for (i=0; i<numCounters; i++) {
          ReadArray[i] = 1;
          pvPut(ReadArray[i], SYNC);
        }
        MCSAbsTimeWF = 1;
        pvPut(MCSAbsTimeWF);
        /* Clear the Acquiring busy record */
        Acquiring = 0;
        pvPut(Acquiring);
      }
    } state monitor_changes
  }
}












🔥 File: ./USB1608G_2AO_V2App/src/drvMultiFunction.cpp
=================================================
/* drvMultiFunction.cpp
 *
 * Driver for Measurement Computing multi-function DAQ board using asynPortDriver base class
 *
 * This driver supports simple analog in/out, digital in/out bit and word, timer (digital pulse generator), counter,
 *   waveform out (aribtrary waveform generator), and waveform in (digital oscilloscope)
 *
 * This driver was previously name drv1608G.cpp but was renamed because it now supports several models.
 *
 * Mark Rivers
 * November 1, 2015
*/

#include <math.h>
#include <string.h>
#include <stdlib.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsString.h>

#include <asynPortDriver.h>

#define DRIVER_VERSION "4.2"

#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

// This needs to be global because we need to protect the UL library from simultaneous access from any driver
epicsMutex ULMutex;

// This function maps the Gain values from UL on Windows to the Range values in UL for Linux.
// We can't use the macros from Windows cbw.h because they conflict with UL for Linux.
// These definitions are taken from cbw.h, but added CBW_ prefix.
#define CBW_BIP60VOLTS       20             /* -60 to 60 Volts */
#define CBW_BIP30VOLTS       23
#define CBW_BIP20VOLTS       15             /* -20 to +20 Volts */
#define CBW_BIP15VOLTS       21             /* -15 to +15 Volts */
#define CBW_BIP10VOLTS       1              /* -10 to +10 Volts */
#define CBW_BIP5VOLTS        0              /* -5 to +5 Volts */
#define CBW_BIP4VOLTS        16             /* -4 to + 4 Volts */
#define CBW_BIP2PT5VOLTS     2              /* -2.5 to +2.5 Volts */
#define CBW_BIP2VOLTS        14             /* -2.0 to +2.0 Volts */
#define CBW_BIP1PT25VOLTS    3              /* -1.25 to +1.25 Volts */
#define CBW_BIP1VOLTS        4              /* -1 to +1 Volts */
#define CBW_BIPPT625VOLTS    5              /* -.625 to +.625 Volts */
#define CBW_BIPPT5VOLTS      6              /* -.5 to +.5 Volts */
#define CBW_BIPPT25VOLTS     12             /* -0.25 to +0.25 Volts */
#define CBW_BIPPT2VOLTS      13             /* -0.2 to +0.2 Volts */
#define CBW_BIPPT1VOLTS      7              /* -.1 to +.1 Volts */
#define CBW_BIPPT05VOLTS     8              /* -.05 to +.05 Volts */
#define CBW_BIPPT01VOLTS     9              /* -.01 to +.01 Volts */
#define CBW_BIPPT005VOLTS    10             /* -.005 to +.005 Volts */
#define CBW_BIP1PT67VOLTS    11             /* -1.67 to +1.67 Volts */
#define CBW_BIPPT312VOLTS    17             /* -0.312 to +0.312 Volts */
#define CBW_BIPPT156VOLTS    18             /* -0.156 to +0.156 Volts */
#define CBW_BIPPT125VOLTS    22             /* -0.125 to +0.125 Volts */
#define CBW_BIPPT078VOLTS    19             /* -0.078 to +0.078 Volts */


#define CBW_UNI10VOLTS       100            /* 0 to 10 Volts*/
#define CBW_UNI5VOLTS        101            /* 0 to 5 Volts */
#define CBW_UNI4VOLTS        114            /* 0 to 4 Volts */
#define CBW_UNI2PT5VOLTS     102            /* 0 to 2.5 Volts */
#define CBW_UNI2VOLTS        103            /* 0 to 2 Volts */
#define CBW_UNI1PT67VOLTS    109            /* 0 to 1.67 Volts */
#define CBW_UNI1PT25VOLTS    104            /* 0 to 1.25 Volts */
#define CBW_UNI1VOLTS        105            /* 0 to 1 Volt */
#define CBW_UNIPT5VOLTS      110            /* 0 to .5 Volt */
#define CBW_UNIPT25VOLTS     111            /* 0 to 0.25 Volt */
#define CBW_UNIPT2VOLTS      112            /* 0 to .2 Volt */
#define CBW_UNIPT1VOLTS      106            /* 0 to .1 Volt */
#define CBW_UNIPT05VOLTS     113            /* 0 to .05 Volt */
#define CBW_UNIPT02VOLTS     108            /* 0 to .02 Volt*/
#define CBW_UNIPT01VOLTS     107            /* 0 to .01 Volt*/

#define CBW_MA4TO20          200            /* 4 to 20 ma */
#define CBW_MA2TO10          201            /* 2 to 10 ma */
#define CBW_MA1TO5           202            /* 1 to 5 ma */
#define CBW_MAPT5TO2PT5      203            /* .5 to 2.5 ma */
#define CBW_MA0TO20          204            /* 0 to 20 ma */
#define CBW_BIPPT025AMPS     205            /* -0.025 to 0.025 ma */

#include <epicsExport.h>
#include <measCompDiscover.h>

static const char *driverName = "MultiFunction";

typedef enum {
  waveTypeUser,
  waveTypeSin,
  waveTypeSquare,
  waveTypeSawTooth,
  waveTypePulse,
  waveTypeRandom
} waveType_t;

// Board parameters
#define modelNameString           "MODEL_NAME"
#define modelNumberString         "MODEL_NUMBER"
#define firmwareVersionString     "FIRMWARE_VERSION"
#define uniqueIDString            "UNIQUE_ID"
#define ULVersionString           "UL_VERSION"
#define driverVersionString       "DRIVER_VERSION"
#define pollSleepMSString         "POLL_SLEEP_MS"
#define pollTimeMSString          "POLL_TIME_MS"
#define lastErrorMessageString    "LAST_ERROR_MESSAGE"

// Pulse output parameters
#define pulseGenRunString         "PULSE_RUN"
#define pulseGenPeriodString      "PULSE_PERIOD"
#define pulseGenDutyCycleString   "PULSE_DUTY_CYCLE"
#define pulseGenDelayString       "PULSE_DELAY"
#define pulseGenCountString       "PULSE_COUNT"
#define pulseGenIdleStateString   "PULSE_IDLE_STATE"

// Counter parameters
#define counterCountsString       "COUNTER_VALUE"
#define counterResetString        "COUNTER_RESET"

// Analog input parameters
#define analogInValueString       "ANALOG_IN_VALUE"
#define analogInRangeString       "ANALOG_IN_RANGE"
#define analogInTypeString        "ANALOG_IN_TYPE"
#define analogInModeString        "ANALOG_IN_MODE"
#define analogInRateString        "ANALOG_IN_RATE"

// Voltage input parameters
#define voltageInValueString      "VOLTAGE_IN_VALUE"
#define voltageInRangeString      "VOLTAGE_IN_RANGE"

// Temperature parameters
#define temperatureInValueString  "TEMPERATURE_IN_VALUE"
#define thermocoupleTypeString    "THERMOCOUPLE_TYPE"
#define thermocoupleOpenDetectString "THERMOCOUPLE_OPEN_DETECT"
#define temperatureScaleString    "TEMPERATURE_SCALE"
#define temperatureFilterString   "TEMPERATURE_FILTER"
#define temperatureSensorString   "TEMPERATURE_SENSOR"
#define temperatureWiringString   "TEMPERATURE_WIRING"

// Waveform digitizer parameters - global
#define waveDigDwellString        "WAVEDIG_DWELL"
#define waveDigDwellActualString  "WAVEDIG_DWELL_ACTUAL"
#define waveDigTotalTimeString    "WAVEDIG_TOTAL_TIME"
#define waveDigFirstChanString    "WAVEDIG_FIRST_CHAN"
#define waveDigNumChansString     "WAVEDIG_NUM_CHANS"
#define waveDigNumPointsString    "WAVEDIG_NUM_POINTS"
#define waveDigCurrentPointString "WAVEDIG_CURRENT_POINT"
#define waveDigExtTriggerString   "WAVEDIG_EXT_TRIGGER"
#define waveDigExtClockString     "WAVEDIG_EXT_CLOCK"
#define waveDigContinuousString   "WAVEDIG_CONTINUOUS"
#define waveDigAutoRestartString  "WAVEDIG_AUTO_RESTART"
#define waveDigRetriggerString    "WAVEDIG_RETRIGGER"
#define waveDigTriggerCountString "WAVEDIG_TRIGGER_COUNT"
#define waveDigBurstModeString    "WAVEDIG_BURST_MODE"
#define waveDigRunString          "WAVEDIG_RUN"
#define waveDigTimeWFString       "WAVEDIG_TIME_WF"
#define waveDigAbsTimeWFString    "WAVEDIG_ABS_TIME_WF"
#define waveDigReadWFString       "WAVEDIG_READ_WF"
// Waveform digitizer parameters - per input
#define waveDigVoltWFString       "WAVEDIG_VOLT_WF"

// Analog output parameters
#define analogOutValueString      "ANALOG_OUT_VALUE"
#define analogOutRangeString      "ANALOG_OUT_RANGE"

// Waveform generator parameters - global
#define waveGenFreqString         "WAVEGEN_FREQ"
#define waveGenDwellString        "WAVEGEN_DWELL"
#define waveGenDwellActualString  "WAVEGEN_DWELL_ACTUAL"
#define waveGenTotalTimeString    "WAVEGEN_TOTAL_TIME"
#define waveGenNumPointsString    "WAVEGEN_NUM_POINTS"
#define waveGenCurrentPointString "WAVEGEN_CURRENT_POINT"
#define waveGenIntDwellString     "WAVEGEN_INT_DWELL"
#define waveGenUserDwellString    "WAVEGEN_USER_DWELL"
#define waveGenIntNumPointsString  "WAVEGEN_INT_NUM_POINTS"
#define waveGenUserNumPointsString "WAVEGEN_USER_NUM_POINTS"
#define waveGenExtTriggerString   "WAVEGEN_EXT_TRIGGER"
#define waveGenExtClockString     "WAVEGEN_EXT_CLOCK"
#define waveGenContinuousString   "WAVEGEN_CONTINUOUS"
#define waveGenRetriggerString    "WAVEGEN_RETRIGGER"
#define waveGenTriggerCountString "WAVEGEN_TRIGGER_COUNT"
#define waveGenRunString          "WAVEGEN_RUN"
#define waveGenUserTimeWFString   "WAVEGEN_USER_TIME_WF"
#define waveGenIntTimeWFString    "WAVEGEN_INT_TIME_WF"
// Waveform generator parameters - per output
#define waveGenWaveTypeString     "WAVEGEN_WAVE_TYPE"
#define waveGenEnableString       "WAVEGEN_ENABLE"
#define waveGenAmplitudeString    "WAVEGEN_AMPLITUDE"
#define waveGenOffsetString       "WAVEGEN_OFFSET"
#define waveGenPulseWidthString   "WAVEGEN_PULSE_WIDTH"
#define waveGenIntWFString        "WAVEGEN_INT_WF"
#define waveGenUserWFString       "WAVEGEN_USER_WF"

// Trigger parameters
#define triggerModeString         "TRIGGER_MODE"

// Digital I/O parameters
#define digitalDirectionString    "DIGITAL_DIRECTION"
#define digitalInputString        "DIGITAL_INPUT"
#define digitalOutputString       "DIGITAL_OUTPUT"

// MAX_ANALOG_IN and MAX_ANALOG_OUT may need to be changed if additional models are added with larger numbers
// These are used as a convenience for allocating small arrays of pointers, not large amounts of data
#define MAX_ANALOG_IN      16
#define MAX_TEMPERATURE_IN 64
#define MAX_ANALOG_OUT     16
#define MAX_IO_PORTS        8
#define MAX_PULSE_GEN       4
#define MAX_SIGNALS        MAX_TEMPERATURE_IN

// For simplicity define a few constants on Linux to be the same as Windows cbw.h
// These need to be copied from cbw.h because uldaq.h and cbw.h cannot both be included due to some conflicting definitions
#ifdef linux
  #define AI_CHAN_TYPE_VOLTAGE  AI_VOLTAGE
  #define AI_CHAN_TYPE_TC       AI_TC
  #define TC_TYPE_J             TC_J
  #define DIFFERENTIAL          0
  #define SINGLE_ENDED          1
  /* Temperature scales */
  #define CELSIUS          0
  #define FAHRENHEIT       1
  #define KELVIN           2
  #define VOLTS            4     /* special scale for DAS-TC boards */
  #define NOSCALE          5
  /* Types of digital input ports */
  #define DIGITALOUT       1
  #define DIGITALIN        2
#endif

typedef enum {
  USB_231            = 297,
  USB_1208LS         = 122,
  USB_1208FS         = 130,
  USB_1208FS_PLUS    = 232,
  USB_1608G          = 308,
  USB_1608GX         = 309,
  USB_1608GX_2AO_OLD = 274,
  USB_1608GX_2AO     = 310,
  USB_1608HS_2AO     = 153,
  USB_1808           = 317, // Fix this when we know the correct value
  USB_1808X          = 318,
  USB_2408_2AO       = 254,
  USB_3101           = 154,
  USB_3102           = 155,
  USB_3103           = 156,
  USB_3104           = 157,
  USB_3105           = 158,
  USB_3106           = 159,
  USB_3110           = 162,
  USB_3112           = 163,
  USB_3114           = 164,
  USB_SSR08          = 134,
  USB_TEMP           = 141,
  USB_TEMP_AI        = 188,
  USB_TC32           = 305,
  ETH_TC32           = 306,
  E_1608             = 303,
  E_DIO24            = 311,
  E_TC               = 312,
  MAX_BOARD_TYPES
} boardType_t;

typedef struct {
  char *enumString;
  int  enumValue;
} enumStruct_t;

static const enumStruct_t inputRangeUSB_231[] = {
  {"+= 20V",   CBW_BIP20VOLTS},
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 4V",    CBW_BIP4VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 2V",    CBW_BIP2VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS},
  {"+= 1V",    CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_231[] = {
  {"+= 10V", CBW_UNI5VOLTS}
};

static const enumStruct_t inputTypeUSB_231[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1208[] = {
  {"+= 20V",   CBW_BIP20VOLTS},
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 4V",    CBW_BIP4VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 2V",    CBW_BIP2VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS},
  {"+= 1V",    CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_1208[] = {
  {"+= 5V", CBW_UNI5VOLTS}
};

static const enumStruct_t outputRangeUSB_1208FS[] = {
  {"+= 4V", CBW_UNI4VOLTS}
};

static const enumStruct_t inputTypeUSB_1208[] = {
    {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1608G[] = {
  {"+= 10V", CBW_BIP10VOLTS},
  {"+= 5V",  CBW_BIP5VOLTS},
  {"+= 2V",  CBW_BIP2VOLTS},
  {"+= 1V",  CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_1608G[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_1608G[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1808[] = {
  {"+= 10V",    CBW_BIP10VOLTS},
  {"+= 5V",     CBW_BIP5VOLTS},
  {"0-10V",     CBW_UNI10VOLTS},
  {"0-5V",      CBW_UNI5VOLTS}
};

static const enumStruct_t outputRangeUSB_1808[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_1808[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_2408[] = {
  {"+= 10V",    CBW_BIP10VOLTS},
  {"+= 5V",     CBW_BIP5VOLTS},
  {"+= 2.5V",   CBW_BIP2PT5VOLTS},
  {"+= 1.25V",  CBW_BIP1PT25VOLTS},
  {"+= 0.625V", CBW_BIPPT625VOLTS},
  {"+= 0.312V", CBW_BIPPT312VOLTS},
  {"+= 0.156V", CBW_BIPPT156VOLTS},
  {"+= 0.078V", CBW_BIPPT078VOLTS}
};

static const enumStruct_t outputRangeUSB_2408[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_2408[] = {
  {"Volts",   AI_CHAN_TYPE_VOLTAGE},
  {"TC deg.", AI_CHAN_TYPE_TC}
};

static const enumStruct_t inputRangeUSB_3101[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeUSB_3101[] = {
  {"0-10V",  CBW_UNI10VOLTS},
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_3101[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_SSR08[] = {
  {"N.A.",  0}
};

static const enumStruct_t outputRangeUSB_SSR08[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_SSR08[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_TEMP[] = {
  {"N.A.", 0},
};

static const enumStruct_t outputRangeUSB_TEMP[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_TEMP[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_TEMP_AI[] = {
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS}
};

static const enumStruct_t outputRangeUSB_TEMP_AI[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_TEMP_AI[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeTC32[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeTC32[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeTC32[] = {
  {"TC deg.", AI_CHAN_TYPE_TC}
};

static const enumStruct_t inputRangeE_1608[] = {
  {"+= 10V", CBW_BIP10VOLTS},
  {"+= 5V",  CBW_BIP5VOLTS},
  {"+= 2V",  CBW_BIP2VOLTS},
  {"+= 1V",  CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeE_1608[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeE_1608[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeE_TC[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeE_TC[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeE_TC[] = {
  {"TC deg.", AI_CHAN_TYPE_TC}
};

#ifdef _WIN32
  // The sensor type cannot be configured in UL for Windows so widthwe use these default enum values
  static const enumStruct_t temperatureSensorUSB_TEMP[] = {
    {"RTD",           0},
    {"Thermistor",    1},
    {"Thermocouple",  2},
    {"Semiconductor", 3},
    {"Disabled",      4}
  };
  // The wiring cannot be configured in UL for Windows so we use these default enum values
  static const enumStruct_t temperatureWiringUSB_TEMP[] = {
    {"2 wire 1 sensor",   0},
    {"2 wire 2 sensors",  1},
    {"3 wire",            2},
    {"4 wire",            3}
  };
#else
  // These enum values are for UL for Linux.  
  static const enumStruct_t temperatureSensorUSB_TEMP[] = {
    {"RTD",           AI_RTD},
    {"Thermistor",    AI_THERMISTOR},
    {"Thermocouple",  AI_TC},
    {"Semiconductor", AI_SEMICONDUCTOR},
    {"Disabled",      AI_DISABLED}
  };
  static const enumStruct_t temperatureWiringUSB_TEMP[] = {
    {"2 wire 1 sensor",   SCT_2_WIRE_1},
    {"2 wire 2 sensors",  SCT_2_WIRE_2},
    {"3 wire",            SCT_3_WIRE},
    {"4 wire",            SCT_4_WIRE}
  };
#endif

typedef struct {
  boardType_t boardFamily;
  const enumStruct_t *pInputRange;
  int numInputRange;
  const enumStruct_t *pOutputRange;
  int numOutputRange;
  const enumStruct_t *pInputType;
  int numInputType;
} boardEnums_t;

static const boardEnums_t allBoardEnums[] = {
  {USB_231,        inputRangeUSB_231,     sizeof(inputRangeUSB_231)/sizeof(enumStruct_t),
                   outputRangeUSB_231,    sizeof(outputRangeUSB_231)/sizeof(enumStruct_t),
                   inputTypeUSB_231,      sizeof(inputTypeUSB_231)/sizeof(enumStruct_t)},

  {USB_1208LS,     inputRangeUSB_1208,    sizeof(inputRangeUSB_1208)/sizeof(enumStruct_t),
                   outputRangeUSB_1208,   sizeof(outputRangeUSB_1208)/sizeof(enumStruct_t),
                   inputTypeUSB_1208,     sizeof(inputTypeUSB_1208)/sizeof(enumStruct_t)},

  {USB_1208FS,     inputRangeUSB_1208,    sizeof(inputRangeUSB_1208)/sizeof(enumStruct_t),
                   outputRangeUSB_1208FS, sizeof(outputRangeUSB_1208FS)/sizeof(enumStruct_t),
                   inputTypeUSB_1208,     sizeof(inputTypeUSB_1208)/sizeof(enumStruct_t)},

  {USB_1608G,      inputRangeUSB_1608G,   sizeof(inputRangeUSB_1608G)/sizeof(enumStruct_t),
                   outputRangeUSB_1608G,  sizeof(outputRangeUSB_1608G)/sizeof(enumStruct_t),
                   inputTypeUSB_1608G,    sizeof(inputTypeUSB_1608G)/sizeof(enumStruct_t)},

  {USB_1808,       inputRangeUSB_1808,    sizeof(inputRangeUSB_1808)/sizeof(enumStruct_t),
                   outputRangeUSB_1808,   sizeof(outputRangeUSB_1808)/sizeof(enumStruct_t),
                   inputTypeUSB_1808,     sizeof(inputTypeUSB_1808)/sizeof(enumStruct_t)},

  {USB_3101,       inputRangeUSB_3101,    sizeof(inputRangeUSB_3101)/sizeof(enumStruct_t),
                   outputRangeUSB_3101,   sizeof(outputRangeUSB_3101)/sizeof(enumStruct_t),
                   inputTypeUSB_3101,     sizeof(inputTypeUSB_3101)/sizeof(enumStruct_t)},

  {USB_2408_2AO,   inputRangeUSB_2408,    sizeof(inputRangeUSB_2408)/sizeof(enumStruct_t),
                   outputRangeUSB_2408,   sizeof(outputRangeUSB_2408)/sizeof(enumStruct_t),
                   inputTypeUSB_2408,     sizeof(inputTypeUSB_2408)/sizeof(enumStruct_t)},

  {USB_SSR08,      inputRangeUSB_SSR08,   sizeof(inputRangeUSB_SSR08)/sizeof(enumStruct_t),
                   outputRangeUSB_SSR08,  sizeof(outputRangeUSB_SSR08)/sizeof(enumStruct_t),
                   inputTypeUSB_SSR08,    sizeof(inputTypeUSB_SSR08)/sizeof(enumStruct_t)},

  {USB_TEMP,       inputRangeUSB_TEMP,    sizeof(inputRangeUSB_TEMP)/sizeof(enumStruct_t),
                   outputRangeUSB_TEMP,   sizeof(outputRangeUSB_TEMP)/sizeof(enumStruct_t),
                   inputTypeUSB_TEMP,     sizeof(inputTypeUSB_TEMP)/sizeof(enumStruct_t)},

  {USB_TEMP_AI,    inputRangeUSB_TEMP_AI, sizeof(inputRangeUSB_TEMP_AI)/sizeof(enumStruct_t),
                   outputRangeUSB_TEMP_AI,sizeof(outputRangeUSB_TEMP_AI)/sizeof(enumStruct_t),
                   inputTypeUSB_TEMP_AI,  sizeof(inputTypeUSB_TEMP_AI)/sizeof(enumStruct_t)},

  {USB_TC32,       inputRangeTC32,        sizeof(inputRangeTC32)/sizeof(enumStruct_t),
                   outputRangeTC32,       sizeof(outputRangeTC32)/sizeof(enumStruct_t),
                   inputTypeTC32,         sizeof(inputTypeTC32)/sizeof(enumStruct_t)},

  {E_1608,         inputRangeE_1608,      sizeof(inputRangeE_1608)/sizeof(enumStruct_t),
                   outputRangeE_1608,     sizeof(outputRangeE_1608)/sizeof(enumStruct_t),
                   inputTypeE_1608,       sizeof(inputTypeE_1608)/sizeof(enumStruct_t)},

  {E_DIO24,        inputRangeE_DIO24,     sizeof(inputRangeE_DIO24)/sizeof(enumStruct_t),
                   outputRangeE_DIO24,    sizeof(outputRangeE_DIO24)/sizeof(enumStruct_t),
                   inputTypeE_DIO24,      sizeof(inputTypeE_DIO24)/sizeof(enumStruct_t)},

  {E_TC,           inputRangeE_TC,        sizeof(inputRangeE_TC)/sizeof(enumStruct_t),
                   outputRangeE_TC,       sizeof(outputRangeE_TC)/sizeof(enumStruct_t),
                   inputTypeE_TC,         sizeof(inputTypeE_TC)/sizeof(enumStruct_t)},
};

static int maxBoardFamilies = (int) (sizeof(allBoardEnums) / sizeof(boardEnums_t));
#define ROUND(x) ((x) >= 0. ? (int)x+0.5 : (int)(x-0.5))
#define MAX_BOARDNAME_LEN 256
#define MAX_LIBRARY_MESSAGE_LEN 256
#define PI 3.14159265

/** This is the class definition for the MultiFunction class
  */
class MultiFunction : public asynPortDriver {
public:
  MultiFunction(const char *portName, const char *uniqueID, int maxInputPoints, int maxOutputPoints);

  /* These are the methods that we override from asynPortDriver */
  virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
  virtual asynStatus getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high);
  virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
  virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
  virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);
  virtual asynStatus readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus writeFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements);
  virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readEnum(asynUser *pasynUser, char *strings[], int values[], int severities[], size_t nElements, size_t *nIn);
  virtual void report(FILE *fp, int details);
  // These should be private but are called from C
  virtual void pollerThread(void);

protected:
  // Model parameters
  int modelName_;
  int modelNumber_;
  int firmwareVersion_;
  int uniqueID_;
  int ULVersion_;
  int driverVersion_;
  int pollSleepMS_;
  int pollTimeMS_;
  int lastErrorMessage_;

  // Pulse generator parameters
  int pulseGenRun_;
  int pulseGenPeriod_;
  int pulseGenDutyCycle_;
  int pulseGenDelay_;
  int pulseGenCount_;
  int pulseGenIdleState_;

  // Counter parameters
  int counterCounts_;
  int counterReset_;

  // Analog input parameters
  int analogInValue_;
  int analogInRange_;
  int analogInType_;
  int analogInMode_;
  int analogInRate_;

  // Voltage input parameters
  int voltageInValue_;
  int voltageInRange_;

  // Temperature parameters
  int temperatureInValue_;
  int thermocoupleType_;
  int thermocoupleOpenDetect_;
  int temperatureScale_;
  int temperatureFilter_;
  int temperatureSensor_;
  int temperatureWiring_;

  // Waveform digitizer parameters - global
  int waveDigDwell_;
  int waveDigDwellActual_;
  int waveDigTotalTime_;
  int waveDigFirstChan_;
  int waveDigNumChans_;
  int waveDigNumPoints_;
  int waveDigCurrentPoint_;
  int waveDigExtTrigger_;
  int waveDigExtClock_;
  int waveDigContinuous_;
  int waveDigAutoRestart_;
  int waveDigRetrigger_;
  int waveDigTriggerCount_;
  int waveDigBurstMode_;
  int waveDigRun_;
  int waveDigTimeWF_;
  int waveDigAbsTimeWF_;
  int waveDigReadWF_;
  // Waveform digitizer parameters - per input
  int waveDigVoltWF_;

  // Analog output parameters
  int analogOutValue_;
  int analogOutRange_;

  // Waveform generator parameters - global
  int waveGenFreq_;
  int waveGenDwell_;
  int waveGenDwellActual_;
  int waveGenTotalTime_;
  int waveGenNumPoints_;
  int waveGenCurrentPoint_;
  int waveGenIntDwell_;
  int waveGenUserDwell_;
  int waveGenIntNumPoints_;
  int waveGenUserNumPoints_;
  int waveGenExtTrigger_;
  int waveGenExtClock_;
  int waveGenContinuous_;
  int waveGenRetrigger_;
  int waveGenTriggerCount_;
  int waveGenRun_;
  int waveGenUserTimeWF_;
  int waveGenIntTimeWF_;
  // Waveform generator parameters - per output
  int waveGenWaveType_;
  int waveGenEnable_;
  int waveGenAmplitude_;
  int waveGenOffset_;
  int waveGenPulseWidth_;
  int waveGenIntWF_;
  int waveGenUserWF_;

  // Trigger parameters
  int triggerMode_;

  // Digital I/O parameters
  int digitalDirection_;
  int digitalInput_;
  int digitalOutput_;

private:
  #ifdef _WIN32
    int boardNum_;
  #else
    DaqDeviceHandle daqDeviceHandle_;
  #endif
  DaqDeviceDescriptor daqDeviceDescriptor_;
  char boardName_[MAX_BOARDNAME_LEN];
  int boardType_;
  int boardFamily_;
  const boardEnums_t *pBoardEnums_;
  int numAnalogIn_;
  int analogInTypeConfigurable_;
  int analogInDataRateConfigurable_;
  int analogOutRangeConfigurable_;
  int numAnalogOut_;
  #ifdef linux
    AiInputMode aiInputMode_;
    TriggerType triggerType_;
    int aiScanTrigCount_;  // Not currently used
    int aoScanTrigCount_;  // Not currently used
  #endif
  int ADCResolution_;
  int DACResolution_;
  int numCounters_;
  int firstCounter_;
  int numTimers_;
  int numIOPorts_;
  int numTempChans_;
  int digitalIOPort_[MAX_IO_PORTS];
  int digitalIOBitConfigurable_[MAX_IO_PORTS];
  int digitalIOPortConfigurable_[MAX_IO_PORTS];
  int digitalIOPortWriteOnly_[MAX_IO_PORTS];
  int digitalIOPortReadOnly_[MAX_IO_PORTS];
  int numIOBits_[MAX_IO_PORTS];
  epicsUInt32 digitalIOMask_[MAX_IO_PORTS];
  double minPulseGenFrequency_;
  double maxPulseGenFrequency_;
  double minPulseGenDelay_;
  double maxPulseGenDelay_;
  double pollTime_;
  int forceCallback_[MAX_IO_PORTS];
  size_t maxInputPoints_;
  size_t maxOutputPoints_;
  epicsFloat64 *waveDigBuffer_[MAX_ANALOG_IN];
  epicsFloat32 *waveDigTimeBuffer_;
  epicsFloat64 *waveDigAbsTimeBuffer_;
  epicsFloat32 *waveGenIntBuffer_[MAX_ANALOG_OUT];
  epicsFloat32 *waveGenUserBuffer_[MAX_ANALOG_OUT];
  epicsFloat32 *waveGenUserTimeBuffer_;
  epicsFloat32 *waveGenIntTimeBuffer_;
  epicsFloat64 *pInBuffer_;
  #ifdef _WIN32
    epicsUInt16  *waveGenOutBuffer_;
  #else
    epicsFloat64 *waveGenOutBuffer_;
  #endif
  int numWaveGenChans_;
  int numWaveDigChans_;
  int pulseGenRunning_[MAX_PULSE_GEN];
  int waveGenRunning_;
  int waveDigRunning_;
  int startPulseGenerator(int timerNum);
  int stopPulseGenerator(int timerNum);
  int startWaveGen();
  int stopWaveGen();
  int computeWaveGenTimes();
  int startWaveDig();
  int stopWaveDig();
  int readWaveDig();
  int computeWaveDigTimes();
  int defineWaveform(int channel);
  int setOpenThermocoupleDetect(int addr, int value);
  int reportError(int err, const char *functionName, const char *message);
  #ifdef linux
  int mapRange(int Gain, Range *range);
  int mapTriggerType(int cbwTriggerType, TriggerType *triggerType);
  #endif
};

static void pollerThreadC(void * pPvt)
{
    MultiFunction *pMultiFunction = (MultiFunction *)pPvt;
    pMultiFunction->pollerThread();
}

MultiFunction::MultiFunction(const char *portName, const char *uniqueID, int maxInputPoints, int maxOutputPoints)
  : asynPortDriver(portName, MAX_SIGNALS,
      asynUInt32DigitalMask | asynInt32Mask   | asynInt32ArrayMask   | asynFloat32ArrayMask | 
                              asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask        | asynEnumMask | asynDrvUserMask,
      asynUInt32DigitalMask | asynInt32Mask   | asynInt32ArrayMask   | asynFloat32ArrayMask | 
                              asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask        | asynEnumMask,
      ASYN_MULTIDEVICE | ASYN_CANBLOCK, 1, /* ASYN_CANBLOCK=1, ASYN_MULTIDEVICE=1, autoConnect=1 */
      0, 0),  /* Default priority and stack size */
    maxInputPoints_(maxInputPoints),
    maxOutputPoints_(maxOutputPoints),
    numWaveGenChans_(1),
    numWaveDigChans_(1),
    waveGenRunning_(0),
    waveDigRunning_(0)
{
  int i, j;
  int status;
  long long handle;
  static const char *functionName = "MultiFunction";

  for (i=0; i<MAX_PULSE_GEN; i++) pulseGenRunning_[i]=0;
  for (i=0; i<MAX_IO_PORTS; i++) forceCallback_[i] = 1;

  status = measCompCreateDevice(uniqueID, daqDeviceDescriptor_, &handle);
  if (status) {
    printf("Error creating device with measCompCreateDevice\n");
    return;
  }
  #ifdef _WIN32
    boardNum_ = (int) handle;
    strcpy(boardName_, daqDeviceDescriptor_.ProductName);
    boardType_ = daqDeviceDescriptor_.ProductID;
  #else
    daqDeviceHandle_ = handle;
    strcpy(boardName_, daqDeviceDescriptor_.productName);
    boardType_ = daqDeviceDescriptor_.productId;
  #endif

  // Model parameters
  createParam(modelNameString,                 asynParamOctet,  &modelName_);
  createParam(modelNumberString,               asynParamInt32,  &modelNumber_);
  createParam(firmwareVersionString,            asynParamOctet, &firmwareVersion_);
  createParam(uniqueIDString,                   asynParamOctet, &uniqueID_);
  createParam(ULVersionString,                  asynParamOctet, &ULVersion_);
  createParam(driverVersionString,              asynParamOctet, &driverVersion_);
  createParam(pollSleepMSString,              asynParamFloat64, &pollSleepMS_);
  createParam(pollTimeMSString,               asynParamFloat64, &pollTimeMS_);
  createParam(lastErrorMessageString,           asynParamOctet, &lastErrorMessage_);

  // Pulse generator parameters
  createParam(pulseGenRunString,               asynParamInt32, &pulseGenRun_);
  createParam(pulseGenPeriodString,          asynParamFloat64, &pulseGenPeriod_);
  createParam(pulseGenDutyCycleString,       asynParamFloat64, &pulseGenDutyCycle_);
  createParam(pulseGenDelayString,           asynParamFloat64, &pulseGenDelay_);
  createParam(pulseGenCountString,             asynParamInt32, &pulseGenCount_);
  createParam(pulseGenIdleStateString,         asynParamInt32, &pulseGenIdleState_);

  // Counter parameters
  createParam(counterCountsString,             asynParamInt32, &counterCounts_);
  createParam(counterResetString,              asynParamInt32, &counterReset_);

  // Analog input parameters
  createParam(analogInValueString,             asynParamInt32, &analogInValue_);
  createParam(analogInRangeString,             asynParamInt32, &analogInRange_);
  createParam(analogInTypeString,              asynParamInt32, &analogInType_);
  createParam(analogInModeString,              asynParamInt32, &analogInMode_);
  createParam(analogInRateString,              asynParamInt32, &analogInRate_);

  // Voltage input parameters
  createParam(voltageInValueString,          asynParamFloat64, &voltageInValue_);
  createParam(voltageInRangeString,            asynParamInt32, &voltageInRange_);

  // Temperature parameters
  createParam(temperatureInValueString,      asynParamFloat64, &temperatureInValue_);
  createParam(thermocoupleTypeString,          asynParamInt32, &thermocoupleType_);
  createParam(thermocoupleOpenDetectString,    asynParamInt32, &thermocoupleOpenDetect_);
  createParam(temperatureScaleString,          asynParamInt32, &temperatureScale_);
  createParam(temperatureFilterString,         asynParamInt32, &temperatureFilter_);
  createParam(temperatureSensorString,         asynParamInt32, &temperatureSensor_);
  createParam(temperatureWiringString,         asynParamInt32, &temperatureWiring_);

  // Waveform digitizer parameters - global
  createParam(waveDigDwellString,            asynParamFloat64, &waveDigDwell_);
  createParam(waveDigDwellActualString,      asynParamFloat64, &waveDigDwellActual_);
  createParam(waveDigTotalTimeString,        asynParamFloat64, &waveDigTotalTime_);
  createParam(waveDigFirstChanString,          asynParamInt32, &waveDigFirstChan_);
  createParam(waveDigNumChansString,           asynParamInt32, &waveDigNumChans_);
  createParam(waveDigNumPointsString,          asynParamInt32, &waveDigNumPoints_);
  createParam(waveDigCurrentPointString,       asynParamInt32, &waveDigCurrentPoint_);
  createParam(waveDigExtTriggerString,         asynParamInt32, &waveDigExtTrigger_);
  createParam(waveDigExtClockString,           asynParamInt32, &waveDigExtClock_);
  createParam(waveDigContinuousString,         asynParamInt32, &waveDigContinuous_);
  createParam(waveDigAutoRestartString,        asynParamInt32, &waveDigAutoRestart_);
  createParam(waveDigRetriggerString,          asynParamInt32, &waveDigRetrigger_);
  createParam(waveDigTriggerCountString,       asynParamInt32, &waveDigTriggerCount_);
  createParam(waveDigBurstModeString,          asynParamInt32, &waveDigBurstMode_);
  createParam(waveDigRunString,                asynParamInt32, &waveDigRun_);
  createParam(waveDigTimeWFString,      asynParamFloat32Array, &waveDigTimeWF_);
  createParam(waveDigAbsTimeWFString,   asynParamFloat64Array, &waveDigAbsTimeWF_);
  createParam(waveDigReadWFString,             asynParamInt32, &waveDigReadWF_);
  // Waveform digitizer parameters - per input
  createParam(waveDigVoltWFString,      asynParamFloat32Array, &waveDigVoltWF_);

  // Analog output parameters
  createParam(analogOutValueString,            asynParamInt32, &analogOutValue_);
  createParam(analogOutRangeString,            asynParamInt32, &analogOutRange_);

  // Waveform generator parameters - global
  createParam(waveGenFreqString,             asynParamFloat64, &waveGenFreq_);
  createParam(waveGenDwellString,            asynParamFloat64, &waveGenDwell_);
  createParam(waveGenDwellActualString,      asynParamFloat64, &waveGenDwellActual_);
  createParam(waveGenTotalTimeString,        asynParamFloat64, &waveGenTotalTime_);
  createParam(waveGenNumPointsString,          asynParamInt32, &waveGenNumPoints_);
  createParam(waveGenCurrentPointString,       asynParamInt32, &waveGenCurrentPoint_);
  createParam(waveGenIntDwellString,         asynParamFloat64, &waveGenIntDwell_);
  createParam(waveGenUserDwellString,        asynParamFloat64, &waveGenUserDwell_);
  createParam(waveGenIntNumPointsString,       asynParamInt32, &waveGenIntNumPoints_);
  createParam(waveGenUserNumPointsString,      asynParamInt32, &waveGenUserNumPoints_);
  createParam(waveGenExtTriggerString,         asynParamInt32, &waveGenExtTrigger_);
  createParam(waveGenExtClockString,           asynParamInt32, &waveGenExtClock_);
  createParam(waveGenContinuousString,         asynParamInt32, &waveGenContinuous_);
  createParam(waveGenRetriggerString,          asynParamInt32, &waveGenRetrigger_);
  createParam(waveGenTriggerCountString,       asynParamInt32, &waveGenTriggerCount_);
  createParam(waveGenRunString,                asynParamInt32, &waveGenRun_);
  createParam(waveGenUserTimeWFString,  asynParamFloat32Array, &waveGenUserTimeWF_);
  createParam(waveGenIntTimeWFString,   asynParamFloat32Array, &waveGenIntTimeWF_);
  // Waveform generator parameters - per output
  createParam(waveGenWaveTypeString,           asynParamInt32, &waveGenWaveType_);
  createParam(waveGenEnableString,             asynParamInt32, &waveGenEnable_);
  createParam(waveGenAmplitudeString,        asynParamFloat64, &waveGenAmplitude_);
  createParam(waveGenOffsetString,           asynParamFloat64, &waveGenOffset_);
  createParam(waveGenPulseWidthString,       asynParamFloat64, &waveGenPulseWidth_);
  createParam(waveGenIntWFString,       asynParamFloat32Array, &waveGenIntWF_);
  createParam(waveGenUserWFString,      asynParamFloat32Array, &waveGenUserWF_);

  // Trigger parameters
  createParam(triggerModeString,               asynParamInt32, &triggerMode_);

  // Digital I/O parameters
  createParam(digitalDirectionString,  asynParamUInt32Digital, &digitalDirection_);
  createParam(digitalInputString,      asynParamUInt32Digital, &digitalInput_);
  createParam(digitalOutputString,     asynParamUInt32Digital, &digitalOutput_);

  // Map very similar boards for simplicity
  boardFamily_ = boardType_;
  switch (boardType_) {
    case USB_1208LS:
    case USB_1208FS_PLUS:
      boardFamily_ = USB_1208LS;
      break;
    case USB_1608G:
    case USB_1608GX:
    case USB_1608GX_2AO:
    case USB_1608GX_2AO_OLD:
    case USB_1608HS_2AO:
      boardFamily_ = USB_1608G;
      break;
    case USB_1808:
    case USB_1808X:
      boardFamily_ = USB_1808;
      break;
    case USB_3101:
    case USB_3102:
    case USB_3103:
    case USB_3104:
    case USB_3105:
    case USB_3106:
    case USB_3110:
    case USB_3112:
    case USB_3114:
      boardFamily_ = USB_3101;
      break;
    case USB_TC32:
    case ETH_TC32:
      boardFamily_ = USB_TC32;
      break;
    default:
      break;
  }

  char uniqueIDStr[256];
  char firmwareVersion[256];
  char ULVersion[256];
  ULMutex.lock();
  #ifdef _WIN32
    int size = sizeof(uniqueIDStr);
    cbGetConfigString(BOARDINFO, boardNum_, 0, BIDEVUNIQUEID, uniqueIDStr, &size);
    size = sizeof(firmwareVersion);
    cbGetConfigString(BOARDINFO, boardNum_, VER_FW_MAIN, BIDEVVERSION, firmwareVersion, &size);
    float DLLRevNum, VXDRevNum;
    cbGetRevision(&DLLRevNum, &VXDRevNum);
    sprintf(ULVersion, "%f %f", DLLRevNum, VXDRevNum);
  #else
    strcpy(uniqueIDStr, uniqueID);
    unsigned int size = sizeof(firmwareVersion);
    ulDevGetConfigStr(daqDeviceHandle_, ::DEV_CFG_VER_STR, DEV_VER_FW_MAIN, firmwareVersion, &size);
    size = sizeof(ULVersion);
    ulGetInfoStr(UL_INFO_VER_STR, 0, ULVersion, &size);
  #endif
  setIntegerParam(modelNumber_, boardType_);
  setStringParam(modelName_, boardName_);
  setStringParam(uniqueID_, uniqueIDStr);
  setStringParam(firmwareVersion_, firmwareVersion);
  setStringParam(ULVersion_, ULVersion);
  setStringParam(driverVersion_, DRIVER_VERSION);
  
  #ifdef _WIN32
    int inMask, outMask;
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMADCHANS,    &numAnalogIn_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMDACHANS,    &numAnalogOut_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIADRES,         &ADCResolution_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIDACRES,        &DACResolution_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIDINUMDEVS,     &numIOPorts_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMTEMPCHANS,  &numTempChans_);
  #else
    long long infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_NUM_CHANS_BY_TYPE, AI_VOLTAGE, &infoValue);
    if (status)
      numAnalogIn_ = 0;
    else
      numAnalogIn_ = infoValue;
    status = ulAOGetInfo(daqDeviceHandle_, AO_INFO_NUM_CHANS, 0, &infoValue);
    if (status)
      numAnalogOut_ = 0;
    else
      numAnalogOut_ = infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_RESOLUTION, 0, &infoValue);
    ADCResolution_ = infoValue;
    status = ulAOGetInfo(daqDeviceHandle_, AO_INFO_RESOLUTION, 0, &infoValue);
    DACResolution_ = infoValue;
    status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_NUM_PORTS, 0, &infoValue);
    numIOPorts_ = infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_NUM_CHANS_BY_TYPE, AI_TC, &infoValue);
    numTempChans_ = infoValue;
  #endif
  if (numIOPorts_ > MAX_IO_PORTS) numIOPorts_ = MAX_IO_PORTS;
  for (i=0; i<numIOPorts_; i++) {
    digitalIOPortConfigurable_[i] = 0;
    #ifdef _WIN32
      cbGetConfig(DIGITALINFO, boardNum_, i, DIDEVTYPE, &digitalIOPort_[i]);
      cbGetConfig(DIGITALINFO, boardNum_, i, DIINMASK,  &inMask);
      cbGetConfig(DIGITALINFO, boardNum_, i, DIOUTMASK, &outMask);
      digitalIOPortReadOnly_[i]    = ((inMask != 0) && (outMask == 0));
      digitalIOPortWriteOnly_[i]   = ((inMask == 0) && (outMask != 0));
      digitalIOBitConfigurable_[i] = ((inMask & outMask) == 0);
      cbGetConfig(DIGITALINFO, boardNum_, i, DINUMBITS, &numIOBits_[i]);
    #else
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_PORT_TYPE, i, &infoValue);
      digitalIOPort_[i] = infoValue;
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_PORT_IO_TYPE, i, &infoValue);
      digitalIOPortReadOnly_[i]    = (infoValue == DPIOT_IN);
      digitalIOPortWriteOnly_[i]   = (infoValue == DPIOT_OUT);
      digitalIOBitConfigurable_[i] = (infoValue == DPIOT_BITIO);
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_NUM_BITS, i, &infoValue);
      numIOBits_[i] = infoValue;
    #endif
    digitalIOMask_[i] = 0;
    for (j=0; j<numIOBits_[i]; j++) {
      digitalIOMask_[i] |= (1 << j);
    }
  }
  ULMutex.unlock();
  // Assume only voltage input is supported
  analogInTypeConfigurable_ = 0;
  // Assume analog in data rate not configurable
  analogInDataRateConfigurable_ = 0;
  // Assume analog output range is not configurable
  analogOutRangeConfigurable_ = 0;
  switch (boardFamily_) {
    case USB_231:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      // For output need to address all bits using first port
      numIOBits_[0] = 8;
      // The rules for bit configurable above don't work for this model
      digitalIOPortConfigurable_[0] = 1;
      digitalIOPortConfigurable_[1] = 1;
      digitalIOBitConfigurable_[0] = 0;
      digitalIOPortConfigurable_[1] = 1;
      break;
    case USB_1208LS:
    case USB_1208FS:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 1;
      // For output need to address all bits using first port
      numIOBits_[0] = 16;
      // The rules for bit configurable above don't work for this model
      digitalIOPortConfigurable_[0] = 1;
      digitalIOPortConfigurable_[1] = 1;
      digitalIOBitConfigurable_[0] = 0;
      digitalIOPortConfigurable_[1] = 1;
      break;
    case USB_1608G:
      numTimers_    = 1;
      numCounters_  = 2;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 32e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 67.11;
      break;
    case USB_1608HS_2AO:
      numTimers_    = 1;
      numCounters_  = 1;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 32e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 67.11;
      break;
    case USB_1808:
      numTimers_    = 2;
      numCounters_  = 4;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 50e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 42.94;
      break;
    case USB_2408_2AO:
      numTimers_    = 0;
      numCounters_  = 2;
      firstCounter_ = 0;
      analogInTypeConfigurable_  = 1; // Supports voltage and thermocouple
      analogInDataRateConfigurable_ = 1; // Can configure analog input data rate
      break;
    case USB_3101:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      analogOutRangeConfigurable_ = 1; // Can select 0-10V or +-10V
      break;
    case USB_SSR08:
      numTimers_    = 0;
      numCounters_  = 0;
      for (i=0; i<2; i++) {
        // Digital I/O port 0 is outputs 1 - 4      
        // Digital I/O port 1 is outputs 5 - 8      
        setUIntDigitalParam(i, digitalDirection_, 0xFFFFFFFF, digitalIOMask_[i]);
      }
      break;
    case USB_TEMP:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<8; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      break;
    case USB_TEMP_AI:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<4; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      for (i=4; i<8; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_VOLTAGE);
      }
      break;
    case USB_TC32:
      numTimers_    = 0;
      numCounters_  = 0;
      for (i=0; i<MAX_TEMPERATURE_IN; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      // On Linux the TC-32 reports that numIOPorts_ = 4, but it is really only 2
      // This should be fixed in uldaq.
      #ifdef linux
        numIOPorts_ = 2;
      #endif
      // Digital I/O port 0 is input only
      setUIntDigitalParam(0, digitalDirection_, 0, 0xFFFFFFFF);
      // Digital I/O port 1 is output and temperature alarms
      setUIntDigitalParam(1, digitalDirection_, 0xFFFFFFFF, 0xFFFFFFFF);
      break;
    case E_1608:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      break;
    case E_DIO24:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      break;
    case E_TC:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<MAX_TEMPERATURE_IN; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      break;
    default:
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error, unknown board type=%d, board family=%d\n",
        driverName, functionName, boardType_, boardFamily_);
      break;
  }

  for (i=0, pBoardEnums_=0; i<maxBoardFamilies; i++) {
    if (allBoardEnums[i].boardFamily == boardFamily_) {
       pBoardEnums_ = &allBoardEnums[i];
       break;
    }
  }
  if (pBoardEnums_ == 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error, unknown board family=%d\n",
      driverName, functionName, boardFamily_);
  }

  // Allocate memory for the input and output buffers
  for (i=0; i<numAnalogIn_; i++) {
    waveDigBuffer_[i]  = (epicsFloat64 *) calloc(maxInputPoints_,  sizeof(epicsFloat64));
  }
  for (i=0; i<numAnalogOut_; i++) {
    waveGenIntBuffer_[i]  = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
    waveGenUserBuffer_[i] = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  }
  waveGenUserTimeBuffer_ = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  waveGenIntTimeBuffer_  = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  waveDigTimeBuffer_     = (epicsFloat32 *) calloc(maxInputPoints_,  sizeof(epicsFloat32));
  waveDigAbsTimeBuffer_  = (epicsFloat64 *) calloc(maxInputPoints_,  sizeof(epicsFloat64));
  pInBuffer_ = (epicsFloat64 *) calloc(maxInputPoints  * numAnalogIn_, sizeof(epicsFloat64));
  #ifdef _WIN32
    waveGenOutBuffer_ = (epicsUInt16 *) calloc(maxOutputPoints * numAnalogOut_, sizeof(epicsUInt16));
  #else
    waveGenOutBuffer_ = (epicsFloat64 *) calloc(maxOutputPoints * numAnalogOut_, sizeof(epicsFloat64));
  #endif

  // Set values of some parameters that need to be set because init record order is not predictable
  // or because the corresponding records are PINI=NO.
  setIntegerParam(waveGenUserNumPoints_, 1);
  setIntegerParam(waveGenIntNumPoints_, 1);
  setIntegerParam(waveDigNumPoints_, 1);
  setIntegerParam(pulseGenRun_, 0);
  setIntegerParam(waveDigRun_, 0);
  setIntegerParam(waveGenRun_, 0);
  for (i=0; i<numTempChans_; i++) {
    setIntegerParam(i, thermocoupleType_, TC_TYPE_J);
  }
  // Set the analog output range to the first supported value for this model
  for (i=0; i<MAX_ANALOG_OUT; i++) {
    setIntegerParam(i, analogOutRange_, pBoardEnums_->pOutputRange[0].enumValue);
  }

  /* Start the thread to poll counters and digital inputs and do callbacks to
   * device support */
  epicsThreadCreate("MultiFunctionPoller",
                    epicsThreadPriorityLow,
                    epicsThreadGetStackSize(epicsThreadStackMedium),
                    (EPICSTHREADFUNC)pollerThreadC,
                    this);
}

int  MultiFunction::reportError(int err, const char *functionName, const char *message)
{
  char libraryMessage[MAX_LIBRARY_MESSAGE_LEN];
  ULMutex.lock();
  switch (err) {
    case 0: 
      asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
        "%s::%s Info: %s\n", driverName, functionName, message);
      break;
    case -1: 
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s Error: %s\n", driverName, functionName, message);
      break;
    default:
      #ifdef _WIN32
        cbGetErrMsg(err, libraryMessage);
      #else
        ulGetErrMsg((UlError)err, libraryMessage);
      #endif
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s Error: %s, err=%d %s\n", driverName, functionName, message, err, libraryMessage);
  }
  ULMutex.unlock();
  return err;
}

#ifdef linux
int MultiFunction::mapRange(int Gain, Range *range)
{
    static const char *functionName = "mapRange";
    // Converts cbw Gain to uldaq Range
    switch (Gain) {
      case CBW_BIP60VOLTS:    *range = BIP60VOLTS; break;
      case CBW_BIP30VOLTS:    *range = BIP30VOLTS; break;
      case CBW_BIP20VOLTS:    *range = BIP20VOLTS; break;
      case CBW_BIP15VOLTS:    *range = BIP15VOLTS; break;
      case CBW_BIP10VOLTS:    *range = BIP10VOLTS; break;
      case CBW_BIP5VOLTS:     *range = BIP5VOLTS; break;
      case CBW_BIP4VOLTS:     *range = BIP4VOLTS; break;
      case CBW_BIP2PT5VOLTS:  *range = BIP2PT5VOLTS; break;
      case CBW_BIP2VOLTS:     *range = BIP2VOLTS; break;
      case CBW_BIP1PT25VOLTS: *range = BIP1PT25VOLTS; break;
      case CBW_BIP1VOLTS:     *range = BIP1VOLTS; break;
      case CBW_BIPPT625VOLTS: *range = BIPPT625VOLTS; break;
      case CBW_BIPPT5VOLTS:   *range = BIPPT5VOLTS; break;
      case CBW_BIPPT25VOLTS:  *range = BIPPT25VOLTS; break;
      case CBW_BIPPT2VOLTS:   *range = BIPPT2VOLTS; break;
      case CBW_BIPPT1VOLTS:   *range = BIPPT1VOLTS; break;
      case CBW_BIPPT05VOLTS:  *range = BIPPT05VOLTS; break;
      case CBW_BIPPT01VOLTS:  *range = BIPPT01VOLTS; break;
      case CBW_BIPPT005VOLTS: *range = BIPPT005VOLTS; break;
//      case CBW_BIP1PT67VOLTS: *range = BIP1PT67VOLTS; break;
      case CBW_BIPPT312VOLTS: *range = BIPPT312VOLTS; break;
      case CBW_BIPPT156VOLTS: *range = BIPPT156VOLTS; break;
      case CBW_BIPPT125VOLTS: *range = BIPPT125VOLTS; break;
      case CBW_BIPPT078VOLTS: *range = BIPPT078VOLTS; break;

      case CBW_UNI10VOLTS:    *range = UNI10VOLTS; break;
      case CBW_UNI5VOLTS:     *range = UNI5VOLTS; break;
      case CBW_UNI4VOLTS:     *range = UNI4VOLTS; break;
      case CBW_UNI2PT5VOLTS:  *range = UNI2PT5VOLTS; break;
      case CBW_UNI2VOLTS:     *range = UNI2VOLTS; break;
//      case CBW_UNI1PT67VOLTS: *range = UNI1PT67VOLTS; break;
      case CBW_UNI1PT25VOLTS: *range = UNI1PT25VOLTS; break;
      case CBW_UNI1VOLTS:     *range = UNI1VOLTS; break;
      case CBW_UNIPT5VOLTS:   *range = UNIPT5VOLTS; break;
      case CBW_UNIPT25VOLTS:  *range = UNIPT25VOLTS; break;
      case CBW_UNIPT2VOLTS:   *range = UNIPT2VOLTS; break;
      case CBW_UNIPT1VOLTS:   *range = UNIPT1VOLTS; break;
      case CBW_UNIPT05VOLTS:  *range = UNIPT05VOLTS; break;
//      case CBW_UNIPT02VOLTS:  *range = UNIPT02VOLTS; break;
      case CBW_UNIPT01VOLTS:  *range = UNIPT01VOLTS; break;

      case CBW_MA0TO20:       *range = MA0TO20; break;
      default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
            "%s::%s unsupported gain=%d\n", driverName, functionName, Gain);
          return -1;
    }
    return 0;
}

// This function maps the trigger types from UL on Windows to the values in UL for Linux.
// We can't use the macros from Windows cbw.h because they conflict with UL for Linux.
// These definitions are taken from cbw.h, but added CBW_ prefix.

#define CBW_TRIGABOVE           0
#define CBW_TRIGBELOW           1
#define CBW_GATE_NEG_HYS        2
#define CBW_GATE_POS_HYS        3
#define CBW_GATE_ABOVE          4
#define CBW_GATE_BELOW          5
#define CBW_GATE_IN_WINDOW      6
#define CBW_GATE_OUT_WINDOW     7
#define CBW_GATE_HIGH           8
#define CBW_GATE_LOW            9
#define CBW_TRIG_HIGH           10
#define CBW_TRIG_LOW            11
#define CBW_TRIG_POS_EDGE       12
#define CBW_TRIG_NEG_EDGE       13
#define CBW_TRIG_RISING         14
#define CBW_TRIG_FALLING        15
#define CBW_TRIG_PATTERN_EQ     16
#define CBW_TRIG_PATTERN_NE     17
#define CBW_TRIG_PATTERN_ABOVE  18
#define CBW_TRIG_PATTERN_BELOW  19

int MultiFunction::mapTriggerType(int cbwTriggerType, TriggerType *triggerType)
{
    static const char *functionName = "mapTriggerType";
    // Converts cbw trigger type to uldaq trigger type;
    switch (cbwTriggerType) {
      case CBW_TRIG_POS_EDGE:       *triggerType = TRIG_POS_EDGE; break;
      case CBW_TRIG_NEG_EDGE:       *triggerType = TRIG_NEG_EDGE; break;
      case CBW_TRIG_HIGH:           *triggerType = TRIG_HIGH; break;
      case CBW_TRIG_LOW:            *triggerType = TRIG_LOW; break;
      case CBW_GATE_HIGH:           *triggerType = GATE_HIGH; break;
      case CBW_GATE_LOW:            *triggerType = GATE_LOW; break;
      case CBW_TRIG_RISING:         *triggerType = TRIG_RISING; break;
      case CBW_TRIG_FALLING:        *triggerType = TRIG_FALLING; break;
      case CBW_TRIGABOVE:           *triggerType = TRIG_ABOVE; break;
      case CBW_TRIGBELOW:           *triggerType = TRIG_BELOW; break;
      case CBW_GATE_ABOVE:          *triggerType = GATE_ABOVE; break;
      case CBW_GATE_BELOW:          *triggerType = GATE_BELOW; break;
      case CBW_GATE_IN_WINDOW:      *triggerType = GATE_IN_WINDOW; break;
      case CBW_GATE_OUT_WINDOW:     *triggerType = GATE_OUT_WINDOW; break;
      case CBW_TRIG_PATTERN_EQ:     *triggerType = TRIG_PATTERN_EQ; break;
      case CBW_TRIG_PATTERN_NE:     *triggerType = TRIG_PATTERN_NE; break;
      case CBW_TRIG_PATTERN_ABOVE:  *triggerType = TRIG_PATTERN_ABOVE; break;
      case CBW_TRIG_PATTERN_BELOW:  *triggerType = TRIG_PATTERN_BELOW; break;
      default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s unsupported cbwTriggerType=%d\n", driverName, functionName, cbwTriggerType);
          *triggerType = TRIG_NONE;
          return -1;
    }
    return 0;
}

#endif

int MultiFunction::startPulseGenerator(int timerNum)
{
  int status=0;
  double frequency, period, delay;
  double dutyCycle;
  int count, idleState;
  static const char *functionName = "startPulseGenerator";

  getDoubleParam (timerNum, pulseGenPeriod_,    &period);
  getDoubleParam (timerNum, pulseGenDutyCycle_, &dutyCycle);
  getDoubleParam (timerNum, pulseGenDelay_,     &delay);
  getIntegerParam(timerNum, pulseGenCount_,     &count);
  getIntegerParam(timerNum, pulseGenIdleState_, &idleState);

  frequency = 1./period;
  if (frequency < minPulseGenFrequency_) frequency = minPulseGenFrequency_;
  if (frequency > maxPulseGenFrequency_) frequency = maxPulseGenFrequency_;
  period = 1. / frequency;
  if (dutyCycle <= 0.) dutyCycle = .0001;
  if (dutyCycle >= 1.) dutyCycle = .9999;
  if (delay < minPulseGenDelay_) delay = minPulseGenDelay_;
  if (delay > maxPulseGenDelay_) delay = maxPulseGenDelay_;

  ULMutex.lock();
  #ifdef _WIN32
    status = cbPulseOutStart(boardNum_, timerNum, &frequency, &dutyCycle, count, &delay, idleState, 0);
  #else
    TmrIdleState idle = (idleState == 0) ? TMRIS_LOW : TMRIS_HIGH;
    status = ulTmrPulseOutStart(daqDeviceHandle_, timerNum, &frequency, &dutyCycle, count, &delay, idle, PO_DEFAULT);
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling PulseOutStart");
  if (status) return status;
  // We may not have gotten the frequency, dutyCycle, and delay we asked for, set the actual values
  // in the parameter library
  pulseGenRunning_[timerNum] = 1;
  period = 1. / frequency;
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: started pulse generator %d actual frequency=%f, actual period=%f, actual duty cycle=%f, actual delay=%f\n",
    driverName, functionName, timerNum, frequency, period, dutyCycle, delay);
  setDoubleParam(timerNum, pulseGenPeriod_, period);
  setDoubleParam(timerNum, pulseGenDutyCycle_, dutyCycle);
  setDoubleParam(timerNum, pulseGenDelay_, delay);
  return 0;
}

int MultiFunction::stopPulseGenerator(int timerNum)
{
  pulseGenRunning_[timerNum] = 0;
  int err;
  ULMutex.lock();
  #ifdef _WIN32
    err = cbPulseOutStop(boardNum_, timerNum);
  #else
    err = ulTmrPulseOutStop(daqDeviceHandle_, timerNum);
  #endif
  ULMutex.unlock();
  return err;
}

int MultiFunction::defineWaveform(int channel)
{
  int waveType;
  int numPoints;
  int nPulse;
  int i;
  epicsFloat32 *outPtr = waveGenIntBuffer_[channel];
  double dwell, offset, base, amplitude, pulseWidth, scale;
  static const char *functionName = "defineWaveform";

  getIntegerParam(channel, waveGenWaveType_,  &waveType);
  if (waveType == waveTypeUser) {
    getIntegerParam(waveGenUserNumPoints_, &numPoints);
    if ((size_t)numPoints > maxOutputPoints_) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s:%s: ERROR numPoints=%d must be less than maxOutputPoints=%d\n",
        driverName, functionName, numPoints, (int)maxOutputPoints_);
      return -1;
    }
    getDoubleParam(waveGenUserDwell_, &dwell);
    setIntegerParam(waveGenNumPoints_, numPoints);
    setDoubleParam(waveGenDwell_, dwell);
    setDoubleParam(waveGenFreq_, 1./dwell/numPoints);
    return 0;
  }

  getIntegerParam(waveGenIntNumPoints_,  &numPoints);
  if ((size_t)numPoints > maxOutputPoints_) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s:%s: ERROR numPoints=%d must be less than maxOutputPoints=%d\n",
      driverName, functionName, numPoints, (int)maxOutputPoints_);
    return -1;
  }

  getDoubleParam(waveGenIntDwell_,             &dwell);
  getDoubleParam(channel, waveGenOffset_,      &offset);
  getDoubleParam(channel, waveGenAmplitude_,   &amplitude);
  getDoubleParam(channel, waveGenPulseWidth_,  &pulseWidth);
  setIntegerParam(waveGenNumPoints_, numPoints);
  setDoubleParam(waveGenDwell_, dwell);
  setDoubleParam(waveGenFreq_, 1./dwell/numPoints);
  base = offset - amplitude/2.;
  switch (waveType) {
    case waveTypeSin:
      scale = 2.*PI/(numPoints-1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (offset + amplitude/2. * sin(i*scale));
      break;
    case waveTypeSquare:
      for (i=0; i<numPoints/2; i++)         *outPtr++ = (epicsFloat32) (base + amplitude);
      for (i=numPoints/2; i<numPoints; i++) *outPtr++ = (epicsFloat32) (base);
      break;
    case waveTypeSawTooth:
      scale = 1./(numPoints-1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (base + amplitude*i*scale);
      break;
    case waveTypePulse:
      nPulse = (int) ((pulseWidth / dwell) + 0.5);
      if (nPulse < 1) nPulse = 1;
      if (nPulse >= numPoints-1) nPulse = numPoints-1;
      for (i=0; i<nPulse; i++)              *outPtr++ = (epicsFloat32) (base + amplitude);
      for (i=nPulse; i<numPoints; i++)      *outPtr++ = (epicsFloat32) (base);
      break;
    case waveTypeRandom:
      scale = amplitude / RAND_MAX;
      srand(1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (base + rand() * scale);
      break;
  }
  doCallbacksFloat32Array(waveGenIntBuffer_[channel], numPoints, waveGenIntWF_, channel);
  return 0;
}

int MultiFunction::startWaveGen()
{
  int status=0;
  int numPoints;
  int enable;
  int firstChan=-1, lastChan=-1, firstType=-1;
  int waveType;
  int extTrigger, extClock, continuous, retrigger;
  int options;
  int i, j, k;
  double offset, scale;
  double userOffset, userAmplitude;
  double dwell;
  epicsFloat32* inPtr[MAX_ANALOG_OUT];
  #ifdef _WIN32
    epicsUInt16 *outPtr;
  #else
    epicsFloat64 *outPtr;
  #endif
  static const char *functionName = "startWaveGen";

  getIntegerParam(waveGenExtTrigger_, &extTrigger);
  getIntegerParam(waveGenExtClock_,   &extClock);
  getIntegerParam(waveGenContinuous_, &continuous);
  getIntegerParam(waveGenRetrigger_,  &retrigger);

  for (i=0; i<numAnalogOut_; i++) {
    getIntegerParam(i, waveGenEnable_, &enable);
    if (!enable) continue;
    getIntegerParam(i, waveGenWaveType_,  &waveType);
    if (waveType == waveTypeUser)
      inPtr[i] = waveGenUserBuffer_[i];
    else
      inPtr[i] = waveGenIntBuffer_[i];
    if (firstChan < 0) {
      firstChan = i;
      firstType = waveType;
    }
    // Cannot mix user-defined and internal waveform types, because internal modifies dwell time
    // based on frequency
    if (((firstType == waveTypeUser) && (waveType != waveTypeUser)) ||
        ((firstType != waveTypeUser) && (waveType == waveTypeUser))) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s:%s: ERROR if any enabled waveform type is user-defined then all must be.\n",
        driverName, functionName);
      return -1;
    }
    lastChan = i;
    status = defineWaveform(i);
    if (status) return -1;
  }

  if (firstChan < 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s:%s: ERROR no enabled channels\n",
      driverName, functionName);
     return -1;
  }

  numWaveGenChans_ = lastChan - firstChan + 1;

  // dwell and numPoints were computed by defineWaveform above
  getIntegerParam(waveGenNumPoints_, &numPoints);
  getDoubleParam(waveGenDwell_, &dwell);
 
  // Copy data from float32 array to outputMemHandel, converting from volts to D/A units
  // Pre-defined waveforms have been fully defined at this point
  // User-defined waveforms need to have the offset and scale applied
  for (i=0; i<numWaveGenChans_; i++) {
    k = firstChan + i;
    outPtr = &(waveGenOutBuffer_[i]);
    offset = 10.;        // Mid-scale range of DAC
    scale = 65535./20.;  // D/A units per volt; 16-bit DAC, +-10V range
    if (waveType == waveTypeUser) {
      getDoubleParam(i, waveGenOffset_, &userOffset);
      getDoubleParam(i, waveGenAmplitude_,  &userAmplitude);
    } else {
      userOffset = 0.;
      userAmplitude = 1.0;
    }
    for (j=0; j<numPoints; j++) {
     *outPtr = (epicsUInt16)((inPtr[k][j]*userAmplitude + userOffset + offset)*scale + 0.5);
      outPtr += numWaveGenChans_;
    }
  }
  ULMutex.lock();
  #ifdef _WIN32
    long pointsPerSecond = (long)((1. / dwell) + 0.5);
    options                  = BACKGROUND;
    if (extTrigger) options |= EXTTRIGGER;
    if (extClock)   options |= EXTCLOCK;
    if (continuous) options |= CONTINUOUS;
    if (retrigger)  options |= RETRIGMODE;
    status = cbAOutScan(boardNum_, firstChan, lastChan, numWaveGenChans_*numPoints, &pointsPerSecond, BIP10VOLTS,
                        waveGenOutBuffer_, options);
    // Convert back from pointsPerSecond to dwell, since value might have changed
    dwell = (1. / pointsPerSecond);
  #else
    options                  = SO_DEFAULTIO;
    if (extTrigger) options |= SO_EXTTRIGGER;
    if (extClock)   options |= SO_EXTCLOCK;
    if (continuous) options |= SO_CONTINUOUS;
    if (retrigger)  options |= SO_RETRIGGER;
    double rate = 1./dwell;
    status = ulAOutScan(daqDeviceHandle_, firstChan, lastChan, BIP10VOLTS, numPoints, &rate, (ScanOption) options, AOUTSCAN_FF_NOSCALEDATA, waveGenOutBuffer_);
    // Convert back from rate to dwell, since value might have changed
    dwell = 1./rate;
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling AOutScan");

  if (status) return status;

  waveGenRunning_ = 1;
  setIntegerParam(waveGenRun_, 1);
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: called cbAOutScan, firstChan=%d, lastChan=%d, numPoints*numWaveGenChans_=%d, dwell=%f, options=0x%x\n",
    driverName, functionName, firstChan, lastChan,  numWaveGenChans_*numPoints, dwell, options);

  setDoubleParam(waveGenDwellActual_, dwell);
  setDoubleParam(waveGenTotalTime_, dwell*numPoints);
  return status;
}

int MultiFunction::stopWaveGen()
{
  int err;
  waveGenRunning_ = 0;
  setIntegerParam(waveGenRun_, 0);
  ULMutex.lock();
  #ifdef _WIN32
    err = cbStopBackground(boardNum_, AOFUNCTION);
  #else
    err = ulAOutScanStop(daqDeviceHandle_);
  #endif
  ULMutex.unlock();
  return err;
}

int MultiFunction::computeWaveGenTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(waveGenUserNumPoints_, &numPoints);
  getDoubleParam(waveGenUserDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveGenUserTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveGenUserTimeBuffer_, numPoints, waveGenUserTimeWF_, 0);

  getIntegerParam(waveGenIntNumPoints_, &numPoints);
  getDoubleParam(waveGenIntDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveGenIntTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveGenIntTimeBuffer_, numPoints, waveGenIntTimeWF_, 0);
  return 0;
}

int MultiFunction::startWaveDig()
{
  int firstChan, lastChan, numChans, numPoints;
  int chan, range;
  short gainArray[MAX_ANALOG_IN], chanArray[MAX_ANALOG_IN];
  int i;
  int extTrigger, extClock, continuous, retrigger, burstMode;
  int status;
  int options;
  double dwell;
  bool invalidScanRate=false;
  static const char *functionName = "startWaveDig";

  getIntegerParam(waveDigNumPoints_,  &numPoints);
  getIntegerParam(waveDigFirstChan_,  &firstChan);
  getIntegerParam(waveDigNumChans_,   &numChans);
  numWaveDigChans_ = numChans;
  getIntegerParam(waveDigExtTrigger_, &extTrigger);
  getIntegerParam(waveDigExtClock_,   &extClock);
  getIntegerParam(waveDigContinuous_, &continuous);
  getIntegerParam(waveDigRetrigger_,  &retrigger);
  getIntegerParam(waveDigBurstMode_,  &burstMode);
  getDoubleParam(waveDigDwell_, &dwell);

  lastChan = firstChan + numChans - 1;
  setIntegerParam(waveDigCurrentPoint_, 0);

  // Construct the gain array
  for (i=0; i<numChans; i++) {
    chan = firstChan + i;
    chanArray[i] = chan;
    getIntegerParam(chan, analogInRange_, &range);
    gainArray[i] = range;
  }
  ULMutex.lock();
  #ifdef _WIN32
    status = cbALoadQueue(boardNum_, chanArray, gainArray, numChans);
  #else
    AiQueueElement *queue = new AiQueueElement[numChans];
    for (int i=0; i<numChans; i++) {
        queue[i].channel = chanArray[i];
        queue[i].inputMode = aiInputMode_ == DIFFERENTIAL ? AI_DIFFERENTIAL : AI_SINGLE_ENDED;
        mapRange(gainArray[i], &queue[i].range);
    }
    status = ulAInLoadQueue(daqDeviceHandle_, queue, numChans);
    delete[] queue;
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling ALoadQueue");
  if (status) return status;

  ULMutex.lock();
  #ifdef _WIN32
    long pointsPerSecond = (long)((1. / dwell) + 0.5);
    options                  = BACKGROUND;
    options                 |= SCALEDATA;
    if (extTrigger) options |= EXTTRIGGER;
    if (extClock)   options |= EXTCLOCK;
    if (continuous) options |= CONTINUOUS;
    if (retrigger)  options |= RETRIGMODE;
    if (burstMode)  options |= BURSTMODE;
    status = cbAInScan(boardNum_, firstChan, lastChan, numWaveDigChans_*numPoints, &pointsPerSecond, BIP10VOLTS,
                       pInBuffer_, options);
    if (status == BADRATE) invalidScanRate = true;
    // Convert back from pointsPerSecond to dwell, since value might have changed
    dwell = (1. / pointsPerSecond);
  #else
    double rate = 1./dwell;
    options                  = SO_DEFAULTIO;
    if (extTrigger) options |= SO_EXTTRIGGER;
    if (extClock)   options |= SO_EXTCLOCK;
    if (continuous) options |= SO_CONTINUOUS;
    if (retrigger)  options |= SO_RETRIGGER;
    if (burstMode)  options |= SO_BURSTMODE;
    // This is equivalent to OPTIONS |= SCALEDATA on Windows
    AInScanFlag flags = AINSCAN_FF_DEFAULT;
    status = ulAInScan(daqDeviceHandle_, firstChan, lastChan, aiInputMode_, BIP10VOLTS, numPoints, &rate, (ScanOption) options, flags, pInBuffer_);
    if (status == ERR_BAD_RATE) invalidScanRate = true;
     // Convert back from rate to dwell, since value might have changed
    dwell = (1. / rate);
  #endif
  ULMutex.unlock();

  if (invalidScanRate) {
    setDoubleParam(waveDigDwellActual_, -9999);
  } else {
    setDoubleParam(waveDigDwellActual_, dwell);
  }

  reportError(status, functionName, "Calling AInScan");
  if (status) return status;

  waveDigRunning_ = 1;
  setIntegerParam(waveDigRun_, 1);
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: called cbAInScan, firstChan=%d, lastChan=%d, numPoints=%d, dwell=%f, options=0x%x\n",
    driverName, functionName, firstChan, lastChan, numPoints, dwell, options);

  setDoubleParam(waveDigTotalTime_, dwell*numPoints);
  return 0;
}

int MultiFunction::stopWaveDig()
{
  int autoRestart;
  int status;
  static const char *functionName = "stopWaveDig";

  waveDigRunning_ = 0;
  setIntegerParam(waveDigRun_, 0);
  readWaveDig();
  getIntegerParam(waveDigAutoRestart_, &autoRestart);
  ULMutex.lock();
  #ifdef _WIN32
    status = cbStopBackground(boardNum_, AIFUNCTION);
  #else
    status = ulAInScanStop(daqDeviceHandle_);
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Stopping AIn scan");
  if (autoRestart)
    status |= startWaveDig();
  return status;
}

int MultiFunction::readWaveDig()
{
  int firstChan, lastChan;
  int currentPoint;
  int i;
  static const char *functionName = "readWaveDig";

  getIntegerParam(waveDigFirstChan_,    &firstChan);
  lastChan = firstChan + numWaveDigChans_ - 1;
  getIntegerParam(waveDigCurrentPoint_, &currentPoint);

  for (i=firstChan; i<=lastChan; i++) {
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
      "%s:%s:, doing callbacks on input %d, first value=%f\n",
      driverName, functionName, i, waveDigBuffer_[i][0]);
    doCallbacksFloat64Array(waveDigBuffer_[i], currentPoint, waveDigVoltWF_, i);
  }
  doCallbacksFloat64Array(waveDigAbsTimeBuffer_, currentPoint, waveDigAbsTimeWF_, 0);
  return 0;
}

int MultiFunction::computeWaveDigTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(waveDigNumPoints_, &numPoints);
  getDoubleParam(waveDigDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveDigTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveDigTimeBuffer_, numPoints, waveDigTimeWF_, 0);
  return 0;
}


asynStatus MultiFunction::getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high)
{
  int function = pasynUser->reason;


  if (function == analogOutValue_) {
    *low = 0;
    *high = (1 << DACResolution_) - 1;
  }
  else if (function == analogInValue_) {
    *low = 0;
    *high = (1 << ADCResolution_) - 1;
  }
  else {
    return(asynError);
  }
  return(asynSuccess);
}

asynStatus MultiFunction::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
  int addr;
  int function = pasynUser->reason;
  int range;
  int status=0;
  static const char *functionName = "writeInt32";

  this->getAddress(pasynUser, &addr);
  setIntegerParam(addr, function, value);

  bool isThermocouple = true;
  if (analogInTypeConfigurable_) {
    int ival;
    getIntegerParam(addr, analogInType_, &ival);
    if (ival != AI_CHAN_TYPE_TC) isThermocouple = false;
  }

  ULMutex.lock();
  // Analog input functions
  if (function == analogInType_ && analogInTypeConfigurable_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIADCHANTYPE, value);
      // It seems to be necessary to reprogram the thermocouple type when switching from volts to TC
    #else
      long long configValue = (value == AI_CHAN_TYPE_VOLTAGE) ? AI_VOLTAGE : AI_TC;
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TYPE, addr, configValue);
    #endif
    reportError(status, functionName, "Setting analog input type");
    // It seems to be necessary to reprogram the thermocouple type when switching from volts to TC
    if (value == AI_CHAN_TYPE_TC) {
      int ival;
      // Set the TC type.  Note that the enums for thermocouple types are the same on Windows and Linux
      getIntegerParam(addr, thermocoupleType_, &ival);
      #ifdef _WIN32
        status = cbSetConfig(BOARDINFO, boardNum_, addr, BICHANTCTYPE, ival);
      #else
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TC_TYPE, addr, ival);
      #endif
      reportError(status, functionName, "Set thermocouple type");
      // Set open thermocouple detection
      getIntegerParam(addr, thermocoupleOpenDetect_, &ival);
      setOpenThermocoupleDetect(addr, ival);
    }
  }

  // Analog output functions
  if ((function == analogOutRange_) && analogOutRangeConfigurable_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIDACRANGE, value);
    #else
      // No function to immediately set it on Linux, this value is read from parameter library when calling ulAOut
    #endif
    reportError(status, functionName, "Setting analog out range");
  }

  else if (function == analogInMode_) {
    #ifdef _WIN32
      status = cbAInputMode(boardNum_, value);
    #else
      aiInputMode_ = (value == DIFFERENTIAL) ? AI_DIFFERENTIAL : AI_SINGLE_ENDED;
    #endif
    reportError(status, functionName, "Setting analog input mode");
  }

  else if ((function == analogInRate_) && analogInDataRateConfigurable_) {
    #ifdef _WIN32 
        status = cbSetConfig(BOARDINFO, boardNum_, addr, BIADDATARATE, value);
    #else
        status = ulAISetConfigDbl(daqDeviceHandle_, AI_CFG_CHAN_DATA_RATE, addr, value);
    #endif
    reportError(status, functionName, "Setting data rate");
  }

  else if ((function == thermocoupleType_) && isThermocouple) {
    // NOTE:
    // This sleep is a hack to get it working on the TC-32.  Without it the call to cbSetConfig()
    // will often hang if more than 6 channels are being configured.
    // This makes no sense.  The problem cannot be reproduced in the testTC32.c test application
    if (boardFamily_ == USB_TC32) epicsThreadSleep(0.01);
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BICHANTCTYPE, value);
    #else
      // The enums for thermocouple types are the same on Windows and Linux
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TC_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting thermocouple type");
  }

  else if ((function == thermocoupleOpenDetect_) && isThermocouple) {
    setOpenThermocoupleDetect(addr, value);
  }

  else if (function == temperatureSensor_) {
    #ifdef _WIN32 
      // Sensor cannot be configured on UL for Windows
      status = NOERRORS;
    #else
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting temperature sensor");
  }

  else if (function == temperatureWiring_) {
    #ifdef _WIN32
      // Wiring cannot be configured on UL for Windows
      status = NOERRORS;
    #else
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_SENSOR_CONNECTION_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting temperature wiring");
  }

  // Pulse generator functions
  else if (function == pulseGenRun_) {
    // Allow starting a run even if it thinks its running,
    // since there is no way to know when it got done if Count!=0
    if (value) {
      status = startPulseGenerator(addr);
    }
    else if (!value && pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
    }
  }
  else if ((function == pulseGenCount_) ||
           (function == pulseGenIdleState_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Counter functions
  else if (function == counterReset_) {
    #ifdef _WIN32
      // LOADREG0=0, LOADREG1=1, so we use addr
      status = cbCLoad32(boardNum_, addr, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, addr, CRT_LOAD, 0);
    #endif
    reportError(status, functionName, "Resetting counter");
  }

  // Trigger functions
  else if (function == triggerMode_) {
    #ifdef _WIN32
      status = cbSetTrigger(boardNum_, value, 0, 0);
    #else
      // In uldaq there are separate calls for ulDaqInSetTrigger, ulDaqOutSetTrigger, etc.
      // We just cache the information here and then call those functions when starting the appropriate scan
      status = mapTriggerType(value, &triggerType_);
    #endif
    reportError(status, functionName, "Setting trigger mode");
  }

  // Waveform digitizer functions
  else if (function == waveDigRun_) {
    if (value && !waveDigRunning_)
      status = startWaveDig();
    else if (!value && waveDigRunning_)
      status = stopWaveDig();
  }

  else if (function == waveDigReadWF_) {
    readWaveDig();
  }

  else if (function == waveDigNumPoints_) {
    if (value > (int)maxInputPoints_) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                "%s::%s error WaveDigNumPoints=%d must be less than MaxInputPoints=%d\n",
                driverName, functionName, value, (int)maxInputPoints_);
      setIntegerParam(waveDigNumPoints_, maxInputPoints_);
    }
    computeWaveDigTimes();
  }

  else if (function == waveDigTriggerCount_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, 0, BIADTRIGCOUNT, value);
    #else
      aiScanTrigCount_ = value;
    #endif
    reportError(status, functionName, "Setting waveDig trigger count");
  }

  // Analog output functions
  else if (function == analogOutValue_) {
    if (waveGenRunning_) {
      reportError(-1, functionName, "cannot write analog outputs while waveform generator is running.");
      ULMutex.unlock();
      return asynError;
    }
    status = getIntegerParam(addr, analogOutRange_, &range);

    #ifdef _WIN32
      status = cbAOut(boardNum_, addr, range, value);
    #else
      Range ulRange;
      mapRange(range, &ulRange);
      status = ulAOut(daqDeviceHandle_, addr, ulRange, AOUT_FF_NOSCALEDATA, (double) value);
    #endif
    reportError(status, functionName, "calling AOut");
  }

  // Waveform generator functions
  else if (function == waveGenRun_) {
    if (value && !waveGenRunning_)
      status = startWaveGen();
    else if (!value && waveGenRunning_)
      status = stopWaveGen();
  }

  else if ((function == waveGenWaveType_) ||
      (function == waveGenUserNumPoints_) ||
      (function == waveGenIntNumPoints_)  ||
      (function == waveGenEnable_)        ||
      (function == waveGenExtTrigger_)    ||
      (function == waveGenExtClock_)      ||
      (function == waveGenContinuous_)) {
    defineWaveform(addr);
    if (waveGenRunning_) {
      status = stopWaveGen();
      status |= startWaveGen();
    }
  }

  else if (function == waveGenTriggerCount_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, 0, BIDACTRIGCOUNT, value);
    #else
      aoScanTrigCount_ = value;
    #endif
    reportError(status, functionName, "Setting waveGen trigger count");
  }
  ULMutex.unlock();

  // This is a separate if statement because these cases are also treated above
  if ((function == waveGenUserNumPoints_) ||
      (function == waveGenIntNumPoints_)) {
    computeWaveGenTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %d to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, function=%d, ERROR writing %d to address %d, status=%d\n",
             driverName, functionName, this->portName, function, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

int MultiFunction::setOpenThermocoupleDetect(int addr, int value)
{
  int status=0;
  static const char *functionName = "setOpenThermocoupleDetect";

  if ((boardFamily_ != USB_TEMP) && (boardFamily_ != USB_TEMP_AI)) {
    ULMutex.lock();
    #ifdef _WIN32 
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIDETECTOPENTC, value);
    #else
      OtdMode mode = value ? OTD_ENABLED : OTD_DISABLED;
      // TC-32 and E-TC can only change open thermocouple detect for the entire device, not per-channel
      if (boardFamily_ == USB_TC32 || boardFamily_ == E_TC ) {
        int dev = 0;
        if (addr >= 32) dev = 1;
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_OTD_MODE, dev, mode);
      } else { 
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_OTD_MODE, addr, mode);
      }
    #endif
    ULMutex.unlock();
    reportError(status, functionName, "Setting thermocouple open detect mode");
  }
  return status;
}

asynStatus MultiFunction::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  static const char *functionName = "writeFloat64";

  this->getAddress(pasynUser, &addr);
  setDoubleParam(addr, function, value);

  // Pulse generator functions
  if ((function == pulseGenPeriod_)    ||
      (function == pulseGenDutyCycle_) ||
      (function == pulseGenDelay_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Waveform generator functions
  else if ((function == waveGenUserDwell_)  ||
           (function == waveGenIntDwell_)   ||
           (function == waveGenPulseWidth_) ||
           (function == waveGenAmplitude_)  ||
           (function == waveGenOffset_)) {
    defineWaveform(addr);
    if (waveGenRunning_) {
      status = stopWaveGen();
      status |= startWaveGen();
    }
  }

  // Waveform digitizer functions
  else if (function == waveDigDwell_) {
    computeWaveDigTimes();
  }

  // This is a separate if statement because these cases are also treated above
  if ((function == waveGenUserDwell_)  ||
      (function == waveGenIntDwell_)) {
    computeWaveGenTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %f to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing %f to address %d, status=%d\n",
             driverName, functionName, this->portName, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  int type;
  int scale;
  int filter=0;
  int range;
  static const char *functionName = "readFloat64";

  this->getAddress(pasynUser, &addr);

  // Temperature input function
  if (function == temperatureInValue_) {
    if (waveDigRunning_) {
      int currentPoint;
      getIntegerParam(waveDigCurrentPoint_, &currentPoint);
      if (currentPoint > 0) {
        *value = waveDigBuffer_[addr][currentPoint-1];
      }
    }
    else {
      getIntegerParam(addr, analogInType_, &type);
      getIntegerParam(addr, temperatureScale_, &scale);
      getIntegerParam(addr, temperatureFilter_, &filter);
      if (type != AI_CHAN_TYPE_TC) return asynSuccess;
      ULMutex.lock();
      #ifdef _WIN32
        float fVal;
        status = cbTIn(boardNum_, addr, scale, &fVal, filter);
        if (status == OPENCONNECTION) {
          // This is an "expected" error if the thermocouple is broken or disconnected
          // Don't print error message, just set temp to -9999.
          fVal = -9999.;
          status = 0;
          *value = (double) fVal;
        }
        *value = (double) fVal;
      #else
        TempScale tempScale;
        // cbTin has a filter option but ulTin does not?
        TInFlag flags = TIN_FF_DEFAULT;
        switch (scale) {
            case CELSIUS:     tempScale = TS_CELSIUS; break;
            case FAHRENHEIT:  tempScale = TS_FAHRENHEIT; break;
            case KELVIN:      tempScale = TS_KELVIN; break;
            case VOLTS:       tempScale = TS_VOLTS; break;
            case NOSCALE:     tempScale = TS_NOSCALE; break;
            default:
                asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s unsupported Scale=%d\n", driverName, functionName, scale);
                tempScale = TS_CELSIUS;
        }
        status = ulTIn(daqDeviceHandle_, addr, tempScale, flags, value);
        if (status == ERR_OPEN_CONNECTION) {
          // This is an "expected" error if the thermocouple is broken or disconnected
          // Don't print error message, just set temp to -9999.
          status = 0;
          *value = -9999.;
        }
      #endif
      ULMutex.unlock();
    }
    setDoubleParam(addr, temperatureInValue_, *value);
    reportError(status, functionName, "Calling TIn");
  }
  else if (function == voltageInValue_) {
    getIntegerParam(addr, voltageInRange_, &range);
    ULMutex.lock();
    #ifdef _WIN32
      float fVal;
      status = cbVIn(boardNum_, addr, range, &fVal, 0);
      *value = fVal;
    #else
      double data;
      Range ulRange;
      mapRange(range, &ulRange);
      int chan = addr;
      if (boardFamily_ == USB_TEMP_AI) {
        // On Linux the address needs to be 4 larger
        chan = addr + 4;
      }
      status = ulAIn(daqDeviceHandle_, chan, aiInputMode_, ulRange, AIN_FF_DEFAULT, &data);
      *value = (float) data;
    #endif
    ULMutex.unlock();
    reportError(status, functionName, "Calling AIn");
    setDoubleParam(addr, voltageInValue_, *value);
  }

  // Other functions we call the base class method
  else {
     status = asynPortDriver::readFloat64(pasynUser, value);
  }

  callParamCallbacks(addr);
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
  int function = pasynUser->reason;
  int status=0;
  int i;
  int addr;
  epicsUInt32 direction=0;
  static const char *functionName = "writeUInt32Digital";

  this->getAddress(pasynUser, &addr);
  setUIntDigitalParam(addr, function, value, mask);
  ULMutex.lock();
  if (function == digitalDirection_) {
    if (digitalIOPortConfigurable_[addr]) {
      #ifdef _WIN32
        int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
        status = cbDConfigPort(boardNum_, digitalIOPort_[addr], dir);
      #else
        DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
        status = ulDConfigPort(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], dir);
      #endif
      reportError(status, functionName, "Calling ConfigPort");
      direction = value ? 0xFFFF : 0;
      setUIntDigitalParam(0, digitalDirection_, direction, 0xFFFFFFFF);
    }
    else {
      for (i=0; i<numIOBits_[addr]; i++) {
        if ((mask & (1<<i)) != 0) {
          if (digitalIOBitConfigurable_[addr]) {
            #ifdef _WIN32
              int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
              status = cbDConfigBit(boardNum_, digitalIOPort_[addr], i, dir);
            #else
             DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
             status = ulDConfigBit(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, dir);
            #endif
            reportError(status, functionName, "Calling ConfigBit");
          }
          else {
            // Cannot program direction.  Set open collector output to 0.
            #ifdef _WIN32
              status = cbDBitOut(boardNum_, digitalIOPort_[addr], i, 0);
            #else
              status = ulDBitOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, 0);
            #endif
            reportError(status, functionName, "Calling BitOut");
          }
        }
      }
    }
  }

  else if (function == digitalOutput_) {
    getUIntDigitalParam(addr, digitalDirection_, &direction, 0xFFFFFFFF);
    if ((mask & direction) == digitalIOMask_[addr]) {
      // Use word I/O if all bits are outputs and we are writing all bits
      #ifdef _WIN32
        if (numIOBits_[addr] > 16) {
          status = cbDOut32(boardNum_, digitalIOPort_[addr], value & mask);
        } else {
          status = cbDOut(boardNum_, digitalIOPort_[addr], value & mask);
        }
      #else
        status = ulDOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], value & mask);
      #endif
      reportError(status, functionName, "Calling DOut");
    }
    else {
      // Use bit I/O if we are not writing all bits
      epicsUInt32 outMask, outValue;
      for (i=0, outMask=1; i<numIOBits_[addr]; i++, outMask = (outMask<<1)) {
        // Only write the value if the mask has this bit set and the direction for that bit is output (1)
        outValue = ((value & outMask) == 0) ? 0 : 1;
        if ((mask & outMask & direction) != 0) {
          #ifdef _WIN32
            status = cbDBitOut(boardNum_, digitalIOPort_[addr], i, outValue);
          #else
            status = ulDBitOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, outValue);
          #endif
          reportError(status, functionName, "Calling DBitOut");
        }
      }
    }
  }
  ULMutex.unlock();

  callParamCallbacks();
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, function=%d, wrote value=0x%x, mask=0x%x, direction=0x%x\n",
             driverName, functionName, this->portName, function, value, mask, direction);
  } 
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat32 *inPtr;
  static const char *functionName = "readFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (addr >= numAnalogOut_) {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: addr=%d max=%d\n",
      driverName, functionName, addr, numAnalogOut_-1);
    return asynError;
  }
  // Assume WaveGen function, WaveDig numPoints handled below
  getIntegerParam(waveGenNumPoints_, &numPoints);
  if (function == waveGenUserWF_)
    inPtr = waveGenUserBuffer_[addr];
  else if (function == waveGenIntWF_)
    inPtr = waveGenIntBuffer_[addr];
  else if (function == waveGenUserTimeWF_)
    inPtr = waveGenUserTimeBuffer_;
  else if (function == waveGenIntTimeWF_)
    inPtr = waveGenIntTimeBuffer_;
  else if (function == waveDigTimeWF_) {
    inPtr = waveDigTimeBuffer_;
    getIntegerParam(waveDigNumPoints_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat32));

  return asynSuccess;
}

asynStatus MultiFunction::readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat64 *inPtr;
  static const char *functionName = "readFloat64Array";

  this->getAddress(pasynUser, &addr);

  if (function == waveDigVoltWF_) {
    if (addr >= numAnalogIn_) {
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
        "%s:%s: ERROR: addr=%d max=%d\n",
        driverName, functionName, addr, numAnalogIn_-1);
      return asynError;
    }
    inPtr = waveDigBuffer_[addr];
  }
  else if (function == waveDigAbsTimeWF_) {
    inPtr = waveDigAbsTimeBuffer_;
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  getIntegerParam(waveDigNumPoints_, &numPoints);
  if (*nIn > (size_t)numPoints) *nIn = numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat64));
  return asynSuccess;
}

asynStatus MultiFunction::writeFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements)
{
  int function = pasynUser->reason;
  int addr;
  static const char *functionName = "writeFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (function == waveGenUserWF_) {
    if ((addr >= numAnalogOut_) || (nElements > maxOutputPoints_)) {
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
        "%s:%s: ERROR: addr=%d max=%d, nElements=%d max=%d\n",
        driverName, functionName, addr, numAnalogOut_-1, (int)nElements, (int)maxOutputPoints_);
      return asynError;
    }
    memcpy(waveGenUserBuffer_[addr], value, nElements*sizeof(epicsFloat32));
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }

  return asynSuccess;
}

asynStatus MultiFunction::readEnum(asynUser *pasynUser, char *strings[], int values[], int severities[], size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int i;
  const enumStruct_t *pEnum;
  int numEnums;
  //static const char *functionName = "readEnum";

  if (function == analogInRange_) {
    pEnum    = pBoardEnums_->pInputRange;
    numEnums = pBoardEnums_->numInputRange;
  }
  else if (function == voltageInRange_) {
    pEnum    = pBoardEnums_->pInputRange;
    numEnums = pBoardEnums_->numInputRange;
  }
  else if (function == analogOutRange_) {
    pEnum    = pBoardEnums_->pOutputRange;
    numEnums = pBoardEnums_->numOutputRange;
  }
  else if (function == analogInType_) {
    pEnum    = pBoardEnums_->pInputType;
    numEnums = pBoardEnums_->numInputType;
  }
  else if (function == temperatureSensor_) {
    pEnum    = temperatureSensorUSB_TEMP;
    numEnums = sizeof(temperatureSensorUSB_TEMP)/sizeof(enumStruct_t);
  }
  else if (function == temperatureWiring_) {
    pEnum    = temperatureWiringUSB_TEMP;
    numEnums = sizeof(temperatureWiringUSB_TEMP)/sizeof(enumStruct_t);
  }
  else {
      *nIn = 0;
      return asynError;
  }
  for (i=0; ((i<numEnums) && (i<(int)nElements)); i++) {
    if (strings[i]) free(strings[i]);
    strings[i] = epicsStrDup(pEnum[i].enumString);
    values[i] = pEnum[i].enumValue;
    severities[i] = 0;
  }
  *nIn = i;
  return asynSuccess;
}

void MultiFunction::pollerThread()
{
  /* This function runs in a separate thread.  It waits for the poll
   * time */
  static const char *functionName = "pollerThread";
  epicsUInt32 newValue, changedBits, prevInput[MAX_IO_PORTS]={0};
  int i;
  int currentPoint;
  epicsUInt32 countVal;
  long aoCount, aoIndex, aiCount, aiIndex;
  short aoStatus, aiStatus;
  epicsTime startTime=epicsTime::getCurrent(), endTime, currentTime;
  int lastPoint;
  int status=0, prevStatus=0;

  while(1) {
    lock();
    ULMutex.lock();
    endTime = epicsTime::getCurrent();
    setDoubleParam(pollTimeMS_, (endTime-startTime)*1000.);
    startTime = epicsTime::getCurrent();

    // Read the digital inputs
    for (i=0; i<numIOPorts_; i++) {
      if (digitalIOPortWriteOnly_[i]) continue;
      #ifdef _WIN32
        epicsUInt16 biVal16;
        if (numIOBits_[i] > 16) {
          status = cbDIn32(boardNum_, digitalIOPort_[i], &newValue);
        } else {
          status = cbDIn(boardNum_, digitalIOPort_[i], &biVal16);
          newValue = biVal16;
        }
      #else
        unsigned long long data;
        status = ulDIn(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[i], &data);
        newValue = (epicsUInt32) data;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling DIn");
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR, "portNumber=%d\n", i);
        }
        goto error;
      }
      changedBits = newValue ^ prevInput[i];
      if (forceCallback_[i] || (changedBits != 0)) {
        prevInput[i] = newValue;
        forceCallback_[i] = 0;
        setUIntDigitalParam(i, digitalInput_, newValue, 0xFFFFFFFF);
      }
    }

    // Read the counter inputs
    for (i=0; i<numCounters_; i++) {
      #ifdef _WIN32
        ULONG data;
        status = cbCIn32(boardNum_, firstCounter_ + i, &data);
        countVal = (epicsUInt32)data;
      #else
        unsigned long long data;
        status = ulCIn(daqDeviceHandle_, firstCounter_ + i, &data);
        countVal = (epicsUInt32)data;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling CIn");
        }
        goto error;
      }
      setIntegerParam(i, counterCounts_, countVal);
    }

    if (waveGenRunning_) {
      // Poll the status of the waveform generator output
      #ifdef _WIN32
        status = cbGetIOStatus(boardNum_, &aoStatus, &aoCount, &aoIndex, AOFUNCTION);
      #else
        ScanStatus scanStatus;
        TransferStatus xferStatus;
        status = ulAOutScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
        aoStatus = scanStatus;
        aoCount = xferStatus.currentTotalCount;
        aoIndex = xferStatus.currentIndex;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling AOutScanStatus");
        }
        goto error;
      } else {
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
          "%s::%s waveform generator status, aoStatus=%d, aoCount=%ld, aoIndex=%ld\n",
          driverName, functionName, aoStatus, aoCount, aoIndex);
      }
      currentPoint = (aoIndex / numWaveGenChans_) + 1;
      setIntegerParam(waveGenCurrentPoint_, currentPoint);
      if (aoStatus == 0) {
        stopWaveGen();
      }
    }

    if (waveDigRunning_) {
      // Poll the status of the waveform digitizer input
      #ifdef _WIN32
        status = cbGetIOStatus(boardNum_, &aiStatus, &aiCount, &aiIndex, AIFUNCTION);
      #else
        ScanStatus scanStatus;
        TransferStatus xferStatus;
        status = ulAInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
        aiStatus = scanStatus;
        aiCount = xferStatus.currentTotalCount;
        aiIndex = xferStatus.currentIndex;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling AInScanStatus");
        }
        #ifdef _WIN32
          // On Windows after a network glitch cbGetIOStatus will return continually return DEADDEV
          // Need to stop and start the waveform digitizer if it was running
          if (status == DEADDEV) {
            stopWaveDig();
            startWaveDig();
          }
          goto error;
        #endif
      } else {
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
          "%s::%s waveform digitizer status, aiStatus=%d, aiCount=%ld, aiIndex=%ld\n",
          driverName, functionName, aiStatus, aiCount, aiIndex);
      }
      getIntegerParam(waveDigCurrentPoint_, &currentPoint);
      lastPoint = aiIndex / numWaveDigChans_ + 1;
      if (lastPoint > currentPoint) {
        currentTime = epicsTime::getCurrent();
        epicsTimeStamp now = (epicsTimeStamp)currentTime;
        int firstChan;
        getIntegerParam(waveDigFirstChan_, &firstChan);
        int lastChan = firstChan + numWaveDigChans_ - 1;
        epicsFloat64 *pAnalogIn = pInBuffer_ + currentPoint*numWaveDigChans_;
        for(; currentPoint < lastPoint; currentPoint++) {
          for (int j=firstChan; j<=lastChan; j++) {
            waveDigBuffer_[j][currentPoint] = *pAnalogIn++;
          }
          waveDigAbsTimeBuffer_[currentPoint] = now.secPastEpoch + now.nsec/1.e9;
        }
        setIntegerParam(waveDigCurrentPoint_, currentPoint);
      }
      if (aiStatus == 0) {
        stopWaveDig();
      }
    } else {
      // If the waveform digitizer is not running then read the analog inputs
      int range, type, mode;
      epicsInt32 value;
      getIntegerParam(0, analogInMode_, &mode);
      for (i=0; i<numAnalogIn_; i++) {
        getIntegerParam(i, analogInRange_, &range);
        getIntegerParam(i, analogInType_, &type);
        if (type != AI_CHAN_TYPE_VOLTAGE) continue;
        if ((boardType_ == E_1608) && (mode == DIFFERENTIAL) && (i>3)) break;
        #ifdef _WIN32
          if (ADCResolution_ <= 16) {
            epicsUInt16 shortVal;
            status = cbAIn(boardNum_, i, range, &shortVal);
            value = shortVal;
          } else {
            ULONG ulongVal;
            status = cbAIn32(boardNum_, i, range, &ulongVal, 0);
            value = (epicsInt32)ulongVal;
          }
        #else
          double data;
          Range ulRange;
          mapRange(range, &ulRange);
          status = ulAIn(daqDeviceHandle_, i, aiInputMode_, ulRange, AIN_FF_NOSCALEDATA, &data);
          value = (epicsInt32) data;
        #endif
        setIntegerParam(i, analogInValue_, value);
      }
    }

    for (i=0; i<MAX_SIGNALS; i++) {
      callParamCallbacks(i);
    }
error:
    if (prevStatus && !status) {
      reportError(-1, functionName, "Device returned to normal status");
    }
    prevStatus = status;
    double pollTime;
    getDoubleParam(pollSleepMS_, &pollTime);
    ULMutex.unlock();
    unlock();
    epicsThreadSleep(pollTime/1000.);
  }
}

/* Report  parameters */
void MultiFunction::report(FILE *fp, int details)
{
  int i;
  int counts;

  asynPortDriver::report(fp, details);
  fprintf(fp, "  Port: %s, board ID=%d, board type=%s\n",
          this->portName, boardType_, boardName_);
  if (details >= 1) {
    fprintf(fp, "  analog inputs      = %d\n", numAnalogIn_);
    fprintf(fp, "  analog input bits  = %d\n", ADCResolution_);
    fprintf(fp, "  analog outputs     = %d\n", numAnalogOut_);
    fprintf(fp, "  analog output bits = %d\n", DACResolution_);
    fprintf(fp, "  temperature inputs = %d\n", numTempChans_);
    fprintf(fp, "  digital I/O ports  = %d\n", numIOPorts_);
    for (i=0; i<numIOPorts_; i++) {
      fprintf(fp, "  digital I/O port     %d\n", i);
      fprintf(fp, "    I/O port              = %d\n", digitalIOPort_[i]);
      fprintf(fp, "    I/O bits              = %d\n", numIOBits_[i]);
      fprintf(fp, "    I/O bit configurable  = %d\n", digitalIOBitConfigurable_[i]);
      fprintf(fp, "    I/O port configurable = %d\n", digitalIOPortConfigurable_[i]);
      fprintf(fp, "    I/O port read only    = %d\n", digitalIOPortReadOnly_[i]);
      fprintf(fp, "    I/O port write only   = %d\n", digitalIOPortWriteOnly_[i]);
      fprintf(fp, "    I/O port mask         = 0x%x\n", digitalIOMask_[i]);
    }
    fprintf(fp, "  timers             = %d\n", numTimers_);
    if (numTimers_ > 0) {
      fprintf(fp, "  pulse generator\n");
      fprintf(fp, "    frequency range  = %f : %f\n", minPulseGenFrequency_, maxPulseGenFrequency_);
      fprintf(fp, "    delay range      = %f : %f\n", minPulseGenDelay_, maxPulseGenDelay_);
    }
    fprintf(fp, "  # counters         = %d", numCounters_);
    fprintf(fp, "  first counter      = %d", firstCounter_);
    fprintf(fp, "  counterCounts = ");
    for (i=0; i<numCounters_; i++) {
      getIntegerParam(i, counterCounts_, &counts);
      fprintf(fp, " %d", counts);
    }
    fprintf(fp, "\n");
  }
}

/** Configuration command, called directly or from iocsh */
extern "C" int MultiFunctionConfig(const char *portName, const char *uniqueID,
                              int maxInputPoints, int maxOutputPoints)
{
  new MultiFunction(portName, uniqueID, maxInputPoints, maxOutputPoints);
  return asynSuccess;
}


static const iocshArg configArg0 = { "Port name",      iocshArgString};
static const iocshArg configArg1 = { "UniqueID",       iocshArgString};
static const iocshArg configArg2 = { "Max. input points", iocshArgInt};
static const iocshArg configArg3 = { "Max. output points",iocshArgInt};
static const iocshArg * const configArgs[] = {&configArg0,
                                              &configArg1,
                                              &configArg2,
                                              &configArg3};
static const iocshFuncDef configFuncDef = {"MultiFunctionConfig",4,configArgs};
static void configCallFunc(const iocshArgBuf *args)
{
  MultiFunctionConfig(args[0].sval, args[1].sval, args[2].ival, args[3].ival);
}


static const iocshFuncDef showDevicesFuncDef = {"measCompShowDevices",0,0};
static void showDevicesCallFunc(const iocshArgBuf *args)
{
  measCompShowDevices();
}

void drvMultiFunctionRegister(void)
{
  iocshRegister(&configFuncDef,configCallFunc);
  iocshRegister(&showDevicesFuncDef,showDevicesCallFunc);
}


extern "C" {
epicsExportRegistrar(drvMultiFunctionRegister);
}












🔥 File: ./USB1608G_2AO_V2App/src/drvUSBCTR.cpp
=================================================
/* drvUSBCTR.cpp
 *
 * Driver for Measurement Computing USB-CTR04/08 counter/timer module using asynPortDriver base class
 *
 * This driver supports simple digital in/out bit and word, timer (digital pulse generator), counter,
 *   EPICS scaler record, multi-channel scaler mode
 *
 * Mark Rivers
 * May 29, 2014
*/

#include <math.h>
#include <stdlib.h>
#include <string.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsTime.h>

#include <asynPortDriver.h>

#include "drvMca.h"
#include "devScalerAsyn.h"

#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

#include <epicsExport.h>
#include <measCompDiscover.h>

#define DRIVER_VERSION "4.2"

typedef enum {
  MCSPoint0Clear,
  MCSPoint0NoClear,
  MCSPoint0Skip
} MCSPoint0Action_t;

static const char *driverName = "USBCTR";

// Board parameters
#define modelNameString           "MODEL_NAME"
#define modelNumberString         "MODEL_NUMBER"
#define firmwareVersionString     "FIRMWARE_VERSION"
#define uniqueIDString            "UNIQUE_ID"
#define ULVersionString           "UL_VERSION"
#define driverVersionString       "DRIVER_VERSION"
#define pollSleepMSString         "POLL_SLEEP_MS"
#define pollTimeMSString          "POLL_TIME_MS"
#define lastErrorMessageString    "LAST_ERROR_MESSAGE"

// Pulse output parameters
#define pulseGenRunString         "PULSE_RUN"
#define pulseGenPeriodString      "PULSE_PERIOD"
#define pulseGenDutyCycleString   "PULSE_DUTY_CYCLE"
#define pulseGenDelayString       "PULSE_DELAY"
#define pulseGenCountString       "PULSE_COUNT"
#define pulseGenIdleStateString   "PULSE_IDLE_STATE"

// Counter parameters
#define counterCountsString       "COUNTER_VALUE"
#define counterResetString        "COUNTER_RESET"

// Trigger parameters
#define triggerModeString         "TRIGGER_MODE"

// Digital I/O parameters
#define digitalDirectionString    "DIGITAL_DIRECTION"
#define digitalInputString        "DIGITAL_INPUT"
#define digitalOutputString       "DIGITAL_OUTPUT"

// MCS parameters other than those in drvMca.h
#define MCSCurrentPointString     "MCS_CURRENT_POINT"
#define MCSMaxPointsString        "MCS_MAX_POINTS"
#define MCSTimeWFString           "MCS_TIME_WF"
#define MCSAbsTimeWFString        "MCS_ABS_TIME_WF"
#define MCSCounterEnableString    "MCS_COUNTER_ENABLE"
#define MCSPrescaleCounterString  "MCS_PRESCALE_COUNTER"
#define MCSPoint0ActionString     "MCS_POINT0_ACTION"

// Model ID
#define modelString               "MODEL"

#define MIN_FREQUENCY   0.023
#define MAX_FREQUENCY   48e6
#define MIN_DELAY       0.
#define MAX_DELAY       67.11
#define MAX_COUNTERS    8   // Maximum mumber of counters on USB-CTR04/08
#define MAX_MCS_COUNTERS (MAX_COUNTERS + 1) // +1 for collecting the digital I/O in MCS mode
#define DIGITAL_IO_COUNTER (MAX_MCS_COUNTERS-1) // Index of the digital I/O enable in mcsCounterEnable_ array;
#define MAX_DAQ_LEN     2*MAX_MCS_COUNTERS // Each counter can take 2 words
#define NUM_TIMERS      4   // Number of timers on USB-CTR08
#define NUM_IO_BITS     8   // Number of digital I/O bits on USB-CTR08
#define MAX_SIGNALS     MAX_MCS_COUNTERS
#define MAX_ERROR_STRING_LEN 256
#define MAX_BOARDNAME_LEN    256

#define DEFAULT_POLL_TIME 0.01
#define SINGLEIO_THRESHOLD_TIME 0.01  // Above this time uses SINGLEIO, below uses block I/O.

/** This is the class definition for the USBCTR class
  */
class USBCTR : public asynPortDriver {
public:
  USBCTR(const char *portName, const char *uniqueID, int maxTimePoints, double pollTime);

  /* These are the methods that we override from asynPortDriver */
  virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
  virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
  virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
  virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);
  virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn);
  virtual void report(FILE *fp, int details);
  // These should be private but are called from C
  virtual void pollerThread(void);

protected:
  // Model parameters
  int modelName_;
  int modelNumber_;
  int firmwareVersion_;
  int uniqueID_;
  int ULVersion_;
  int driverVersion_;
  int pollSleepMS_;
  int pollTimeMS_;
  int lastErrorMessage_;

  // Pulse generator parameters
  int pulseGenRun_;
  int pulseGenPeriod_;
  int pulseGenDutyCycle_;
  int pulseGenDelay_;
  int pulseGenCount_;
  int pulseGenIdleState_;

  // Counter parameters
  int counterCounts_;
  int counterReset_;

  // Trigger parameters
  int triggerMode_;

  // Digital I/O parameters
  int digitalDirection_;
  int digitalInput_;
  int digitalOutput_;

  // MCS parameters other than those in drvMca.h
  int MCSCurrentPoint_;
  int MCSMaxPoints_;
  int MCSTimeWF_;
  int MCSAbsTimeWF_;
  int MCSCounterEnable_;
  int MCSPrescaleCounter_;
  int MCSPoint0Action_;

  // Command for EPICS MCA record
  int mcaStartAcquire_;
  int mcaStopAcquire_;
  int mcaErase_;
  int mcaData_;
  int mcaReadStatus_;
  int mcaChannelAdvanceSource_;
  int mcaNumChannels_;
  int mcaDwellTime_;
  int mcaPresetLiveTime_;
  int mcaPresetRealTime_;
  int mcaPresetCounts_;
  int mcaPresetLowChannel_;
  int mcaPresetHighChannel_;
  int mcaPresetSweeps_;
  int mcaAcquireMode_;
  int mcaSequence_;
  int mcaPrescale_;
  int mcaAcquiring_;
  int mcaElapsedLiveTime_;
  int mcaElapsedRealTime_;
  int mcaElapsedCounts_;

  // Commands for EPICS scaler record
  int scalerReset_;
  int scalerChannels_;
  int scalerRead_;
  int scalerPresets_;
  int scalerArm_;
  int scalerDone_;

// Model ID
  int model_;

private:
  int boardType_;
  #ifdef _WIN32
    int boardNum_;
  #else
    DaqDeviceHandle daqDeviceHandle_;
  #endif
  DaqDeviceDescriptor daqDeviceDescriptor_;
  char boardName_[MAX_BOARDNAME_LEN];
  double pollTime_;
  int forceCallback_;
  int numCounters_;
  int numMCSCounters_;
  int maxTimePoints_;
  epicsInt32 scalerCounts_[MAX_COUNTERS];
  epicsInt32 scalerPresetCounts_[MAX_COUNTERS];
  epicsInt32 *MCSBuffer_[MAX_MCS_COUNTERS];
  bool mcsCounterEnable_[MAX_MCS_COUNTERS];
  short chanArray_[MAX_DAQ_LEN];
  short chanTypeArray_[MAX_DAQ_LEN];
  short gainArray_[MAX_DAQ_LEN];

  epicsFloat32 *MCSTimeBuffer_;
  epicsFloat64 *MCSAbsTimeBuffer_;
  epicsFloat64 *pCountsF64_;
  epicsUInt64 *pCountsUI64_;
  epicsInt32 *pCountsI32_;
  epicsInt16 *pCountsI16_;
  int counterBits_;

  bool pulseGenRunning_[NUM_TIMERS];
  bool scalerRunning_;
  bool MCSRunning_;
  bool MCSErased_;
  epicsTimeStamp startTime_;
  double elapsedPrevious_;
  char errorMessage_[MAX_ERROR_STRING_LEN];

  char *getErrorMessage(int error);
  int startPulseGenerator(int timerNum);
  int stopPulseGenerator(int timerNum);
  int resetScaler();
  int startScaler();
  int readScaler();
  int stopScaler();
  int clearScalerPresets();
  int setScalerPresets();
  int startMCS();
  int stopMCS();
  int readMCS();
  int eraseMCS();
  int computeMCSTimes();
};

static void pollerThreadC(void * pPvt)
{
    USBCTR *pUSBCTR = (USBCTR *)pPvt;
    pUSBCTR->pollerThread();
}

USBCTR::USBCTR(const char *portName, const char *uniqueID, int maxTimePoints, double pollTime)
  : asynPortDriver(portName, MAX_SIGNALS,
      asynInt32Mask | asynUInt32DigitalMask | asynInt32ArrayMask | asynFloat32ArrayMask | asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask |asynDrvUserMask,
      asynInt32Mask | asynUInt32DigitalMask | asynInt32ArrayMask | asynFloat32ArrayMask | asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask,
      // Note: ASYN_CANBLOCK must not be set because the scaler record does not work with asynchronous device support
      ASYN_MULTIDEVICE, 1, /* ASYN_CANBLOCK=0, ASYN_MULTIDEVICE=1, autoConnect=1 */
      0, 0),  /* Default priority and stack size */
    pollTime_((pollTime > 0.) ? pollTime : DEFAULT_POLL_TIME),
    forceCallback_(1),
    maxTimePoints_(maxTimePoints),
    scalerRunning_(false),
    MCSRunning_(false)
{
  int i;
  int status;
  long long handle;
  //static const char *functionName = "USBCTR";

  for (i=0; i<NUM_TIMERS; i++) pulseGenRunning_[i]=0;

  status = measCompCreateDevice(uniqueID, daqDeviceDescriptor_, &handle);
  if (status) {
    printf("Error creating device with measCompCreateDevice\n");
    return;
  }

  #ifdef _WIN32
    boardNum_ = (int) handle;
    strcpy(boardName_, daqDeviceDescriptor_.ProductName);
    boardType_ = daqDeviceDescriptor_.ProductID;
  #else
    daqDeviceHandle_ = handle;
    strcpy(boardName_, daqDeviceDescriptor_.productName);
    boardType_ = daqDeviceDescriptor_.productId;
  #endif

  // Model parameters
  createParam(modelNameString,                 asynParamOctet,  &modelName_);
  createParam(modelNumberString,               asynParamInt32,  &modelNumber_);
  createParam(firmwareVersionString,            asynParamOctet, &firmwareVersion_);
  createParam(uniqueIDString,                   asynParamOctet, &uniqueID_);
  createParam(ULVersionString,                  asynParamOctet, &ULVersion_);
  createParam(driverVersionString,              asynParamOctet, &driverVersion_);
  createParam(pollSleepMSString,              asynParamFloat64, &pollSleepMS_);
  createParam(pollTimeMSString,               asynParamFloat64, &pollTimeMS_);
  createParam(lastErrorMessageString,           asynParamOctet, &lastErrorMessage_);

  // Pulse generator parameters
  createParam(pulseGenRunString,               asynParamInt32, &pulseGenRun_);
  createParam(pulseGenPeriodString,          asynParamFloat64, &pulseGenPeriod_);
  createParam(pulseGenDutyCycleString,       asynParamFloat64, &pulseGenDutyCycle_);
  createParam(pulseGenDelayString,           asynParamFloat64, &pulseGenDelay_);
  createParam(pulseGenCountString,             asynParamInt32, &pulseGenCount_);
  createParam(pulseGenIdleStateString,         asynParamInt32, &pulseGenIdleState_);

  // Counter parameters
  createParam(counterCountsString,             asynParamInt32, &counterCounts_);
  createParam(counterResetString,              asynParamInt32, &counterReset_);

  // Trigger parameters
  createParam(triggerModeString,               asynParamInt32, &triggerMode_);

  // Digital I/O parameters
  createParam(digitalDirectionString,  asynParamUInt32Digital, &digitalDirection_);
  createParam(digitalInputString,      asynParamUInt32Digital, &digitalInput_);
  createParam(digitalOutputString,     asynParamUInt32Digital, &digitalOutput_);

  // MCS parameters other than those in drvMca.h
  createParam(MCSCurrentPointString,           asynParamInt32, &MCSCurrentPoint_);
  createParam(MCSMaxPointsString,              asynParamInt32, &MCSMaxPoints_);
  createParam(MCSTimeWFString,          asynParamFloat32Array, &MCSTimeWF_);
  createParam(MCSAbsTimeWFString,       asynParamFloat64Array, &MCSAbsTimeWF_);
  createParam(MCSCounterEnableString,  asynParamUInt32Digital, &MCSCounterEnable_);
  createParam(MCSPrescaleCounterString,        asynParamInt32, &MCSPrescaleCounter_);
  createParam(MCSPoint0ActionString,           asynParamInt32, &MCSPoint0Action_);

  // MCA record parameters
  createParam(mcaStartAcquireString,                asynParamInt32, &mcaStartAcquire_);
  createParam(mcaStopAcquireString,                 asynParamInt32, &mcaStopAcquire_);            /* int32, write */
  createParam(mcaEraseString,                       asynParamInt32, &mcaErase_);                  /* int32, write */
  createParam(mcaDataString,                   asynParamInt32Array, &mcaData_);                   /* int32Array, read/write */
  createParam(mcaReadStatusString,                  asynParamInt32, &mcaReadStatus_);             /* int32, write */
  createParam(mcaChannelAdvanceSourceString,        asynParamInt32, &mcaChannelAdvanceSource_);   /* int32, write */
  createParam(mcaNumChannelsString,                 asynParamInt32, &mcaNumChannels_);            /* int32, write */
  createParam(mcaDwellTimeString,                 asynParamFloat64, &mcaDwellTime_);              /* float64, write */
  createParam(mcaPresetLiveTimeString,            asynParamFloat64, &mcaPresetLiveTime_);         /* float64, write */
  createParam(mcaPresetRealTimeString,            asynParamFloat64, &mcaPresetRealTime_);         /* float64, write */
  createParam(mcaPresetCountsString,              asynParamFloat64, &mcaPresetCounts_);           /* float64, write */
  createParam(mcaPresetLowChannelString,            asynParamInt32, &mcaPresetLowChannel_);       /* int32, write */
  createParam(mcaPresetHighChannelString,           asynParamInt32, &mcaPresetHighChannel_);      /* int32, write */
  createParam(mcaPresetSweepsString,                asynParamInt32, &mcaPresetSweeps_);           /* int32, write */
  createParam(mcaAcquireModeString,                 asynParamInt32, &mcaAcquireMode_);            /* int32, write */
  createParam(mcaSequenceString,                    asynParamInt32, &mcaSequence_);               /* int32, write */
  createParam(mcaPrescaleString,                    asynParamInt32, &mcaPrescale_);               /* int32, write */
  createParam(mcaAcquiringString,                   asynParamInt32, &mcaAcquiring_);              /* int32, read */
  createParam(mcaElapsedLiveTimeString,           asynParamFloat64, &mcaElapsedLiveTime_);        /* float64, read */
  createParam(mcaElapsedRealTimeString,           asynParamFloat64, &mcaElapsedRealTime_);        /* float64, read */
  createParam(mcaElapsedCountsString,             asynParamFloat64, &mcaElapsedCounts_);          /* float64, read */

  // Scaler record parameters
  createParam(SCALER_RESET_COMMAND_STRING,          asynParamInt32, &scalerReset_);               /* int32, write */
  createParam(SCALER_CHANNELS_COMMAND_STRING,       asynParamInt32, &scalerChannels_);            /* int32, read */
  createParam(SCALER_READ_COMMAND_STRING,      asynParamInt32Array, &scalerRead_);                /* int32Array, read */
  createParam(SCALER_PRESET_COMMAND_STRING,         asynParamInt32, &scalerPresets_);             /* int32, write */
  createParam(SCALER_ARM_COMMAND_STRING,            asynParamInt32, &scalerArm_);                 /* int32, write */
  createParam(SCALER_DONE_COMMAND_STRING,           asynParamInt32, &scalerDone_);                /* int32, read */

  // Model ID
  createParam(modelString,                          asynParamInt32, &model_);                     /* int32, read */

  if (strcmp(boardName_, "USB-CTR08") == 0) {
    setIntegerParam(model_, 0);
    numCounters_ = 8;
  } else if (strcmp(boardName_, "USB-CTR04") == 0) {
    setIntegerParam(model_, 1);
    numCounters_ = 4;
  } else {
    printf("Unknown model\n");
  }

  char uniqueIDStr[256];
  char firmwareVersion[256];
  char ULVersion[256];
  #ifdef _WIN32
    int size = sizeof(uniqueIDStr);
    cbGetConfigString(BOARDINFO, boardNum_, 0, BIDEVUNIQUEID, uniqueIDStr, &size);
    size = sizeof(firmwareVersion);
    cbGetConfigString(BOARDINFO, boardNum_, VER_FW_MAIN, BIDEVVERSION, firmwareVersion, &size);
    float DLLRevNum, VXDRevNum;
    cbGetRevision(&DLLRevNum, &VXDRevNum);
    sprintf(ULVersion, "%f %f", DLLRevNum, VXDRevNum);
  #else
    strcpy(uniqueIDStr, uniqueID);
    unsigned int size = sizeof(firmwareVersion);
    ulDevGetConfigStr(daqDeviceHandle_, ::DEV_CFG_VER_STR, DEV_VER_FW_MAIN, firmwareVersion, &size);
    size = sizeof(ULVersion);
    ulGetInfoStr(UL_INFO_VER_STR, 0, ULVersion, &size);
  #endif
  setIntegerParam(modelNumber_, boardType_);
  setStringParam(modelName_, boardName_);
  setStringParam(uniqueID_, uniqueIDStr);
  setStringParam(firmwareVersion_, firmwareVersion);
  setStringParam(ULVersion_, ULVersion);
  setStringParam(driverVersion_, DRIVER_VERSION);
  
  // Allocate memory for the input buffers
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    MCSBuffer_[i]  = (epicsInt32 *) calloc(maxTimePoints_,  sizeof(epicsInt32));
  }
  MCSTimeBuffer_    = (epicsFloat32 *) calloc(maxTimePoints_,  sizeof(epicsFloat32));
  MCSAbsTimeBuffer_ = (epicsFloat64 *) calloc(maxTimePoints_,  sizeof(epicsFloat64));
  for (i=0; i<MAX_DAQ_LEN; i++) {
    gainArray_[i] = BIP10VOLTS;
  }
  pCountsF64_  = (epicsFloat64 *) calloc((maxTimePoints+1)  * MAX_MCS_COUNTERS, sizeof(epicsFloat64));
  pCountsUI64_ = (epicsUInt64 *)pCountsF64_;
  pCountsI32_ = (epicsInt32 *)pCountsF64_;
  pCountsI16_ = (epicsInt16 *)pCountsF64_;

  // Set values of some parameters that need to be set because init record order is not predictable
  // or because the corresponding records are PINI=NO.
  setIntegerParam(pulseGenRun_, 0);
  setIntegerParam(scalerDone_, 1);
  setIntegerParam(scalerChannels_, numCounters_);
  setIntegerParam(MCSMaxPoints_, maxTimePoints_);
  setIntegerParam(mcaNumChannels_, maxTimePoints_);
  resetScaler();
  clearScalerPresets();
  MCSErased_ = false;

  eraseMCS();

  // Put pulse generators in known state
  for (i=0; i<NUM_TIMERS; i++) {
    stopPulseGenerator(i);
  }

  /* Start the thread to poll counters and digital inputs and do callbacks to
   * device support */
  epicsThreadCreate("USBCTRPoller",
                    epicsThreadPriorityLow,
                    epicsThreadGetStackSize(epicsThreadStackMedium),
                    (EPICSTHREADFUNC)pollerThreadC,
                    this);
}

char *USBCTR::getErrorMessage(int error)
{
  #ifdef _WIN32
      cbGetErrMsg(error, errorMessage_);
  #else
      ulGetErrMsg((UlError)error, errorMessage_);
  #endif
  return errorMessage_;
}

int USBCTR::startPulseGenerator(int timerNum)
{
  int status=0;
  double frequency, period, delay;
  double dutyCycle;
  int count, idleState;
  static const char *functionName = "startPulseGenerator";

  getDoubleParam (timerNum, pulseGenPeriod_,    &period);
  getDoubleParam (timerNum, pulseGenDutyCycle_, &dutyCycle);
  getDoubleParam (timerNum, pulseGenDelay_,     &delay);
  getIntegerParam(timerNum, pulseGenCount_,     &count);
  getIntegerParam(timerNum, pulseGenIdleState_, &idleState);

  frequency = 1./period;
  if (frequency < MIN_FREQUENCY) frequency = MIN_FREQUENCY;
  if (frequency > MAX_FREQUENCY) frequency = MAX_FREQUENCY;
  period = 1. / frequency;
  if (dutyCycle <= 0.) dutyCycle = .0001;
  if (dutyCycle >= 1.) dutyCycle = .9999;
  if (delay < MIN_DELAY) delay = MIN_DELAY;
  if (delay > MAX_DELAY) delay = MAX_DELAY;

  #ifdef _WIN32
    status = cbPulseOutStart(boardNum_, timerNum, &frequency, &dutyCycle, count, &delay, idleState, 0);
  #else
    TmrIdleState idle = (idleState == 0) ? TMRIS_LOW : TMRIS_HIGH;
    status = ulTmrPulseOutStart(daqDeviceHandle_, timerNum, &frequency, &dutyCycle, count, &delay, idle, PO_DEFAULT);
  #endif
  if (status != 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbPulseOutStart timerNum=%d frequency=%f, dutyCycle=%f,"
      " count=%d, delay=%f, idleState=%d, status=%d, error=%s\n",
      driverName, functionName, timerNum, frequency, dutyCycle,
      count, delay, idleState, status, getErrorMessage(status));
    return status;
  }
  // We may not have gotten the frequency, dutyCycle, and delay we asked for, set the actual values
  // in the parameter library
  pulseGenRunning_[timerNum] = true;
  period = 1. / frequency;
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: started pulse generator %d actual frequency=%f, actual period=%f, actual duty cycle=%f, actual delay=%f\n",
    driverName, functionName, timerNum, frequency, period, dutyCycle, delay);
  setDoubleParam(timerNum, pulseGenPeriod_, period);
  setDoubleParam(timerNum, pulseGenDutyCycle_, dutyCycle);
  setDoubleParam(timerNum, pulseGenDelay_, delay);
  return 0;
}

int USBCTR::stopPulseGenerator(int timerNum)
{
  int status;
  static const char *functionName = "stopPulseGenerator";

  pulseGenRunning_[timerNum] = false;
  #ifdef _WIN32
    status = cbPulseOutStop(boardNum_, timerNum);
  #else
    status = ulTmrPulseOutStop(daqDeviceHandle_, timerNum);
  #endif
  if (status != 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbPulseOutStop timerNum=%d, status=%d, error=%s\n",
      driverName, functionName, timerNum, status, getErrorMessage(status));
  }
  return status;
}

int USBCTR::startMCS()
{
  int numPoints;
  int i;
  int options;
  int status;
  epicsUInt32 counterEnable;
  int prescale;
  int prescaleCounter;
  int mode;
  int point0Action;
  double dwell;
  int channelAdvance;
  static const char *functionName = "startMCS";

  getIntegerParam(MCSPrescaleCounter_, &prescaleCounter);
  getIntegerParam(mcaPrescale_, &prescale);
  getIntegerParam(mcaChannelAdvanceSource_, &channelAdvance);
  getUIntDigitalParam(MCSCounterEnable_,  &counterEnable, 0xFFFFFFFF);

  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    mcsCounterEnable_[i] = (counterEnable & (1<<i)) ? true : false;
  }
  numMCSCounters_ = 0;
  for (i=0; i<numCounters_; i++) {
    if (!mcsCounterEnable_[i]) continue;
    numMCSCounters_++;
    #ifdef _WIN32
      mode = OUTPUT_ON | CLEAR_ON_READ;
      status = cbCConfigScan(boardNum_, i, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
    #else
      mode = CMM_OUTPUT_ON | CMM_CLEAR_ON_READ;
      status = ulCConfigScan(daqDeviceHandle_, i, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
        driverName, functionName, i, mode, status, getErrorMessage(status));
    }
  }

  if ((channelAdvance == mcaChannelAdvance_External) && (prescale > 1) ) {
    #ifdef _WIN32
      status = cbCLoad32(boardNum_, OUTPUTVAL0REG0+prescaleCounter, 0);
      status = cbCLoad32(boardNum_, OUTPUTVAL1REG0+prescaleCounter, prescale-1);
      status = cbCLoad32(boardNum_, MAXLIMITREG0+prescaleCounter, prescale-1);
      mode = OUTPUT_ON | RANGE_LIMIT_ON;
      status = cbCConfigScan(boardNum_, prescaleCounter, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_OUTPUT_VAL0, 0);
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_OUTPUT_VAL1, prescale-1);
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_MAX_LIMIT, prescale-1);
      mode = CMM_OUTPUT_ON | CMM_RANGE_LIMIT_ON;
      status = ulCConfigScan(daqDeviceHandle_, prescaleCounter, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
        driverName, functionName, prescaleCounter, mode, status, getErrorMessage(status));
    }
  }
  getIntegerParam(mcaNumChannels_, &numPoints);
  getDoubleParam(mcaDwellTime_, &dwell);
  getIntegerParam(MCSPoint0Action_, &point0Action);
  if (point0Action == MCSPoint0Skip) numPoints++;
  #ifdef _WIN32
    long count;
    int chanCount;
    long pretrigCount = 0;
    double rateFactor=1.0;
    if (dwell > 1e-6) rateFactor = 1000.;
    long rate = (LONG)((rateFactor / dwell) + 0.5);
    options = 0;
    if (dwell > 1e-4) {
      counterBits_ = 32;
    } else {
      counterBits_ = 16;
    }
    options |= BACKGROUND;
    if (rateFactor > 1.0)
      options |= HIGHRESRATE;
    if (channelAdvance == mcaChannelAdvance_External)
      options |= EXTCLOCK;
    // At long dwell times read use a single buffer for reading the data
    if (dwell >= SINGLEIO_THRESHOLD_TIME)
      options |= SINGLEIO;
    // Always use EXTTRIGGER
    options |= EXTTRIGGER;
    if (point0Action == MCSPoint0NoClear)
      options |= NOCLEAR;
  
    for (i=0, chanCount=0; i<numCounters_; i++) {
      if (!mcsCounterEnable_[i]) continue;
      chanArray_[chanCount] = i;
      chanTypeArray_[chanCount] = CTRBANK0;
      chanCount++;
      if (counterBits_ == 16) continue;
      chanArray_[chanCount] = i;
      chanTypeArray_[chanCount] = CTRBANK1;
      chanCount++;
    }
    if (mcsCounterEnable_[DIGITAL_IO_COUNTER]) {
      numMCSCounters_++;
      chanArray_[chanCount] = AUXPORT;
      chanTypeArray_[chanCount] = DIGITAL8;
      chanCount++;
      if (counterBits_ == 32) { // Add padding for binary data
        chanArray_[chanCount] = 0;
        chanTypeArray_[chanCount] = PADZERO;
        chanCount++;
      }
    }
    count = chanCount * numPoints;
    status = cbDaqInScan(boardNum_, chanArray_, chanTypeArray_, gainArray_, chanCount, &rate,
                         &pretrigCount, &count, pCountsI16_, options);
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
      "%s::%s called cbDaqInScan, chanCount=%d, count=%ld, rate=%ld,"
      " inputMemHandle_=%p, options=0x%x, status=%d\n",
      driverName, functionName, chanCount, count, rate,
      pCountsI16_, options, status);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbDaqInScan, chanCount=%d, count=%ld, rate=%ld,"
        " inputMemHandle_=%p, options=0x%x, status=%d, error=%s\n",
        driverName, functionName, chanCount, count, rate,
        pCountsI16_, options, status, getErrorMessage(status));
    }
    // The actual dwell time can be different from requested due to clock granularity
    setDoubleParam(mcaDwellTime_, rateFactor/rate);
  #else
    double rate = 1. / dwell;  
    options = SO_DEFAULTIO;
    if (channelAdvance == mcaChannelAdvance_External)
      options |= SO_EXTCLOCK;
    // At long dwell times read use a single buffer for reading the data
    if (dwell >= SINGLEIO_THRESHOLD_TIME)
      options |= SO_SINGLEIO;
    // Always use EXTTRIGGER
    options |= SO_EXTTRIGGER;
    int flags = DAQINSCAN_FF_DEFAULT;
    if (point0Action == MCSPoint0NoClear)
      flags |= DAQINSCAN_FF_NOCLEAR;
    DaqInChanDescriptor *pDICD = new DaqInChanDescriptor[MAX_MCS_COUNTERS];
    int outChan=0;
    for (i=0; i<numCounters_; i++) {
      if (!mcsCounterEnable_[i]) continue;
      pDICD[outChan].channel = i;
      pDICD[outChan].type = DAQI_CTR32;
      pDICD[outChan].range = BIP10VOLTS;
      outChan++;
    }
    if (mcsCounterEnable_[DIGITAL_IO_COUNTER]) {
      numMCSCounters_++;
      pDICD[outChan].channel = AUXPORT;
      pDICD[outChan].type = DAQI_DIGITAL;
      pDICD[outChan].range = BIP10VOLTS;
      outChan++;
    }
    int numChans = outChan;
    status = ulDaqInScan(daqDeviceHandle_, pDICD, numChans, numPoints, &rate, (ScanOption) options, (DaqInScanFlag) flags, pCountsF64_);
    delete[] pDICD;
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling ulDaqInScan, numChans=%d, numPoints=%d, rate=%f, options=0x%x, flags=0x%x, status=%d, error=%s\n",
        driverName, functionName, numChans, numPoints, rate,
        options, status, flags, getErrorMessage(status));
    }
    // The actual dwell time can be different from requested due to clock granularity
    setDoubleParam(mcaDwellTime_, 1./rate);
  #endif
  setIntegerParam(MCSCurrentPoint_, 0);
  MCSRunning_ = true;

  return 0;
}

int USBCTR::readMCS()
{
  int lastPoint=0;
  int currentPoint;
  int status;
  int i, j;
  short ctrStatus;
  long ctrCount, ctrIndex;
  epicsTimeStamp now;
  int numTimePoints;
  int point0Action;
  double presetReal, elapsedTime;
  static const char *functionName = "readMCS";

  // We need to treat Windows and Linux differently here because with UL for Linux the buffer is always float64, while on
  // Windows it is either int32 or int16.
  getIntegerParam(MCSCurrentPoint_, &currentPoint);
  getIntegerParam(mcaNumChannels_,  &numTimePoints);
  getIntegerParam(MCSPoint0Action_, &point0Action);
  #ifdef _WIN32
    status = cbGetIOStatus(boardNum_, &ctrStatus, &ctrCount, &ctrIndex, DAQIFUNCTION);
  #else
    ScanStatus scanStatus;
    TransferStatus xferStatus;
    status = ulDaqInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
    ctrStatus = scanStatus;
    ctrCount = xferStatus.currentTotalCount;
    ctrIndex = xferStatus.currentIndex;
  #endif
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s getStatus returned status=%d, ctrStatus=%d, ctrCount=%ld, ctrIndex=%ld\n",
    driverName, functionName, status, ctrStatus, ctrCount, ctrIndex);
  if (ctrStatus == 0) {
    MCSRunning_ = false;
  }
  if (ctrIndex >= 0) {
#ifdef _WIN32
    if (counterBits_ == 32) ctrIndex /= 2;
#endif
    lastPoint = ctrIndex / numMCSCounters_ + 1;

    int inPtr = currentPoint;
    if (point0Action == MCSPoint0Skip) {
      inPtr++;
    }
    epicsTimeStamp now;
    epicsTimeGetCurrent(&now);
    for(; inPtr < lastPoint; inPtr++) {
      for (i=0, j=0; i<MAX_MCS_COUNTERS; i++) {
        if (!mcsCounterEnable_[i]) continue;
#ifdef _WIN32
        if (counterBits_ == 32) {
          MCSBuffer_[i][currentPoint] = pCountsI32_[inPtr*numMCSCounters_ + j];
          // There seems to be a bug in PADZERO and it is actually giving counter0 value not 0
          if (i == DIGITAL_IO_COUNTER) MCSBuffer_[i][currentPoint] &= 0xff;
        } else {
          MCSBuffer_[i][currentPoint] = pCountsI16_[inPtr*numMCSCounters_ + j];
        }
#else
          MCSBuffer_[i][currentPoint] = (int) pCountsF64_[inPtr*numMCSCounters_ + j];
#endif
        j++;
      }
      MCSAbsTimeBuffer_[currentPoint] = now.secPastEpoch + now.nsec/1.e9;
      currentPoint++;
    }
  }
  setIntegerParam(MCSCurrentPoint_, currentPoint);

  getDoubleParam(mcaPresetRealTime_,  &presetReal);
  getDoubleParam(mcaElapsedRealTime_, &elapsedTime);
  epicsTimeGetCurrent(&now);
  elapsedTime = epicsTimeDiffInSeconds(&now, &startTime_);
  if (MCSRunning_ && (presetReal > 0) && (elapsedTime >= presetReal)) {
    MCSRunning_ = false;
  }

  // Set elapsed times
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    setDoubleParam(i, mcaElapsedRealTime_, elapsedTime);
    setDoubleParam(i, mcaElapsedLiveTime_, elapsedTime);
  }

  if (!MCSRunning_) {
    stopMCS();
    for (i=0; i<numCounters_; i++) {
      setIntegerParam(i, mcaAcquiring_, 0);
    }
  }

  // Do callbacks on all channels
  for (i=0; i<numCounters_; i++) {
    callParamCallbacks(i);
  }

  return 0;
}

int USBCTR::eraseMCS()
{
  int i;
  int numTimePoints;
  //static const char *functionName="eraseMCS";

  MCSErased_ = true;

  getIntegerParam(mcaNumChannels_, &numTimePoints);

  /* Reset pointers to start of buffer */
  setIntegerParam(MCSCurrentPoint_, 0);

  /* Reset the elapsed time and counts */
  elapsedPrevious_ = 0.;
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    memset(MCSBuffer_[i], 0, numTimePoints * sizeof(epicsUInt32));
    setDoubleParam(i, mcaElapsedLiveTime_, 0.0);
    setDoubleParam(i, mcaElapsedRealTime_, 0.0);
    setDoubleParam(i, mcaElapsedCounts_, 0.0);
    callParamCallbacks(i);
  }

  /* Reset the start time.  This is necessary here because we may be
   * acquiring, and AcqOn will not be called. Normally this is set in AcqOn.
   */
  epicsTimeGetCurrent(&startTime_);

  return 0;
}

int USBCTR::stopMCS()
{
  int status;
  static const char *functionName = "stopMCS";

  if (MCSRunning_) {
    // Forced stop
    MCSRunning_ = false;
    readMCS();
    // readMCS will call this function when it finds MCSRunning=false so we can return now
    return 0;
  }
  #ifdef _WIN32
    status = cbStopBackground(boardNum_, DAQIFUNCTION);
  #else
    status = ulDaqInScanStop(daqDeviceHandle_);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s ERROR calling cbStopBackground(CTRFUNCTION), status=%d, error=%s\n",
      driverName, functionName, status, getErrorMessage(status));
  }
  return status;
}

int USBCTR::computeMCSTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(mcaNumChannels_, &numPoints);
  getDoubleParam(mcaDwellTime_, &dwell);
  for (i=0; i<numPoints; i++) {
    MCSTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(MCSTimeBuffer_, numPoints, MCSTimeWF_, 0);
  return 0;
}

int USBCTR::startScaler()
{
  int status;
  int i;
  int mode;
  int samplesPerCounter = 20;
  long rate = 100;
  int firstCounter = 0;
  int lastCounter = numCounters_ - 1;
  int options;
  static const char *functionName = "startScaler";

  #ifdef _WIN32
    for (i=0; i<numCounters_; i++) {
      mode = OUTPUT_ON | COUNT_DOWN_OFF | GATING_ON;
      if (i == 0) mode = mode | RANGE_LIMIT_ON | NO_RECYCLE_ON | INVERT_GATE;
      status = cbCConfigScan(boardNum_, i, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
          driverName, functionName, i, mode, status, getErrorMessage(status));
      }
    }
    int count = samplesPerCounter * numCounters_;
    options = BACKGROUND | CONTINUOUS | CTR64BIT | SINGLEIO;
    status = cbCInScan(boardNum_, firstCounter, lastCounter, count, &rate,
                       pCountsUI64_, options);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCInScan, firstCounter=%d, lastCounter=%d, count=%d, rate=%d, options=0x%x, status=%d, error=%s\n",
        driverName, functionName, firstCounter, lastCounter, count, rate, options, status, getErrorMessage(status));
    }
  #else
    for (i=0; i<numCounters_; i++) {
      mode = CMM_OUTPUT_ON | CMM_GATING_ON;
      if (i == 0) mode = mode | CMM_RANGE_LIMIT_ON | CMM_NO_RECYCLE | CMM_INVERT_GATE;
      status = ulCConfigScan(daqDeviceHandle_, i, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling ulCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
          driverName, functionName, i, mode, status, getErrorMessage(status));
      }
    }
    options = SO_CONTINUOUS | SO_SINGLEIO;
    double dblRate = (double) rate;
    CInScanFlag flags = CINSCAN_FF_CTR64_BIT;
    status = ulCInScan(daqDeviceHandle_, firstCounter, lastCounter, samplesPerCounter, &dblRate, (ScanOption) options, flags, pCountsUI64_);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling ulCInScan, firstCounter=%d, lastCounter=%d, samplesPerCounter=%d, rate=%d, options=0x%x, flags=0x%x, status=%d, error=%s\n",
        driverName, functionName, firstCounter, lastCounter, samplesPerCounter, (int) rate, options, flags, status, getErrorMessage(status));
    }
  #endif
  scalerRunning_ = true;
  return 0;
}

int USBCTR::readScaler()
{
  int numValues;
  int i, j;
  int status;
  short ctrStatus;
  long ctrCount, ctrIndex;
  int lastIndex;
  bool scalerDone = false;
  static const char *functionName = "readScaler";

  // Poll the status of the counter scan
  #ifdef _WIN32
    status = cbGetIOStatus(boardNum_, &ctrStatus, &ctrCount, &ctrIndex, CTRFUNCTION);
  #else
    ScanStatus scanStatus;
    TransferStatus xferStatus;
    status = ulDaqInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
    ctrStatus = scanStatus;
    ctrCount = xferStatus.currentTotalCount;
    ctrIndex = xferStatus.currentIndex;
  #endif
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s getStatus returned status=%d, ctrStatus=%d, ctrCount=%ld, ctrIndex=%ld\n",
    driverName, functionName, status, ctrStatus, ctrCount, ctrIndex);

  numValues = ctrIndex + 1;
  // Get the index of the start of the last complete set of counts in the buffer
  if (numValues < numCounters_) return 0;
  lastIndex = (numValues/numCounters_ - 1) * numCounters_;
  for (i=0; i<=lastIndex; i+= numCounters_) {
    for (j=0; j<numCounters_; j++) {
      scalerCounts_[j] = (epicsInt32) pCountsUI64_[i+j];
      if ((scalerPresetCounts_[j] > 0) && (scalerCounts_[j] >= scalerPresetCounts_[j])) {
        scalerDone = true;
      }
    }
    if (scalerDone) {
      stopScaler();
      break;
    }
  }
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s lastIndex=%d, scalerCounts_[0]=%d, scalerPresetCounts_[0]=%d\n",
    driverName, functionName, lastIndex, scalerCounts_[0], scalerPresetCounts_[0]);
  return 0;
}

int USBCTR::stopScaler()
{
  int status;
  static const char *functionName = "stopScaler";

  #ifdef _WIN32
    status = cbStopBackground(boardNum_, CTRFUNCTION);
  #else
    status = ulCInScanStop(daqDeviceHandle_);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s ERROR calling cbStopBackground(CTRFUNCTION), status=%d, error=%s\n",
      driverName, functionName, status, getErrorMessage(status));
  }
  scalerRunning_ = false;
  setIntegerParam(scalerDone_, 1);
  return status;
}

int USBCTR::resetScaler()
{
  int i;
  int status=0;

  /* Reset scaler */
  if (scalerRunning_) {
    status = stopScaler();
  }
  for (i=0; i<numCounters_; i++) {
    scalerCounts_[i] = 0;
  }
  return status;
}


int USBCTR::clearScalerPresets()
{
  int i;

  for (i=0; i<numCounters_; i++) {
    scalerPresetCounts_[i] = 0;
  }
  return 0;
}

int USBCTR::setScalerPresets()
{
  int i;
  int status;
  static const char *functionName = "setScalerPresets";

  for (i=0; i<numCounters_; i++) {
    getIntegerParam(i, scalerPresets_, &scalerPresetCounts_[i]);
    if (scalerPresetCounts_[i] > 0) {
      #ifdef _WIN32
        status = cbCLoad32(boardNum_, MAXLIMITREG0+i, scalerPresetCounts_[i]);
      #else
        status = ulCLoad(daqDeviceHandle_, i, CRT_MAX_LIMIT, scalerPresetCounts_[i]);
      #endif
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling cbCLoad32, counter=%d, presetCounts=%d, status=%d, error=%s\n",
          driverName, functionName, i, scalerPresetCounts_[i], status, getErrorMessage(status));
      }
    }
  }
  // For counter0 output register 0 and 1 control when the counter output goes low and high
  #ifdef _WIN32
    status = cbCLoad32(boardNum_, OUTPUTVAL0REG0, 0);
  #else 
    status = ulCLoad(daqDeviceHandle_, 0, CRT_OUTPUT_VAL0, 0);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbCLoad32, reg=OUTPUTVAL0REG0, value=%d, status=%d, error=%s\n",
      driverName, functionName, 0, status, getErrorMessage(status));
  }
  #ifdef _WIN32
    status = cbCLoad32(boardNum_, OUTPUTVAL1REG0, scalerPresetCounts_[0]);
  #else 
    status = ulCLoad(daqDeviceHandle_, 0, CRT_OUTPUT_VAL1, scalerPresetCounts_[0]);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbCLoad32, reg=OUTPUTVAL1REG0, value=%d, status=%d, error=%s\n",
      driverName, functionName, scalerPresetCounts_[0], status, getErrorMessage(status));
  }

  return 0;
}

asynStatus USBCTR::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  int numTimePoints;
  int currentPoint;
  int i;
  static const char *functionName = "writeInt32";

  this->getAddress(pasynUser, &addr);
  setIntegerParam(addr, function, value);

  // Pulse generator functions
  if (function == pulseGenRun_) {
    // Allow starting a run even if it thinks its running,
    // since there is no way to know when it got done if Count!=0
    if (value) {
      status = startPulseGenerator(addr);
    }
    else if (!value && pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
    }
  }
  if ((function == pulseGenCount_) ||
      (function == pulseGenIdleState_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Counter functions
  if (function == counterReset_) {
    #ifdef _WIN32
      // LOADREG0=0, LOADREG1=1, so we use addr
      status = cbCLoad32(boardNum_, addr, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, addr, CRT_LOAD, 0);
    #endif
  }

  // Trigger functions
  if (function == triggerMode_) {
    #ifdef _WIN32
      status = cbDaqSetTrigger(boardNum_, TRIG_EXTTTL, value, 0, CTRBANK0, 0, 0, 0, START_EVENT);
    #else
      TriggerType triggerType = TRIG_LOW;
      // We map the UL Windows trigger types to Ul Linux
      // We can't use macros from cbw.h because that file conflicts with uldaq.h
      switch (value) {
        case 0: triggerType = TRIG_RISING; break;
        case 1: triggerType = TRIG_FALLING; break;
        case 6: triggerType = TRIG_HIGH; break;
        case 7: triggerType = TRIG_LOW; break;
        default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
            "%s::%s error unsupported trigger value=%d\n",
            driverName, functionName, value);
          break;
      }
      DaqInChanDescriptor trigChanDescriptor;
      status = ulDaqInSetTrigger(daqDeviceHandle_, triggerType, trigChanDescriptor, 0, 0, 0);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbDaqSetTrigger status=%d, error=%s\n",
        driverName, functionName, status, getErrorMessage(status));
    }
  }

  // Scaler functions
  else if (function == scalerReset_) {
    /* Reset scaler */
    if (MCSRunning_) goto done;
    resetScaler();
    scalerRunning_ = false;
    /* Clear all of the presets and counts*/
    for (i=0; i<numCounters_; i++) {
      scalerCounts_[i] = 0;
      setIntegerParam(i, scalerPresets_, 0);
    }
  }

  else if (function == scalerArm_) {
    if (MCSRunning_) goto done;
    /* Arm or disarm scaler */
    if (value != 0) {
      setScalerPresets();
      startScaler();
    } else {
      stopScaler();
    }
    setIntegerParam(scalerDone_, 0);
  }

  // MCA commands
  getIntegerParam(mcaNumChannels_, &numTimePoints);
  if (function == mcaStartAcquire_) {
    if (scalerRunning_) {
      status = -1;
      goto done;
    }
    if (MCSRunning_) goto done;
    // If we have already completed acquisition due to nextChan_, don't start, signal error
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    if (currentPoint >= numTimePoints) {
        // Must toggle mcaAcquiring to 1 and back to 0 to signal SNL program to clear Acquiring
      setIntegerParam(mcaAcquiring_, 1);
      callParamCallbacks();
      setIntegerParam(mcaAcquiring_, 0);
      goto done;
    }
    setIntegerParam(mcaAcquiring_, 1);
    MCSErased_ = false;
    // Set the acquisition start time
    epicsTimeGetCurrent(&startTime_);
    // Start the hardware
    startMCS();
  }

  else if (function == mcaStopAcquire_) {
    if (scalerRunning_) goto done;
    /* Stop data acquisition */
    if (!MCSRunning_) {
      // We are not acquiring.
      status = asynSuccess;
      goto done;
    }
    // Stop the hardware
    stopMCS();
  }

  else if (function == mcaErase_) {
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: [%s addr=%d]: erased\n",
              driverName, functionName, portName, addr);

    /* Erase the buffer in the private data structure */
    eraseMCS();

  }

  else if (function == mcaNumChannels_) {
    /* Terminology warning:
     * This is the number of channels that are to be acquired. Channels
     * correspond to time bins or external channel advance triggers, as
     * opposed to the 8 input counters that the USB-CTR08 supports.
     */
    if (value > maxTimePoints_) {
      setIntegerParam(mcaNumChannels_, maxTimePoints_);
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
                "%s:%s:  # channels=%d too large, max=%d\n",
                driverName, functionName, value, maxTimePoints_);
    }
  }

  done:
  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, function=%d, wrote %d to address %d\n",
             driverName, functionName, this->portName, function, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, function=%d, ERROR writing %d to address %d, status=%d\n",
             driverName, functionName, this->portName, function, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}


asynStatus USBCTR::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  //static const char *functionName = "readInt32";

  this->getAddress(pasynUser, &addr);

  if (function == scalerRead_) {
    /* Read a single scaler channel */
    *value = scalerCounts_[addr];
  }

  // Other functions we call the base class method
  else {
     status = asynPortDriver::readInt32(pasynUser, value);
  }

  callParamCallbacks(addr);
  return (status==0) ? asynSuccess : asynError;
}

asynStatus USBCTR::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  static const char *functionName = "writeFloat64";

  this->getAddress(pasynUser, &addr);
  setDoubleParam(addr, function, value);

  // Pulse generator functions
  if ((function == pulseGenPeriod_)    ||
      (function == pulseGenDutyCycle_) ||
      (function == pulseGenDelay_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // MCS functions
  else if (function == mcaDwellTime_) {
    computeMCSTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %f to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing %f to address %d, status=%d\n",
             driverName, functionName, this->portName, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

asynStatus USBCTR::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
  int function = pasynUser->reason;
  int status=0;
  int i;
  epicsUInt32 outValue=0, outMask, direction;
  static const char *functionName = "writeUInt32Digital";


  setUIntDigitalParam(function, value, mask);
  if (function == digitalDirection_) {
    for (i=0; i<NUM_IO_BITS; i++) {
      if ((mask & (1<<i)) != 0) {
        #ifdef _WIN32
          int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
          status = cbDConfigBit(boardNum_, AUXPORT, i, dir);
        #else
          DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
          status = ulDConfigBit(daqDeviceHandle_, AUXPORT, i, dir);
        #endif
      }
    }
  }

  else if (function == digitalOutput_) {
    getUIntDigitalParam(digitalDirection_, &direction, 0xFFFFFFFF);
    for (i=0, outMask=1; i<NUM_IO_BITS; i++, outMask = (outMask<<1)) {
      // Only write the value if the mask has this bit set and the direction for that bit is output (1)
      outValue = ((value &outMask) == 0) ? 0 : 1;
      if ((mask & outMask & direction) != 0) {
        #ifdef _WIN32
          status = cbDBitOut(boardNum_, AUXPORT, i, outValue);
        #else
          status = ulDBitOut(daqDeviceHandle_, AUXPORT, i, outValue);
        #endif
      }
    }
  }

  callParamCallbacks();
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote outValue=0x%x, value=0x%x, mask=0x%x, direction=0x%x\n",
             driverName, functionName, this->portName, outValue, value, mask, direction);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing outValue=0x%x, value=0x%x, mask=0x%x, direction=0x%x, status=%d\n",
             driverName, functionName, this->portName, outValue, value, mask, direction, status);
  }
  return (status==0) ? asynSuccess : asynError;
}


asynStatus USBCTR::readInt32Array(asynUser *pasynUser, epicsInt32 *data,
                                  size_t numRead, size_t *numActual)
{
  int signal;
  int command;
  const char *paramName;
  asynStatus status = asynSuccess;
  int currentPoint;
  size_t i;
  static const char* functionName="readInt32Array";

  parseAsynUser(pasynUser, &command, &signal, &paramName);
  pasynManager->getAddr(pasynUser, &signal);
  asynPrint(pasynUser, ASYN_TRACE_FLOW,
            "%s:%s: entry, command=%d, signal=%d, numRead=%d, &data=%p\n",
            driverName, functionName, command, signal, (int)numRead, data);

  if (command == mcaData_) {
    /* Transfer the data from the private driver structure to the supplied data
     * buffer. The private data structure will have the information for all the
     * signals, so we need to just extract the signal being requested.
     */
    int nChans;
    int numCopy;
    getIntegerParam(mcaNumChannels_, &nChans);
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    numCopy = (int)numRead;
    if (numCopy > nChans) numCopy = nChans;
    // We copy all the channels but we only report nchans
    // This ensures the entire array is correct even if it was not set to zero at the start
    memcpy(data, MCSBuffer_[signal], numCopy*sizeof(epicsInt32));
    *numActual = numRead;
    if ((int)*numActual > currentPoint) *numActual = currentPoint;
    // Make it set NORD non-zero?
    if (*numActual == 0) *numActual = 1;
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: [signal=%d]: read %d chans (numRead=%d, numCopy=%d, currentPoint=%d, nChans=%d)\n",
              driverName, functionName, signal, (int)*numActual, (int)numRead, numCopy, currentPoint, nChans);
    }
  else if (command == scalerRead_) {
    for (i=0; (i<numRead && i<(size_t)numCounters_); i++) {
      data[i] = scalerCounts_[i];
    }
    for (i=numCounters_; i<numRead; i++) {
      data[i] = 0;
    }
    *numActual = numRead;
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: scalerReadCommand: read %d chans, data=%d %d %d %d %d %d %d %d\n",
              driverName, functionName, (int)numRead, data[0], data[1], data[2], data[3],
                                                      data[4], data[5], data[6], data[7]);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
              "%s:%s: got illegal command %d\n",
              driverName, functionName, command);
    status = asynError;
  }
  return status;
}


asynStatus USBCTR::readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat32 *inPtr;
  static const char *functionName = "readFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (function == MCSTimeWF_) {
    inPtr = MCSTimeBuffer_;
    getIntegerParam(mcaNumChannels_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat32));

  return asynSuccess;
}

asynStatus USBCTR::readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat64 *inPtr;
  static const char *functionName = "readFloat6Array";

  this->getAddress(pasynUser, &addr);

  if (function == MCSAbsTimeWF_) {
    inPtr = MCSAbsTimeBuffer_;
    getIntegerParam(mcaNumChannels_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat64));

  return asynSuccess;
}

void USBCTR::pollerThread()
{
  /* This function runs in a separate thread.  It waits for the poll
   * time */
  static const char *functionName = "pollerThread";
  epicsUInt32 newValue, changedBits, prevInput=0;
  epicsTime startTime=epicsTime::getCurrent(), endTime, currentTime;
  unsigned short biVal;;
  int i;
  int status;

  while(1) {
    lock();
    endTime = epicsTime::getCurrent();
    setDoubleParam(pollTimeMS_, (endTime-startTime)*1000.);
    startTime = epicsTime::getCurrent();

    // Read the digital inputs
    #ifdef _WIN32
      status = cbDIn(boardNum_, AUXPORT, &biVal);
    #else
      unsigned long long data;
      status = ulDIn(daqDeviceHandle_, AUXPORT, &data);
      biVal = (unsigned short) data;
    #endif
    if (status)
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                "%s:%s: ERROR calling cbDIn, status=%d\n",
                driverName, functionName, status);
    newValue = biVal;
    changedBits = newValue ^ prevInput;
    if (forceCallback_ || (changedBits != 0)) {
      prevInput = newValue;
      forceCallback_ = 0;
      setUIntDigitalParam(digitalInput_, newValue, 0xFFFFFFFF);
    }

    if (scalerRunning_) {
      readScaler();
    }

    if (MCSRunning_) {
      readMCS();
    }

    for (i=0; i<MAX_SIGNALS; i++) {
      callParamCallbacks(i);
    }
    double pollTime;
    getDoubleParam(pollSleepMS_, &pollTime);
    unlock();
    epicsThreadSleep(pollTime/1000.);
  }
}


/* Report  parameters */
void USBCTR::report(FILE *fp, int details)
{
  int i;
  int currentPoint;

  fprintf(fp, "  Port: %s, pollTime=%f\n",
          this->portName, pollTime_);
  if (details >= 1) {
    fprintf(fp, "  Pulse generators:\n");
    for (i=0; i<NUM_TIMERS; i++) {
      fprintf(fp, "    %d: Running:%d\n", i, pulseGenRunning_[i]);
    }
    fprintf(fp, "  numCounters: %d\n", numCounters_);
    fprintf(fp, "  Scaler:\n");
    fprintf(fp, "    Running: %d\n", scalerRunning_);
    for (i=0; i<numCounters_; i++) {
      fprintf(fp, "    %d: preset=%d, count=%d\n", i, scalerPresetCounts_[i], scalerCounts_[i]);
    }
    fprintf(fp, "  MCS:\n");
    fprintf(fp, "    Running: %d\n", MCSRunning_);
    fprintf(fp, "    maxTimePoints: %d\n", maxTimePoints_);
    fprintf(fp, "    MCSErased: %d\n", MCSErased_);
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    fprintf(fp, "    currentPoint: %d\n", currentPoint);
  }
  asynPortDriver::report(fp, details);
}

/** Configuration command, called directly or from iocsh */
extern "C" int USBCTRConfig(const char *portName, const char *uniqueID,
                            int maxTimePoints, double pollTime)
{
  new USBCTR(portName, uniqueID, maxTimePoints, pollTime);
  return(asynSuccess);
}


static const iocshArg configArg0 = { "Port name",             iocshArgString};
static const iocshArg configArg1 = { "uniqueID",              iocshArgString};
static const iocshArg configArg2 = { "Max. # of time points", iocshArgInt};
static const iocshArg configArg3 = { "Poll time",             iocshArgDouble};
static const iocshArg * const configArgs[] = {&configArg0,
                                              &configArg1,
                                              &configArg2,
                                              &configArg3};
static const iocshFuncDef configFuncDef = {"USBCTRConfig",4,configArgs};
static void configCallFunc(const iocshArgBuf *args)
{
  USBCTRConfig(args[0].sval, args[1].sval, args[2].ival, args[3].dval);
}

void drvUSBCTRRegister(void)
{
  iocshRegister(&configFuncDef,configCallFunc);
}

extern "C" {
epicsExportRegistrar(drvUSBCTRRegister);
}











🔥 File: ./USB1608G_2AO_V2App/src/measCompAppMain.cpp
=================================================
/* exampleMain.cpp */
/* Author:  Marty Kraimer Date:    17MAR2000 */

#include <stddef.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "epicsExit.h"
#include "epicsThread.h"
#include "iocsh.h"

int main(int argc,char *argv[])
{
    if(argc>=2) {
        iocsh(argv[1]);
        epicsThreadSleep(.2);
    }
    iocsh(NULL);
    epicsExit(0);
    return(0);
}











🔥 File: ./USB1608G_2AO_V2App/src/measCompDiscover.cpp
=================================================
#include <stdio.h>
#include <string>
#include <string.h>
#include <stdlib.h>
#include <osiSock.h>
#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

#include <measCompDiscover.h>

#define MAX_DEVICES 100
// All current Measurement Computing devices (E-1608, E-TC, TC32) use this port for
// discovery.  But it is configurable so we allow the user to specify it.
#define DEFAULT_DISCOVERY_PORT 54211

static DaqDeviceDescriptor measCompInventory[MAX_DEVICES];
static int measCompNumDevices = 0;
bool measCompInventoryInitialized = false;

int measCompDiscoverDevices()
{
  int numDevices = MAX_DEVICES;
  int status;

  if (measCompInventoryInitialized) return 0;
  #ifdef WIN32
    cbIgnoreInstaCal();
    status = cbGetDaqDeviceInventory(ANY_IFC, measCompInventory, &numDevices);
    // Windows eliminates leading zeros on USB device serial numbers, Linux does not.
    // Add the leading zero if the string length is 7
    for (int i=0; i<numDevices; i++) {
        if (measCompInventory[i].InterfaceType == USB_IFC) {
            if (strlen(measCompInventory[i].UniqueID) == 7) {
                std::string tempString = "0" + std::string(measCompInventory[i].UniqueID);
                strcpy(measCompInventory[i].UniqueID, tempString.c_str());
            }
        }
    } 
  #else
    status = ulGetDaqDeviceInventory(ANY_IFC, measCompInventory, (unsigned int *)&numDevices);
    // Copy the IP address to the reserved field for Ethernet devices.
    for (int i=0; i<numDevices; i++) {
        if (measCompInventory[i].devInterface == ETHERNET_IFC) {
            DaqDeviceHandle devHandle = ulCreateDaqDevice(measCompInventory[i]);
            unsigned int maxLen = sizeof(measCompInventory[i].reserved);
            ulDevGetConfigStr(devHandle, DEV_CFG_IP_ADDR_STR, 0, measCompInventory[i].reserved, &maxLen);
            ulReleaseDaqDevice(devHandle);
        }
    }
  #endif
  if (status) {
    printf("Error calling cbGetDaqDeviceInventory=%d\n", status);
    return status;
  }
  measCompNumDevices = numDevices;
  measCompInventoryInitialized = true;
  return 0;
}

void measCompShowDevices()
{
  measCompDiscoverDevices();
  printf("measCompShowDevices, numDevices=%d\n", measCompNumDevices);
  #ifdef WIN32
    for (int i=0; i<measCompNumDevices; i++) {
      printf("Device %d\n", i);
      printf("    ProductName: %s\n",   measCompInventory[i].ProductName);
      printf("      ProductID: %d\n",   measCompInventory[i].ProductID);
      printf("  InterfaceType: %d\n",   measCompInventory[i].InterfaceType);
      printf("      DevString: %s\n",   measCompInventory[i].DevString);
      printf("       UniqueID: %s\n",   measCompInventory[i].UniqueID);
      printf("           NUID: %llu\n", measCompInventory[i].NUID);
      printf("       Reserved: %s\n",   measCompInventory[i].Reserved);
    }
  #else
    for (int i=0; i<measCompNumDevices; i++) {
      printf("Device %d\n", i);
      printf("    ProductName: %s\n",   measCompInventory[i].productName);
      printf("      ProductID: %d\n",   measCompInventory[i].productId);
      printf("  InterfaceType: %d\n",   measCompInventory[i].devInterface);
      printf("      DevString: %s\n",   measCompInventory[i].devString);
      printf("       UniqueID: %s\n",   measCompInventory[i].uniqueId);
      printf("       Reserved: %s\n",   measCompInventory[i].reserved);
    }
  #endif
}

/** Create a measComp device.
  * This method finds a device and connects to it.  It is called from the driver constructor.
  * \param[in] uniqueID 
  *                     This is an 8 digital hex serial number for USB devices without a leading 0x.
  *                     For Ethernet devices it can be:
  *                         An IP DNS name with optional discovery port, e.g. gse-e1608-6:54211
  *                         An IP address with optional discovery port, e.g. 10.54.160.63:54211
  *                         A MAC address, e.g. 00:80:2F:24:53:E5
  * \param[out] deviceDescriptor Pointer to a DaqDeviceDescription structure for this device
  * \param[out] handle A handle for this device.  
  *                         On Windows this is the index in the device inventory list.
  *                         On Linux it is a DaqDeviceHandle.
  */
int measCompCreateDevice(std::string uniqueId, DaqDeviceDescriptor& deviceDescriptor, long long *handle)
{
  size_t colon;
  std::string host = uniqueId;
  std::string port;
  struct sockaddr_in ipAddr;
  bool isEthernet = false;
  char *endptr;
  int portNum = DEFAULT_DISCOVERY_PORT;
  int status;
  int devIndex=-1;
  char ipAddrAsString[25];
  double timeout = 1.0;

  measCompDiscoverDevices();
  // If the uniqueId is a hex number it is USB, else Ethernet
  strtol(uniqueId.c_str(), &endptr, 16);
  if (*endptr != '\0') isEthernet = true;

  // Use hostToIPAddr for 2 reasons:
  // - It will translate IP names to IP addresses
  // - It will fail if the uniqueId is a MAC address
  status = aToIPAddr(uniqueId.c_str(), portNum, &ipAddr);
  if (isEthernet && (status == 0)) {
    ipAddrToDottedIP(&ipAddr, ipAddrAsString, sizeof(ipAddrAsString));
    // The string from ipAddrToDottedIP will always have a :port at the end
    // Parse the port and remove from the host string.
    host = ipAddrAsString;
    colon = host.find(":");
    if (colon != std::string::npos) {
      port = host.substr(colon+1, std::string::npos);
      portNum = atoi(port.c_str());
      host = host.substr(0, colon);
    }
    // See if this host is already known, i.e. it was found on the local subnet
    for (int i=0; i<measCompNumDevices; i++) {
      #ifdef WIN32
        /*  This logic does not work on Windows because there is no way to retrieve the IP address and copy it to .Reserved
         *  This is OK, it is just slightly less efficient because it will always call cbGetNetDeviceDescriptor unless UniqueID is a MAC address.
        if (host.compare(measCompInventory[i].Reserved) == 0) {
          devIndex = i;
        } */
      #else
        if (host.compare(measCompInventory[i].reserved) == 0) {
          devIndex = i;
        }
      #endif
    }
    // We did not find this device on the local subnet, create a new one
    if (devIndex == -1) {
      devIndex = measCompNumDevices++;
      #ifdef WIN32
        status = cbGetNetDeviceDescriptor((char*)host.c_str(), portNum,
                                          &measCompInventory[devIndex], (int) (timeout * 1000));
      #else
        status = ulGetNetDaqDeviceDescriptor((char*)host.c_str(), portNum, NULL,
                                             &measCompInventory[devIndex], timeout);
      #endif
      if (status) {
          printf("Error calling cbGetNetDeviceDescriptor=%d\n", status);
          return -1;
      }
    }
  }
  else {
    // uniqueId was not an IP address or IP DNS name, so it must be a serial number (USB) or MAC address (Ethernet)
    // Search the inventory for the matching UniqueID
    for (int i=0; i<measCompNumDevices; i++) {
      #ifdef WIN32
        if (uniqueId.compare(measCompInventory[i].UniqueID) == 0) {
      #else
        if (uniqueId.compare(measCompInventory[i].uniqueId) == 0) {
      #endif
        devIndex = i;
        break;
      }
    }
  }
  if (devIndex != -1) {
    #ifdef WIN32
      status = cbCreateDaqDevice(devIndex, measCompInventory[devIndex]);
      if (status) {
        printf("Error calling cbCreateDaqDevice=%d\n", status);
        return -1;
      }
      *handle = devIndex;
    #else
      DaqDeviceHandle devHandle = ulCreateDaqDevice(measCompInventory[devIndex]);
      if (!devHandle) {
        printf("Error calling ulCreateDaqDevice devIndex=%d\n", devIndex);
        return -1;
      }
      *handle = devHandle;
      UlError error = ulConnectDaqDevice(devHandle);
      if (error) {
        printf("Error calling ulConnectDaqDevice error=%d\n", error);
        return -1;
      }
    #endif
    //
    deviceDescriptor = measCompInventory[devIndex];
    return 0;
  }
  return -1;
}












🔥 File: ./USB1608G_2AO_V2App/src/measCompDiscover.h
=================================================
#ifndef measCompDiscoverInclude
#define measCompDiscoverInclude

#include <string>
#include <shareLib.h>
#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

epicsShareFunc int measCompDiscoverDevices();
epicsShareFunc void measCompShowDevices();
epicsShareFunc int measCompCreateDevice(std::string uniqueId, DaqDeviceDescriptor& deviceDescriptor, long long *handle);

#endif /* measCompDiscoverInclude */











🔥 File: ./USB1608G_2AO_V2App/src/measCompSupport.dbd
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.dbd)]











🔥 File: ./USB1608G_2AO_V2App/src/thresholdLogicSupport.dbd
=================================================
[SKIPPED: 🚋 OP 화면용 파일 (*.dbd)]
