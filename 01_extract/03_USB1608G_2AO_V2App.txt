üìÅ tree of USB1608G_2AO_V2App/
./USB1608G_2AO_V2App
‚îú‚îÄ‚îÄ Db
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Makefile
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ O.Common
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ O.linux-x86_64
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ Makefile
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO.substitutions
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogIn.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogInMode.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogInMode_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogIn_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogOut.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogOut_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompBinaryDir.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompBinaryDir_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompBinaryIn.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompBinaryOut.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompCounter.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompDevice.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompEncoder.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompLongIn.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompLongOut.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompMCS.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompMCSWaveform.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompMCS_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompPulseGen.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompPulseGen_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompTemperatureIn.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompTemperatureIn_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompTrigger.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompTrigger_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompUSBTempConfig.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompUSBTempConfig_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompVoltageIn.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompVoltageIn_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompWaveformDig.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompWaveformDigN.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompWaveformDig_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompWaveformGen.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompWaveformGenN.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompWaveformGenN_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompWaveformGen_settings.req
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ threshold_logic.template
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ user.db
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ user.proto
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ user.substitutions
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ op
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2.adl
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2.opi
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompADCStripChart.adl
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAiSetup.adl
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogIn8.adl
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogIn8.opi
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogOut2.adl
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAnalogOut2.opi
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompAoSetup2.adl
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompDigitalIO8.adl
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ measCompDigitalIO8.opi
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ ErrorHandler.cpp
    ‚îú‚îÄ‚îÄ ErrorHandler.h
    ‚îú‚îÄ‚îÄ Makefile
    ‚îú‚îÄ‚îÄ O.Common
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ USB1608G_2AO_V2.dbd
    ‚îú‚îÄ‚îÄ O.linux-x86_64
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ErrorHandler.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ErrorHandler.o
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Makefile
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ThresholdLogicController.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ ThresholdLogicController.o
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2.dbd.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2Main.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2Main.o
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2_registerRecordDeviceDriver.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USB1608G_2AO_V2_registerRecordDeviceDriver.o
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USBCTR_SNL.c
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USBCTR_SNL.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USBCTR_SNL.i
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USBCTR_SNL.o
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ USBCTR_SNL.st.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ drvMultiFunction.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ drvMultiFunction.o
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ drvUSBCTR.d
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ drvUSBCTR.o
    ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ measCompDiscover.d
    ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ measCompDiscover.o
    ‚îú‚îÄ‚îÄ ThresholdLogicController.cpp
    ‚îú‚îÄ‚îÄ ThresholdLogicController.h
    ‚îú‚îÄ‚îÄ USB1608G_2AO_V2Main.cpp
    ‚îú‚îÄ‚îÄ USBCTR_SNL.st
    ‚îú‚îÄ‚îÄ drvMultiFunction.cpp
    ‚îú‚îÄ‚îÄ drvUSBCTR.cpp
    ‚îú‚îÄ‚îÄ measCompAppMain.cpp
    ‚îú‚îÄ‚îÄ measCompDiscover.cpp
    ‚îú‚îÄ‚îÄ measCompDiscover.h
    ‚îú‚îÄ‚îÄ measCompSupport.dbd
    ‚îî‚îÄ‚îÄ thresholdLogicSupport.dbd

7 directories, 93 files










üìÑ All files under USB1608G_2AO_V2App/:
./USB1608G_2AO_V2App/Db/Makefile
./USB1608G_2AO_V2App/Db/O.linux-x86_64/Makefile
./USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions
./USB1608G_2AO_V2App/Db/USB1608G_2AO_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogIn.template
./USB1608G_2AO_V2App/Db/measCompAnalogInMode.template
./USB1608G_2AO_V2App/Db/measCompAnalogInMode_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogIn_settings.req
./USB1608G_2AO_V2App/Db/measCompAnalogOut.template
./USB1608G_2AO_V2App/Db/measCompAnalogOut_settings.req
./USB1608G_2AO_V2App/Db/measCompBinaryDir.template
./USB1608G_2AO_V2App/Db/measCompBinaryDir_settings.req
./USB1608G_2AO_V2App/Db/measCompBinaryIn.template
./USB1608G_2AO_V2App/Db/measCompBinaryOut.template
./USB1608G_2AO_V2App/Db/measCompCounter.template
./USB1608G_2AO_V2App/Db/measCompDevice.template
./USB1608G_2AO_V2App/Db/measCompEncoder.template
./USB1608G_2AO_V2App/Db/measCompLongIn.template
./USB1608G_2AO_V2App/Db/measCompLongOut.template
./USB1608G_2AO_V2App/Db/measCompMCS.template
./USB1608G_2AO_V2App/Db/measCompMCSWaveform.template
./USB1608G_2AO_V2App/Db/measCompMCS_settings.req
./USB1608G_2AO_V2App/Db/measCompPulseGen.template
./USB1608G_2AO_V2App/Db/measCompPulseGen_settings.req
./USB1608G_2AO_V2App/Db/measCompTemperatureIn.template
./USB1608G_2AO_V2App/Db/measCompTemperatureIn_settings.req
./USB1608G_2AO_V2App/Db/measCompTrigger.template
./USB1608G_2AO_V2App/Db/measCompTrigger_settings.req
./USB1608G_2AO_V2App/Db/measCompUSBTempConfig.template
./USB1608G_2AO_V2App/Db/measCompUSBTempConfig_settings.req
./USB1608G_2AO_V2App/Db/measCompVoltageIn.template
./USB1608G_2AO_V2App/Db/measCompVoltageIn_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformDig.template
./USB1608G_2AO_V2App/Db/measCompWaveformDigN.template
./USB1608G_2AO_V2App/Db/measCompWaveformDig_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformGen.template
./USB1608G_2AO_V2App/Db/measCompWaveformGenN.template
./USB1608G_2AO_V2App/Db/measCompWaveformGenN_settings.req
./USB1608G_2AO_V2App/Db/measCompWaveformGen_settings.req
./USB1608G_2AO_V2App/Db/threshold_logic.template
./USB1608G_2AO_V2App/Db/user.db
./USB1608G_2AO_V2App/Db/user.proto
./USB1608G_2AO_V2App/Db/user.substitutions
./USB1608G_2AO_V2App/Makefile
./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.adl
./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.opi
./USB1608G_2AO_V2App/op/measCompADCStripChart.adl
./USB1608G_2AO_V2App/op/measCompAiSetup.adl
./USB1608G_2AO_V2App/op/measCompAnalogIn8.adl
./USB1608G_2AO_V2App/op/measCompAnalogIn8.opi
./USB1608G_2AO_V2App/op/measCompAnalogOut2.adl
./USB1608G_2AO_V2App/op/measCompAnalogOut2.opi
./USB1608G_2AO_V2App/op/measCompAoSetup2.adl
./USB1608G_2AO_V2App/op/measCompDigitalIO8.adl
./USB1608G_2AO_V2App/op/measCompDigitalIO8.opi
./USB1608G_2AO_V2App/src/ErrorHandler.cpp
./USB1608G_2AO_V2App/src/ErrorHandler.h
./USB1608G_2AO_V2App/src/Makefile
./USB1608G_2AO_V2App/src/O.Common/USB1608G_2AO_V2.dbd
./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/Makefile
./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2.dbd.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.c
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.i
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.st.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.o
./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.d
./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.o
./USB1608G_2AO_V2App/src/ThresholdLogicController.cpp
./USB1608G_2AO_V2App/src/ThresholdLogicController.h
./USB1608G_2AO_V2App/src/USB1608G_2AO_V2Main.cpp
./USB1608G_2AO_V2App/src/USBCTR_SNL.st
./USB1608G_2AO_V2App/src/drvMultiFunction.cpp
./USB1608G_2AO_V2App/src/drvUSBCTR.cpp
./USB1608G_2AO_V2App/src/measCompAppMain.cpp
./USB1608G_2AO_V2App/src/measCompDiscover.cpp
./USB1608G_2AO_V2App/src/measCompDiscover.h
./USB1608G_2AO_V2App/src/measCompSupport.dbd
./USB1608G_2AO_V2App/src/thresholdLogicSupport.dbd










üìÑ Contents of files under USB1608G_2AO_V2App/:











üî• File: ./USB1608G_2AO_V2App/Db/Makefile
=================================================
TOP=../..
include $(TOP)/configure/CONFIG

#  Optimization of db files using dbst (DEFAULT: NO)
#DB_OPT = YES

#----------------------------------------------------
# Create and install (or just install)
# databases, templates, substitutions like this

DB += $(patsubst ../%, %, $(wildcard ../*.template))
DB += $(patsubst ../%, %, $(wildcard ../*.db))
DB += $(patsubst ../%, %, $(wildcard ../*.vdb))
DB += $(patsubst ../%, %, $(wildcard ../*.substitutions))

REQ += $(patsubst ../%, %, $(wildcard ../*.req))

#----------------------------------------------------
# If <anyname>.db template is not named <anyname>*.template add
# <anyname>_TEMPLATE = <templatename>

include $(TOP)/configure/RULES
#----------------------------------------
#  ADD RULES AFTER THIS LINE











üî• File: ./USB1608G_2AO_V2App/Db/O.linux-x86_64/Makefile
=================================================
#This Makefile created by makeMakefile.pl


all :
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

.DEFAULT: force
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

force:  ;











üî• File: ./USB1608G_2AO_V2App/Db/USB1608G_2AO.substitutions
=================================================
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompDevice.template"
{pattern {} {} }

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongIn.template"
{
pattern
{ R,   MASK, ADDR}
{Li,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryIn.template"
{
pattern
{ R,   MASK, ADDR}
{Bi1,  0x01     0}
{Bi2,  0x02     0}
{Bi3,  0x04     0}
{Bi4,  0x08     0}
{Bi5,  0x10     0}
{Bi6,  0x20     0}
{Bi7,  0x40     0}
{Bi8,  0x80     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompLongOut.template"
{
pattern
{ R,   MASK, ADDR}
{Lo,   0xFF,    0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryOut.template"
{
pattern
{ R,   MASK, ADDR}
{Bo1,  0x01     0}
{Bo2,  0x02     0}
{Bo3,  0x04     0}
{Bo4,  0x08     0}
{Bo5,  0x10     0}
{Bo6,  0x20     0}
{Bo7,  0x40     0}
{Bo8,  0x80     0}
}

# Direction bits on binary I/O
#  VAL 0=input, 1=output
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompBinaryDir.template"
{
pattern
{ R,   MASK,  VAL, ADDR}
{Bd1,  0x01    0,     0}
{Bd2,  0x02    0,     0}
{Bd3,  0x04    0,     0}
{Bd4,  0x08    0,     0}
{Bd5,  0x10    1,     0}
{Bd6,  0x20    1,     0}
{Bd7,  0x40    1,     0}
{Bd8,  0x80    1,     0}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompPulseGen.template"
{
pattern
{    R,      ADDR,  PREC}
{PulseGen1,     0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompCounter.template"
{
pattern
{    R,     ADDR}
{Counter1,     0}
{Counter2,     1}
}

# Analog input mode
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogInMode.template"
{
pattern
{  R,       ADDR,   MODE}
{AiMode,       0,      0}
}

# Analog inputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogIn.template"
{
pattern
{  R, ADDR, EGUL, LOPR, EGUF, HOPR,  RANGE,   SCAN,   PREC}
{Ai1,   0,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai2,   1,  -10., -10.,  10.,  10.,    0,  "1 second",   4}
{Ai3,   2,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai4,   3,   -5.,  -5.,   5.,   5.,    1,  "1 second",   4}
{Ai5,   4,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai6,   5,   -2.,  -2.,   2.,   2.,    2,  "1 second",   4}
{Ai7,   6,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
{Ai8,   7,   -1.,  -1.,   1.,   1.,    3,  "1 second",   4}
}

# Waveform digitzer
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDig.template"
{
pattern
{  R,     ADDR,  PREC}
{WaveDig,    0,     4}
}

file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformDigN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveDig1,     0,      4}
{WaveDig2,     1,      4}
{WaveDig3,     2,      4}
{WaveDig4,     3,      4}
{WaveDig5,     4,      4}
{WaveDig6,     5,      4}
{WaveDig7,     6,      4}
{WaveDig8,     7,      4}
}


# Analog outputs
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompAnalogOut.template"
{
pattern
{ R,   VAL, ADDR, EGUL, DRVL, LOPR, EGUF, DRVH, HOPR, PREC}
{Ao1,   0,    0,  -10., -10., -10.,  10.,  10.,  10.,    4}
{Ao2,   0,    1,  -10., -10., -10.,  10.,  10.,  10.,    4}
}

# Waveform generator
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGen.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen,      0,      4}
}
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompWaveformGenN.template"
{
pattern
{  R,        ADDR,  PREC}
{WaveGen1,     0,      4}
{WaveGen2,     1,      4}
}

# Trigger
file "$(TOP)/USB1608G_2AO_V2App/Db/measCompTrigger.template"
{
pattern
{  R,   ADDR}
{Trig,     0}
}


# Threshold Logic Controller Ïù∏Ïä§ÌÑ¥Ïä§
# Í∞Å ÏïÑÎÇ†Î°úÍ∑∏ ÏûÖÎ†• Ï±ÑÎÑêÏóê ÎåÄÌïú ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ï†úÏñ¥
# ThresholdLogic1: ai1 -> bo5
# ThresholdLogic2: ai2 -> bo6
# ThresholdLogic3: ai4 -> bo7
# ThresholdLogic4: ai5 -> bo8
file "$(TOP)/USB1608G_2AO_V2App/Db/threshold_logic.template"
{
pattern
{ R,               IN_CH,  OUT_CH, THRESHOLD, HYSTERESIS, ENABLE, UPDATE_RATE, PREC, EGU }
{ ThresholdLogic1, "Ai1",   "Bo5",     2.5,       0.1,        1,      10.0,        3,   "V" }
{ ThresholdLogic2, "Ai2",   "Bo6",     5.0,       0.2,        1,      10.0,        3,   "V" }
{ ThresholdLogic3, "Ai3",   "Bo7",     1.0,       0.05,       0,      5.0,         3,   "V" }
{ ThresholdLogic4, "Ai4",   "Bo8",     7.5,       0.3,        0,      20.0,        3,   "V" }
}












üî• File: ./USB1608G_2AO_V2App/Db/USB1608G_2AO_settings.req
=================================================
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd1
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd2
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd3
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd4
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd5
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd6
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd7
file "measCompBinaryDir_settings.req",    P=$(P), R=Bd8
file "measCompPulseGen_settings.req",     P=$(P), R=PulseGen1
file "measCompAnalogInMode_settings.req", P=$(P), R=AiMode
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai1
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai2
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai3
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai4
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai5
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai6
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai7
file "measCompAnalogIn_settings.req",     P=$(P), R=Ai8
file "measCompAnalogOut_settings.req",    P=$(P), R=Ao1
file "measCompAnalogOut_settings.req",    P=$(P), R=Ao2
file "measCompWaveformDig_settings.req",  P=$(P), R=WaveDig
file "measCompWaveformGen_settings.req",  P=$(P), R=WaveGen
file "measCompWaveformGenN_settings.req", P=$(P), R=WaveGen1
file "measCompWaveformGenN_settings.req", P=$(P), R=WaveGen2
file "measCompTrigger_settings.req",      P=$(P), R=Trig











üî• File: ./USB1608G_2AO_V2App/Db/measCompAnalogIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynInt32Average")
    field(INP,  "@asyn($(PORT),$(ADDR))ANALOG_IN_VALUE")
    field(LINR, "LINEAR")
    field(EGUF, "$(EGUF)")
    field(EGUL, "$(EGUL)")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RANGE")
    field(VAL,  "$(RANGE)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_TYPE")
}

record(ao,"$(P)$(R)Rate")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_RATE")
    field(VAL,  "60")
}












üî• File: ./USB1608G_2AO_V2App/Db/measCompAnalogInMode.template
=================================================
record(mbbo,"$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_IN_MODE")
    field(VAL,  "$(MODE)")
    field(ZRVL, "0")
    field(ZRST, "Differential")
    field(ONVL, "1")
    field(ONST, "Single-ended")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompAnalogInMode_settings.req
=================================================
$(P)$(R)












üî• File: ./USB1608G_2AO_V2App/Db/measCompAnalogIn_settings.req
=================================================
$(P)$(R)Range
$(P)$(R)Type
$(P)$(R)Rate
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).EGUF
$(P)$(R).EGUL
$(P)$(R).PREC
$(P)$(R).SCAN












üî• File: ./USB1608G_2AO_V2App/Db/measCompAnalogOut.template
=================================================
record(ao,"$(P)$(R)") {
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Range record will process before this record during iocInit
    field(PHAS, "2")
    field(DTYP, "asynInt32")
    field(FLNK, "$(P)$(R)Return.PROC  PP MS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_RANGE")
}

record(ao,"$(P)$(R)Return") {
    field(DTYP, "asynInt32")
    field(DISV, "0")
    field(SDIS, "$(P)$(R)Pulse.VAL  NPP NMS")
    field(OUT,  "@asyn($(PORT),$(ADDR))ANALOG_OUT_VALUE")
    field(OMSL, "closed_loop")
    field(EGUL, "$(EGUL)")
    field(DRVL, "$(DRVL)")
    field(LOPR, "$(LOPR)")
    field(EGUF, "$(EGUF)")
    field(DRVH, "$(DRVH)")
    field(HOPR, "$(HOPR)")
    field(PREC, "$(PREC)")
    field(LINR, "LINEAR")
    field(VAL,  "$(VAL)")
}

record(bo,"$(P)$(R)Pulse") {
    field(ZNAM, "Normal")
    field(ONAM, "Pulse")
}

record(ao,"$(P)$(R)TweakVal") {
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakUp") {
    field(CALC, "A+B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}

record(calcout,"$(P)$(R)TweakDown") {
    field(CALC, "A-B")
    field(INPA, "$(P)$(R).VAL  NPP MS")
    field(INPB, "$(P)$(R)TweakVal.VAL  NPP MS")
    field(OUT,  "$(P)$(R).VAL  PP MS")
    field(PREC, "$(PREC)")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompAnalogOut_settings.req
=================================================
$(P)$(R)Pulse
$(P)$(R)Range
$(P)$(R)TweakVal
$(P)$(R).DRVL
$(P)$(R).DRVH
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).EGUF
$(P)$(R).EGUL
$(P)$(R).PREC
$(P)$(R)Return.DRVL
$(P)$(R)Return.DRVH
$(P)$(R)Return.LOPR
$(P)$(R)Return.HOPR
$(P)$(R)Return.EGUF
$(P)$(R)Return.EGUL
$(P)$(R)Return.PREC











üî• File: ./USB1608G_2AO_V2App/Db/measCompBinaryDir.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "YES")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_DIRECTION")
    field(ZNAM, "In")
    field(ONAM, "Out")
    field(VAL,  "$(VAL)")
    field(PINI, "YES")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompBinaryDir_settings.req
=================================================
$(P)$(R)











üî• File: ./USB1608G_2AO_V2App/Db/measCompBinaryIn.template
=================================================
record(bi, "$(P)$(R)")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompBinaryOut.template
=================================================
record(bo, "$(P)$(R)")
{
    field(PINI, "$(PINI=YES)")
    # Setting PHAS=2 ensures that the Direction record will process before this record during iocInit
    field(PHAS, "2")
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
}

record(bi, "$(P)$(R)_RBV")
{
    field(DESC, "$(DESC=)")
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(ZNAM, "$(ZNAM=Low)")
    field(ZSV,  "$(ZSV=NO_ALARM)")
    field(ONAM, "$(ONAM=High)")
    field(OSV,  "$(OSV=NO_ALARM)")
    field(SCAN, "I/O Intr")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompCounter.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












üî• File: ./USB1608G_2AO_V2App/Db/measCompDevice.template
=================================================
# Device settings
record(stringin,"$(P)ModelName") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)MODEL_NAME")
}

record(longin,"$(P)ModelNumber") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT) 0)MODEL_NUMBER")
}

record(stringin,"$(P)FirmwareVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)FIRMWARE_VERSION")
}

record(stringin,"$(P)UniqueID") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UNIQUE_ID")
}

record(stringin,"$(P)ULVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)UL_VERSION")
}

record(stringin,"$(P)DriverVersion") {
    field(PINI, "YES")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)DRIVER_VERSION")
}

record(ai,"$(P)PollTimeMS") {
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT) 0)POLL_TIME_MS")
    field(PREC, "1")
    field(SCAN, "I/O Intr")
}

record(ao,"$(P)PollSleepMS") {
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT) 0)POLL_SLEEP_MS")
    field(VAL,  "50")
    field(PREC, "1")
}

record(waveform, "$(P)LastErrorMessage") {
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT) 0)LAST_ERROR_MESSAGE")
    field(NELM, "256")
    field(FTVL, "CHAR")
    field(SCAN, "I/O Intr")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompEncoder.template
=================================================
record(longin, "$(P)$(R)Counts")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))COUNTER_VALUE")
    field(SCAN, "I/O Intr")
}

record(bo, "$(P)$(R)Reset")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))COUNTER_RESET")
    field(VAL,  "1")
}












üî• File: ./USB1608G_2AO_V2App/Db/measCompLongIn.template
=================================================
record(longin, "$(P)$(R)")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_INPUT")
    field(SCAN, "I/O Intr")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompLongOut.template
=================================================
###################################################################
#  Binary output as longout                                       # 
###################################################################
record(longout, "$(P)$(R)")
{
    field(PINI, "$(PINI=NO)")
    field(DTYP, "asynUInt32Digital")
    field(OUT,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
}

record(longin, "$(P)$(R)_RBV")
{
    field(DTYP, "asynUInt32Digital")
    field(INP,  "@asynMask($(PORT),$(ADDR),$(MASK))DIGITAL_OUTPUT")
    field(SCAN, "I/O Intr")
}












üî• File: ./USB1608G_2AO_V2App/Db/measCompMCS.template
=================================================
# measCompMCS.template
# Mark Rivers
# June 2, 2014

record(bi,"$(P)SNL_Connected") {
  field(ZNAM, "Not connected")
  field(ZSV,  "MAJOR")
  field(ONAM, "Connected")
  field(OSV,  "NO_ALARM")
}

record(bo,"$(P)EraseAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)EraseStart") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_ERASE")
  field(ZNAM, "Done")
  field(ONAM, "Erase")
  field(VAL,  "1")
  field(FLNK, "$(P)StartAll.PROC")
}

record(bo,"$(P)StartAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_START_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Start")
  field(VAL,  "1")
  field(FLNK, "$(P)SetAcquiring.PROC")
}

record(bo,"$(P)SetAcquiring") {
  field(OUT,  "$(P)Acquiring PP MS")
  field(ZNAM, "Done")
  field(ONAM, "Set")
  field(VAL,  "1")
  field(FLNK, "$(P)SetClientWait.PROC")
}

record(busy,"$(P)Acquiring") {
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
}

record(bo,"$(P)StopAll") {
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_STOP_ACQUIRE")
  field(ZNAM, "Done")
  field(ONAM, "Stop")
  field(VAL,  "1")
}

record(ao,"$(P)PresetReal") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESET_REAL")
  field(VAL,  "0.0")
  field(PREC, "3")
}

record(bi,"$(P)HardwareAcquiring") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCA_ACQUIRING")
  field(ZNAM, "Done")
  field(ONAM, "Acquiring")
  field(SCAN, "I/O Intr")
}

record(ai,"$(P)ElapsedReal") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_ELAPSED_REAL")
  field(PREC, "3")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ReadAll") {
  field(SCAN, "1 second")
  field(DISV, "0")
  field(SDIS, "$(P)Acquiring NPP NMS")
  field(ZNAM, "Done")
  field(ONAM, "Read")
  field(FLNK, "$(P)ReadAllOnce")
}

record(bo,"$(P)ReadAllOnce") {
  field(VAL,  "1")
  field(OUT,  "$(P)DoReadAll.VAL PP MS")
}

record(bo,"$(P)DoReadAll") {
  field(ZNAM, "Done")
  field(ONAM, "Read")
}

record(longout,"$(P)NuseAll") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_NUM_CHANNELS")
}

record(longin,"$(P)CurrentChannel") {
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_CURRENT_POINT")
  field(SCAN, "I/O Intr")
}

record(ao,"$(P)Dwell") {
  field(PINI, "YES")
  field(DTYP, "asynFloat64")
  field(OUT,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(VAL,  "0.1")
  field(PREC, "4")
}

record(ai,"$(P)Dwell_RBV") {
  field(DTYP, "asynFloat64")
  field(INP,  "@asyn($(PORT),0)MCA_DWELL_TIME")
  field(PREC, "4")
  field(SCAN, "I/O Intr")
}

record(bo,"$(P)ChannelAdvance") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_CH_ADV_SOURCE")
  field(ZNAM, "Internal")
  field(ONAM, "External")
}

record(longout,"$(P)Prescale") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCA_PRESCALE")
  field(VAL,  "1")
}

record(bo,"$(P)EnableClientWait") {
  field(PINI, "YES")
  field(ZNAM, "Disable")
  field(ONAM, "Enable")
}

record(bo,"$(P)SetClientWait") {
  field(DISV, "0")
  field(SDIS, "$(P)EnableClientWait NPP NMS")
  field(OMSL, "closed_loop")
  field(DOL,  "1")
  field(OUT,  "$(P)ClientWait PP MS")
  field(ONAM, "SetClientWait")
  field(ZNAM, "Done")
}

record(busy,"$(P)ClientWait") {
}

record(mbboDirect,"$(P)MCSCounterEnable") {
  field(PINI, "YES")
  field(DTYP, "asynUInt32Digital")
  field(OUT,  "@asynMask($(PORT),0,0xFFFFFFFF)MCS_COUNTER_ENABLE")
  field(VAL, "0x1FF")
}

record(bo, "$(P)MCSCounter1Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B0 PP")
}

record(bo, "$(P)MCSCounter2Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B1 PP")
}

record(bo, "$(P)MCSCounter3Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B2 PP")
}

record(bo, "$(P)MCSCounter4Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B3 PP")
}

record(bo, "$(P)MCSCounter5Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B4 PP")
}

record(bo, "$(P)MCSCounter6Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B5 PP")
}

record(bo, "$(P)MCSCounter7Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B6 PP")
}

record(bo, "$(P)MCSCounter8Enable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B7 PP")
}

record(bo, "$(P)MCSDIOEnable") {
  field(PINI, "YES")
  field(ZNAM, "No")
  field(ONAM, "Yes")
  field(VAL, "1")
  field(OUT, "$(P)MCSCounterEnable.B8 PP")
}

record(mbbo,"$(P)PrescaleCounter") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_PRESCALE_COUNTER")
  field(ZRVL, "0")
  field(ZRST, "CTR0")
  field(ONVL, "1")
  field(ONST, "CTR1")
  field(TWVL, "2")
  field(TWST, "CTR2")
  field(THVL, "3")
  field(THST, "CTR3")
  field(FRVL, "4")
  field(FRST, "CTR4")
  field(FVVL, "5")
  field(FVST, "CTR5")
  field(SXVL, "6")
  field(SXST, "CTR6")
  field(SVVL, "7")
  field(SVST, "CTR7")
}

record(mbbo,"$(P)Point0Action") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(OUT,  "@asyn($(PORT),0)MCS_POINT0_ACTION")
  field(ZRVL, "0")
  field(ZRST, "Clear")
  field(ONVL, "1")
  field(ONST, "No clear")
  field(TWVL, "2")
  field(TWST, "Skip")
}

record(longin,"$(P)MaxChannels") {
  field(PINI, "YES")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT),0)MCS_MAX_POINTS")
}

record(mbbi, "$(P)Model") {
  field(PINI, "YES")
  field(DESC, "Model")
  field(DTYP, "asynInt32")
  field(INP,  "@asyn($(PORT) 0)MODEL")
  field(ZRVL, "0")
  field(ONVL, "1")
  field(ZRST, "USB-CTR08")
  field(ONST, "USB-CTR04")
}

record(mbbo,"$(P)TrigMode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),0)TRIGGER_MODE")
    field(ZRVL, "0")
    field(ZRST, "Rising edge")
    field(ONVL, "1")
    field(ONST, "Falling edge")
    field(TWVL, "6")
    field(TWST, "High level")
    field(THVL, "7")
    field(THST, "Low level")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),0)MCS_ABS_TIME_WF")
    field(NELM, "$(MAX_POINTS)")
    field(SCAN, "I/O Intr")
}

# asyn record for debugging
record(asyn, "$(P)Asyn") {
  field(PORT, "$(PORT)")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompMCSWaveform.template
=================================================
# Waveform record to be used for MCS data, rather than MCA record.

record(waveform, "$(P)$(R)") {
  field(DTYP, "asynInt32ArrayIn")
  field(INP,  "$(INP)MCA_DATA")
  field(FTVL, "LONG")
  field(NELM, "$(NUM_POINTS)")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompMCS_settings.req
=================================================
$(P)PresetReal
$(P)Dwell
$(P)Prescale
$(P)ChannelAdvance
$(P)MCSCounter1Enable
$(P)MCSCounter2Enable
$(P)MCSCounter3Enable
$(P)MCSCounter4Enable
$(P)MCSCounter5Enable
$(P)MCSCounter6Enable
$(P)MCSCounter7Enable
$(P)MCSCounter8Enable
$(P)MCSDIOEnable
$(P)PrescaleCounter
$(P)Point0Action
$(P)ReadAll.SCAN
$(P)NuseAll
$(P)EnableClientWait
$(P)TrigMode











üî• File: ./USB1608G_2AO_V2App/Db/measCompPulseGen.template
=================================================
# This database is loaded for each pulse generator
# Mark Rivers
# July 26, 2011

###################################################################
#  Pulse start/stop                                               # 
###################################################################
record(bo, "$(P)$(R)Run")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_RUN")
    field(ZNAM, "Stop")
    field(ZSV,  "NO_ALARM")
    field(ONAM, "Run")
    field(OSV,  "MINOR")
}

# NOTE: The records for the period and the frequency are a bit
# complex because we want to be able to change either ao record
# and have the other one update

###################################################################
#  Pulse period                                                   # 
###################################################################
record(ao, "$(P)$(R)Period")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcFrequency")
}

record(ai, "$(P)$(R)Period_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_PERIOD")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate frequency based on new period                        # 
###################################################################
record(calcout, "$(P)$(R)CalcFrequency")
{
    field(INPA, "$(P)$(R)Period")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Frequency.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Frequency PP MS")
}

###################################################################
#  Pulse frequency                                                # 
###################################################################
record(ao, "$(P)$(R)Frequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcPeriod PP MS")
}

record(calc, "$(P)$(R)Frequency_RBV")
{
    field(INPA, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "1/A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate period based on new frequency                        # 
###################################################################
record(calcout, "$(P)$(R)CalcPeriod")
{
    field(INPA, "$(P)$(R)Frequency")
    field(CALC, "1/A")
    field(SDIS, "$(P)$(R)Period.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Period PP MS")
}

###################################################################
#  Pulse duty cycle                                               # 
###################################################################
record(ao, "$(P)$(R)DutyCycle")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(VAL,  "0.5")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcWidth")
}

record(ai, "$(P)$(R)DutyCycle_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DUTY_CYCLE")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Calculate width based on new duty cycle                        # 
###################################################################
record(calcout, "$(P)$(R)CalcWidth")
{
    field(INPA, "$(P)$(R)DutyCycle")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A*B")
    field(SDIS, "$(P)$(R)Width.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)Width PP MS")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)Width")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcDutyCycle PP MS")
}

record(calc, "$(P)$(R)Width_RBV")
{
    field(INPA, "$(P)$(R)DutyCycle_RBV CP MS")
    field(INPB, "$(P)$(R)Period_RBV CP MS")
    field(CALC, "B*A")
    field(PREC, "$(PREC)")
}

###################################################################
#  Calculate duty cycle based on new width                        # 
###################################################################
record(calcout, "$(P)$(R)CalcDutyCycle")
{
    field(INPA, "$(P)$(R)Width")
    field(INPB, "$(P)$(R)Period")
    field(CALC, "A/B")
    field(SDIS, "$(P)$(R)DutyCycle.PROC")
    field(DISV, "1")
    field(OUT, "$(P)$(R)DutyCycle PP MS")
}

###################################################################
#  Pulse delay                                                    # 
###################################################################
record(ao, "$(P)$(R)Delay")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(VAL,  "0.")
    field(PREC, "$(PREC)")
}

record(ai, "$(P)$(R)Delay_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))PULSE_DELAY")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Pulse count                                                    # 
###################################################################
record(longout, "$(P)$(R)Count")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_COUNT")
}

###################################################################
#  Pulse idle state                                               # 
###################################################################
record(bo, "$(P)$(R)IdleState")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))PULSE_IDLE_STATE")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(VAL,  "0")
}













üî• File: ./USB1608G_2AO_V2App/Db/measCompPulseGen_settings.req
=================================================
$(P)$(R)Period
$(P)$(R)Width
$(P)$(R)Delay
$(P)$(R)Count
$(P)$(R)IdleState
$(P)$(R)Run











üî• File: ./USB1608G_2AO_V2App/Db/measCompTemperatureIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))TEMPERATURE_IN_VALUE")
    field(PREC, "$(PREC)")
}

record(mbbo,"$(P)$(R)Scale")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SCALE")
    field(ZRVL, "0")
    field(ZRST, "Celsius")
    field(ONVL, "1")
    field(ONST, "Fahrenheit")
    field(TWVL, "2")
    field(TWST, "Kelvin")
    field(THVL, "4")
    field(THST, "Volts")
    field(FRVL, "5")
    field(FRST, "Noscale")
}

record(mbbo,"$(P)$(R)TCType")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_TYPE")
    field(ZRVL, "1")
    field(ZRST, "Type J")
    field(ONVL, "2")
    field(ONST, "Type K")
    field(TWVL, "3")
    field(TWST, "Type T")
    field(THVL, "4")
    field(THST, "Type E")
    field(FRVL, "5")
    field(FRST, "Type R")
    field(FVVL, "6")
    field(FVST, "Type S")
    field(SXVL, "7")
    field(SXST, "Type B")
    field(SVVL, "8")
    field(SVST, "Type N")
}

record(mbbo,"$(P)$(R)Filter")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_FILTER")
    field(ZRVL, "0")
    field(ZRST, "Filter")
    field(ONVL, "0x400")
    field(ONST, "No filter")
}

record(bo,"$(P)$(R)OpenTCDetect")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))THERMOCOUPLE_OPEN_DETECT")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}












üî• File: ./USB1608G_2AO_V2App/Db/measCompTemperatureIn_settings.req
=================================================
$(P)$(R)Scale
$(P)$(R)TCType
$(P)$(R)OpenTCDetect
$(P)$(R)Filter
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).PREC
$(P)$(R).SCAN











üî• File: ./USB1608G_2AO_V2App/Db/measCompTrigger.template
=================================================
record(mbbo,"$(P)$(R)Mode") {
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TRIGGER_MODE")
    field(ZRVL, "12")
    field(ZRST, "Positive edge")
    field(ONVL, "13")
    field(ONST, "Negative edge")
    field(TWVL, "10")
    field(TWST, "High")
    field(THVL, "11")
    field(THST, "Low")
}












üî• File: ./USB1608G_2AO_V2App/Db/measCompTrigger_settings.req
=================================================
$(P)$(R)Mode











üî• File: ./USB1608G_2AO_V2App/Db/measCompUSBTempConfig.template
=================================================
# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)TemperatureSensor")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_SENSOR")
}

record(mbbo,"$(P)$(R)TemperatureWiring")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))TEMPERATURE_WIRING")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompUSBTempConfig_settings.req
=================================================
$(P)$(R)TemperatureSensor
$(P)$(R)TemperatureWiring











üî• File: ./USB1608G_2AO_V2App/Db/measCompVoltageIn.template
=================================================
record(ai,"$(P)$(R)")
{
    field(SCAN, "$(SCAN)")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_VALUE")
    field(HOPR, "$(HOPR)")
    field(LOPR, "$(LOPR)")
    field(PREC, "$(PREC)")
}

# Note: the driver constructs these enum fields based on model.
record(mbbo,"$(P)$(R)Range")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))VOLTAGE_IN_RANGE")
    field(VAL,  "$(RANGE)")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompVoltageIn_settings.req
=================================================
$(P)$(R)Range
$(P)$(R).LOPR
$(P)$(R).HOPR
$(P)$(R).PREC
$(P)$(R).SCAN












üî• File: ./USB1608G_2AO_V2App/Db/measCompWaveformDig.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longout, "$(P)$(R)NumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WDIG_POINTS)")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)FirstChan")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_FIRST_CHAN")
    field(ZRVL, "0")
    field(ZRST, "1")
    field(ONVL, "1")
    field(ONST, "2")
    field(TWVL, "2")
    field(TWST, "3")
    field(THVL, "3")
    field(THST, "4")
    field(FRVL, "4")
    field(FRST, "5")
    field(FVVL, "5")
    field(FVST, "6")
    field(SXVL, "6")
    field(SXST, "7")
    field(SVVL, "7")
    field(SVST, "8")
}

###################################################################
#  First channel to digitize                                      # 
###################################################################
record(mbbo, "$(P)$(R)NumChans")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_NUM_CHANS")
    field(ZRVL, "1")
    field(ZRST, "1")
    field(ONVL, "2")
    field(ONST, "2")
    field(TWVL, "3")
    field(TWST, "3")
    field(THVL, "4")
    field(THST, "4")
    field(FRVL, "5")
    field(FRST, "5")
    field(FVVL, "6")
    field(FVST, "6")
    field(SXVL, "7")
    field(SXST, "7")
    field(SVVL, "8")
    field(SVST, "8")
}
###################################################################
#  Timebase waveform record                                       #
###################################################################
record(waveform, "$(P)$(R)TimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Absolute timebase waveform record                              #
###################################################################
record(waveform, "$(P)$(R)AbsTimeWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_ABS_TIME_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point                                                 # 
###################################################################
record(ao, "$(P)$(R)Dwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  One-shot / continuous                                          # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Auto restart                                                   # 
###################################################################
record(bo, "$(P)$(R)AutoRestart")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_AUTO_RESTART")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Burst mode                                                     # 
###################################################################
record(bo, "$(P)$(R)BurstMode")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_BURST_MODE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}

###################################################################
#  Read waveforms                                                 # 
###################################################################
# This tells the driver to read, which then does callbacks to the
# input waveform records which are I/O Intr scanned
# The driver always reads the waveforms when acquisition completes,
# so this record can be passive for fast scans
record(busy, "$(P)$(R)ReadWF")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEDIG_READ_WF")
    field(ZNAM, "Done")
    field(ONAM, "Read")
    field(SCAN, "1 second")
    field(SDIS, "$(P)$(R)Run")
    field(DISV, "0")
}













üî• File: ./USB1608G_2AO_V2App/Db/measCompWaveformDigN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)VoltWF")
{
    field(FTVL, "DOUBLE")
    field(DTYP, "asynFloat64ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEDIG_VOLT_WF")
    field(NELM, "$(WDIG_POINTS)")
    field(SCAN, "I/O Intr")
}











üî• File: ./USB1608G_2AO_V2App/Db/measCompWaveformDig_settings.req
=================================================
$(P)$(R)NumPoints
$(P)$(R)FirstChan
$(P)$(R)NumChans
$(P)$(R)Dwell
$(P)$(R)ExtTrigger
$(P)$(R)ExtClock
$(P)$(R)Continuous
$(P)$(R)AutoRestart
$(P)$(R)Retrigger
$(P)$(R)TriggerCount
$(P)$(R)BurstMode
$(P)$(R)ReadWF.SCAN











üî• File: ./USB1608G_2AO_V2App/Db/measCompWaveformGen.template
=================================================
# Database for Measurement Computing waveform generator
# Mark Rivers
# November 6, 2011

###################################################################
#  Number of points to use                                        # 
###################################################################
record(longin, "$(P)$(R)NumPoints")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_NUM_POINTS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Number of points to use for user-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)UserNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Number of points to use for pre-defined waveforms             # 
###################################################################
record(longout, "$(P)$(R)IntNumPoints")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_NUM_POINTS")
    field(DRVL, "1")
    field(DRVH, "$(WGEN_POINTS)")
    field(VAL,  "$(WGEN_POINTS)")
}

###################################################################
#  Timebase waveform record for user waveforms                    #
###################################################################
record(waveform, "$(P)$(R)UserTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Timebase waveform record for predefined waveforms              #
###################################################################
record(waveform, "$(P)$(R)IntTimeWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_TIME_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Current point                                                  # 
###################################################################
record(longin, "$(P)$(R)CurrentPoint")
{
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_CURRENT_POINT")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Waveform frequency                                             # 
###################################################################
record(ai, "$(P)$(R)Frequency")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_FREQ")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Time per point readback, based on UserDwell or IntDwell        # 
###################################################################
record(ai, "$(P)$(R)Dwell")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

# Needed?
record(ai, "$(P)$(R)DwellActual")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_DWELL_ACTUAL")
    field(SCAN, "I/O Intr")
    field(PREC, "$(PREC)")
}

###################################################################
#  Total time                                                     # 
###################################################################
record(ai, "$(P)$(R)TotalTime")
{
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_TOTAL_TIME")
    field(PREC, "$(PREC)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Internal waveform dwell                                        # 
###################################################################
record(ao, "$(P)$(R)IntDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcIntFrequency")
}

###################################################################
#  Calculate internal frequency based on new dwell                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntFrequency")
{
    field(INPA, "$(P)$(R)IntDwell")
    field(INPB, "$(P)$(R)IntNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntDwell.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntFrequency PP MS")
}

###################################################################
#  Internal waveform frequency                                    # 
###################################################################
record(ao, "$(P)$(R)IntFrequency")
{
    field(PREC, "$(PREC)")
    field(OUT,  "$(P)$(R)CalcIntDwell PP MS")
}

###################################################################
#  Calculate internal dwell based on new frequency                # 
###################################################################
record(calcout, "$(P)$(R)CalcIntDwell")
{
    field(INPA, "$(P)$(R)IntFrequency")
    field(INPB, "$(P)$(R)IntNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcIntFrequency.PACT")
    field(DISV, "1")
    field(OUT,  "$(P)$(R)IntDwell PP MS")
}

###################################################################
#  User waveform dwell                                            # 
###################################################################
record(ao, "$(P)$(R)UserDwell")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_DWELL")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserFrequency")
}

###################################################################
#  Calculate user frequency based on new dwell                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserFrequency")
{
    field(INPA, "$(P)$(R)UserDwell")
    field(INPB, "$(P)$(R)UserNumPoints")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserDwell.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserFrequency PP MS")
}

###################################################################
#  User waveform frequency                                        # 
###################################################################
record(ao, "$(P)$(R)UserFrequency")
{
    field(PREC, "$(PREC)")
    field(FLNK, "$(P)$(R)CalcUserDwell PP MS")
}

###################################################################
#  Calculate user dwell based on new frequency                    # 
###################################################################
record(calcout, "$(P)$(R)CalcUserDwell")
{
    field(INPA, "$(P)$(R)UserFrequency")
    field(INPB, "$(P)$(R)UserNumPoints CP")
    field(CALC, "1/A/B")
    field(SDIS, "$(P)$(R)CalcUserFrequency.PACT")
    field(DISV, "1")
    field(OUT, "$(P)$(R)UserDwell PP MS")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)ExtTrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_TRIGGER")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External clock                                                 # 
###################################################################
record(bo, "$(P)$(R)ExtClock")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_EXT_CLOCK")
    field(ZNAM, "Internal")
    field(ONAM, "External")
}

###################################################################
#  External trigger                                               # 
###################################################################
record(bo, "$(P)$(R)Continuous")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_CONTINUOUS")
    field(ZNAM, "One-shot")
    field(ONAM, "Continuous")
}

###################################################################
#  Retrigger                                                      # 
###################################################################
record(bo, "$(P)$(R)Retrigger")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RETRIGGER")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Trigger count                                                  # 
###################################################################
record(longout, "$(P)$(R)TriggerCount")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_TRIGGER_COUNT")
    field(VAL,  "1")
}

###################################################################
#  Run                                                            # 
###################################################################
record(busy, "$(P)$(R)Run")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_RUN")
    field(ZNAM, "Stop")
    field(ONAM, "Run")
}













üî• File: ./USB1608G_2AO_V2App/Db/measCompWaveformGenN.template
=================================================
###################################################################
#  User-defined waveform record                                   #
###################################################################
record(waveform, "$(P)$(R)UserWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayOut")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_USER_WF")
    field(NELM, "$(WGEN_POINTS)")
}

###################################################################
#  Internally defined waveform record                             #
###################################################################
record(waveform, "$(P)$(R)InternalWF")
{
    field(FTVL, "FLOAT")
    field(DTYP, "asynFloat32ArrayIn")
    field(INP,  "@asyn($(PORT),$(ADDR))WAVEGEN_INT_WF")
    field(NELM, "$(WGEN_POINTS)")
    field(SCAN, "I/O Intr")
}

###################################################################
#  Enable this channel                                            # 
###################################################################
record(bo, "$(P)$(R)Enable")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_ENABLE")
    field(ZNAM, "Disable")
    field(ONAM, "Enable")
}

###################################################################
#  Waveform type                                                  # 
###################################################################
record(mbbo, "$(P)$(R)Type")
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_WAVE_TYPE")
    field(ZRVL, "0")
    field(ZRST, "User-defined")
    field(ONVL, "1")
    field(ONST, "Sin wave")
    field(TWVL, "2")
    field(TWST, "Square wave")
    field(THVL, "3")
    field(THST, "Sawtooth")
    field(FRVL, "4")
    field(FRST, "Pulse")
    field(FVVL, "5")
    field(FVST, "Random")
}

###################################################################
#  Pulse width                                                    # 
###################################################################
record(ao, "$(P)$(R)PulseWidth")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_PULSE_WIDTH")
    field(VAL,  "0.001")
    field(PREC, "$(PREC)")
}

###################################################################
#  Amplitude                                                      # 
###################################################################
record(ao, "$(P)$(R)Amplitude")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_AMPLITUDE")
    field(VAL,  "1.0")
    field(PREC, "4")
}

###################################################################
#  Offset                                                         # 
###################################################################
record(ao, "$(P)$(R)Offset")
{
    field(PINI, "YES")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR))WAVEGEN_OFFSET")
    field(VAL,  "0.0")
    field(PREC, "4")
}












üî• File: ./USB1608G_2AO_V2App/Db/measCompWaveformGenN_settings.req
=================================================
$(P)$(R)Enable
$(P)$(R)Type
$(P)$(R)PulseWidth
$(P)$(R)Amplitude
$(P)$(R)Offset











üî• File: ./USB1608G_2AO_V2App/Db/measCompWaveformGen_settings.req
=================================================
$(P)$(R)UserNumPoints
$(P)$(R)IntNumPoints
$(P)$(R)UserDwell
$(P)$(R)IntDwell
$(P)$(R)ExtTrigger
$(P)$(R)ExtClock
$(P)$(R)Continuous
$(P)$(R)Retrigger
$(P)$(R)TriggerCount











üî• File: ./USB1608G_2AO_V2App/Db/threshold_logic.template
=================================================
# ThresholdLogic.template
# EPICS Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖúÌîåÎ¶ø - ÏûÑÍ≥ÑÍ∞í Í∏∞Î∞ò Î°úÏßÅ Ï†úÏñ¥
# Îß§Í∞úÎ≥ÄÏàò:
#   P     - PV Ï†ëÎëêÏÇ¨ (Ïòà: "USB1608G_2AO_cpp:")
#   R     - Î†àÏΩîÎìú Ïù¥Î¶Ñ Ï†ëÎØ∏ÏÇ¨ (Ïòà: "ThresholdLogic")
#   PORT  - asyn Ìè¨Ìä∏ Ïù¥Î¶Ñ
#   ADDR  - asyn Ï£ºÏÜå (Í∏∞Î≥∏Í∞í: 0)
#   PREC  - ÏÜåÏàòÏ†ê ÏûêÎ¶øÏàò (Í∏∞Î≥∏Í∞í: 3)
#   EGU   - ÏóîÏßÄÎãàÏñ¥ÎßÅ Îã®ÏúÑ (Í∏∞Î≥∏Í∞í: "V")
#   SCAN  - Ïä§Ï∫î Ï£ºÍ∏∞ (Í∏∞Î≥∏Í∞í: "1 second")

# ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï Î†àÏΩîÎìú (ÏïÑÎÇ†Î°úÍ∑∏ Ï∂úÎ†•)
record(ao, "$(P)$(R)Threshold") {
    field(DESC, "Threshold Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))THRESHOLD_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(THRESHOLD=0.0)")
    field(DRVL, "$(DRVL=-10.0)")
    field(DRVH, "$(DRVH=10.0)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
}

# ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ ÏÑ§Ï†ï Î†àÏΩîÎìú (ÏïÑÎÇ†Î°úÍ∑∏ Ï∂úÎ†•)
record(ao, "$(P)$(R)Hysteresis") {
    field(DESC, "Hysteresis Value Setting")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))HYSTERESIS_VALUE")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(PINI, "YES")
    field(VAL,  "$(HYSTERESIS=0.1)")
    field(DRVL, "0.0")
    field(DRVH, "1.0")
    field(LOPR, "0.0")
    field(HOPR, "1.0")
}

# ÌòÑÏû¨ Í∞í Î™®ÎãàÌÑ∞ÎßÅ Î†àÏΩîÎìú (Ïã§Ï†ú ÏïÑÎÇ†Î°úÍ∑∏ ÏûÖÎ†• Ï±ÑÎÑêÏóêÏÑú Í∞í ÏùΩÍ∏∞)
record(ai, "$(P)$(R)CurrentValue") {
    field(DESC, "Current Input Value from $(IN_CH)")
    field(INP,  "$(P)$(IN_CH) CP")
    field(SCAN, "Passive")
    field(PREC, "$(PREC=3)")
    field(EGU,  "$(EGU=V)")
    field(LOPR, "$(LOPR=-10.0)")
    field(HOPR, "$(HOPR=10.0)")
    field(HIHI, "$(HIHI=9.0)")
    field(HIGH, "$(HIGH=8.0)")
    field(LOW,  "$(LOW=-8.0)")
    field(LOLO, "$(LOLO=-9.0)")
    field(HHSV, "MAJOR")
    field(HSV,  "MINOR")
    field(LSV,  "MINOR")
    field(LLSV, "MAJOR")
    field(FLNK, "$(P)$(R)Compare")
}

# ÏûÑÍ≥ÑÍ∞í ÎπÑÍµê Í≥ÑÏÇ∞ Î†àÏΩîÎìú
record(calcout, "$(P)$(R)Compare") {
    field(DESC, "Threshold Comparison :  $(IN_CH) -> $(OUT_CH)")
    field(CALC, "A>=(B+C)?1:(A<=(B-C)?0:D)")
    field(INPA, "$(P)$(IN_CH) CP")
    field(INPB, "$(P)$(R)Threshold")
    field(INPC, "$(P)$(R)Hysteresis")
    field(INPD, "$(P)$(R)OutputState")
    field(OUT,  "$(P)$(OUT_CH) PP")
    field(OOPT, "Every Time")
    field(DOPT, "Use CALC")
    field(SCAN, "Passive")
}

# Ï∂úÎ†• ÏÉÅÌÉú Î†àÏΩîÎìú (Ïã§Ï†ú Î∞îÏù¥ÎÑàÎ¶¨ Ï∂úÎ†• Ï±ÑÎÑê ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ)
record(bi, "$(P)$(R)OutputState") {
    field(DESC, "Current Output State of $(OUT_CH)")
    field(INP,  "$(P)$(OUT_CH) CP")
    field(SCAN, "Passive")
    field(ZNAM, "Low")
    field(ONAM, "High")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# ÌôúÏÑ±Ìôî Ï†úÏñ¥ Î†àÏΩîÎìú (Î∞îÏù¥ÎÑàÎ¶¨ Ï∂úÎ†•)
record(bo, "$(P)$(R)Enable") {
    field(DESC, "Enable/Disable Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))ENABLE")
    field(PINI, "YES")
    field(VAL,  "$(ENABLE=0)")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "NO_ALARM")
}

# ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ Î†àÏΩîÎìú (Îã§Ï§ë Î∞îÏù¥ÎÑàÎ¶¨ ÏûÖÎ†•)
record(mbbi, "$(P)$(R)Status") {
    field(DESC, "Threshold Logic Status")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))STATUS")
    field(SCAN, "I/O Intr")
    field(ZRST, "Idle")
    field(ONST, "Active")
    field(TWST, "Error")
    field(THST, "Disabled")
    field(ZRSV, "NO_ALARM")
    field(ONSV, "NO_ALARM")
    field(TWSV, "MAJOR")
    field(THSV, "NO_ALARM")
}

# Î¶¨ÏÖã Î™ÖÎ†π Î†àÏΩîÎìú (Î∞îÏù¥ÎÑàÎ¶¨ Ï∂úÎ†•)
record(bo, "$(P)$(R)Reset") {
    field(DESC, "Reset Threshold Logic")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))RESET")
    field(ZNAM, "Normal")
    field(ONAM, "Reset")
    field(HIGH, "1")
    field(PINI, "NO")
}

# ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ ÏÑ§Ï†ï Î†àÏΩîÎìú (ÏïÑÎÇ†Î°úÍ∑∏ Ï∂úÎ†•)
record(ao, "$(P)$(R)UpdateRate") {
    field(DESC, "Update Rate in Hz")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR=0))UPDATE_RATE")
    field(PREC, "1")
    field(EGU,  "Hz")
    field(PINI, "YES")
    field(VAL,  "$(UPDATE_RATE=10.0)")
    field(DRVL, "0.1")
    field(DRVH, "1000.0")
    field(LOPR, "0.1")
    field(HOPR, "1000.0")
}

# ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ Î†àÏΩîÎìú (Î¨∏ÏûêÏó¥ ÏûÖÎ†•)
record(stringin, "$(P)$(R)LastUpdate") {
    field(DESC, "Last Update Timestamp")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR=0))LAST_UPDATE")
    field(SCAN, "I/O Intr")
    field(VAL,  "Never")
}

# ÏïåÎûå ÏÉÅÌÉú Î†àÏΩîÎìú (Î∞îÏù¥ÎÑàÎ¶¨ ÏûÖÎ†•)
record(bi, "$(P)$(R)AlarmState") {
    field(DESC, "Alarm State")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))ALARM_STATE")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Normal")
    field(ONAM, "Alarm")
    field(ZSV,  "NO_ALARM")
    field(OSV,  "MAJOR")
}

# Ìä∏Î¶¨Í±∞ Ïπ¥Ïö¥ÌÑ∞ Î†àÏΩîÎìú (Î°± ÏûÖÎ†•)
record(longin, "$(P)$(R)TriggerCount") {
    field(DESC, "Number of Threshold Triggers")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR=0))TRIGGER_COUNT")
    field(SCAN, "I/O Intr")
    field(EGU,  "counts")
}










üî• File: ./USB1608G_2AO_V2App/Db/user.db
=================================================
[SKIPPED: ‚≠ï empty file]











üî• File: ./USB1608G_2AO_V2App/Db/user.proto
=================================================
[SKIPPED: ‚≠ï empty file]











üî• File: ./USB1608G_2AO_V2App/Db/user.substitutions
=================================================
[SKIPPED: ‚≠ï empty file]











üî• File: ./USB1608G_2AO_V2App/Makefile
=================================================
# Makefile at top of application tree
TOP = ..
include $(TOP)/configure/CONFIG

# Directories to be built, in any order.
# You can replace these wildcards with an explicit list
DIRS += $(wildcard src* *Src*)
DIRS += $(wildcard db* *Db*)

# If the build order matters, add dependency rules like this,
# which specifies that xxxSrc must be built after src:
#xxxSrc_DEPEND_DIRS += src

include $(TOP)/configure/RULES_DIRS











üî• File: ./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.adl
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.adl)]











üî• File: ./USB1608G_2AO_V2App/op/USB1608G_2AO_V2.opi
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.opi)]











üî• File: ./USB1608G_2AO_V2App/op/measCompADCStripChart.adl
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.adl)]











üî• File: ./USB1608G_2AO_V2App/op/measCompAiSetup.adl
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.adl)]











üî• File: ./USB1608G_2AO_V2App/op/measCompAnalogIn8.adl
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.adl)]











üî• File: ./USB1608G_2AO_V2App/op/measCompAnalogIn8.opi
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.opi)]











üî• File: ./USB1608G_2AO_V2App/op/measCompAnalogOut2.adl
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.adl)]











üî• File: ./USB1608G_2AO_V2App/op/measCompAnalogOut2.opi
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.opi)]











üî• File: ./USB1608G_2AO_V2App/op/measCompAoSetup2.adl
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.adl)]











üî• File: ./USB1608G_2AO_V2App/op/measCompDigitalIO8.adl
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.adl)]











üî• File: ./USB1608G_2AO_V2App/op/measCompDigitalIO8.opi
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.opi)]











üî• File: ./USB1608G_2AO_V2App/src/ErrorHandler.cpp
=================================================
/* ErrorHandler.cpp
 *
 * Ïò§Î•ò Ï≤òÎ¶¨ Î∞è Î°úÍπÖÏùÑ ÏúÑÌïú Ïú†Ìã∏Î¶¨Ìã∞ ÌÅ¥ÎûòÏä§ Íµ¨ÌòÑ
 * 
 * Ïù¥ ÌÅ¥ÎûòÏä§Îäî EPICS IOC Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏóêÏÑú Î∞úÏÉùÌïòÎäî Îã§ÏñëÌïú Ïò§Î•òÎ•º 
 * Î∂ÑÎ•òÌïòÍ≥† Î°úÍπÖÌïòÎ©∞, EPICS ÏïåÎûå ÏãúÏä§ÌÖúÍ≥º ÌÜµÌï©ÌïòÏó¨ ÏÉÅÌÉúÎ•º Î≥¥Í≥†Ìï©ÎãàÎã§.
 *
 * Author: EPICS IOC Development Guide
 * Date: 2025
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include <epicsTime.h>
#include <epicsString.h>
#include <epicsThread.h>
#include <epicsMutex.h>
#include <asynDriver.h>

#include "ErrorHandler.h"

// Ï†ïÏ†Å Î©§Î≤Ñ Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
int ErrorHandler::infoCount_ = 0;
int ErrorHandler::warningCount_ = 0;
int ErrorHandler::errorCount_ = 0;
int ErrorHandler::fatalCount_ = 0;

// Ïä§Î†àÎìú ÏïàÏ†ÑÏÑ±ÏùÑ ÏúÑÌïú ÎÆ§ÌÖçÏä§
static epicsMutexId errorStatsMutex = NULL;

// ÎÆ§ÌÖçÏä§ Ï¥àÍ∏∞Ìôî (Ìïú Î≤àÎßå Ïã§Ìñâ)
static void initializeMutex() {
    if (errorStatsMutex == NULL) {
        errorStatsMutex = epicsMutexCreate();
    }
}

/** Ïò§Î•ò Î°úÍπÖ Î©îÏÑúÎìú */
void ErrorHandler::logError(ErrorLevel level, const char* source, const char* message, 
                           asynUser* pasynUser)
{
    if (source == NULL || message == NULL) {
        printf("ErrorHandler::logError: NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®\n");
        return;
    }
    
    // ÎÆ§ÌÖçÏä§ Ï¥àÍ∏∞Ìôî ÌôïÏù∏
    initializeMutex();
    
    // ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ (Ïä§Î†àÎìú ÏïàÏ†Ñ)
    epicsMutexLock(errorStatsMutex);
    switch (level) {
        case INFO:    infoCount_++;    break;
        case WARNING: warningCount_++; break;
        case ERROR:   errorCount_++;   break;
        case FATAL:   fatalCount_++;   break;
    }
    epicsMutexUnlock(errorStatsMutex);
    
    // ÎÇ¥Î∂Ä Î°úÍπÖ Ìò∏Ï∂ú
    internalLog(level, source, message, pasynUser);
}

/** ÏÉÅÏÑ∏ Ïò§Î•ò Î°úÍπÖ Î©îÏÑúÎìú */
void ErrorHandler::logDetailedError(ErrorLevel level, const char* source, const char* message,
                                   const char* details, int errorCode, asynUser* pasynUser)
{
    if (source == NULL || message == NULL) {
        printf("ErrorHandler::logDetailedError: NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®\n");
        return;
    }
    
    // ÏÉÅÏÑ∏ Î©îÏãúÏßÄ Íµ¨ÏÑ±
    char detailedMessage[512];
    if (details != NULL && strlen(details) > 0) {
        snprintf(detailedMessage, sizeof(detailedMessage), 
                "%s [ÏÉÅÏÑ∏: %s] [Ïò§Î•òÏΩîÎìú: %d]", message, details, errorCode);
    } else {
        snprintf(detailedMessage, sizeof(detailedMessage), 
                "%s [Ïò§Î•òÏΩîÎìú: %d]", message, errorCode);
    }
    
    // ÏùºÎ∞ò Î°úÍπÖ Î©îÏÑúÎìú Ìò∏Ï∂ú
    logError(level, source, detailedMessage, pasynUser);
}

/** EPICS ÏïåÎûå ÏÉÅÌÉú ÏÑ§Ï†ï */
asynStatus ErrorHandler::setAlarmStatus(asynUser* pasynUser, AlarmStatus status, AlarmSeverity severity)
{
    if (pasynUser == NULL) {
        logError(ERROR, "ErrorHandler::setAlarmStatus", "NULL asynUser Ìè¨Ïù∏ÌÑ∞");
        return asynError;
    }
    
    // EPICS ÏïåÎûå ÏÑ§Ï†ï (Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî asynPortDriverÏùò setParamAlarmStatus ÏÇ¨Ïö©)
    // Ïó¨Í∏∞ÏÑúÎäî Î°úÍπÖÎßå ÏàòÌñâ
    char alarmMessage[256];
    snprintf(alarmMessage, sizeof(alarmMessage),
            "ÏïåÎûå ÏÑ§Ï†ï - ÏÉÅÌÉú: %s, Ïã¨Í∞ÅÎèÑ: %s",
            alarmStatusToString(status), alarmSeverityToString(severity));
    
    ErrorLevel logLevel = INFO;
    switch (severity) {
        case NO_ALARM:      logLevel = INFO;    break;
        case MINOR_ALARM:   logLevel = WARNING; break;
        case MAJOR_ALARM:   logLevel = ERROR;   break;
        case INVALID_ALARM: logLevel = FATAL;   break;
    }
    
    logError(logLevel, "ErrorHandler::setAlarmStatus", alarmMessage, pasynUser);
    
    return asynSuccess;
}

/** ThresholdLogicController Íµ¨ÏÑ± Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ */
ErrorHandler::ValidationResult ErrorHandler::validateConfiguration(const ThresholdConfig& config)
{
    ValidationResult result;
    result.isValid = true;
    result.errorLevel = INFO;
    strcpy(result.errorMessage, "");
    strcpy(result.suggestion, "");
    
    // Ìè¨Ìä∏ Ïù¥Î¶Ñ Í≤ÄÏÇ¨
    if (!validateStringParameter("portName", config.portName, sizeof(config.portName), 
                                false, "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "Ìè¨Ìä∏ Ïù¥Î¶ÑÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§");
        strcpy(result.suggestion, "1-63ÏûêÏùò ÏòÅÏà´ÏûêÏôÄ Ïñ∏ÎçîÏä§ÏΩîÏñ¥Îßå ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî");
        return result;
    }
    
    // Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ Í≤ÄÏÇ¨
    if (!validateStringParameter("devicePort", config.devicePort, sizeof(config.devicePort), 
                                false, "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶ÑÏù¥ Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§");
        strcpy(result.suggestion, "Ïú†Ìö®Ìïú asyn Ìè¨Ìä∏ Ïù¥Î¶ÑÏùÑ ÏßÄÏ†ïÌïòÏÑ∏Ïöî");
        return result;
    }
    
    // Ïû•Ïπò Ï£ºÏÜå Í≤ÄÏÇ¨
    if (!validateIntParameter("deviceAddr", config.deviceAddr, 0, 255, 
                             "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "Ïû•Ïπò Ï£ºÏÜåÍ∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§");
        strcpy(result.suggestion, "0-255 Î≤îÏúÑÏùò Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî");
        return result;
    }
    
    // ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Í≤ÄÏÇ¨
    if (!validateParameter("updateRate", config.updateRate, 0.1, 1000.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞Í∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§");
        strcpy(result.suggestion, "0.1-1000.0 Hz Î≤îÏúÑÏùò Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî");
        return result;
    }
    
    // Ïä§Î†àÎìú Ïö∞ÏÑ†ÏàúÏúÑ Í≤ÄÏÇ¨
    if (!validateIntParameter("priority", config.priority, 0, 99, 
                             "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = WARNING;
        strcpy(result.errorMessage, "Ïä§Î†àÎìú Ïö∞ÏÑ†ÏàúÏúÑÍ∞Ä Í∂åÏû• Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§");
        strcpy(result.suggestion, "0-99 Î≤îÏúÑÏùò Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî (Í∏∞Î≥∏Í∞í: 50)");
        // Í≤ΩÍ≥†Ïù¥ÎØÄÎ°ú Í≥ÑÏÜç Í≤ÄÏÇ¨
    }
    
    // ÏûÑÍ≥ÑÍ∞í Í≤ÄÏÇ¨
    if (!validateParameter("thresholdValue", config.thresholdValue, -10.0, 10.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "ÏûÑÍ≥ÑÍ∞íÏù¥ Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§");
        strcpy(result.suggestion, "-10.0V ~ +10.0V Î≤îÏúÑÏùò Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî");
        return result;
    }
    
    // ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í≤ÄÏÇ¨
    if (!validateParameter("hysteresis", config.hysteresis, 0.0, 5.0, 
                          "ErrorHandler::validateConfiguration")) {
        result.isValid = false;
        result.errorLevel = ERROR;
        strcpy(result.errorMessage, "ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Í∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§");
        strcpy(result.suggestion, "0.0V ~ 5.0V Î≤îÏúÑÏùò Í∞íÏùÑ ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî");
        return result;
    }
    
    // ÏûÑÍ≥ÑÍ∞íÍ≥º ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í¥ÄÍ≥Ñ Í≤ÄÏÇ¨
    if (config.hysteresis > fabs(config.thresholdValue)) {
        result.isValid = false;
        result.errorLevel = WARNING;
        strcpy(result.errorMessage, "ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Í∞Ä ÏûÑÍ≥ÑÍ∞íÎ≥¥Îã§ ÌÅΩÎãàÎã§");
        strcpy(result.suggestion, "ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Î•º ÏûÑÍ≥ÑÍ∞í Ï†àÎåìÍ∞íÎ≥¥Îã§ ÏûëÍ≤å ÏÑ§Ï†ïÌïòÏÑ∏Ïöî");
        // Í≤ΩÍ≥†Ïù¥ÎØÄÎ°ú Ïú†Ìö®ÏÑ±ÏùÄ ÌÜµÍ≥ºÎ°ú Ï≤òÎ¶¨
        result.isValid = true;
    }
    
    // Î™®Îì† Í≤ÄÏÇ¨ ÌÜµÍ≥º
    if (result.isValid && result.errorLevel == INFO) {
        strcpy(result.errorMessage, "Íµ¨ÏÑ±Ïù¥ Ïú†Ìö®Ìï©ÎãàÎã§");
        strcpy(result.suggestion, "");
    }
    
    return result;
}

/** Îü∞ÌÉÄÏûÑ Ïò§Î•ò Ï≤òÎ¶¨ */
bool ErrorHandler::handleRuntimeError(const char* source, const char* errorType, 
                                     int errorCode, asynUser* pasynUser)
{
    if (source == NULL || errorType == NULL) {
        logError(ERROR, "ErrorHandler::handleRuntimeError", "NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®");
        return false;
    }
    
    char errorMessage[256];
    snprintf(errorMessage, sizeof(errorMessage), 
            "Îü∞ÌÉÄÏûÑ Ïò§Î•ò Î∞úÏÉù - Ïú†Ìòï: %s, ÏΩîÎìú: %d", errorType, errorCode);
    
    ErrorLevel level = ERROR;
    bool recoverable = true;
    
    // Ïò§Î•ò Ïú†ÌòïÎ≥Ñ Ï≤òÎ¶¨
    if (strcmp(errorType, "MEMORY_ALLOCATION") == 0) {
        level = FATAL;
        recoverable = false;
        logError(level, source, "Î©îÎ™®Î¶¨ Ìï†Îãπ Ïã§Ìå® - ÏãúÏä§ÌÖú Ïû¨ÏãúÏûë ÌïÑÏöî", pasynUser);
    }
    else if (strcmp(errorType, "THREAD_CREATION") == 0) {
        level = ERROR;
        recoverable = true;
        logError(level, source, "Ïä§Î†àÎìú ÏÉùÏÑ± Ïã§Ìå® - Ïû¨ÏãúÎèÑ Í∞ÄÎä•", pasynUser);
    }
    else if (strcmp(errorType, "PARAMETER_VALIDATION") == 0) {
        level = WARNING;
        recoverable = true;
        logError(level, source, "Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå® - Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©", pasynUser);
    }
    else if (strcmp(errorType, "DEVICE_COMMUNICATION") == 0) {
        level = ERROR;
        recoverable = true;
        logError(level, source, "Ïû•Ïπò ÌÜµÏã† Ïò§Î•ò - Ïó∞Í≤∞ ÌôïÏù∏ ÌïÑÏöî", pasynUser);
    }
    else if (strcmp(errorType, "TIMEOUT") == 0) {
        level = WARNING;
        recoverable = true;
        logError(level, source, "ÌÉÄÏûÑÏïÑÏõÉ Î∞úÏÉù - Ïû¨ÏãúÎèÑ Í∂åÏû•", pasynUser);
    }
    else {
        // Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò Ïú†Ìòï
        logError(level, source, errorMessage, pasynUser);
    }
    
    return recoverable;
}

/** ÌÜµÏã† Ïò§Î•ò Ï≤òÎ¶¨ */
bool ErrorHandler::handleCommunicationError(const char* source, const char* devicePort,
                                           int deviceAddr, const char* operation,
                                           asynUser* pasynUser)
{
    if (source == NULL || devicePort == NULL || operation == NULL) {
        logError(ERROR, "ErrorHandler::handleCommunicationError", "NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®");
        return false;
    }
    
    char errorMessage[256];
    snprintf(errorMessage, sizeof(errorMessage),
            "ÌÜµÏã† Ïò§Î•ò - Ìè¨Ìä∏: %s, Ï£ºÏÜå: %d, ÏûëÏóÖ: %s", 
            devicePort, deviceAddr, operation);
    
    logError(ERROR, source, errorMessage, pasynUser);
    
    // ÏïåÎûå ÏÑ§Ï†ï
    if (pasynUser != NULL) {
        setAlarmStatus(pasynUser, COMM_ALARM, MAJOR_ALARM);
    }
    
    // ÌÜµÏã† Ïò§Î•òÎäî ÏùºÎ∞òÏ†ÅÏúºÎ°ú Ïû¨ÏãúÎèÑ Í∞ÄÎä•
    return true;
}

/** Ïä§Î†àÎìú Ïò§Î•ò Ï≤òÎ¶¨ */
bool ErrorHandler::handleThreadError(const char* source, const char* threadName,
                                    const char* errorMessage, asynUser* pasynUser)
{
    if (source == NULL || threadName == NULL || errorMessage == NULL) {
        logError(ERROR, "ErrorHandler::handleThreadError", "NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®");
        return false;
    }
    
    char fullMessage[256];
    snprintf(fullMessage, sizeof(fullMessage),
            "Ïä§Î†àÎìú Ïò§Î•ò - Ïù¥Î¶Ñ: %s, Î©îÏãúÏßÄ: %s", threadName, errorMessage);
    
    logError(ERROR, source, fullMessage, pasynUser);
    
    // Ïä§Î†àÎìú Ïò§Î•òÎäî ÎåÄÎ∂ÄÎ∂Ñ Ïû¨ÏãúÏûë Í∞ÄÎä•
    bool restartRecommended = true;
    
    // ÌäπÏ†ï Ïò§Î•ò Ïú†ÌòïÏóê Îî∞Î•∏ Ï≤òÎ¶¨
    if (strstr(errorMessage, "FATAL") != NULL || strstr(errorMessage, "SEGFAULT") != NULL) {
        restartRecommended = false;
        logError(FATAL, source, "ÏπòÎ™ÖÏ†Å Ïä§Î†àÎìú Ïò§Î•ò - Ïû¨ÏãúÏûë Î∂àÍ∞Ä", pasynUser);
    }
    
    return restartRecommended;
}

/** Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ */
bool ErrorHandler::validateParameter(const char* paramName, double value, 
                                   double minValue, double maxValue, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateParameter", "NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®");
        return false;
    }
    
    if (isnan(value) || isinf(value)) {
        char message[256];
        snprintf(message, sizeof(message), 
                "Îß§Í∞úÎ≥ÄÏàò '%s'Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Í∞íÏûÖÎãàÎã§ (NaN ÎòêÎäî Inf)", paramName);
        logError(ERROR, source, message);
        return false;
    }
    
    if (value < minValue || value > maxValue) {
        char message[256];
        snprintf(message, sizeof(message),
                "Îß§Í∞úÎ≥ÄÏàò '%s' Í∞í %fÏù¥ Ïú†Ìö® Î≤îÏúÑ [%f, %f]Î•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§",
                paramName, value, minValue, maxValue);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** Ï†ïÏàò Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ */
bool ErrorHandler::validateIntParameter(const char* paramName, int value, 
                                       int minValue, int maxValue, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateIntParameter", "NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®");
        return false;
    }
    
    if (value < minValue || value > maxValue) {
        char message[256];
        snprintf(message, sizeof(message),
                "Ï†ïÏàò Îß§Í∞úÎ≥ÄÏàò '%s' Í∞í %dÏù¥ Ïú†Ìö® Î≤îÏúÑ [%d, %d]Î•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§",
                paramName, value, minValue, maxValue);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** Î¨∏ÏûêÏó¥ Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ */
bool ErrorHandler::validateStringParameter(const char* paramName, const char* value,
                                          size_t maxLength, bool allowEmpty, const char* source)
{
    if (paramName == NULL || source == NULL) {
        logError(ERROR, "ErrorHandler::validateStringParameter", "NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®");
        return false;
    }
    
    if (value == NULL) {
        char message[256];
        snprintf(message, sizeof(message), "Î¨∏ÏûêÏó¥ Îß§Í∞úÎ≥ÄÏàò '%s'Í∞Ä NULLÏûÖÎãàÎã§", paramName);
        logError(ERROR, source, message);
        return false;
    }
    
    size_t length = strlen(value);
    
    if (!allowEmpty && length == 0) {
        char message[256];
        snprintf(message, sizeof(message), "Î¨∏ÏûêÏó¥ Îß§Í∞úÎ≥ÄÏàò '%s'Í∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§", paramName);
        logError(WARNING, source, message);
        return false;
    }
    
    if (length >= maxLength) {
        char message[256];
        snprintf(message, sizeof(message),
                "Î¨∏ÏûêÏó¥ Îß§Í∞úÎ≥ÄÏàò '%s' Í∏∏Ïù¥ %zuÍ∞Ä ÏµúÎåÄ Í∏∏Ïù¥ %zuÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§",
                paramName, length, maxLength - 1);
        logError(WARNING, source, message);
        return false;
    }
    
    return true;
}

/** Ïò§Î•ò ÌÜµÍ≥Ñ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞ */
void ErrorHandler::getErrorStatistics(int* infoCount, int* warningCount, 
                                     int* errorCount, int* fatalCount)
{
    initializeMutex();
    
    epicsMutexLock(errorStatsMutex);
    if (infoCount)    *infoCount = infoCount_;
    if (warningCount) *warningCount = warningCount_;
    if (errorCount)   *errorCount = errorCount_;
    if (fatalCount)   *fatalCount = fatalCount_;
    epicsMutexUnlock(errorStatsMutex);
}

/** Ïò§Î•ò ÌÜµÍ≥Ñ Ï¥àÍ∏∞Ìôî */
void ErrorHandler::resetErrorStatistics()
{
    initializeMutex();
    
    epicsMutexLock(errorStatsMutex);
    infoCount_ = 0;
    warningCount_ = 0;
    errorCount_ = 0;
    fatalCount_ = 0;
    epicsMutexUnlock(errorStatsMutex);
    
    logError(INFO, "ErrorHandler::resetErrorStatistics", "Ïò§Î•ò ÌÜµÍ≥ÑÍ∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§");
}

/** Ïò§Î•ò Î†àÎ≤®ÏùÑ Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò */
const char* ErrorHandler::errorLevelToString(ErrorLevel level)
{
    switch (level) {
        case INFO:    return "Ï†ïÎ≥¥";
        case WARNING: return "Í≤ΩÍ≥†";
        case ERROR:   return "Ïò§Î•ò";
        case FATAL:   return "ÏπòÎ™ÖÏ†Å";
        default:      return "ÏïåÏàòÏóÜÏùå";
    }
}

/** ÏïåÎûå Ïã¨Í∞ÅÎèÑÎ•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò */
const char* ErrorHandler::alarmSeverityToString(AlarmSeverity severity)
{
    switch (severity) {
        case NO_ALARM:      return "ÏïåÎûåÏóÜÏùå";
        case MINOR_ALARM:   return "Í≤ΩÎØ∏ÌïúÏïåÎûå";
        case MAJOR_ALARM:   return "Ï£ºÏöîÏïåÎûå";
        case INVALID_ALARM: return "Ïú†Ìö®ÌïòÏßÄÏïäÏùå";
        default:            return "ÏïåÏàòÏóÜÏùå";
    }
}

/** ÏïåÎûå ÏÉÅÌÉúÎ•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò */
const char* ErrorHandler::alarmStatusToString(AlarmStatus status)
{
    switch (status) {
        case NO_ALARM_STATUS:     return "Ï†ïÏÉÅ";
        case READ_ALARM:          return "ÏùΩÍ∏∞Ïò§Î•ò";
        case WRITE_ALARM:         return "Ïì∞Í∏∞Ïò§Î•ò";
        case HIHI_ALARM:          return "ÏÉÅÌïúÏÉÅÌïú";
        case HIGH_ALARM:          return "ÏÉÅÌïú";
        case LOLO_ALARM:          return "ÌïòÌïúÌïòÌïú";
        case LOW_ALARM:           return "ÌïòÌïú";
        case STATE_ALARM:         return "ÏÉÅÌÉúÏò§Î•ò";
        case COS_ALARM:           return "Î≥ÄÌôîÏïåÎûå";
        case COMM_ALARM:          return "ÌÜµÏã†Ïò§Î•ò";
        case TIMEOUT_ALARM:       return "ÌÉÄÏûÑÏïÑÏõÉ";
        case HW_LIMIT_ALARM:      return "ÌïòÎìúÏõ®Ïñ¥Ï†úÌïú";
        case CALC_ALARM:          return "Í≥ÑÏÇ∞Ïò§Î•ò";
        case SCAN_ALARM:          return "Ïä§Ï∫îÏò§Î•ò";
        case LINK_ALARM:          return "ÎßÅÌÅ¨Ïò§Î•ò";
        case SOFT_ALARM:          return "ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ÏïåÎûå";
        case BAD_SUB_ALARM:       return "ÏûòÎ™ªÎêúÏÑúÎ∏åÎ†àÏΩîÎìú";
        case UDF_ALARM:           return "Ï†ïÏùòÎêòÏßÄÏïäÏùÄÍ∞í";
        case DISABLE_ALARM:       return "ÎπÑÌôúÏÑ±Ìôî";
        case SIMM_ALARM:          return "ÏãúÎÆ¨Î†àÏù¥ÏÖò";
        case READ_ACCESS_ALARM:   return "ÏùΩÍ∏∞Ï†ëÍ∑ºÏò§Î•ò";
        case WRITE_ACCESS_ALARM:  return "Ïì∞Í∏∞Ï†ëÍ∑ºÏò§Î•ò";
        default:                  return "ÏïåÏàòÏóÜÏùå";
    }
}

/** ÎÇ¥Î∂Ä Î°úÍπÖ Î©îÏÑúÎìú */
void ErrorHandler::internalLog(ErrorLevel level, const char* source, const char* message,
                              asynUser* pasynUser)
{
    // ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ ÏÉùÏÑ±
    char timestamp[64];
    getTimestampString(timestamp, sizeof(timestamp));
    
    // Î°úÍ∑∏ Î©îÏãúÏßÄ Íµ¨ÏÑ±
    char logMessage[512];
    snprintf(logMessage, sizeof(logMessage),
            "[%s] [%s] %s: %s",
            timestamp, errorLevelToString(level), source, message);
    
    // ÏΩòÏÜî Ï∂úÎ†•
    printf("%s\n", logMessage);
    
    // asyn Ìä∏Î†àÏù¥Ïä§ Ï∂úÎ†• (pasynUserÍ∞Ä ÏûàÎäî Í≤ΩÏö∞)
    if (pasynUser != NULL) {
        int traceLevel = convertToAsynTraceLevel(level);
        asynPrint(pasynUser, traceLevel, "%s\n", logMessage);
    }
}

/** ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Î¨∏ÏûêÏó¥ ÏÉùÏÑ± */
void ErrorHandler::getTimestampString(char* buffer, size_t bufferSize)
{
    if (buffer == NULL || bufferSize == 0) {
        return;
    }
    
    epicsTimeStamp currentTime;
    epicsTimeGetCurrent(&currentTime);
    
    // EPICS ÏãúÍ∞ÑÏùÑ Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
    char epicsTimeStr[64];
    epicsTimeToStrftime(epicsTimeStr, sizeof(epicsTimeStr), "%Y-%m-%d %H:%M:%S.%06f", &currentTime);
    
    strncpy(buffer, epicsTimeStr, bufferSize - 1);
    buffer[bufferSize - 1] = '\0';
}

/** asyn Ìä∏Î†àÏù¥Ïä§ Î†àÎ≤® Î≥ÄÌôò */
int ErrorHandler::convertToAsynTraceLevel(ErrorLevel level)
{
    switch (level) {
        case INFO:    return ASYN_TRACE_FLOW;
        case WARNING: return ASYN_TRACE_WARNING;
        case ERROR:   return ASYN_TRACE_ERROR;
        case FATAL:   return ASYN_TRACE_ERROR;
        default:      return ASYN_TRACE_ERROR;
    }
}










üî• File: ./USB1608G_2AO_V2App/src/ErrorHandler.h
=================================================
#ifndef ErrorHandlerInclude
#define ErrorHandlerInclude

#include <epicsTime.h>
#include <asynDriver.h>
#include <shareLib.h>

/** Ïò§Î•ò Ï≤òÎ¶¨ Î∞è Î°úÍπÖÏùÑ ÏúÑÌïú Ïú†Ìã∏Î¶¨Ìã∞ ÌÅ¥ÎûòÏä§
 * 
 * Ïù¥ ÌÅ¥ÎûòÏä§Îäî EPICS IOC Ïï†ÌîåÎ¶¨ÏºÄÏù¥ÏÖòÏóêÏÑú Î∞úÏÉùÌïòÎäî Îã§ÏñëÌïú Ïò§Î•òÎ•º 
 * Î∂ÑÎ•òÌïòÍ≥† Î°úÍπÖÌïòÎ©∞, EPICS ÏïåÎûå ÏãúÏä§ÌÖúÍ≥º ÌÜµÌï©ÌïòÏó¨ ÏÉÅÌÉúÎ•º Î≥¥Í≥†Ìï©ÎãàÎã§.
 */
class epicsShareClass ErrorHandler {
public:
    /** Ïò§Î•ò Î†àÎ≤® Ï†ïÏùò */
    enum ErrorLevel {
        INFO = 0,       ///< Ï†ïÎ≥¥ÏÑ± Î©îÏãúÏßÄ
        WARNING = 1,    ///< Í≤ΩÍ≥† - ÎèôÏûëÏóê ÏòÅÌñ• ÏóÜÏùå
        ERROR = 2,      ///< Ïò§Î•ò - Í∏∞Îä•Ïóê ÏòÅÌñ• ÏûàÏùå
        FATAL = 3       ///< ÏπòÎ™ÖÏ†Å Ïò§Î•ò - ÏãúÏä§ÌÖú Ï§ëÎã® ÌïÑÏöî
    };
    
    /** EPICS ÏïåÎûå Ïã¨Í∞ÅÎèÑ Ï†ïÏùò */
    enum AlarmSeverity {
        NO_ALARM = 0,       ///< ÏïåÎûå ÏóÜÏùå
        MINOR_ALARM = 1,    ///< Í≤ΩÎØ∏Ìïú ÏïåÎûå
        MAJOR_ALARM = 2,    ///< Ï£ºÏöî ÏïåÎûå
        INVALID_ALARM = 3   ///< Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÏÉÅÌÉú
    };
    
    /** EPICS ÏïåÎûå ÏÉÅÌÉú Ï†ïÏùò */
    enum AlarmStatus {
        NO_ALARM_STATUS = 0,    ///< Ï†ïÏÉÅ ÏÉÅÌÉú
        READ_ALARM = 1,         ///< ÏùΩÍ∏∞ Ïò§Î•ò
        WRITE_ALARM = 2,        ///< Ïì∞Í∏∞ Ïò§Î•ò
        HIHI_ALARM = 3,         ///< ÏÉÅÌïú ÏÉÅÌïú ÏïåÎûå
        HIGH_ALARM = 4,         ///< ÏÉÅÌïú ÏïåÎûå
        LOLO_ALARM = 5,         ///< ÌïòÌïú ÌïòÌïú ÏïåÎûå
        LOW_ALARM = 6,          ///< ÌïòÌïú ÏïåÎûå
        STATE_ALARM = 7,        ///< ÏÉÅÌÉú ÏïåÎûå
        COS_ALARM = 8,          ///< Î≥ÄÌôî ÏïåÎûå
        COMM_ALARM = 9,         ///< ÌÜµÏã† ÏïåÎûå
        TIMEOUT_ALARM = 10,     ///< ÌÉÄÏûÑÏïÑÏõÉ ÏïåÎûå
        HW_LIMIT_ALARM = 11,    ///< ÌïòÎìúÏõ®Ïñ¥ Ï†úÌïú ÏïåÎûå
        CALC_ALARM = 12,        ///< Í≥ÑÏÇ∞ Ïò§Î•ò ÏïåÎûå
        SCAN_ALARM = 13,        ///< Ïä§Ï∫î Ïò§Î•ò ÏïåÎûå
        LINK_ALARM = 14,        ///< ÎßÅÌÅ¨ Ïò§Î•ò ÏïåÎûå
        SOFT_ALARM = 15,        ///< ÏÜåÌîÑÌä∏Ïõ®Ïñ¥ ÏïåÎûå
        BAD_SUB_ALARM = 16,     ///< ÏûòÎ™ªÎêú ÏÑúÎ∏åÎ†àÏΩîÎìú ÏïåÎûå
        UDF_ALARM = 17,         ///< Ï†ïÏùòÎêòÏßÄ ÏïäÏùÄ Í∞í ÏïåÎûå
        DISABLE_ALARM = 18,     ///< ÎπÑÌôúÏÑ±Ìôî ÏïåÎûå
        SIMM_ALARM = 19,        ///< ÏãúÎÆ¨Î†àÏù¥ÏÖò ÏïåÎûå
        READ_ACCESS_ALARM = 20, ///< ÏùΩÍ∏∞ Ï†ëÍ∑º ÏïåÎûå
        WRITE_ACCESS_ALARM = 21 ///< Ïì∞Í∏∞ Ï†ëÍ∑º ÏïåÎûå
    };
    
    /** Íµ¨ÏÑ± Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Í≤∞Í≥º */
    struct ValidationResult {
        bool isValid;               ///< Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ ÌÜµÍ≥º Ïó¨Î∂Ä
        ErrorLevel errorLevel;      ///< Ïò§Î•ò Î†àÎ≤®
        char errorMessage[256];     ///< Ïò§Î•ò Î©îÏãúÏßÄ
        char suggestion[256];       ///< Ìï¥Í≤∞ Î∞©Ïïà Ï†úÏïà
    };
    
    /** ThresholdLogicController Íµ¨ÏÑ± Îß§Í∞úÎ≥ÄÏàò */
    struct ThresholdConfig {
        char portName[64];          ///< Ìè¨Ìä∏ Ïù¥Î¶Ñ
        char devicePort[64];        ///< Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ
        int deviceAddr;             ///< Ïû•Ïπò Ï£ºÏÜå
        double updateRate;          ///< ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ (Hz)
        int priority;               ///< Ïä§Î†àÎìú Ïö∞ÏÑ†ÏàúÏúÑ
        double thresholdValue;      ///< ÏûÑÍ≥ÑÍ∞í
        double hysteresis;          ///< ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í∞í
    };

public:
    /** Ïò§Î•ò Î°úÍπÖ Î©îÏÑúÎìú
     * \param[in] level Ïò§Î•ò Î†àÎ≤®
     * \param[in] source Ïò§Î•ò Î∞úÏÉù ÏÜåÏä§ (ÌÅ¥ÎûòÏä§Î™Ö::Î©îÏÑúÎìúÎ™Ö)
     * \param[in] message Ïò§Î•ò Î©îÏãúÏßÄ
     * \param[in] pasynUser asyn ÏÇ¨Ïö©Ïûê Ìè¨Ïù∏ÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
     */
    static void logError(ErrorLevel level, const char* source, const char* message, 
                        asynUser* pasynUser = NULL);
    
    /** ÏÉÅÏÑ∏ Ïò§Î•ò Î°úÍπÖ Î©îÏÑúÎìú (Ï∂îÍ∞Ä Ï†ïÎ≥¥ Ìè¨Ìï®)
     * \param[in] level Ïò§Î•ò Î†àÎ≤®
     * \param[in] source Ïò§Î•ò Î∞úÏÉù ÏÜåÏä§
     * \param[in] message Ïò§Î•ò Î©îÏãúÏßÄ
     * \param[in] details ÏÉÅÏÑ∏ Ï†ïÎ≥¥
     * \param[in] errorCode Ïò§Î•ò ÏΩîÎìú
     * \param[in] pasynUser asyn ÏÇ¨Ïö©Ïûê Ìè¨Ïù∏ÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
     */
    static void logDetailedError(ErrorLevel level, const char* source, const char* message,
                               const char* details, int errorCode, asynUser* pasynUser = NULL);
    
    /** EPICS ÏïåÎûå ÏÉÅÌÉú ÏÑ§Ï†ï
     * \param[in] pasynUser asyn ÏÇ¨Ïö©Ïûê Ìè¨Ïù∏ÌÑ∞
     * \param[in] status ÏïåÎûå ÏÉÅÌÉú
     * \param[in] severity ÏïåÎûå Ïã¨Í∞ÅÎèÑ
     * \return asynStatus Í≤∞Í≥º
     */
    static asynStatus setAlarmStatus(asynUser* pasynUser, AlarmStatus status, AlarmSeverity severity);
    
    /** ThresholdLogicController Íµ¨ÏÑ± Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
     * \param[in] config Í≤ÄÏÇ¨Ìï† Íµ¨ÏÑ±
     * \return ValidationResult Í≤ÄÏÇ¨ Í≤∞Í≥º
     */
    static ValidationResult validateConfiguration(const ThresholdConfig& config);
    
    /** Îü∞ÌÉÄÏûÑ Ïò§Î•ò Ï≤òÎ¶¨
     * \param[in] source Ïò§Î•ò Î∞úÏÉù ÏÜåÏä§
     * \param[in] errorType Ïò§Î•ò Ïú†Ìòï
     * \param[in] errorCode Ïò§Î•ò ÏΩîÎìú
     * \param[in] pasynUser asyn ÏÇ¨Ïö©Ïûê Ìè¨Ïù∏ÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
     * \return Î≥µÍµ¨ Í∞ÄÎä• Ïó¨Î∂Ä
     */
    static bool handleRuntimeError(const char* source, const char* errorType, 
                                 int errorCode, asynUser* pasynUser = NULL);
    
    /** ÌÜµÏã† Ïò§Î•ò Ï≤òÎ¶¨
     * \param[in] source Ïò§Î•ò Î∞úÏÉù ÏÜåÏä§
     * \param[in] devicePort Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ
     * \param[in] deviceAddr Ïû•Ïπò Ï£ºÏÜå
     * \param[in] operation ÏàòÌñâ Ï§ëÏù¥Îçò ÏûëÏóÖ
     * \param[in] pasynUser asyn ÏÇ¨Ïö©Ïûê Ìè¨Ïù∏ÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
     * \return Ïû¨ÏãúÎèÑ Í∂åÏû• Ïó¨Î∂Ä
     */
    static bool handleCommunicationError(const char* source, const char* devicePort,
                                       int deviceAddr, const char* operation,
                                       asynUser* pasynUser = NULL);
    
    /** Ïä§Î†àÎìú Ïò§Î•ò Ï≤òÎ¶¨
     * \param[in] source Ïò§Î•ò Î∞úÏÉù ÏÜåÏä§
     * \param[in] threadName Ïä§Î†àÎìú Ïù¥Î¶Ñ
     * \param[in] errorMessage Ïò§Î•ò Î©îÏãúÏßÄ
     * \param[in] pasynUser asyn ÏÇ¨Ïö©Ïûê Ìè¨Ïù∏ÌÑ∞ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
     * \return Ïä§Î†àÎìú Ïû¨ÏãúÏûë Í∂åÏû• Ïó¨Î∂Ä
     */
    static bool handleThreadError(const char* source, const char* threadName,
                                const char* errorMessage, asynUser* pasynUser = NULL);
    
    /** Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
     * \param[in] paramName Îß§Í∞úÎ≥ÄÏàò Ïù¥Î¶Ñ
     * \param[in] value Í≤ÄÏÇ¨Ìï† Í∞í
     * \param[in] minValue ÏµúÏÜåÍ∞í
     * \param[in] maxValue ÏµúÎåÄÍ∞í
     * \param[in] source Ìò∏Ï∂ú ÏÜåÏä§
     * \return Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ ÌÜµÍ≥º Ïó¨Î∂Ä
     */
    static bool validateParameter(const char* paramName, double value, 
                                double minValue, double maxValue, const char* source);
    
    /** Ï†ïÏàò Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
     * \param[in] paramName Îß§Í∞úÎ≥ÄÏàò Ïù¥Î¶Ñ
     * \param[in] value Í≤ÄÏÇ¨Ìï† Í∞í
     * \param[in] minValue ÏµúÏÜåÍ∞í
     * \param[in] maxValue ÏµúÎåÄÍ∞í
     * \param[in] source Ìò∏Ï∂ú ÏÜåÏä§
     * \return Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ ÌÜµÍ≥º Ïó¨Î∂Ä
     */
    static bool validateIntParameter(const char* paramName, int value, 
                                   int minValue, int maxValue, const char* source);
    
    /** Î¨∏ÏûêÏó¥ Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
     * \param[in] paramName Îß§Í∞úÎ≥ÄÏàò Ïù¥Î¶Ñ
     * \param[in] value Í≤ÄÏÇ¨Ìï† Î¨∏ÏûêÏó¥
     * \param[in] maxLength ÏµúÎåÄ Í∏∏Ïù¥
     * \param[in] allowEmpty Îπà Î¨∏ÏûêÏó¥ ÌóàÏö© Ïó¨Î∂Ä
     * \param[in] source Ìò∏Ï∂ú ÏÜåÏä§
     * \return Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ ÌÜµÍ≥º Ïó¨Î∂Ä
     */
    static bool validateStringParameter(const char* paramName, const char* value,
                                      size_t maxLength, bool allowEmpty, const char* source);
    
    /** Ïò§Î•ò ÌÜµÍ≥Ñ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
     * \param[out] infoCount Ï†ïÎ≥¥ Î©îÏãúÏßÄ Ïàò
     * \param[out] warningCount Í≤ΩÍ≥† Î©îÏãúÏßÄ Ïàò
     * \param[out] errorCount Ïò§Î•ò Î©îÏãúÏßÄ Ïàò
     * \param[out] fatalCount ÏπòÎ™ÖÏ†Å Ïò§Î•ò Î©îÏãúÏßÄ Ïàò
     */
    static void getErrorStatistics(int* infoCount, int* warningCount, 
                                 int* errorCount, int* fatalCount);
    
    /** Ïò§Î•ò ÌÜµÍ≥Ñ Ï¥àÍ∏∞Ìôî */
    static void resetErrorStatistics();
    
    /** Ïò§Î•ò Î†àÎ≤®ÏùÑ Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
     * \param[in] level Ïò§Î•ò Î†àÎ≤®
     * \return Ïò§Î•ò Î†àÎ≤® Î¨∏ÏûêÏó¥
     */
    static const char* errorLevelToString(ErrorLevel level);
    
    /** ÏïåÎûå Ïã¨Í∞ÅÎèÑÎ•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
     * \param[in] severity ÏïåÎûå Ïã¨Í∞ÅÎèÑ
     * \return ÏïåÎûå Ïã¨Í∞ÅÎèÑ Î¨∏ÏûêÏó¥
     */
    static const char* alarmSeverityToString(AlarmSeverity severity);
    
    /** ÏïåÎûå ÏÉÅÌÉúÎ•º Î¨∏ÏûêÏó¥Î°ú Î≥ÄÌôò
     * \param[in] status ÏïåÎûå ÏÉÅÌÉú
     * \return ÏïåÎûå ÏÉÅÌÉú Î¨∏ÏûêÏó¥
     */
    static const char* alarmStatusToString(AlarmStatus status);

private:
    // Ï†ïÏ†Å Î©§Î≤Ñ Î≥ÄÏàòÎì§ (Ïò§Î•ò ÌÜµÍ≥Ñ)
    static int infoCount_;      ///< Ï†ïÎ≥¥ Î©îÏãúÏßÄ Ïπ¥Ïö¥ÌÑ∞
    static int warningCount_;   ///< Í≤ΩÍ≥† Î©îÏãúÏßÄ Ïπ¥Ïö¥ÌÑ∞
    static int errorCount_;     ///< Ïò§Î•ò Î©îÏãúÏßÄ Ïπ¥Ïö¥ÌÑ∞
    static int fatalCount_;     ///< ÏπòÎ™ÖÏ†Å Ïò§Î•ò Î©îÏãúÏßÄ Ïπ¥Ïö¥ÌÑ∞
    
    /** ÎÇ¥Î∂Ä Î°úÍπÖ Î©îÏÑúÎìú
     * \param[in] level Ïò§Î•ò Î†àÎ≤®
     * \param[in] source Ïò§Î•ò Î∞úÏÉù ÏÜåÏä§
     * \param[in] message Î©îÏãúÏßÄ
     * \param[in] pasynUser asyn ÏÇ¨Ïö©Ïûê Ìè¨Ïù∏ÌÑ∞
     */
    static void internalLog(ErrorLevel level, const char* source, const char* message,
                          asynUser* pasynUser);
    
    /** ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Î¨∏ÏûêÏó¥ ÏÉùÏÑ±
     * \param[out] buffer Ï∂úÎ†• Î≤ÑÌçº
     * \param[in] bufferSize Î≤ÑÌçº ÌÅ¨Í∏∞
     */
    static void getTimestampString(char* buffer, size_t bufferSize);
    
    /** asyn Ìä∏Î†àÏù¥Ïä§ Î†àÎ≤® Î≥ÄÌôò
     * \param[in] level ErrorHandler Ïò§Î•ò Î†àÎ≤®
     * \return asyn Ìä∏Î†àÏù¥Ïä§ Î†àÎ≤®
     */
    static int convertToAsynTraceLevel(ErrorLevel level);
};

#endif /* ErrorHandlerInclude */










üî• File: ./USB1608G_2AO_V2App/src/Makefile
=================================================
TOP=../..

include $(TOP)/configure/CONFIG
#----------------------------------------
# Build the IOC application


PROD_IOC = USB1608G_2AO_V2
# USB1608G_2AO_V2.dbd will be created and installed
DBD += USB1608G_2AO_V2.dbd


# USB1608G_2AO_V2.dbd will be made up from these files:
USB1608G_2AO_V2_DBD += base.dbd
USB1608G_2AO_V2_DBD += measCompApp.dbd
USB1608G_2AO_V2_DBD += measCompSupport.dbd
USB1608G_2AO_V2_DBD += thresholdLogicSupport.dbd


# Include dbd files from all support applications:
#USB1608G_2AO_V2_DBD += xxx.dbd

# Add all the support libraries needed by this IOC
#USB1608G_2AO_V2_LIBS += xxx

# #USB1608G_2AO_V2_registerRecordDeviceDriver.cpp derives from #USB1608G_2AO_V2.dbd
USB1608G_2AO_V2_SRCS += USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
USB1608G_2AO_V2_SRCS += drvMultiFunction.cpp
USB1608G_2AO_V2_SRCS += drvUSBCTR.cpp
USB1608G_2AO_V2_SRCS += measCompDiscover.cpp
USB1608G_2AO_V2_SRCS += ThresholdLogicController.cpp
USB1608G_2AO_V2_SRCS += ErrorHandler.cpp
USB1608G_2AO_V2_SRCS += USBCTR_SNL.st


# Build the main IOC entry point on workstation OSs.
USB1608G_2AO_V2_SRCS_DEFAULT += USB1608G_2AO_V2Main.cpp
USB1608G_2AO_V2_SRCS_vxWorks += -nil-

# Add support from base/src/vxWorks if needed
#USB1608G_2AO_V2_OBJS_vxWorks += $(EPICS_BASE_BIN)/vxComLibrary

# Finally link to the EPICS Base libraries
USB1608G_2AO_V2_LIBS += $(EPICS_BASE_IOC_LIBS)
USB1608G_2AO_V2_LIBS += measComp
USB1608G_2AO_V2_LIBS += scaler
USB1608G_2AO_V2_LIBS += busy
USB1608G_2AO_V2_LIBS += calc
USB1608G_2AO_V2_LIBS += mca
USB1608G_2AO_V2_LIBS += sscan
USB1608G_2AO_V2_LIBS += autosave
USB1608G_2AO_V2_LIBS += asyn
USB1608G_2AO_V2_LIBS += seq pv

USB1608G_2AO_V2_SYS_LIBS_Linux += uldaq
USB1608G_2AO_V2_SYS_LIBS_Linux += usb-1.0
#===========================

include $(TOP)/configure/RULES
#----------------------------------------
#  ADD RULES AFTER THIS LINE











üî• File: ./USB1608G_2AO_V2App/src/O.Common/USB1608G_2AO_V2.dbd
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.dbd)]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.d
=================================================
ErrorHandler.o: ../ErrorHandler.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 ../ErrorHandler.h /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ErrorHandler.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/Makefile
=================================================
#This Makefile created by makeMakefile.pl


all :
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

.DEFAULT: force
	$(MAKE) -f ../Makefile TOP=../../.. T_A=linux-x86_64  $@

force:  ;











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.d
=================================================
ThresholdLogicController.o: ../ThresholdLogicController.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctetSyncIO.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 ../ThresholdLogicController.h ../ErrorHandler.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/ThresholdLogicController.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2.dbd.d
=================================================
../O.Common/USB1608G_2AO_V2.dbd: /usr/local/epics/EPICS_R7.0/base/dbd/base.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuGlobal.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmSevr.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmStat.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuFtype.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuIvoa.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuOmsl.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPini.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPost.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuPriority.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuYesNo.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuSimm.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuConvert.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/menuScan.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stdRecords.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aaiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dbCommon.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aaoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/aSubRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/biRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/boRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/calcRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/calcoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/compressRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dfanoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/eventRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/fanoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/histogramRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/int64inRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/int64outRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/longinRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/longoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/lsiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/lsoRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbbiRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbbiDirectRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbboRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/mbboDirectRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/permissiveRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/printfRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/selRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/seqRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stateRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stringinRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/stringoutRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/subRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/subArrayRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/waveformRecord.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/filters.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/links.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/devSoft.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/asSub.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/dbCore.dbd \
    /usr/local/epics/EPICS_R7.0/base/dbd/rsrv.dbd \
    /usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2/dbd/measCompApp.dbd \
    ../measCompSupport.dbd \
    ../thresholdLogicSupport.dbd

/usr/local/epics/EPICS_R7.0/base/dbd/base.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuGlobal.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmSevr.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuAlarmStat.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuFtype.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuIvoa.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuOmsl.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPini.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPost.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuPriority.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuYesNo.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuSimm.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuConvert.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/menuScan.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stdRecords.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aaiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dbCommon.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aaoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/aSubRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/biRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/boRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/calcRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/calcoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/compressRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dfanoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/eventRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/fanoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/histogramRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/int64inRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/int64outRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/longinRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/longoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/lsiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/lsoRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbbiRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbbiDirectRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbboRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/mbboDirectRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/permissiveRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/printfRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/selRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/seqRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stateRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stringinRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/stringoutRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/subRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/subArrayRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/waveformRecord.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/filters.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/links.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/devSoft.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/asSub.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/dbCore.dbd:
/usr/local/epics/EPICS_R7.0/base/dbd/rsrv.dbd:
/usr/local/epics/EPICS_R7.0/modules/synApps/support/measComp-R4-2/dbd/measCompApp.dbd:
../measCompSupport.dbd:
../thresholdLogicSupport.dbd:
../O.Common/USB1608G_2AO_V2.dbd: ../Makefile











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.d
=================================================
USB1608G_2AO_V2Main.o: ../USB1608G_2AO_V2Main.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExit.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2Main.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.cpp
=================================================
/* THIS IS A GENERATED FILE. DO NOT EDIT! */
/* Generated from ../O.Common/USB1608G_2AO_V2.dbd */

#include <string.h>
#ifndef USE_TYPED_RSET
#  define USE_TYPED_RSET
#endif
#include "compilerDependencies.h"
#include "epicsStdlib.h"
#include "iocsh.h"
#include "iocshRegisterCommon.h"
#include "registryCommon.h"
#include "recSup.h"
#include "shareLib.h"

extern "C" {

epicsShareExtern typed_rset *pvar_rset_aSubRSET, *pvar_rset_aaiRSET,
    *pvar_rset_aaoRSET, *pvar_rset_acalcoutRSET, *pvar_rset_aiRSET,
    *pvar_rset_aoRSET, *pvar_rset_asynRSET, *pvar_rset_biRSET,
    *pvar_rset_boRSET, *pvar_rset_busyRSET, *pvar_rset_calcRSET,
    *pvar_rset_calcoutRSET, *pvar_rset_compressRSET,
    *pvar_rset_dfanoutRSET, *pvar_rset_eventRSET, *pvar_rset_fanoutRSET,
    *pvar_rset_histogramRSET, *pvar_rset_int64inRSET,
    *pvar_rset_int64outRSET, *pvar_rset_longinRSET,
    *pvar_rset_longoutRSET, *pvar_rset_lsiRSET, *pvar_rset_lsoRSET,
    *pvar_rset_mbbiRSET, *pvar_rset_mbbiDirectRSET, *pvar_rset_mbboRSET,
    *pvar_rset_mbboDirectRSET, *pvar_rset_mcaRSET,
    *pvar_rset_permissiveRSET, *pvar_rset_printfRSET,
    *pvar_rset_scalcoutRSET, *pvar_rset_scalerRSET,
    *pvar_rset_scanparmRSET, *pvar_rset_selRSET, *pvar_rset_seqRSET,
    *pvar_rset_sscanRSET, *pvar_rset_sseqRSET, *pvar_rset_stateRSET,
    *pvar_rset_stringinRSET, *pvar_rset_stringoutRSET, *pvar_rset_subRSET,
    *pvar_rset_subArrayRSET, *pvar_rset_swaitRSET,
    *pvar_rset_transformRSET, *pvar_rset_waveformRSET;

typedef int (*rso_func)(dbRecordType *pdbRecordType);
epicsShareExtern rso_func pvar_func_aSubRecordSizeOffset,
    pvar_func_aaiRecordSizeOffset, pvar_func_aaoRecordSizeOffset,
    pvar_func_acalcoutRecordSizeOffset, pvar_func_aiRecordSizeOffset,
    pvar_func_aoRecordSizeOffset, pvar_func_asynRecordSizeOffset,
    pvar_func_biRecordSizeOffset, pvar_func_boRecordSizeOffset,
    pvar_func_busyRecordSizeOffset, pvar_func_calcRecordSizeOffset,
    pvar_func_calcoutRecordSizeOffset, pvar_func_compressRecordSizeOffset,
    pvar_func_dfanoutRecordSizeOffset, pvar_func_eventRecordSizeOffset,
    pvar_func_fanoutRecordSizeOffset, pvar_func_histogramRecordSizeOffset,
    pvar_func_int64inRecordSizeOffset, pvar_func_int64outRecordSizeOffset,
    pvar_func_longinRecordSizeOffset, pvar_func_longoutRecordSizeOffset,
    pvar_func_lsiRecordSizeOffset, pvar_func_lsoRecordSizeOffset,
    pvar_func_mbbiRecordSizeOffset, pvar_func_mbbiDirectRecordSizeOffset,
    pvar_func_mbboRecordSizeOffset, pvar_func_mbboDirectRecordSizeOffset,
    pvar_func_mcaRecordSizeOffset, pvar_func_permissiveRecordSizeOffset,
    pvar_func_printfRecordSizeOffset, pvar_func_scalcoutRecordSizeOffset,
    pvar_func_scalerRecordSizeOffset, pvar_func_scanparmRecordSizeOffset,
    pvar_func_selRecordSizeOffset, pvar_func_seqRecordSizeOffset,
    pvar_func_sscanRecordSizeOffset, pvar_func_sseqRecordSizeOffset,
    pvar_func_stateRecordSizeOffset, pvar_func_stringinRecordSizeOffset,
    pvar_func_stringoutRecordSizeOffset, pvar_func_subRecordSizeOffset,
    pvar_func_subArrayRecordSizeOffset, pvar_func_swaitRecordSizeOffset,
    pvar_func_transformRecordSizeOffset,
    pvar_func_waveformRecordSizeOffset;

static const char * const recordTypeNames[] = {
    "aSub", "aai", "aao", "acalcout", "ai", "ao", "asyn", "bi", "bo",
    "busy", "calc", "calcout", "compress", "dfanout", "event", "fanout",
    "histogram", "int64in", "int64out", "longin", "longout", "lsi", "lso",
    "mbbi", "mbbiDirect", "mbbo", "mbboDirect", "mca", "permissive",
    "printf", "scalcout", "scaler", "scanparm", "sel", "seq", "sscan",
    "sseq", "state", "stringin", "stringout", "sub", "subArray", "swait",
    "transform", "waveform"
};

static const recordTypeLocation rtl[] = {
    {(struct typed_rset *)pvar_rset_aSubRSET, pvar_func_aSubRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aaiRSET, pvar_func_aaiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aaoRSET, pvar_func_aaoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_acalcoutRSET, pvar_func_acalcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aiRSET, pvar_func_aiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_aoRSET, pvar_func_aoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_asynRSET, pvar_func_asynRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_biRSET, pvar_func_biRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_boRSET, pvar_func_boRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_busyRSET, pvar_func_busyRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_calcRSET, pvar_func_calcRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_calcoutRSET, pvar_func_calcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_compressRSET, pvar_func_compressRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_dfanoutRSET, pvar_func_dfanoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_eventRSET, pvar_func_eventRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_fanoutRSET, pvar_func_fanoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_histogramRSET, pvar_func_histogramRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_int64inRSET, pvar_func_int64inRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_int64outRSET, pvar_func_int64outRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_longinRSET, pvar_func_longinRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_longoutRSET, pvar_func_longoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_lsiRSET, pvar_func_lsiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_lsoRSET, pvar_func_lsoRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbbiRSET, pvar_func_mbbiRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbbiDirectRSET, pvar_func_mbbiDirectRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbboRSET, pvar_func_mbboRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mbboDirectRSET, pvar_func_mbboDirectRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_mcaRSET, pvar_func_mcaRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_permissiveRSET, pvar_func_permissiveRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_printfRSET, pvar_func_printfRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scalcoutRSET, pvar_func_scalcoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scalerRSET, pvar_func_scalerRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_scanparmRSET, pvar_func_scanparmRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_selRSET, pvar_func_selRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_seqRSET, pvar_func_seqRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_sscanRSET, pvar_func_sscanRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_sseqRSET, pvar_func_sseqRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stateRSET, pvar_func_stateRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stringinRSET, pvar_func_stringinRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_stringoutRSET, pvar_func_stringoutRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_subRSET, pvar_func_subRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_subArrayRSET, pvar_func_subArrayRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_swaitRSET, pvar_func_swaitRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_transformRSET, pvar_func_transformRecordSizeOffset},
    {(struct typed_rset *)pvar_rset_waveformRSET, pvar_func_waveformRecordSizeOffset}
};

epicsShareExtern dset *pvar_dset_devAaiSoft, *pvar_dset_asynInt8ArrayAai,
    *pvar_dset_asynInt16ArrayAai, *pvar_dset_asynInt32ArrayAai,
    *pvar_dset_asynFloat32ArrayAai, *pvar_dset_asynFloat64ArrayAai,
    *pvar_dset_asynInt64ArrayAai, *pvar_dset_devAaoSoft,
    *pvar_dset_asynInt8ArrayAao, *pvar_dset_asynInt16ArrayAao,
    *pvar_dset_asynInt32ArrayAao, *pvar_dset_asynFloat32ArrayAao,
    *pvar_dset_asynFloat64ArrayAao, *pvar_dset_asynInt64ArrayAao,
    *pvar_dset_devaCalcoutSoft, *pvar_dset_devAiSoft,
    *pvar_dset_devAiSoftRaw, *pvar_dset_devAiSoftCallback,
    *pvar_dset_devTimestampAI, *pvar_dset_devAiGeneralTime,
    *pvar_dset_asynAiInt32, *pvar_dset_asynAiInt32Average,
    *pvar_dset_asynAiFloat64, *pvar_dset_asynAiFloat64Average,
    *pvar_dset_asynAiInt64, *pvar_dset_devAoSoft, *pvar_dset_devAoSoftRaw,
    *pvar_dset_devAoSoftCallback, *pvar_dset_asynAoInt32,
    *pvar_dset_asynAoFloat64, *pvar_dset_asynAoInt64,
    *pvar_dset_asynRecordDevice, *pvar_dset_devBiSoft,
    *pvar_dset_devBiSoftRaw, *pvar_dset_devBiSoftCallback,
    *pvar_dset_devBiDbState, *pvar_dset_asynBiInt32,
    *pvar_dset_asynBiUInt32Digital, *pvar_dset_devBoSoft,
    *pvar_dset_devBoSoftRaw, *pvar_dset_devBoSoftCallback,
    *pvar_dset_devBoGeneralTime, *pvar_dset_devBoDbState,
    *pvar_dset_asynBoInt32, *pvar_dset_asynBoUInt32Digital,
    *pvar_dset_devBusySoft, *pvar_dset_devBusySoftRaw,
    *pvar_dset_asynBusyInt32, *pvar_dset_devCalcoutSoft,
    *pvar_dset_devCalcoutSoftCallback, *pvar_dset_devEventSoft,
    *pvar_dset_devHistogramSoft, *pvar_dset_devI64inSoft,
    *pvar_dset_devI64inSoftCallback, *pvar_dset_asynInt64In,
    *pvar_dset_devI64outSoft, *pvar_dset_devI64outSoftCallback,
    *pvar_dset_asynInt64Out, *pvar_dset_devLiSoft,
    *pvar_dset_devLiSoftCallback, *pvar_dset_devLiGeneralTime,
    *pvar_dset_asynLiInt32, *pvar_dset_asynLiUInt32Digital,
    *pvar_dset_asynLiInt64, *pvar_dset_devLoSoft,
    *pvar_dset_devLoSoftCallback, *pvar_dset_asynLoInt32,
    *pvar_dset_asynLoUInt32Digital, *pvar_dset_asynLoInt64,
    *pvar_dset_devLsiSoft, *pvar_dset_devLsiEnviron,
    *pvar_dset_asynLsiOctetCmdResponse, *pvar_dset_asynLsiOctetWriteRead,
    *pvar_dset_asynLsiOctetRead, *pvar_dset_devLsoSoft,
    *pvar_dset_devLsoSoftCallback, *pvar_dset_devLsoStdio,
    *pvar_dset_asynLsoOctetWrite, *pvar_dset_devMbbiSoft,
    *pvar_dset_devMbbiSoftRaw, *pvar_dset_devMbbiSoftCallback,
    *pvar_dset_asynMbbiInt32, *pvar_dset_asynMbbiUInt32Digital,
    *pvar_dset_devMbbiDirectSoft, *pvar_dset_devMbbiDirectSoftRaw,
    *pvar_dset_devMbbiDirectSoftCallback,
    *pvar_dset_asynMbbiDirectUInt32Digital, *pvar_dset_devMbboSoft,
    *pvar_dset_devMbboSoftRaw, *pvar_dset_devMbboSoftCallback,
    *pvar_dset_asynMbboInt32, *pvar_dset_asynMbboUInt32Digital,
    *pvar_dset_devMbboDirectSoft, *pvar_dset_devMbboDirectSoftRaw,
    *pvar_dset_devMbboDirectSoftCallback,
    *pvar_dset_asynMbboDirectUInt32Digital, *pvar_dset_devMCA_soft,
    *pvar_dset_devMcaAsyn, *pvar_dset_devPrintfSoft,
    *pvar_dset_devPrintfSoftCallback, *pvar_dset_devPrintfStdio,
    *pvar_dset_asynPfOctetWrite, *pvar_dset_devsCalcoutSoft,
    *pvar_dset_devScalerAsyn, *pvar_dset_devSiSoft,
    *pvar_dset_devSiSoftCallback, *pvar_dset_devTimestampSI,
    *pvar_dset_devSiGeneralTime, *pvar_dset_devSiEnviron,
    *pvar_dset_asynSiOctetCmdResponse, *pvar_dset_asynSiOctetWriteRead,
    *pvar_dset_asynSiOctetRead, *pvar_dset_devSoSoft,
    *pvar_dset_devSoSoftCallback, *pvar_dset_devSoStdio,
    *pvar_dset_asynSoOctetWrite, *pvar_dset_devSASoft,
    *pvar_dset_devSWaitIoEvent, *pvar_dset_devWfSoft,
    *pvar_dset_asynWfOctetCmdResponse, *pvar_dset_asynWfOctetWriteRead,
    *pvar_dset_asynWfOctetRead, *pvar_dset_asynWfOctetWrite,
    *pvar_dset_asynWfOctetWriteBinary, *pvar_dset_asynInt8ArrayWfIn,
    *pvar_dset_asynInt8ArrayWfOut, *pvar_dset_asynInt16ArrayWfIn,
    *pvar_dset_asynInt16ArrayWfOut, *pvar_dset_asynInt32ArrayWfIn,
    *pvar_dset_asynInt32ArrayWfOut, *pvar_dset_asynFloat32ArrayWfIn,
    *pvar_dset_asynFloat32ArrayWfOut, *pvar_dset_asynFloat64ArrayWfIn,
    *pvar_dset_asynFloat64ArrayWfOut, *pvar_dset_asynInt32TimeSeries,
    *pvar_dset_asynFloat64TimeSeries, *pvar_dset_asynInt64ArrayWfIn,
    *pvar_dset_asynInt64ArrayWfOut, *pvar_dset_asynInt64TimeSeries;

static const char * const deviceSupportNames[] = {
    "devAaiSoft", "asynInt8ArrayAai", "asynInt16ArrayAai",
    "asynInt32ArrayAai", "asynFloat32ArrayAai", "asynFloat64ArrayAai",
    "asynInt64ArrayAai", "devAaoSoft", "asynInt8ArrayAao",
    "asynInt16ArrayAao", "asynInt32ArrayAao", "asynFloat32ArrayAao",
    "asynFloat64ArrayAao", "asynInt64ArrayAao", "devaCalcoutSoft",
    "devAiSoft", "devAiSoftRaw", "devAiSoftCallback", "devTimestampAI",
    "devAiGeneralTime", "asynAiInt32", "asynAiInt32Average",
    "asynAiFloat64", "asynAiFloat64Average", "asynAiInt64", "devAoSoft",
    "devAoSoftRaw", "devAoSoftCallback", "asynAoInt32", "asynAoFloat64",
    "asynAoInt64", "asynRecordDevice", "devBiSoft", "devBiSoftRaw",
    "devBiSoftCallback", "devBiDbState", "asynBiInt32",
    "asynBiUInt32Digital", "devBoSoft", "devBoSoftRaw",
    "devBoSoftCallback", "devBoGeneralTime", "devBoDbState",
    "asynBoInt32", "asynBoUInt32Digital", "devBusySoft", "devBusySoftRaw",
    "asynBusyInt32", "devCalcoutSoft", "devCalcoutSoftCallback",
    "devEventSoft", "devHistogramSoft", "devI64inSoft",
    "devI64inSoftCallback", "asynInt64In", "devI64outSoft",
    "devI64outSoftCallback", "asynInt64Out", "devLiSoft",
    "devLiSoftCallback", "devLiGeneralTime", "asynLiInt32",
    "asynLiUInt32Digital", "asynLiInt64", "devLoSoft",
    "devLoSoftCallback", "asynLoInt32", "asynLoUInt32Digital",
    "asynLoInt64", "devLsiSoft", "devLsiEnviron",
    "asynLsiOctetCmdResponse", "asynLsiOctetWriteRead",
    "asynLsiOctetRead", "devLsoSoft", "devLsoSoftCallback", "devLsoStdio",
    "asynLsoOctetWrite", "devMbbiSoft", "devMbbiSoftRaw",
    "devMbbiSoftCallback", "asynMbbiInt32", "asynMbbiUInt32Digital",
    "devMbbiDirectSoft", "devMbbiDirectSoftRaw",
    "devMbbiDirectSoftCallback", "asynMbbiDirectUInt32Digital",
    "devMbboSoft", "devMbboSoftRaw", "devMbboSoftCallback",
    "asynMbboInt32", "asynMbboUInt32Digital", "devMbboDirectSoft",
    "devMbboDirectSoftRaw", "devMbboDirectSoftCallback",
    "asynMbboDirectUInt32Digital", "devMCA_soft", "devMcaAsyn",
    "devPrintfSoft", "devPrintfSoftCallback", "devPrintfStdio",
    "asynPfOctetWrite", "devsCalcoutSoft", "devScalerAsyn", "devSiSoft",
    "devSiSoftCallback", "devTimestampSI", "devSiGeneralTime",
    "devSiEnviron", "asynSiOctetCmdResponse", "asynSiOctetWriteRead",
    "asynSiOctetRead", "devSoSoft", "devSoSoftCallback", "devSoStdio",
    "asynSoOctetWrite", "devSASoft", "devSWaitIoEvent", "devWfSoft",
    "asynWfOctetCmdResponse", "asynWfOctetWriteRead", "asynWfOctetRead",
    "asynWfOctetWrite", "asynWfOctetWriteBinary", "asynInt8ArrayWfIn",
    "asynInt8ArrayWfOut", "asynInt16ArrayWfIn", "asynInt16ArrayWfOut",
    "asynInt32ArrayWfIn", "asynInt32ArrayWfOut", "asynFloat32ArrayWfIn",
    "asynFloat32ArrayWfOut", "asynFloat64ArrayWfIn",
    "asynFloat64ArrayWfOut", "asynInt32TimeSeries",
    "asynFloat64TimeSeries", "asynInt64ArrayWfIn", "asynInt64ArrayWfOut",
    "asynInt64TimeSeries"
};

static const dset * const devsl[] = {
    pvar_dset_devAaiSoft, pvar_dset_asynInt8ArrayAai,
    pvar_dset_asynInt16ArrayAai, pvar_dset_asynInt32ArrayAai,
    pvar_dset_asynFloat32ArrayAai, pvar_dset_asynFloat64ArrayAai,
    pvar_dset_asynInt64ArrayAai, pvar_dset_devAaoSoft,
    pvar_dset_asynInt8ArrayAao, pvar_dset_asynInt16ArrayAao,
    pvar_dset_asynInt32ArrayAao, pvar_dset_asynFloat32ArrayAao,
    pvar_dset_asynFloat64ArrayAao, pvar_dset_asynInt64ArrayAao,
    pvar_dset_devaCalcoutSoft, pvar_dset_devAiSoft,
    pvar_dset_devAiSoftRaw, pvar_dset_devAiSoftCallback,
    pvar_dset_devTimestampAI, pvar_dset_devAiGeneralTime,
    pvar_dset_asynAiInt32, pvar_dset_asynAiInt32Average,
    pvar_dset_asynAiFloat64, pvar_dset_asynAiFloat64Average,
    pvar_dset_asynAiInt64, pvar_dset_devAoSoft, pvar_dset_devAoSoftRaw,
    pvar_dset_devAoSoftCallback, pvar_dset_asynAoInt32,
    pvar_dset_asynAoFloat64, pvar_dset_asynAoInt64,
    pvar_dset_asynRecordDevice, pvar_dset_devBiSoft,
    pvar_dset_devBiSoftRaw, pvar_dset_devBiSoftCallback,
    pvar_dset_devBiDbState, pvar_dset_asynBiInt32,
    pvar_dset_asynBiUInt32Digital, pvar_dset_devBoSoft,
    pvar_dset_devBoSoftRaw, pvar_dset_devBoSoftCallback,
    pvar_dset_devBoGeneralTime, pvar_dset_devBoDbState,
    pvar_dset_asynBoInt32, pvar_dset_asynBoUInt32Digital,
    pvar_dset_devBusySoft, pvar_dset_devBusySoftRaw,
    pvar_dset_asynBusyInt32, pvar_dset_devCalcoutSoft,
    pvar_dset_devCalcoutSoftCallback, pvar_dset_devEventSoft,
    pvar_dset_devHistogramSoft, pvar_dset_devI64inSoft,
    pvar_dset_devI64inSoftCallback, pvar_dset_asynInt64In,
    pvar_dset_devI64outSoft, pvar_dset_devI64outSoftCallback,
    pvar_dset_asynInt64Out, pvar_dset_devLiSoft,
    pvar_dset_devLiSoftCallback, pvar_dset_devLiGeneralTime,
    pvar_dset_asynLiInt32, pvar_dset_asynLiUInt32Digital,
    pvar_dset_asynLiInt64, pvar_dset_devLoSoft,
    pvar_dset_devLoSoftCallback, pvar_dset_asynLoInt32,
    pvar_dset_asynLoUInt32Digital, pvar_dset_asynLoInt64,
    pvar_dset_devLsiSoft, pvar_dset_devLsiEnviron,
    pvar_dset_asynLsiOctetCmdResponse, pvar_dset_asynLsiOctetWriteRead,
    pvar_dset_asynLsiOctetRead, pvar_dset_devLsoSoft,
    pvar_dset_devLsoSoftCallback, pvar_dset_devLsoStdio,
    pvar_dset_asynLsoOctetWrite, pvar_dset_devMbbiSoft,
    pvar_dset_devMbbiSoftRaw, pvar_dset_devMbbiSoftCallback,
    pvar_dset_asynMbbiInt32, pvar_dset_asynMbbiUInt32Digital,
    pvar_dset_devMbbiDirectSoft, pvar_dset_devMbbiDirectSoftRaw,
    pvar_dset_devMbbiDirectSoftCallback,
    pvar_dset_asynMbbiDirectUInt32Digital, pvar_dset_devMbboSoft,
    pvar_dset_devMbboSoftRaw, pvar_dset_devMbboSoftCallback,
    pvar_dset_asynMbboInt32, pvar_dset_asynMbboUInt32Digital,
    pvar_dset_devMbboDirectSoft, pvar_dset_devMbboDirectSoftRaw,
    pvar_dset_devMbboDirectSoftCallback,
    pvar_dset_asynMbboDirectUInt32Digital, pvar_dset_devMCA_soft,
    pvar_dset_devMcaAsyn, pvar_dset_devPrintfSoft,
    pvar_dset_devPrintfSoftCallback, pvar_dset_devPrintfStdio,
    pvar_dset_asynPfOctetWrite, pvar_dset_devsCalcoutSoft,
    pvar_dset_devScalerAsyn, pvar_dset_devSiSoft,
    pvar_dset_devSiSoftCallback, pvar_dset_devTimestampSI,
    pvar_dset_devSiGeneralTime, pvar_dset_devSiEnviron,
    pvar_dset_asynSiOctetCmdResponse, pvar_dset_asynSiOctetWriteRead,
    pvar_dset_asynSiOctetRead, pvar_dset_devSoSoft,
    pvar_dset_devSoSoftCallback, pvar_dset_devSoStdio,
    pvar_dset_asynSoOctetWrite, pvar_dset_devSASoft,
    pvar_dset_devSWaitIoEvent, pvar_dset_devWfSoft,
    pvar_dset_asynWfOctetCmdResponse, pvar_dset_asynWfOctetWriteRead,
    pvar_dset_asynWfOctetRead, pvar_dset_asynWfOctetWrite,
    pvar_dset_asynWfOctetWriteBinary, pvar_dset_asynInt8ArrayWfIn,
    pvar_dset_asynInt8ArrayWfOut, pvar_dset_asynInt16ArrayWfIn,
    pvar_dset_asynInt16ArrayWfOut, pvar_dset_asynInt32ArrayWfIn,
    pvar_dset_asynInt32ArrayWfOut, pvar_dset_asynFloat32ArrayWfIn,
    pvar_dset_asynFloat32ArrayWfOut, pvar_dset_asynFloat64ArrayWfIn,
    pvar_dset_asynFloat64ArrayWfOut, pvar_dset_asynInt32TimeSeries,
    pvar_dset_asynFloat64TimeSeries, pvar_dset_asynInt64ArrayWfIn,
    pvar_dset_asynInt64ArrayWfOut, pvar_dset_asynInt64TimeSeries
};

epicsShareExtern drvet *pvar_drvet_drvAsyn;

static const char *driverSupportNames[] = {
    "drvAsyn"};

static struct drvet *drvsl[] = {
    pvar_drvet_drvAsyn};

epicsShareExtern jlif *pvar_jlif_lnkCalcIf, *pvar_jlif_lnkConstIf,
    *pvar_jlif_lnkDebugIf, *pvar_jlif_lnkStateIf, *pvar_jlif_lnkTraceIf;

static struct jlif *jlifsl[] = {
    pvar_jlif_lnkCalcIf,
    pvar_jlif_lnkConstIf,
    pvar_jlif_lnkDebugIf,
    pvar_jlif_lnkStateIf,
    pvar_jlif_lnkTraceIf};

typedef void (*reg_func)(void);
epicsShareExtern reg_func pvar_func_Scaler974Register,
    pvar_func_ThresholdLogicRegister, pvar_func_USBCTR_SNLRegistrar,
    pvar_func_aCalcMonitorMemRegister,
    pvar_func_acalcTotalAllocatedMemoryRegister, pvar_func_arrInitialize,
    pvar_func_arrayTestRegister, pvar_func_asInitHooksRegister,
    pvar_func_asSub, pvar_func_asynInterposeDelayRegister,
    pvar_func_asynInterposeEchoRegister,
    pvar_func_asynInterposeEosRegister,
    pvar_func_asynInterposeFlushRegister, pvar_func_asynRegister,
    pvar_func_configMenuRegistrar, pvar_func_dbndInitialize,
    pvar_func_dbrestoreRegister, pvar_func_decInitialize,
    pvar_func_drvMultiFunctionRegister, pvar_func_drvScalerSoftRegister,
    pvar_func_drvUSBCTRRegister, pvar_func_editSseqRegistrar,
    pvar_func_fastSweepRegister, pvar_func_interpRegister,
    pvar_func_rsrvRegistrar, pvar_func_saveDataRegistrar,
    pvar_func_save_restoreRegister, pvar_func_subAveRegister,
    pvar_func_syncInitialize, pvar_func_tsInitialize,
    pvar_func_utagInitialize;

epicsShareExtern int * const pvar_int_CASDEBUG;
epicsShareExtern int * const pvar_int_aCalcAsyncThreshold;
epicsShareExtern int * const pvar_int_aCalcLoopMax;
epicsShareExtern int * const pvar_int_aCalcMonitorMem_debug;
epicsShareExtern int * const pvar_int_aCalcPerformDebug;
epicsShareExtern int * const pvar_int_aCalcPostfixDebug;
epicsShareExtern int * const pvar_int_aCalcoutRecordDebug;
epicsShareExtern int * const pvar_int_arrayTestDebug;
epicsShareExtern int * const pvar_int_asCaDebug;
epicsShareExtern int * const pvar_int_atExitDebug;
epicsShareExtern double * const pvar_double_boHIGHlimit;
epicsShareExtern int * const pvar_int_boHIGHprecision;
epicsShareExtern double * const pvar_double_calcoutODLYlimit;
epicsShareExtern int * const pvar_int_calcoutODLYprecision;
epicsShareExtern int * const pvar_int_callbackParallelThreadsDefault;
epicsShareExtern int * const pvar_int_configMenuDebug;
epicsShareExtern int * const pvar_int_dbAccessDebugPUTF;
epicsShareExtern int * const pvar_int_dbBptNotMonotonic;
epicsShareExtern int * const pvar_int_dbConvertStrict;
epicsShareExtern int * const pvar_int_dbJLinkDebug;
epicsShareExtern int * const pvar_int_dbQuietMacroWarnings;
epicsShareExtern int * const pvar_int_dbRecordsAbcSorted;
epicsShareExtern int * const pvar_int_dbRecordsOnceOnly;
epicsShareExtern int * const pvar_int_dbTemplateMaxVars;
epicsShareExtern int * const pvar_int_dbThreadRealtimeLock;
epicsShareExtern int * const pvar_int_debugSubAve;
epicsShareExtern int * const pvar_int_debug_saveData;
epicsShareExtern int * const pvar_int_debug_saveDataMsg;
epicsShareExtern int * const pvar_int_devaCalcoutSoftDebug;
epicsShareExtern int * const pvar_int_devsCalcoutSoftDebug;
epicsShareExtern int * const pvar_int_histogramSDELprecision;
epicsShareExtern int * const pvar_int_interpDebug;
epicsShareExtern int * const pvar_int_lnkDebug_debug;
epicsShareExtern int * const pvar_int_logClientDebug;
epicsShareExtern int * const pvar_int_mcaRecordDebug;
epicsShareExtern int * const pvar_int_recDynLinkDebug;
epicsShareExtern int * const pvar_int_recDynLinkQsize;
epicsShareExtern int * const pvar_int_sCalcLoopMax;
epicsShareExtern int * const pvar_int_sCalcPerformDebug;
epicsShareExtern int * const pvar_int_sCalcPostfixDebug;
epicsShareExtern int * const pvar_int_sCalcStackHW;
epicsShareExtern int * const pvar_int_sCalcStackLW;
epicsShareExtern int * const pvar_int_sCalcoutRecordDebug;
epicsShareExtern int * const pvar_int_saveData_MessagePolicy;
epicsShareExtern int * const pvar_int_save_restoreDatedBackupFiles;
epicsShareExtern int * const pvar_int_save_restoreDebug;
epicsShareExtern int * const pvar_int_save_restoreIncompleteSetsOk;
epicsShareExtern int * const pvar_int_save_restoreNumSeqFiles;
epicsShareExtern int * const pvar_int_save_restoreRemountThreshold;
epicsShareExtern int * const pvar_int_save_restoreSeqPeriodInSeconds;
epicsShareExtern int * const pvar_int_scalerRecordDebug;
epicsShareExtern int * const pvar_int_scaler_wait_time;
epicsShareExtern int * const pvar_int_scanparmRecordDebug;
epicsShareExtern double * const pvar_double_seqDLYlimit;
epicsShareExtern int * const pvar_int_seqDLYprecision;
epicsShareExtern int * const pvar_int_sscanRecordConnectWaitSeconds;
epicsShareExtern int * const pvar_int_sscanRecordDebug;
epicsShareExtern int * const pvar_int_sscanRecordDontCheckLimits;
epicsShareExtern int * const pvar_int_sscanRecordLookupTime;
epicsShareExtern int * const pvar_int_sscanRecordViewPos;
epicsShareExtern int * const pvar_int_sseqRecDebug;
epicsShareExtern int * const pvar_int_swaitRecordDebug;
epicsShareExtern int * const pvar_int_transformRecordDebug;

static struct iocshVarDef vardefs[] = {
    {"CASDEBUG", iocshArgInt, pvar_int_CASDEBUG},
    {"aCalcAsyncThreshold", iocshArgInt, pvar_int_aCalcAsyncThreshold},
    {"aCalcLoopMax", iocshArgInt, pvar_int_aCalcLoopMax},
    {"aCalcMonitorMem_debug", iocshArgInt, pvar_int_aCalcMonitorMem_debug},
    {"aCalcPerformDebug", iocshArgInt, pvar_int_aCalcPerformDebug},
    {"aCalcPostfixDebug", iocshArgInt, pvar_int_aCalcPostfixDebug},
    {"aCalcoutRecordDebug", iocshArgInt, pvar_int_aCalcoutRecordDebug},
    {"arrayTestDebug", iocshArgInt, pvar_int_arrayTestDebug},
    {"asCaDebug", iocshArgInt, pvar_int_asCaDebug},
    {"atExitDebug", iocshArgInt, pvar_int_atExitDebug},
    {"boHIGHlimit", iocshArgDouble, pvar_double_boHIGHlimit},
    {"boHIGHprecision", iocshArgInt, pvar_int_boHIGHprecision},
    {"calcoutODLYlimit", iocshArgDouble, pvar_double_calcoutODLYlimit},
    {"calcoutODLYprecision", iocshArgInt, pvar_int_calcoutODLYprecision},
    {"callbackParallelThreadsDefault", iocshArgInt, pvar_int_callbackParallelThreadsDefault},
    {"configMenuDebug", iocshArgInt, pvar_int_configMenuDebug},
    {"dbAccessDebugPUTF", iocshArgInt, pvar_int_dbAccessDebugPUTF},
    {"dbBptNotMonotonic", iocshArgInt, pvar_int_dbBptNotMonotonic},
    {"dbConvertStrict", iocshArgInt, pvar_int_dbConvertStrict},
    {"dbJLinkDebug", iocshArgInt, pvar_int_dbJLinkDebug},
    {"dbQuietMacroWarnings", iocshArgInt, pvar_int_dbQuietMacroWarnings},
    {"dbRecordsAbcSorted", iocshArgInt, pvar_int_dbRecordsAbcSorted},
    {"dbRecordsOnceOnly", iocshArgInt, pvar_int_dbRecordsOnceOnly},
    {"dbTemplateMaxVars", iocshArgInt, pvar_int_dbTemplateMaxVars},
    {"dbThreadRealtimeLock", iocshArgInt, pvar_int_dbThreadRealtimeLock},
    {"debugSubAve", iocshArgInt, pvar_int_debugSubAve},
    {"debug_saveData", iocshArgInt, pvar_int_debug_saveData},
    {"debug_saveDataMsg", iocshArgInt, pvar_int_debug_saveDataMsg},
    {"devaCalcoutSoftDebug", iocshArgInt, pvar_int_devaCalcoutSoftDebug},
    {"devsCalcoutSoftDebug", iocshArgInt, pvar_int_devsCalcoutSoftDebug},
    {"histogramSDELprecision", iocshArgInt, pvar_int_histogramSDELprecision},
    {"interpDebug", iocshArgInt, pvar_int_interpDebug},
    {"lnkDebug_debug", iocshArgInt, pvar_int_lnkDebug_debug},
    {"logClientDebug", iocshArgInt, pvar_int_logClientDebug},
    {"mcaRecordDebug", iocshArgInt, pvar_int_mcaRecordDebug},
    {"recDynLinkDebug", iocshArgInt, pvar_int_recDynLinkDebug},
    {"recDynLinkQsize", iocshArgInt, pvar_int_recDynLinkQsize},
    {"sCalcLoopMax", iocshArgInt, pvar_int_sCalcLoopMax},
    {"sCalcPerformDebug", iocshArgInt, pvar_int_sCalcPerformDebug},
    {"sCalcPostfixDebug", iocshArgInt, pvar_int_sCalcPostfixDebug},
    {"sCalcStackHW", iocshArgInt, pvar_int_sCalcStackHW},
    {"sCalcStackLW", iocshArgInt, pvar_int_sCalcStackLW},
    {"sCalcoutRecordDebug", iocshArgInt, pvar_int_sCalcoutRecordDebug},
    {"saveData_MessagePolicy", iocshArgInt, pvar_int_saveData_MessagePolicy},
    {"save_restoreDatedBackupFiles", iocshArgInt, pvar_int_save_restoreDatedBackupFiles},
    {"save_restoreDebug", iocshArgInt, pvar_int_save_restoreDebug},
    {"save_restoreIncompleteSetsOk", iocshArgInt, pvar_int_save_restoreIncompleteSetsOk},
    {"save_restoreNumSeqFiles", iocshArgInt, pvar_int_save_restoreNumSeqFiles},
    {"save_restoreRemountThreshold", iocshArgInt, pvar_int_save_restoreRemountThreshold},
    {"save_restoreSeqPeriodInSeconds", iocshArgInt, pvar_int_save_restoreSeqPeriodInSeconds},
    {"scalerRecordDebug", iocshArgInt, pvar_int_scalerRecordDebug},
    {"scaler_wait_time", iocshArgInt, pvar_int_scaler_wait_time},
    {"scanparmRecordDebug", iocshArgInt, pvar_int_scanparmRecordDebug},
    {"seqDLYlimit", iocshArgDouble, pvar_double_seqDLYlimit},
    {"seqDLYprecision", iocshArgInt, pvar_int_seqDLYprecision},
    {"sscanRecordConnectWaitSeconds", iocshArgInt, pvar_int_sscanRecordConnectWaitSeconds},
    {"sscanRecordDebug", iocshArgInt, pvar_int_sscanRecordDebug},
    {"sscanRecordDontCheckLimits", iocshArgInt, pvar_int_sscanRecordDontCheckLimits},
    {"sscanRecordLookupTime", iocshArgInt, pvar_int_sscanRecordLookupTime},
    {"sscanRecordViewPos", iocshArgInt, pvar_int_sscanRecordViewPos},
    {"sseqRecDebug", iocshArgInt, pvar_int_sseqRecDebug},
    {"swaitRecordDebug", iocshArgInt, pvar_int_swaitRecordDebug},
    {"transformRecordDebug", iocshArgInt, pvar_int_transformRecordDebug},
    {NULL, iocshArgInt, NULL}
};

int USB1608G_2AO_V2_registerRecordDeviceDriver(DBBASE *pbase)
{
    static int executed = 0;
    const char *bldTop = "/usr/local/epics/EPICS_R7.0/siteApp/USB1608G_2AO_V2";
    const char *envTop = getenv("TOP");

    if (envTop && strcmp(envTop, bldTop)) {
        printf("Warning: IOC is booting with TOP = \"%s\"\n"
               "          but was built with TOP = \"%s\"\n",
               envTop, bldTop);
    }

    if (!pbase) {
        printf("pdbbase is NULL; you must load a DBD file first.\n");
        return -1;
    }

    if (executed) {
        printf("Warning: Registration already done.\n");
    }
    executed = 1;

    registerRecordTypes(pbase, NELEMENTS(rtl), recordTypeNames, rtl);
    registerDevices(pbase, NELEMENTS(devsl), deviceSupportNames, devsl);
    registerDrivers(pbase, NELEMENTS(drvsl), driverSupportNames, drvsl);
    registerJLinks(pbase, NELEMENTS(jlifsl), jlifsl);
    runRegistrarOnce(pvar_func_Scaler974Register);
    runRegistrarOnce(pvar_func_ThresholdLogicRegister);
    runRegistrarOnce(pvar_func_USBCTR_SNLRegistrar);
    runRegistrarOnce(pvar_func_aCalcMonitorMemRegister);
    runRegistrarOnce(pvar_func_acalcTotalAllocatedMemoryRegister);
    runRegistrarOnce(pvar_func_arrInitialize);
    runRegistrarOnce(pvar_func_arrayTestRegister);
    runRegistrarOnce(pvar_func_asInitHooksRegister);
    runRegistrarOnce(pvar_func_asSub);
    runRegistrarOnce(pvar_func_asynInterposeDelayRegister);
    runRegistrarOnce(pvar_func_asynInterposeEchoRegister);
    runRegistrarOnce(pvar_func_asynInterposeEosRegister);
    runRegistrarOnce(pvar_func_asynInterposeFlushRegister);
    runRegistrarOnce(pvar_func_asynRegister);
    runRegistrarOnce(pvar_func_configMenuRegistrar);
    runRegistrarOnce(pvar_func_dbndInitialize);
    runRegistrarOnce(pvar_func_dbrestoreRegister);
    runRegistrarOnce(pvar_func_decInitialize);
    runRegistrarOnce(pvar_func_drvMultiFunctionRegister);
    runRegistrarOnce(pvar_func_drvScalerSoftRegister);
    runRegistrarOnce(pvar_func_drvUSBCTRRegister);
    runRegistrarOnce(pvar_func_editSseqRegistrar);
    runRegistrarOnce(pvar_func_fastSweepRegister);
    runRegistrarOnce(pvar_func_interpRegister);
    runRegistrarOnce(pvar_func_rsrvRegistrar);
    runRegistrarOnce(pvar_func_saveDataRegistrar);
    runRegistrarOnce(pvar_func_save_restoreRegister);
    runRegistrarOnce(pvar_func_subAveRegister);
    runRegistrarOnce(pvar_func_syncInitialize);
    runRegistrarOnce(pvar_func_tsInitialize);
    runRegistrarOnce(pvar_func_utagInitialize);
    iocshRegisterVariable(vardefs);
    return 0;
}

/* USB1608G_2AO_V2_registerRecordDeviceDriver */
static const iocshArg rrddArg0 = {"pdbbase", iocshArgPdbbase};
static const iocshArg *rrddArgs[] = {&rrddArg0};
static const iocshFuncDef rrddFuncDef = {
    "USB1608G_2AO_V2_registerRecordDeviceDriver",
    1,
    rrddArgs,
    "Register the various records, devices, for this DBD.\n\n"
    "These are registered into the database given as first argument,\n"
    "which should always be 'pdbbase'.\n\n"
    "Example: USB1608G_2AO_V2_registerRecordDeviceDriver pdbbase\n",
};
static void rrddCallFunc(const iocshArgBuf *)
{
    iocshSetError(USB1608G_2AO_V2_registerRecordDeviceDriver(*iocshPpdbbase));
}

} // extern "C"

/*
 * Register commands on application startup
 */
static int Registration() {
    iocshRegisterCommon();
    iocshRegister(&rrddFuncDef, rrddCallFunc);
    return 0;
}

static int done EPICS_UNUSED = Registration();











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.d
=================================================
USB1608G_2AO_V2_registerRecordDeviceDriver.o: \
 USB1608G_2AO_V2_registerRecordDeviceDriver.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdlib.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdStrtod.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/iocshRegisterCommon.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbCoreAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/registryCommon.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbStaticLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbFldTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbBase.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbDefs.h \
 /usr/local/epics/EPICS_R7.0/base/include/recSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/devSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/link.h \
 /usr/local/epics/EPICS_R7.0/base/include/cantProceed.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbJLink.h \
 /usr/local/epics/EPICS_R7.0/base/include/dbCoreAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/registryRecordType.h \
 /usr/local/epics/EPICS_R7.0/base/include/recSup.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USB1608G_2AO_V2_registerRecordDeviceDriver.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.c
=================================================
/* C code for program USBCTR_SNL, generated by snc from ../USBCTR_SNL.st */
#include <string.h>
#include <stddef.h>
#include <stdio.h>
#include <limits.h>

#include "seq_snc.h"
# line 17 "../USBCTR_SNL.st"
#include <stdlib.h>
# line 18 "../USBCTR_SNL.st"
#include <errlog.h>
# line 19 "../USBCTR_SNL.st"
#include <string.h>
# line 36 "../USBCTR_SNL.st"
static const EF_ID ReadArraysMon = 1;
# line 39 "../USBCTR_SNL.st"
static const EF_ID HardwareAcquiringMon = 2;

/* Variable declarations */
struct seqg_vars {
# line 24 "../USBCTR_SNL.st"
	int i;
# line 25 "../USBCTR_SNL.st"
	int n;
# line 26 "../USBCTR_SNL.st"
	int numCounters;
# line 27 "../USBCTR_SNL.st"
	char temp[100];
# line 29 "../USBCTR_SNL.st"
	char *prefix;
# line 30 "../USBCTR_SNL.st"
	char *record;
# line 31 "../USBCTR_SNL.st"
	char *field;
# line 33 "../USBCTR_SNL.st"
	int ReadArray[9];
# line 35 "../USBCTR_SNL.st"
	int ReadArrays;
# line 38 "../USBCTR_SNL.st"
	int HardwareAcquiring;
# line 41 "../USBCTR_SNL.st"
	int MCSAbsTimeWF;
# line 43 "../USBCTR_SNL.st"
	int SNL_Connected;
# line 44 "../USBCTR_SNL.st"
	int AsynDebug;
# line 47 "../USBCTR_SNL.st"
	int Acquiring;
};


/* Function declarations */

#define seqg_var (*(struct seqg_vars *const *)seqg_env)

/* Program init func */
static void seqg_init(PROG_ID seqg_env)
{
}

/****** Code for state "init" in state set "mca_control" ******/

/* Event function for state "init" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_init(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
	if (TRUE)
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "init" in state set "mca_control" */
static void seqg_action_mca_control_0_init(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 52 "../USBCTR_SNL.st"
			seqg_var->prefix = seq_macValueGet(seqg_env, "P");
# line 53 "../USBCTR_SNL.st"
			seqg_var->record = seq_macValueGet(seqg_env, "R");
# line 54 "../USBCTR_SNL.st"
			seqg_var->field = seq_macValueGet(seqg_env, "FIELD");
# line 55 "../USBCTR_SNL.st"
			seqg_var->numCounters = atoi(seq_macValueGet(seqg_env, "NUM_COUNTERS"));
# line 56 "../USBCTR_SNL.st"
			if ((seqg_var->numCounters <= 0) || (seqg_var->numCounters > 9))
			{
# line 57 "../USBCTR_SNL.st"
				printf("NUM_COUNTERS is illegal.\n");
# line 58 "../USBCTR_SNL.st"
				seqg_var->numCounters = 0;
			}
# line 60 "../USBCTR_SNL.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
			{
# line 61 "../USBCTR_SNL.st"
				seqg_var->n = seqg_var->i + 1;
# line 62 "../USBCTR_SNL.st"
				sprintf(seqg_var->temp, "%s%s%d.%s", seqg_var->prefix, seqg_var->record, seqg_var->n, seqg_var->field);
# line 63 "../USBCTR_SNL.st"
				seq_pvAssign(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), seqg_var->temp);
			}
		}
		return;
	}
}

/****** Code for state "waitConnected" in state set "mca_control" ******/

/* Event function for state "waitConnected" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_waitConnected(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 69 "../USBCTR_SNL.st"
	if (seqg_var->numCounters <= 0)
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 73 "../USBCTR_SNL.st"
	if (seq_pvAssignCount(seqg_env) == seq_pvConnectCount(seqg_env))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "waitConnected" in state set "mca_control" */
static void seqg_action_mca_control_0_waitConnected(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 70 "../USBCTR_SNL.st"
			printf(">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
		}
		return;
	case 1:
		{
# line 74 "../USBCTR_SNL.st"
			printf("USBCTR: All channels connected.\n");
# line 75 "../USBCTR_SNL.st"
			seqg_var->SNL_Connected = 1;
# line 76 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 12/*SNL_Connected*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	}
}

/****** Code for state "dead" in state set "mca_control" ******/

/* Event function for state "dead" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_dead(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 81 "../USBCTR_SNL.st"
	if (seq_delay(seqg_env, 3600.0))
	{
		*seqg_pnst = 2;
		*seqg_ptrn = 0;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "dead" in state set "mca_control" */
static void seqg_action_mca_control_0_dead(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
		}
		return;
	}
}

/****** Code for state "monitor_changes" in state set "mca_control" ******/

/* Event function for state "monitor_changes" in state set "mca_control" */
static seqBool seqg_event_mca_control_0_monitor_changes(SS_ID seqg_env, int *seqg_ptrn, int *seqg_pnst)
{
# line 86 "../USBCTR_SNL.st"
	if (seq_pvAssignCount(seqg_env) != seq_pvConnectCount(seqg_env))
	{
		*seqg_pnst = 1;
		*seqg_ptrn = 0;
		return TRUE;
	}
# line 90 "../USBCTR_SNL.st"
	if (seq_efTestAndClear(seqg_env, ReadArraysMon) && (seqg_var->ReadArrays == 1))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 1;
		return TRUE;
	}
# line 102 "../USBCTR_SNL.st"
	if (seq_efTestAndClear(seqg_env, HardwareAcquiringMon))
	{
		*seqg_pnst = 3;
		*seqg_ptrn = 2;
		return TRUE;
	}
	return FALSE;
}

/* Action function for state "monitor_changes" in state set "mca_control" */
static void seqg_action_mca_control_0_monitor_changes(SS_ID seqg_env, int seqg_trn, int *seqg_pnst)
{
	switch(seqg_trn)
	{
	case 0:
		{
# line 87 "../USBCTR_SNL.st"
			printf("USBCTR: Not all channels connected.\n");
		}
		return;
	case 1:
		{
# line 91 "../USBCTR_SNL.st"
			if (seqg_var->AsynDebug)
# line 91 "../USBCTR_SNL.st"
				printf("USBCTR.st: Read array data\n");
# line 92 "../USBCTR_SNL.st"
			for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
			{
# line 93 "../USBCTR_SNL.st"
				seqg_var->ReadArray[seqg_var->i] = 1;
# line 94 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), DEFAULT, DEFAULT_TIMEOUT);
			}
# line 96 "../USBCTR_SNL.st"
			seqg_var->MCSAbsTimeWF = 1;
# line 97 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 11/*MCSAbsTimeWF*/, DEFAULT, DEFAULT_TIMEOUT);
# line 98 "../USBCTR_SNL.st"
			seqg_var->ReadArrays = 0;
# line 99 "../USBCTR_SNL.st"
			seq_pvPutTmo(seqg_env, 9/*ReadArrays*/, DEFAULT, DEFAULT_TIMEOUT);
		}
		return;
	case 2:
		{
# line 103 "../USBCTR_SNL.st"
			if (seqg_var->AsynDebug)
# line 103 "../USBCTR_SNL.st"
				printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", seqg_var->HardwareAcquiring);
# line 105 "../USBCTR_SNL.st"
			if (!seqg_var->HardwareAcquiring)
			{
# line 107 "../USBCTR_SNL.st"
				for (seqg_var->i = 0; seqg_var->i < seqg_var->numCounters; seqg_var->i++)
				{
# line 108 "../USBCTR_SNL.st"
					seqg_var->ReadArray[seqg_var->i] = 1;
# line 109 "../USBCTR_SNL.st"
					seq_pvPutTmo(seqg_env, 0/*ReadArray*/ + (CH_ID)(seqg_var->i), SYNC, DEFAULT_TIMEOUT);
				}
# line 111 "../USBCTR_SNL.st"
				seqg_var->MCSAbsTimeWF = 1;
# line 112 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 11/*MCSAbsTimeWF*/, DEFAULT, DEFAULT_TIMEOUT);
# line 114 "../USBCTR_SNL.st"
				seqg_var->Acquiring = 0;
# line 115 "../USBCTR_SNL.st"
				seq_pvPutTmo(seqg_env, 14/*Acquiring*/, DEFAULT, DEFAULT_TIMEOUT);
			}
		}
		return;
	}
}

#undef seqg_var

/************************ Tables ************************/

/* Channel table */
static seqChan seqg_chans[] = {
	/* chName, offset, varName, varType, count, eventNum, efId, monitored, queueSize, queueIndex */
	{"", offsetof(struct seqg_vars, ReadArray[0]), "ReadArray[0]", P_INT, 1, 3, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[1]), "ReadArray[1]", P_INT, 1, 4, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[2]), "ReadArray[2]", P_INT, 1, 5, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[3]), "ReadArray[3]", P_INT, 1, 6, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[4]), "ReadArray[4]", P_INT, 1, 7, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[5]), "ReadArray[5]", P_INT, 1, 8, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[6]), "ReadArray[6]", P_INT, 1, 9, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[7]), "ReadArray[7]", P_INT, 1, 10, 0, 0, 0, 0},
	{"", offsetof(struct seqg_vars, ReadArray[8]), "ReadArray[8]", P_INT, 1, 11, 0, 0, 0, 0},
	{"{P}DoReadAll", offsetof(struct seqg_vars, ReadArrays), "ReadArrays", P_INT, 1, 12, 1, 1, 0, 0},
	{"{P}HardwareAcquiring", offsetof(struct seqg_vars, HardwareAcquiring), "HardwareAcquiring", P_INT, 1, 13, 2, 1, 0, 0},
	{"{P}AbsTimeWF.PROC", offsetof(struct seqg_vars, MCSAbsTimeWF), "MCSAbsTimeWF", P_INT, 1, 14, 0, 0, 0, 0},
	{"{P}SNL_Connected", offsetof(struct seqg_vars, SNL_Connected), "SNL_Connected", P_INT, 1, 15, 0, 0, 0, 0},
	{"{P}Asyn.TB1", offsetof(struct seqg_vars, AsynDebug), "AsynDebug", P_INT, 1, 16, 0, 1, 0, 0},
	{"{P}Acquiring", offsetof(struct seqg_vars, Acquiring), "Acquiring", P_INT, 1, 17, 0, 0, 0, 0},
};

/* Event masks for state set "mca_control" */
static const seqMask seqg_mask_mca_control_0_init[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_waitConnected[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_dead[] = {
	0x00000000,
};
static const seqMask seqg_mask_mca_control_0_monitor_changes[] = {
	0x00001006,
};

/* State table for state set "mca_control" */
static seqState seqg_states_mca_control[] = {
	{
	/* state name */        "init",
	/* action function */   seqg_action_mca_control_0_init,
	/* event function */    seqg_event_mca_control_0_init,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_init,
	/* state options */     (0)
	},
	{
	/* state name */        "waitConnected",
	/* action function */   seqg_action_mca_control_0_waitConnected,
	/* event function */    seqg_event_mca_control_0_waitConnected,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_waitConnected,
	/* state options */     (0)
	},
	{
	/* state name */        "dead",
	/* action function */   seqg_action_mca_control_0_dead,
	/* event function */    seqg_event_mca_control_0_dead,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_dead,
	/* state options */     (0)
	},
	{
	/* state name */        "monitor_changes",
	/* action function */   seqg_action_mca_control_0_monitor_changes,
	/* event function */    seqg_event_mca_control_0_monitor_changes,
	/* entry function */    0,
	/* exit function */     0,
	/* event mask array */  seqg_mask_mca_control_0_monitor_changes,
	/* state options */     (0)
	},
};

/* State set table */
static seqSS seqg_statesets[] = {
	{
	/* state set name */    "mca_control",
	/* states */            seqg_states_mca_control,
	/* number of states */  4
	},
};

/* Program table (global) */
seqProgram USBCTR_SNL = {
	/* magic number */      2002009,
	/* program name */      "USBCTR_SNL",
	/* channels */          seqg_chans,
	/* num. channels */     15,
	/* state sets */        seqg_statesets,
	/* num. state sets */   1,
	/* user var size */     sizeof(struct seqg_vars),
	/* param */             "P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ",
	/* num. event flags */  2,
	/* encoded options */   (0 | OPT_NEWEF | OPT_REENT),
	/* init func */         seqg_init,
	/* entry func */        0,
	/* exit func */         0,
	/* num. queues */       0
};

/* Register sequencer commands and program */
#include "epicsExport.h"
static void USBCTR_SNLRegistrar (void) {
    seqRegisterSequencerCommands();
    seqRegisterSequencerProgram (&USBCTR_SNL);
}
epicsExportRegistrar(USBCTR_SNLRegistrar);











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.d
=================================================
USBCTR_SNL.o: USBCTR_SNL.c \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_snc.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seqCom.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/pvAlarm.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_release.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_prim_types.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/sequencer-mirror-R2-2-9/include/seq_mask.h \
 /usr/local/epics/EPICS_R7.0/base/include/errlog.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.i
=================================================
# 0 "../USBCTR_SNL.st"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "../USBCTR_SNL.st"
program USBCTR_SNL("P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ")
# 11 "../USBCTR_SNL.st"
option +r;



option -c;

%%#include <stdlib.h>
%%#include <errlog.h>
%%#include <string.h>




int i;
int n;
int numCounters;
char temp[100];

char *prefix;
char *record;
char *field;

int ReadArray[9];
assign ReadArray to {};
int ReadArrays; assign ReadArrays to "{P}DoReadAll";
monitor ReadArrays; evflag ReadArraysMon; sync ReadArrays ReadArraysMon;

int HardwareAcquiring; assign HardwareAcquiring to "{P}HardwareAcquiring";
monitor HardwareAcquiring; evflag HardwareAcquiringMon; sync HardwareAcquiring HardwareAcquiringMon;

int MCSAbsTimeWF; assign MCSAbsTimeWF to "{P}AbsTimeWF.PROC";

int SNL_Connected; assign SNL_Connected to "{P}SNL_Connected";
int AsynDebug; assign AsynDebug to "{P}Asyn.TB1";
monitor AsynDebug;

int Acquiring; assign Acquiring to "{P}Acquiring";

ss mca_control {
  state init {
    when() {
      prefix = macValueGet("P");
      record = macValueGet("R");
      field = macValueGet("FIELD");
      numCounters = atoi(macValueGet("NUM_COUNTERS"));
      if ((numCounters <= 0) || (numCounters > 9)) {
        printf ("NUM_COUNTERS is illegal.\n");
        numCounters = 0;
      }
      for (i=0; i<numCounters; i++) {
        n = i+1;
        sprintf(temp, "%s%s%d.%s", prefix, record, n, field);
        pvAssign(ReadArray[i], temp);
       }
    } state waitConnected
  }

  state waitConnected {
    when (numCounters <= 0) {
      printf (">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
    } state dead

    when (pvAssignCount () == pvConnectCount ()) {
      printf ("USBCTR: All channels connected.\n");
      SNL_Connected = 1;
      pvPut(SNL_Connected);
    } state monitor_changes
  }

  state dead {
    when (delay (3600.0)) {
    } state dead
  }

  state monitor_changes {
    when (pvAssignCount () != pvConnectCount ()) {
      printf ("USBCTR: Not all channels connected.\n");
    } state waitConnected

    when(efTestAndClear(ReadArraysMon) && (ReadArrays == 1)) {
      if (AsynDebug) printf("USBCTR.st: Read array data\n");
      for (i=0; i<numCounters; i++) {
        ReadArray[i] = 1;
        pvPut(ReadArray[i]);
      }
      MCSAbsTimeWF = 1;
      pvPut(MCSAbsTimeWF);
      ReadArrays = 0;
      pvPut(ReadArrays);
    } state monitor_changes

    when(efTestAndClear(HardwareAcquiringMon)) {
      if (AsynDebug) printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", HardwareAcquiring);

      if (!HardwareAcquiring) {

        for (i=0; i<numCounters; i++) {
          ReadArray[i] = 1;
          pvPut(ReadArray[i], SYNC);
        }
        MCSAbsTimeWF = 1;
        pvPut(MCSAbsTimeWF);

        Acquiring = 0;
        pvPut(Acquiring);
      }
    } state monitor_changes
  }
}











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/USBCTR_SNL.st.d
=================================================
# DO NOT EDIT: This file created by mkmf.pl














üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.d
=================================================
drvMultiFunction.o: ../drvMultiFunction.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsString.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 ../measCompDiscover.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvMultiFunction.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.d
=================================================
drvUSBCTR.o: ../drvUSBCTR.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/iocsh.h \
 /usr/local/epics/EPICS_R7.0/base/include/compilerDependencies.h \
 /usr/local/epics/EPICS_R7.0/base/include/compiler/gcc/compilerSpecific.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsAssert.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsGuard.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdMutex.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdThread.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsEvent.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdTime.h \
 /usr/local/epics/EPICS_R7.0/base/include/errMdef.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynPortDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTypes.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsMutex.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynStandardInterfaces.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDriver.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsStdio.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsTempFile.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsVersion.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynAPI.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynUInt32Digital.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt8Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt16Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynInt64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat32Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynFloat64Array.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynGenericPointer.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynEnum.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOctet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynDrvUser.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynOption.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamSet.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/asynParamType.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/asyn-R4-44-2/include/paramErrors.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/mca-R7-10/include/drvMca.h \
 /usr/local/epics/EPICS_R7.0/modules/synApps/support/scaler-4-1/include/devScalerAsyn.h \
 /usr/local/epics/EPICS_R7.0/base/include/epicsExport.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h \
 ../measCompDiscover.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/drvUSBCTR.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.d
=================================================
measCompDiscover.o: ../measCompDiscover.cpp \
 /usr/local/epics/EPICS_R7.0/base/include/osiSock.h \
 /usr/local/epics/EPICS_R7.0/base/include/libComAPI.h \
 /usr/local/epics/EPICS_R7.0/base/include/os/Linux/osdSock.h \
 /usr/local/epics/EPICS_R7.0/base/include/ellLib.h ../measCompDiscover.h \
 /usr/local/epics/EPICS_R7.0/base/include/shareLib.h











üî• File: ./USB1608G_2AO_V2App/src/O.linux-x86_64/measCompDiscover.o
=================================================
[SKIPPED: ‚ùå binary or unreadable file]











üî• File: ./USB1608G_2AO_V2App/src/ThresholdLogicController.cpp
=================================================
/* ThresholdLogicController.cpp
 *
 * ÏûÑÍ≥ÑÍ∞í Í∏∞Î∞ò Î°úÏßÅ Ï†úÏñ¥Î•º ÏúÑÌïú asynPortDriver Íµ¨ÌòÑ
 * 
 * Ïù¥ ÎìúÎùºÏù¥Î≤ÑÎäî ÏïÑÎÇ†Î°úÍ∑∏ ÏûÖÎ†• Í∞íÏùÑ Î™®ÎãàÌÑ∞ÎßÅÌïòÍ≥† ÏÑ§Ï†ïÎêú ÏûÑÍ≥ÑÍ∞íÍ≥º ÎπÑÍµêÌïòÏó¨
 * ÎîîÏßÄÌÑ∏ Ï∂úÎ†•ÏùÑ Ï†úÏñ¥ÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
 * ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í∏∞Îä•ÏùÑ Ìè¨Ìï®ÌïòÏó¨ ÏïàÏ†ïÏ†ÅÏù∏ Ï∂úÎ†• Ï†úÏñ¥Î•º Î≥¥Ïû•Ìï©ÎãàÎã§.
 *
 * Author: EPICS IOC Development Guide
 * Date: 2025
 */


/* ThresholdLogicController Íµ¨ÌòÑÎêú ÎÇ¥Ïö©:         */
// 1. ThresholdLogicController.cpp ÌååÏùº ÏÉùÏÑ±
// 2. asynPortDriver Ï¥àÍ∏∞Ìôî Î∞è Îß§Í∞úÎ≥ÄÏàò ÏÉùÏÑ±
//     ÏÉùÏÑ±ÏûêÏóêÏÑú asynPortDriverÎ•º Ïò¨Î∞îÎ•¥Í≤å Ï¥àÍ∏∞Ìôî
//     9Í∞úÏùò Îß§Í∞úÎ≥ÄÏàòÎ•º ÏÉùÏÑ± (ÏûÑÍ≥ÑÍ∞í, ÌòÑÏû¨Í∞í, Ï∂úÎ†•ÏÉÅÌÉú, ÌôúÏÑ±Ìôî, ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Îì±)
//     Ï¥àÍ∏∞Í∞í ÏÑ§Ï†ï Î∞è Îß§Í∞úÎ≥ÄÏàò ÏΩúÎ∞± Ìò∏Ï∂ú
// 3. Í∏∞Î≥∏Ï†ÅÏù∏ ÏùΩÍ∏∞/Ïì∞Í∏∞ Î©îÏÑúÎìú Ïä§ÏºàÎ†àÌÜ§ Íµ¨ÌòÑ
//     writeFloat64(): ÏûÑÍ≥ÑÍ∞í, ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§, ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ ÏÑ§Ï†ï Ï≤òÎ¶¨
//     readFloat64(): ÌòÑÏû¨Í∞í ÏùΩÍ∏∞ Î∞è Ï∫êÏãúÎêú Í∞í Î∞òÌôò
//     writeInt32(): ÌôúÏÑ±Ìôî ÏÉÅÌÉú Ï†úÏñ¥ Î∞è Ï∂úÎ†•ÏÉÅÌÉú Î≥¥Ìò∏
//     readInt32(): Ï†ïÏàò Îß§Í∞úÎ≥ÄÏàò ÏùΩÍ∏∞
// 4. Ï∂îÍ∞Ä Íµ¨ÌòÑÎêú Í∏∞Îä•Îì§
//     ÏÜåÎ©∏Ïûê: Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨ Î∞è Ïä§Î†àÎìú Ï§ëÏßÄ
//     IOC Ïâò Î™ÖÎ†πÏñ¥: ThresholdLogicConfig Ìï®Ïàò Î∞è Îì±Î°ù
//     ÎÇ¥Î∂Ä Î©îÏÑúÎìú Ïä§ÏºàÎ†àÌÜ§: Ìñ•ÌõÑ ÏûëÏóÖÏóêÏÑú Íµ¨ÌòÑÌï† Î©îÏÑúÎìúÎì§Ïùò Í∏∞Î≥∏ ÌãÄ
//     Ïò§Î•ò Ï≤òÎ¶¨: Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Î∞è Î°úÍπÖ
//     ÌïúÍµ≠Ïñ¥ Ï£ºÏÑù: Î™®Îì† Ï£ºÏöî Í∏∞Îä•Ïóê ÎåÄÌïú ÌïúÍµ≠Ïñ¥ ÏÑ§Î™Ö
// 5. ÏöîÍµ¨ÏÇ¨Ìï≠ Ï∂©Ï°± ÌôïÏù∏
//     ÏöîÍµ¨ÏÇ¨Ìï≠ 4.1: asynPortDriver ÏÉÅÏÜç Î∞è Îß§Í∞úÎ≥ÄÏàò Í¥ÄÎ¶¨ Íµ¨ÌòÑ
//     ÏöîÍµ¨ÏÇ¨Ìï≠ 4.2: Í∏∞Î≥∏ Íµ¨Ï°∞ Î∞è Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ï†ïÏùò


#include <math.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsString.h>
#include <epicsTime.h>
#include <epicsExport.h>
#include <asynPortDriver.h>
#include <asynOctetSyncIO.h>

#include "ThresholdLogicController.h"
#include "ErrorHandler.h"

static const char *driverName = "ThresholdLogicController";

/** ThresholdLogicController ÏÉùÏÑ±Ïûê
 * \param[in] portName Ïù¥ ÎìúÎùºÏù¥Î≤ÑÏùò asyn Ìè¨Ìä∏ Ïù¥Î¶Ñ
 * \param[in] devicePort Ïó∞Í≤∞Ìï† Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ  
 * \param[in] deviceAddr Ïû•Ïπò Ï£ºÏÜå
 */
ThresholdLogicController::ThresholdLogicController(const char* portName, const char* devicePort, int deviceAddr)
    : asynPortDriver(portName, 
                     1, /* maxAddr */ 
                     asynFloat64Mask | asynInt32Mask | asynDrvUserMask, /* Interface mask */
                     asynFloat64Mask | asynInt32Mask,  /* Interrupt mask */
                     ASYN_CANBLOCK, /* asynFlags */
                     1, /* Autoconnect */
                     0, /* Default priority */
                     0) /* Default stack size */
{
    const char* functionName = "ThresholdLogicController";
    
    // Ïû•Ïπò Ïó∞Í≤∞ Ï†ïÎ≥¥ Ï†ÄÏû•
    strncpy(devicePortName_, devicePort, sizeof(devicePortName_) - 1);
    devicePortName_[sizeof(devicePortName_) - 1] = '\0';
    deviceAddr_ = deviceAddr;
    
    // Îß§Í∞úÎ≥ÄÏàò ÏÉùÏÑ±
    createParam(THRESHOLD_VALUE_STRING,  asynParamFloat64, &P_ThresholdValue);
    createParam(CURRENT_VALUE_STRING,    asynParamFloat64, &P_CurrentValue);
    createParam(OUTPUT_STATE_STRING,     asynParamInt32,   &P_OutputState);
    createParam(ENABLE_STRING,           asynParamInt32,   &P_Enable);
    createParam(HYSTERESIS_STRING,       asynParamFloat64, &P_Hysteresis);
    createParam(UPDATE_RATE_STRING,      asynParamFloat64, &P_UpdateRate);
    createParam(ALARM_STATUS_STRING,     asynParamInt32,   &P_AlarmStatus);
    createParam(DEVICE_PORT_STRING,      asynParamOctet,   &P_DevicePort);
    createParam(DEVICE_ADDR_STRING,      asynParamInt32,   &P_DeviceAddr);
    
    // Ï¥àÍ∏∞Í∞í ÏÑ§Ï†ï
    thresholdValue_ = 0.0;
    currentValue_ = 0.0;
    outputState_ = false;
    enabled_ = false;
    hysteresis_ = 0.1;  // Í∏∞Î≥∏ ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í∞í
    updateRate_ = 10.0; // Í∏∞Î≥∏ 10Hz ÏóÖÎç∞Ïù¥Ìä∏
    alarmStatus_ = 0;   // ÏïåÎûå ÏóÜÏùå
    lastOutputState_ = false;
    
    // Ïä§Î†àÎìú Í¥ÄÎ¶¨ Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
    monitorThread_ = NULL;
    threadRunning_ = false;
    threadExit_ = false;
    
    // Îß§Í∞úÎ≥ÄÏàò Ï¥àÍ∏∞Í∞íÏùÑ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§Ïóê ÏÑ§Ï†ï
    setDoubleParam(P_ThresholdValue, thresholdValue_);
    setDoubleParam(P_CurrentValue, currentValue_);
    setIntegerParam(P_OutputState, outputState_ ? 1 : 0);
    setIntegerParam(P_Enable, enabled_ ? 1 : 0);
    setDoubleParam(P_Hysteresis, hysteresis_);
    setDoubleParam(P_UpdateRate, updateRate_);
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    setStringParam(P_DevicePort, devicePortName_);
    setIntegerParam(P_DeviceAddr, deviceAddr_);
    
    // ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Ï¥àÍ∏∞Ìôî
    epicsTimeGetCurrent(&lastUpdate_);
    
    // Íµ¨ÏÑ± Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (ErrorHandler ÏÇ¨Ïö©)
    if (!validateConfigurationWithErrorHandler()) {
        ErrorHandler::logError(ErrorHandler::WARNING, functionName, 
                              "Íµ¨ÏÑ± Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ÏóêÏÑú Í≤ΩÍ≥†Í∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§", pasynUserSelf);
    }
    
    // Îß§Í∞úÎ≥ÄÏàò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÏïåÎ¶º
    callParamCallbacks();
    
    // ÏÑ±Í≥µÏ†ÅÏù∏ ÏÉùÏÑ± Î°úÍ∑∏
    char successMessage[256];
    snprintf(successMessage, sizeof(successMessage),
            "Ìè¨Ìä∏=%s, Ïû•ÏπòÌè¨Ìä∏=%s, Ï£ºÏÜå=%dÎ°ú ThresholdLogicController ÏÉùÏÑ±Îê®",
            portName, devicePort, deviceAddr);
    ErrorHandler::logError(ErrorHandler::INFO, functionName, successMessage, pasynUserSelf);
}

/** ThresholdLogicController ÏÜåÎ©∏Ïûê */
ThresholdLogicController::~ThresholdLogicController()
{
    const char* functionName = "~ThresholdLogicController";
    
    // Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú Ï§ëÏßÄ
    stopMonitoring();
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ThresholdLogicController ÏÜåÎ©∏Îê®\n",
              driverName, functionName);
}

/** Float64 Îß§Í∞úÎ≥ÄÏàò Ïì∞Í∏∞ Î©îÏÑúÎìú */
asynStatus ThresholdLogicController::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "writeFloat64";
    
    // Îß§Í∞úÎ≥ÄÏàòÎ≥Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Î∞è Ï≤òÎ¶¨
    if (function == P_ThresholdValue) {
        // ÏûÑÍ≥ÑÍ∞í Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (ErrorHandler ÏÇ¨Ïö©)
        if (!ErrorHandler::validateParameter("thresholdValue", value, -10.0, 10.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "ÏûÑÍ≥ÑÍ∞íÏù¥ Ïú†Ìö® Î≤îÏúÑ(-10.0V ~ +10.0V)Î•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§", pasynUser);
            return asynError;
        }
        
        // ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ÏôÄÏùò Í¥ÄÍ≥Ñ Í≤ÄÏÇ¨
        if (fabs(value) < hysteresis_) {
            char warningMsg[256];
            snprintf(warningMsg, sizeof(warningMsg),
                    "ÏûÑÍ≥ÑÍ∞íÏù¥ ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Î≥¥Îã§ ÏûëÏùå - ÏûÑÍ≥ÑÍ∞í: %f, ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§: %f",
                    value, hysteresis_);
            ErrorHandler::logError(ErrorHandler::WARNING, functionName, warningMsg, pasynUser);
        }
        
        thresholdValue_ = value;
        status = setDoubleParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ïÎê®: %f V\n", driverName, functionName, value);
    }
    else if (function == P_Hysteresis) {
        // ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (ErrorHandler ÏÇ¨Ïö©)
        if (!ErrorHandler::validateParameter("hysteresis", value, 0.0, 5.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Í∞Ä Ïú†Ìö® Î≤îÏúÑ(0.0V ~ 5.0V)Î•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§", pasynUser);
            return asynError;
        }
        
        // ÏûÑÍ≥ÑÍ∞íÍ≥ºÏùò Í¥ÄÍ≥Ñ Í≤ÄÏÇ¨
        if (value > fabs(thresholdValue_)) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Í∞Ä ÏûÑÍ≥ÑÍ∞íÎ≥¥Îã§ ÌÅº - ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§: %f, ÏûÑÍ≥ÑÍ∞í: %f\n",
                      driverName, functionName, value, thresholdValue_);
        }
        
        hysteresis_ = value;
        status = setDoubleParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ ÏÑ§Ï†ïÎê®: %f V\n", driverName, functionName, value);
    }
    else if (function == P_UpdateRate) {
        // ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (ErrorHandler ÏÇ¨Ïö©)
        if (!ErrorHandler::validateParameter("updateRate", value, 0.1, 1000.0, functionName)) {
            ErrorHandler::logError(ErrorHandler::ERROR, functionName, 
                                  "ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞Í∞Ä Ïú†Ìö® Î≤îÏúÑ(0.1Hz ~ 1000Hz)Î•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§", pasynUser);
            return asynError;
        }
        
        double oldRate = updateRate_;
        updateRate_ = value;
        status = setDoubleParam(function, value);
        
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Î≥ÄÍ≤ΩÎê®: %f Hz -> %f Hz\n", 
                  driverName, functionName, oldRate, value);
        
        // Ïä§Î†àÎìúÍ∞Ä Ïã§Ìñâ Ï§ëÏù∏ Í≤ΩÏö∞ ÏÉàÎ°úÏö¥ Ï£ºÍ∏∞Í∞Ä Îã§Ïùå Î£®ÌîÑÏóêÏÑú Ï†ÅÏö©Îê®ÏùÑ ÏïåÎ¶º
        if (threadRunning_) {
            asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                      "%s::%s: ÏÉàÎ°úÏö¥ ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞Îäî Îã§Ïùå Î£®ÌîÑÏóêÏÑú Ï†ÅÏö©Îê©ÎãàÎã§\n",
                      driverName, functionName);
        }
    }
    else if (function == P_CurrentValue) {
        // ÌòÑÏû¨Í∞íÏùÄ ÏùΩÍ∏∞ Ï†ÑÏö©Ïù¥ÎØÄÎ°ú Ïì∞Í∏∞ Í±∞Î∂Ä
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ÌòÑÏû¨Í∞íÏùÄ ÏùΩÍ∏∞ Ï†ÑÏö© Îß§Í∞úÎ≥ÄÏàòÏûÖÎãàÎã§\n",
                  driverName, functionName);
        return asynError;
    }
    else {
        // Ïïå Ïàò ÏóÜÎäî Îß§Í∞úÎ≥ÄÏàòÏóê ÎåÄÌï¥ÏÑúÎäî Î∂ÄÎ™® ÌÅ¥ÎûòÏä§ Ìò∏Ï∂ú
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: Ïïå Ïàò ÏóÜÎäî Float64 Îß§Í∞úÎ≥ÄÏàò: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::writeFloat64(pasynUser, value);
    }
    
    // ÏÑ±Í≥µÌïú Í≤ΩÏö∞ÏóêÎßå Îß§Í∞úÎ≥ÄÏàò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÏïåÎ¶º
    if (status == asynSuccess) {
        callParamCallbacks();
    } else {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: Îß§Í∞úÎ≥ÄÏàò ÏÑ§Ï†ï Ïã§Ìå® - function=%d, value=%f, status=%d\n",
                  driverName, functionName, function, value, status);
    }
    
    return status;
}

/** Float64 Îß§Í∞úÎ≥ÄÏàò ÏùΩÍ∏∞ Î©îÏÑúÎìú */
asynStatus ThresholdLogicController::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "readFloat64";
    
    // ÏûÖÎ†• Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (value == NULL) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®\n",
                  driverName, functionName);
        return asynError;
    }
    
    // Îß§Í∞úÎ≥ÄÏàòÎ≥Ñ ÏùΩÍ∏∞ Ï≤òÎ¶¨
    if (function == P_ThresholdValue) {
        *value = thresholdValue_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ÏûÑÍ≥ÑÍ∞í ÏùΩÍ∏∞: %f V\n", driverName, functionName, *value);
    }
    else if (function == P_CurrentValue) {
        // ÌòÑÏû¨Í∞íÏùÄ Ïã§ÏãúÍ∞ÑÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏ÎêòÎØÄÎ°ú ÏµúÏã† Í∞í Î∞òÌôò
        *value = currentValue_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ÌòÑÏû¨Í∞í ÏùΩÍ∏∞: %f V\n", driverName, functionName, *value);
        
        // ÌòÑÏû¨Í∞íÏù¥ Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇòÎäî Í≤ΩÏö∞ Í≤ΩÍ≥†
        if (*value < -10.0 || *value > 10.0) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: ÌòÑÏû¨Í∞íÏù¥ ÏòàÏÉÅ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %f V\n",
                      driverName, functionName, *value);
        }
    }
    else if (function == P_Hysteresis) {
        *value = hysteresis_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ ÏùΩÍ∏∞: %f V\n", driverName, functionName, *value);
    }
    else if (function == P_UpdateRate) {
        *value = updateRate_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ ÏùΩÍ∏∞: %f Hz\n", driverName, functionName, *value);
    }
    else {
        // Ïïå Ïàò ÏóÜÎäî Îß§Í∞úÎ≥ÄÏàòÏóê ÎåÄÌï¥ÏÑúÎäî Î∂ÄÎ™® ÌÅ¥ÎûòÏä§ Ìò∏Ï∂ú
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: Ïïå Ïàò ÏóÜÎäî Float64 Îß§Í∞úÎ≥ÄÏàò: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::readFloat64(pasynUser, value);
        
        if (status != asynSuccess) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: Î∂ÄÎ™® ÌÅ¥ÎûòÏä§ÏóêÏÑú Îß§Í∞úÎ≥ÄÏàò ÏùΩÍ∏∞ Ïã§Ìå®: function=%d\n",
                      driverName, functionName, function);
        }
    }
    
    // Ïò§Î•ò Î∞úÏÉù Ïãú Î°úÍπÖ
    if (status != asynSuccess) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: Îß§Í∞úÎ≥ÄÏàò ÏùΩÍ∏∞ Ïã§Ìå® - function=%d, status=%d\n",
                  driverName, functionName, function, status);
    }
    
    return status;
}

/** Int32 Îß§Í∞úÎ≥ÄÏàò Ïì∞Í∏∞ Î©îÏÑúÎìú */
asynStatus ThresholdLogicController::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "writeInt32";
    
    // Îß§Í∞úÎ≥ÄÏàòÎ≥Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Î∞è Ï≤òÎ¶¨
    if (function == P_Enable) {
        // ÌôúÏÑ±Ìôî ÏÉÅÌÉú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (0 ÎòêÎäî 1Îßå ÌóàÏö©)
        if (value != 0 && value != 1) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: ÌôúÏÑ±Ìôî Í∞íÏù¥ 0 ÎòêÎäî 1Ïù¥ ÏïÑÎãò: %d (0ÏúºÎ°ú Ï≤òÎ¶¨)\n",
                      driverName, functionName, value);
            value = (value != 0) ? 1 : 0; // 0Ïù¥ ÏïÑÎãå Í∞íÏùÄ 1Î°ú Ï≤òÎ¶¨
        }
        
        bool newEnabled = (value != 0);
        if (newEnabled != enabled_) {
            // ÏÉÅÌÉú Î≥ÄÍ≤Ω Ï†Ñ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
            if (newEnabled) {
                // ÌôúÏÑ±ÌôîÌïòÍ∏∞ Ï†Ñ ÌïÑÏàò Îß§Í∞úÎ≥ÄÏàò Í≤ÄÏÇ¨
                if (!validateParameters()) {
                    asynPrint(pasynUser, ASYN_TRACE_ERROR,
                              "%s::%s: Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå® - ÌôúÏÑ±ÌôîÌï† Ïàò ÏóÜÏùå\n",
                              driverName, functionName);
                    return asynError;
                }
                
                // Ïû•Ïπò Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
                if (strlen(devicePortName_) == 0) {
                    asynPrint(pasynUser, ASYN_TRACE_ERROR,
                              "%s::%s: Ïû•Ïπò Ìè¨Ìä∏Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå - ÌôúÏÑ±ÌôîÌï† Ïàò ÏóÜÏùå\n",
                              driverName, functionName);
                    return asynError;
                }
            }
            
            enabled_ = newEnabled;
            status = setIntegerParam(function, value);
            
            if (enabled_) {
                startMonitoring();
                asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                          "%s::%s: ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ ÌôúÏÑ±ÌôîÎê® (Ìè¨Ìä∏: %s, Ï£ºÏÜå: %d)\n", 
                          driverName, functionName, devicePortName_, deviceAddr_);
            } else {
                stopMonitoring();
                asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                          "%s::%s: ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ ÎπÑÌôúÏÑ±ÌôîÎê®\n", driverName, functionName);
            }
        } else {
            // ÏÉÅÌÉú Î≥ÄÍ≤ΩÏù¥ ÏóÜÎäî Í≤ΩÏö∞ÏóêÎèÑ Îß§Í∞úÎ≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏
            status = setIntegerParam(function, value);
            asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                      "%s::%s: ÌôúÏÑ±Ìôî ÏÉÅÌÉú Ïú†ÏßÄ: %s\n", 
                      driverName, functionName, enabled_ ? "ÌôúÏÑ±Ìôî" : "ÎπÑÌôúÏÑ±Ìôî");
        }
    }
    else if (function == P_OutputState) {
        // Ï∂úÎ†• ÏÉÅÌÉúÎäî ÏùΩÍ∏∞ Ï†ÑÏö©Ïù¥ÎØÄÎ°ú Ïì∞Í∏∞ Í±∞Î∂Ä
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: Ï∂úÎ†• ÏÉÅÌÉúÎäî ÏùΩÍ∏∞ Ï†ÑÏö© Îß§Í∞úÎ≥ÄÏàòÏûÖÎãàÎã§ (ÏãúÎèÑÎêú Í∞í: %d)\n",
                  driverName, functionName, value);
        return asynError;
    }
    else if (function == P_AlarmStatus) {
        // ÏïåÎûå ÏÉÅÌÉúÎèÑ ÏùΩÍ∏∞ Ï†ÑÏö©Ïù¥ÎØÄÎ°ú Ïì∞Í∏∞ Í±∞Î∂Ä
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: ÏïåÎûå ÏÉÅÌÉúÎäî ÏùΩÍ∏∞ Ï†ÑÏö© Îß§Í∞úÎ≥ÄÏàòÏûÖÎãàÎã§ (ÏãúÎèÑÎêú Í∞í: %d)\n",
                  driverName, functionName, value);
        return asynError;
    }
    else if (function == P_DeviceAddr) {
        // Ïû•Ïπò Ï£ºÏÜå Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (0-255 Î≤îÏúÑ)
        if (value < 0 || value > 255) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: Ïû•Ïπò Ï£ºÏÜåÍ∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %d (Î≤îÏúÑ: 0-255)\n",
                      driverName, functionName, value);
            return asynError;
        }
        
        // ÌôúÏÑ±Ìôî ÏÉÅÌÉúÏóêÏÑúÎäî Ïû•Ïπò Ï£ºÏÜå Î≥ÄÍ≤Ω Î∂àÍ∞Ä
        if (enabled_) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: ÌôúÏÑ±Ìôî ÏÉÅÌÉúÏóêÏÑúÎäî Ïû•Ïπò Ï£ºÏÜåÎ•º Î≥ÄÍ≤ΩÌï† Ïàò ÏóÜÏäµÎãàÎã§\n",
                      driverName, functionName);
            return asynError;
        }
        
        deviceAddr_ = value;
        status = setIntegerParam(function, value);
        asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
                  "%s::%s: Ïû•Ïπò Ï£ºÏÜå ÏÑ§Ï†ïÎê®: %d\n", driverName, functionName, value);
    }
    else {
        // Ïïå Ïàò ÏóÜÎäî Îß§Í∞úÎ≥ÄÏàòÏóê ÎåÄÌï¥ÏÑúÎäî Î∂ÄÎ™® ÌÅ¥ÎûòÏä§ Ìò∏Ï∂ú
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: Ïïå Ïàò ÏóÜÎäî Int32 Îß§Í∞úÎ≥ÄÏàò: function=%d, value=%d\n",
                  driverName, functionName, function, value);
        status = asynPortDriver::writeInt32(pasynUser, value);
    }
    
    // ÏÑ±Í≥µÌïú Í≤ΩÏö∞ÏóêÎßå Îß§Í∞úÎ≥ÄÏàò Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÏïåÎ¶º
    if (status == asynSuccess) {
        callParamCallbacks();
    } else {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: Îß§Í∞úÎ≥ÄÏàò ÏÑ§Ï†ï Ïã§Ìå® - function=%d, value=%d, status=%d\n",
                  driverName, functionName, function, value, status);
    }
    
    return status;
}

/** Int32 Îß§Í∞úÎ≥ÄÏàò ÏùΩÍ∏∞ Î©îÏÑúÎìú */
asynStatus ThresholdLogicController::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
    int function = pasynUser->reason;
    asynStatus status = asynSuccess;
    const char* functionName = "readInt32";
    
    // ÏûÖÎ†• Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (value == NULL) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®\n",
                  driverName, functionName);
        return asynError;
    }
    
    // Îß§Í∞úÎ≥ÄÏàòÎ≥Ñ ÏùΩÍ∏∞ Ï≤òÎ¶¨
    if (function == P_Enable) {
        *value = enabled_ ? 1 : 0;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ÌôúÏÑ±Ìôî ÏÉÅÌÉú ÏùΩÍ∏∞: %d (%s)\n", 
                  driverName, functionName, *value, enabled_ ? "ÌôúÏÑ±Ìôî" : "ÎπÑÌôúÏÑ±Ìôî");
    }
    else if (function == P_OutputState) {
        *value = outputState_ ? 1 : 0;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: Ï∂úÎ†• ÏÉÅÌÉú ÏùΩÍ∏∞: %d (%s)\n", 
                  driverName, functionName, *value, outputState_ ? "HIGH" : "LOW");
        
        // Ïä§Î†àÎìúÍ∞Ä Ïã§Ìñâ Ï§ëÏù¥ÏßÄ ÏïäÏùÄÎç∞ Ï∂úÎ†• ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ Í≤ΩÍ≥†
        if (!threadRunning_ && outputState_) {
            asynPrint(pasynUser, ASYN_TRACE_WARNING,
                      "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìúÍ∞Ä Ï§ëÏßÄÎêú ÏÉÅÌÉúÏóêÏÑú Ï∂úÎ†•Ïù¥ HIGHÏûÖÎãàÎã§\n",
                      driverName, functionName);
        }
    }
    else if (function == P_AlarmStatus) {
        *value = alarmStatus_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: ÏïåÎûå ÏÉÅÌÉú ÏùΩÍ∏∞: %d\n", driverName, functionName, *value);
        
        // ÏïåÎûå ÏÉÅÌÉúÏóê Îî∞Î•∏ Ï∂îÍ∞Ä Ï†ïÎ≥¥ Ï†úÍ≥µ
        const char* alarmDesc = "";
        switch (alarmStatus_) {
            case 0: alarmDesc = "Ï†ïÏÉÅ"; break;
            case 1: alarmDesc = "Í≤ΩÍ≥†"; break;
            case 2: alarmDesc = "Ï£ºÏöî Ïò§Î•ò"; break;
            case 3: alarmDesc = "ÏπòÎ™ÖÏ†Å Ïò§Î•ò"; break;
            default: alarmDesc = "Ïïå Ïàò ÏóÜÏùå"; break;
        }
        
        if (alarmStatus_ != 0) {
            asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                      "%s::%s: ÏïåÎûå ÏÉÅÌÉú ÏÉÅÏÑ∏: %s\n", 
                      driverName, functionName, alarmDesc);
        }
    }
    else if (function == P_DeviceAddr) {
        *value = deviceAddr_;
        asynPrint(pasynUser, ASYN_TRACEIO_DEVICE,
                  "%s::%s: Ïû•Ïπò Ï£ºÏÜå ÏùΩÍ∏∞: %d\n", driverName, functionName, *value);
    }
    else {
        // Ïïå Ïàò ÏóÜÎäî Îß§Í∞úÎ≥ÄÏàòÏóê ÎåÄÌï¥ÏÑúÎäî Î∂ÄÎ™® ÌÅ¥ÎûòÏä§ Ìò∏Ï∂ú
        asynPrint(pasynUser, ASYN_TRACE_WARNING,
                  "%s::%s: Ïïå Ïàò ÏóÜÎäî Int32 Îß§Í∞úÎ≥ÄÏàò: function=%d\n",
                  driverName, functionName, function);
        status = asynPortDriver::readInt32(pasynUser, value);
        
        if (status != asynSuccess) {
            asynPrint(pasynUser, ASYN_TRACE_ERROR,
                      "%s::%s: Î∂ÄÎ™® ÌÅ¥ÎûòÏä§ÏóêÏÑú Îß§Í∞úÎ≥ÄÏàò ÏùΩÍ∏∞ Ïã§Ìå®: function=%d\n",
                      driverName, functionName, function);
        }
    }
    
    // Ïò§Î•ò Î∞úÏÉù Ïãú Î°úÍπÖ
    if (status != asynSuccess) {
        asynPrint(pasynUser, ASYN_TRACE_ERROR,
                  "%s::%s: Îß§Í∞úÎ≥ÄÏàò ÏùΩÍ∏∞ Ïã§Ìå® - function=%d, status=%d\n",
                  driverName, functionName, function, status);
    }
    
    return status;
}

/** ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ï≤òÎ¶¨ Î©îÏÑúÎìú 
 * 
 * Ïù¥ Î©îÏÑúÎìúÎäî Îã§Ïùå Í∏∞Îä•Îì§ÏùÑ ÏàòÌñâÌï©ÎãàÎã§:
 * 1. Ïû•ÏπòÏóêÏÑú ÌòÑÏû¨ Í∞íÏùÑ ÏùΩÏñ¥Ïò¥
 * 2. ÏûÑÍ≥ÑÍ∞íÍ≥º ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Î•º Í≥†Î†§Ìïú ÎπÑÍµê Î°úÏßÅ ÏàòÌñâ
 * 3. Ï∂úÎ†• ÏÉÅÌÉú Î≥ÄÌôî Í∞êÏßÄ Î∞è Ï†úÏñ¥
 * 4. ÏïåÎûå ÏÉÅÌÉú ÏÑ§Ï†ï Î∞è ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ ÏóÖÎç∞Ïù¥Ìä∏
 */
void ThresholdLogicController::processThresholdLogic()
{
    const char* functionName = "processThresholdLogic";
    asynStatus status = asynSuccess;
    
    // ÌôúÏÑ±ÌôîÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
    if (!enabled_) {
        return;
    }
    
    // 1. Ïû•ÏπòÏóêÏÑú ÌòÑÏû¨ Í∞íÏùÑ ÏùΩÏñ¥Ïò¥
    status = readCurrentValueFromDevice();
    if (status != asynSuccess) {
        ErrorHandler::handleCommunicationError(functionName, devicePortName_, deviceAddr_, 
                                              "ÌòÑÏû¨Í∞í ÏùΩÍ∏∞", pasynUserSelf);
        alarmStatus_ = 2; // MAJOR ÏïåÎûå
        ErrorHandler::setAlarmStatus(pasynUserSelf, ErrorHandler::COMM_ALARM, 
                                   ErrorHandler::MAJOR_ALARM);
        updateAlarmStatus();
        return;
    }
    
    // 2. ÏûÑÍ≥ÑÍ∞í ÎπÑÍµê Î∞è ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Î°úÏßÅ Íµ¨ÌòÑ
    bool newOutputState = outputState_; // ÌòÑÏû¨ Ï∂úÎ†• ÏÉÅÌÉúÎ°ú Ï¥àÍ∏∞Ìôî
    
    if (!outputState_) {
        // ÌòÑÏû¨ Ï∂úÎ†•Ïù¥ LOWÏù∏ Í≤ΩÏö∞: ÏûÑÍ≥ÑÍ∞íÏùÑ Ï¥àÍ≥ºÌïòÎ©¥ HIGHÎ°ú Î≥ÄÍ≤Ω
        if (currentValue_ > thresholdValue_) {
            newOutputState = true;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: ÏûÑÍ≥ÑÍ∞í Ï¥àÍ≥º Í∞êÏßÄ - ÌòÑÏû¨Í∞í: %f, ÏûÑÍ≥ÑÍ∞í: %f\n",
                      driverName, functionName, currentValue_, thresholdValue_);
        }
    } else {
        // ÌòÑÏû¨ Ï∂úÎ†•Ïù¥ HIGHÏù∏ Í≤ΩÏö∞: ÏûÑÍ≥ÑÍ∞í-ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ ÏïÑÎûòÎ°ú Îñ®Ïñ¥ÏßÄÎ©¥ LOWÎ°ú Î≥ÄÍ≤Ω
        double lowerThreshold = thresholdValue_ - hysteresis_;
        if (currentValue_ < lowerThreshold) {
            newOutputState = false;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ ÏûÑÍ≥ÑÍ∞í ÎØ∏Îßå Í∞êÏßÄ - ÌòÑÏû¨Í∞í: %f, ÌïòÌïúÏûÑÍ≥ÑÍ∞í: %f\n",
                      driverName, functionName, currentValue_, lowerThreshold);
        }
    }
    
    // 3. ÏÉÅÌÉú Î≥ÄÌôî Í∞êÏßÄ Î∞è Ï∂úÎ†• Ï†úÏñ¥
    if (newOutputState != outputState_) {
        // ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞
        lastOutputState_ = outputState_; // Ïù¥Ï†Ñ ÏÉÅÌÉú Ï†ÄÏû•
        outputState_ = newOutputState;   // ÏÉàÎ°úÏö¥ ÏÉÅÌÉú ÏÑ§Ï†ï
        
        // Ïû•ÏπòÏóê ÏÉàÎ°úÏö¥ Ï∂úÎ†• ÏÉÅÌÉú ÏÑ§Ï†ï
        status = writeOutputStateToDevice(outputState_);
        if (status != asynSuccess) {
            ErrorHandler::handleCommunicationError(functionName, devicePortName_, deviceAddr_, 
                                                  "Ï∂úÎ†•ÏÉÅÌÉú ÏÑ§Ï†ï", pasynUserSelf);
            alarmStatus_ = 2; // MAJOR ÏïåÎûå
            ErrorHandler::setAlarmStatus(pasynUserSelf, ErrorHandler::WRITE_ALARM, 
                                       ErrorHandler::MAJOR_ALARM);
        } else {
            // ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂úÎ†• ÏÉÅÌÉúÍ∞Ä Î≥ÄÍ≤ΩÎê®
            alarmStatus_ = 0; // ÏïåÎûå Ìï¥Ï†ú
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: Ï∂úÎ†• ÏÉÅÌÉú Î≥ÄÍ≤ΩÎê®: %s -> %s\n",
                      driverName, functionName, 
                      lastOutputState_ ? "HIGH" : "LOW",
                      outputState_ ? "HIGH" : "LOW");
        }
        
        // Ï∂úÎ†• ÏÉÅÌÉú Îß§Í∞úÎ≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏
        setIntegerParam(P_OutputState, outputState_ ? 1 : 0);
    } else {
        // ÏÉÅÌÉú Î≥ÄÌôîÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞ - Ï†ïÏÉÅ ÎèôÏûë
        if (alarmStatus_ == 0) {
            // Ïù¥ÎØ∏ ÏïåÎûåÏù¥ ÏóÜÎäî ÏÉÅÌÉúÎùºÎ©¥ Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
        } else {
            // Ïù¥Ï†ÑÏóê ÏïåÎûåÏù¥ ÏûàÏóàÎã§Î©¥ Ìï¥Ï†ú
            alarmStatus_ = 0;
            asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                      "%s::%s: Ï†ïÏÉÅ ÎèôÏûë - ÏïåÎûå Ìï¥Ï†ú\n",
                      driverName, functionName);
        }
    }
    
    // 4. Îß§Í∞úÎ≥ÄÏàò ÏóÖÎç∞Ïù¥Ìä∏ Î∞è ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ Í∞±Ïã†
    setDoubleParam(P_CurrentValue, currentValue_);
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    
    // ÌÉÄÏûÑÏä§ÌÉ¨ÌîÑ ÏóÖÎç∞Ïù¥Ìä∏
    epicsTimeGetCurrent(&lastUpdate_);
    
    // 5. ÏïåÎûå ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Î∞è ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏïåÎ¶º
    updateAlarmStatus();
    callParamCallbacks();
    
    // ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ Ï∂úÎ†• (TRACE_FLOW Î†àÎ≤®)
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: Ï≤òÎ¶¨ ÏôÑÎ£å - ÌòÑÏû¨Í∞í: %f, ÏûÑÍ≥ÑÍ∞í: %f, Ï∂úÎ†•: %s, ÏïåÎûå: %d\n",
              driverName, functionName, currentValue_, thresholdValue_,
              outputState_ ? "HIGH" : "LOW", alarmStatus_);
}

/** Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë Î©îÏÑúÎìú */
void ThresholdLogicController::startMonitoring()
{
    const char* functionName = "startMonitoring";
    
    // Ïù¥ÎØ∏ Ïä§Î†àÎìúÍ∞Ä Ïã§Ìñâ Ï§ëÏù∏ Í≤ΩÏö∞ Ï§ëÎ≥µ ÏãúÏûë Î∞©ÏßÄ
    if (threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìúÍ∞Ä Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏûÖÎãàÎã§\n",
                  driverName, functionName);
        return;
    }
    
    // Ïä§Î†àÎìú Ï¢ÖÎ£å ÌîåÎûòÍ∑∏ Ï¥àÍ∏∞Ìôî
    threadExit_ = false;
    
    // ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (0.1Hz ~ 1000Hz Î≤îÏúÑ)
    if (updateRate_ < 0.1 || updateRate_ > 1000.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞Í∞Ä Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ® (%f Hz), Í∏∞Î≥∏Í∞í 10HzÎ°ú ÏÑ§Ï†ï\n",
                  driverName, functionName, updateRate_);
        updateRate_ = 10.0;
        setDoubleParam(P_UpdateRate, updateRate_);
    }
    
    // Ïä§Î†àÎìú Ïù¥Î¶Ñ ÏÉùÏÑ±
    char threadName[64];
    snprintf(threadName, sizeof(threadName), "ThresholdMonitor_%s", portName);
    
    // epicsThread ÏÉùÏÑ± Î∞è ÏãúÏûë
    try {
        monitorThread_ = new epicsThread(
            *this,                      // epicsThreadRunable Í∞ùÏ≤¥ (this)
            threadName,                 // Ïä§Î†àÎìú Ïù¥Î¶Ñ
            epicsThreadGetStackSize(epicsThreadStackMedium), // Ïä§ÌÉù ÌÅ¨Í∏∞
            epicsThreadPriorityMedium   // Ï§ëÍ∞Ñ Ïö∞ÏÑ†ÏàúÏúÑ
        );
        
        if (monitorThread_ == NULL) {
            ErrorHandler::handleThreadError(functionName, threadName, 
                                           "Ïä§Î†àÎìú Í∞ùÏ≤¥ ÏÉùÏÑ± Ïã§Ìå®", pasynUserSelf);
            return;
        }
        
        // Ïä§Î†àÎìú ÏãúÏûë
        monitorThread_->start();
        threadRunning_ = true;
        
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú ÏãúÏûëÎê® - ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞: %f Hz\n",
                  driverName, functionName, updateRate_);
        
    } catch (std::exception& e) {
        ErrorHandler::handleThreadError(functionName, threadName, e.what(), pasynUserSelf);
        
        // Ïã§Ìå® Ïãú Ï†ïÎ¶¨
        if (monitorThread_) {
            delete monitorThread_;
            monitorThread_ = NULL;
        }
        threadRunning_ = false;
    }
}

/** Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ Î©îÏÑúÎìú */
void ThresholdLogicController::stopMonitoring()
{
    const char* functionName = "stopMonitoring";
    
    // Ïä§Î†àÎìúÍ∞Ä Ïã§Ìñâ Ï§ëÏù¥ÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
    if (!threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìúÍ∞Ä Ïã§Ìñâ Ï§ëÏù¥ÏßÄ ÏïäÏäµÎãàÎã§\n",
                  driverName, functionName);
        return;
    }
    
    // Ïä§Î†àÎìú Ï¢ÖÎ£å Ïã†Ìò∏ ÏÑ§Ï†ï
    threadExit_ = true;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú Ï¢ÖÎ£å Ïã†Ìò∏ Ï†ÑÏÜ°\n",
              driverName, functionName);
    
    // Ïä§Î†àÎìúÍ∞Ä Ï¢ÖÎ£åÎê† ÎïåÍπåÏßÄ ÎåÄÍ∏∞ (ÏµúÎåÄ 5Ï¥à)
    if (monitorThread_) {
        int waitCount = 0;
        const int maxWaitCount = 50; // 5Ï¥à (100ms * 50)
        
        while (threadRunning_ && waitCount < maxWaitCount) {
            epicsThreadSleep(0.1); // 100ms ÎåÄÍ∏∞
            waitCount++;
        }
        
        if (threadRunning_) {
            // Ïä§Î†àÎìúÍ∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ï¢ÖÎ£åÎêòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞ Í∞ïÏ†ú Ï¢ÖÎ£å
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: Ïä§Î†àÎìúÍ∞Ä Ï†ïÏÉÅ Ï¢ÖÎ£åÎêòÏßÄ ÏïäÏïÑ Í∞ïÏ†ú Ï¢ÖÎ£åÌï©ÎãàÎã§\n",
                      driverName, functionName);
        } else {
            asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                      "%s::%s: Ïä§Î†àÎìúÍ∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§\n",
                      driverName, functionName);
        }
        
        // Ïä§Î†àÎìú Í∞ùÏ≤¥ ÏÇ≠Ï†ú
        try {
            delete monitorThread_;
            monitorThread_ = NULL;
        } catch (std::exception& e) {
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: Ïä§Î†àÎìú ÏÇ≠Ï†ú Ï§ë ÏòàÏô∏ Î∞úÏÉù: %s\n",
                      driverName, functionName, e.what());
        }
    }
    
    // ÏÉÅÌÉú Î≥ÄÏàò Ï¥àÍ∏∞Ìôî
    threadRunning_ = false;
    threadExit_ = false;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ ÏôÑÎ£å\n",
              driverName, functionName);
}

/** epicsThreadRunable Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Íµ¨ÌòÑ - Ï£ºÍ∏∞Ï†Å Îç∞Ïù¥ÌÑ∞ ÏàòÏßë Î∞è ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ï≤òÎ¶¨ */
void ThresholdLogicController::run()
{
    const char* functionName = "run";
    
    // Ïä§Î†àÎìú ÏãúÏûë Î°úÍ∑∏
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú ÏãúÏûë - PID: %lu\n",
              driverName, functionName, (unsigned long)epicsThreadGetIdSelf());
    
    // ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Í≥ÑÏÇ∞ (HzÎ•º Ï¥à Îã®ÏúÑÎ°ú Î≥ÄÌôò)
    double sleepTime = 1.0 / updateRate_;
    
    // ÏÑ±Îä• Î™®ÎãàÌÑ∞ÎßÅ Î≥ÄÏàò
    int cycleCount = 0;
    epicsTimeStamp startTime, currentTime;
    epicsTimeGetCurrent(&startTime);
    
    // Î©îÏù∏ Î™®ÎãàÌÑ∞ÎßÅ Î£®ÌîÑ
    while (!threadExit_) {
        try {
            // Î£®ÌîÑ ÏãúÏûë ÏãúÍ∞Ñ Í∏∞Î°ù
            epicsTimeStamp loopStart;
            epicsTimeGetCurrent(&loopStart);
            
            // Ïª®Ìä∏Î°§Îü¨Í∞Ä ÌôúÏÑ±ÌôîÎêú Í≤ΩÏö∞ÏóêÎßå ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ï≤òÎ¶¨
            if (enabled_) {
                // ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ï≤òÎ¶¨ (Î©îÏù∏ Í∏∞Îä•)
                processThresholdLogic();
                
                // Ï≤òÎ¶¨ ÏôÑÎ£å ÌõÑ Îß§Í∞úÎ≥ÄÏàò ÏΩúÎ∞± Ìò∏Ï∂ú (ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏)
                callParamCallbacks();
            } else {
                // ÎπÑÌôúÏÑ±Ìôî ÏÉÅÌÉúÏóêÏÑúÎäî ÌòÑÏû¨ Í∞íÎßå ÏóÖÎç∞Ïù¥Ìä∏ (Î™®ÎãàÌÑ∞ÎßÅ Ïú†ÏßÄ)
                asynStatus status = readCurrentValueFromDevice();
                if (status == asynSuccess) {
                    setDoubleParam(P_CurrentValue, currentValue_);
                    callParamCallbacks();
                }
            }
            
            // Ï£ºÍ∏∞Ï†Å ÏÑ±Îä• Î¶¨Ìè¨Ìä∏ (1000 ÏÇ¨Ïù¥ÌÅ¥ÎßàÎã§)
            cycleCount++;
            if (cycleCount % 1000 == 0) {
                epicsTimeGetCurrent(&currentTime);
                double elapsedTime = epicsTimeDiffInSeconds(&currentTime, &startTime);
                double actualRate = cycleCount / elapsedTime;
                
                asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                          "%s::%s: ÏÑ±Îä• Î¶¨Ìè¨Ìä∏ - ÏÇ¨Ïù¥ÌÅ¥: %d, Ïã§Ï†ú Ï£ºÍ∏∞: %.2f Hz, Î™©Ìëú Ï£ºÍ∏∞: %.2f Hz\n",
                          driverName, functionName, cycleCount, actualRate, updateRate_);
                
                // Ïπ¥Ïö¥ÌÑ∞ Î∞è ÏãúÍ∞Ñ Î¶¨ÏÖã
                cycleCount = 0;
                startTime = currentTime;
            }
            
            // Î£®ÌîÑ Ï≤òÎ¶¨ ÏãúÍ∞Ñ Í≥ÑÏÇ∞
            epicsTimeStamp loopEnd;
            epicsTimeGetCurrent(&loopEnd);
            double processingTime = epicsTimeDiffInSeconds(&loopEnd, &loopStart);
            
            // Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞Î≥¥Îã§ Í∏¥ Í≤ΩÏö∞ Í≤ΩÍ≥†
            if (processingTime > sleepTime) {
                asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                          "%s::%s: Ï≤òÎ¶¨ ÏãúÍ∞Ñ Ï¥àÍ≥º - Ï≤òÎ¶¨ÏãúÍ∞Ñ: %.3fÏ¥à, Î™©ÌëúÏ£ºÍ∏∞: %.3fÏ¥à\n",
                          driverName, functionName, processingTime, sleepTime);
            }
            
            // ÎÇ®ÏùÄ ÏãúÍ∞ÑÎßåÌÅº ÎåÄÍ∏∞ (Ï†ïÌôïÌïú Ï£ºÍ∏∞ Ïú†ÏßÄ)
            double remainingSleepTime = sleepTime - processingTime;
            if (remainingSleepTime > 0.001) { // ÏµúÏÜå 1ms ÎåÄÍ∏∞
                epicsThreadSleep(remainingSleepTime);
            } else {
                // Ï≤òÎ¶¨ ÏãúÍ∞ÑÏù¥ ÎÑàÎ¨¥ Í∏∏Ïñ¥ÏÑú ÎåÄÍ∏∞Ìï† ÏãúÍ∞ÑÏù¥ ÏóÜÎäî Í≤ΩÏö∞ ÏµúÏÜå ÎåÄÍ∏∞
                epicsThreadSleep(0.001); // 1ms ÏµúÏÜå ÎåÄÍ∏∞
            }
            
        } catch (std::exception& e) {
            // ÏòàÏô∏ Î∞úÏÉù Ïãú Î°úÍ∑∏ Ï∂úÎ†• Î∞è Í≥ÑÏÜç Ïã§Ìñâ
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: Ïä§Î†àÎìú Î£®ÌîÑ Ï§ë ÏòàÏô∏ Î∞úÏÉù: %s\n",
                      driverName, functionName, e.what());
            
            // ÏòàÏô∏ Î∞úÏÉù Ïãú Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ Í≥ÑÏÜç
            epicsThreadSleep(1.0);
        } catch (...) {
            // Ïïå Ïàò ÏóÜÎäî ÏòàÏô∏ Ï≤òÎ¶¨
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: Ïïå Ïàò ÏóÜÎäî ÏòàÏô∏ Î∞úÏÉù\n",
                      driverName, functionName);
            
            // ÏòàÏô∏ Î∞úÏÉù Ïãú Ïû†Ïãú ÎåÄÍ∏∞ ÌõÑ Í≥ÑÏÜç
            epicsThreadSleep(1.0);
        }
        
        // ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞Í∞Ä Î≥ÄÍ≤ΩÎêú Í≤ΩÏö∞ ÏÉàÎ°úÏö¥ Ï£ºÍ∏∞Î°ú ÏóÖÎç∞Ïù¥Ìä∏
        double newSleepTime = 1.0 / updateRate_;
        if (fabs(newSleepTime - sleepTime) > 0.001) { // 1ms Ïù¥ÏÉÅ Ï∞®Ïù¥ÎÇòÎäî Í≤ΩÏö∞
            sleepTime = newSleepTime;
            asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                      "%s::%s: ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Î≥ÄÍ≤ΩÎê®: %.2f Hz (%.3fÏ¥à Í∞ÑÍ≤©)\n",
                      driverName, functionName, updateRate_, sleepTime);
        }
    }
    
    // Ïä§Î†àÎìú Ï¢ÖÎ£å Ï≤òÎ¶¨
    threadRunning_ = false;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú Ï¢ÖÎ£å - Ï¥ù ÏÇ¨Ïù¥ÌÅ¥: %d\n",
              driverName, functionName, cycleCount);
}

/** Ï†ïÏ†Å Ïä§Î†àÎìú Ìï®Ïàò - Ìò∏ÌôòÏÑ±ÏùÑ ÏúÑÌï¥ Ïú†ÏßÄ (ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå) */
void ThresholdLogicController::monitorThreadFunc(void* param)
{
    const char* functionName = "monitorThreadFunc";
    
    // Ïù¥ Ìï®ÏàòÎäî Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏùå (run() Î©îÏÑúÎìúÎ°ú ÎåÄÏ≤¥Îê®)
    printf("%s::%s: Í≤ΩÍ≥† - Ïù¥ Ìï®ÏàòÎäî Îçî Ïù¥ÏÉÅ ÏÇ¨Ïö©ÎêòÏßÄ ÏïäÏäµÎãàÎã§. run() Î©îÏÑúÎìúÎ•º ÏÇ¨Ïö©ÌïòÏÑ∏Ïöî.\n", 
           driverName, functionName);
}

/** Ïû•ÏπòÏóêÏÑú ÌòÑÏû¨ Í∞íÏùÑ ÏùΩÏñ¥Ïò§Îäî Î©îÏÑúÎìú 
 * 
 * Ïù¥ Î©îÏÑúÎìúÎäî Ïó∞Í≤∞Îêú Ïû•Ïπò Ìè¨Ìä∏Î•º ÌÜµÌï¥ ÏïÑÎÇ†Î°úÍ∑∏ ÏûÖÎ†• Í∞íÏùÑ ÏùΩÏñ¥ÏòµÎãàÎã§.
 * Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî asyn ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º ÌÜµÌï¥ Ïû•ÏπòÏôÄ ÌÜµÏã†Ìï©ÎãàÎã§.
 */
asynStatus ThresholdLogicController::readCurrentValueFromDevice()
{
    const char* functionName = "readCurrentValueFromDevice";
    asynStatus status = asynSuccess;
    asynUser *pasynUser = NULL;
    
    // asyn ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ± (Ïû•Ïπò Ìè¨Ìä∏Ïóê Ïó∞Í≤∞)
    status = pasynOctetSyncIO->connect(devicePortName_, deviceAddr_, &pasynUser, NULL);
    if (status != asynSuccess) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Ïû•Ïπò Ìè¨Ìä∏ %sÏóê Ïó∞Í≤∞ Ïã§Ìå®\n",
                  driverName, functionName, devicePortName_);
        return status;
    }
    
    try {
        // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Ïó¨Í∏∞ÏÑú Ïû•ÏπòÎ≥Ñ ÌîÑÎ°úÌÜ†ÏΩúÏóê Îî∞Îùº Í∞íÏùÑ ÏùΩÏñ¥Ïò¥
        // ÌòÑÏû¨Îäî ÏãúÎÆ¨Î†àÏù¥ÏÖòÏùÑ ÏúÑÌï¥ Í∞ÑÎã®Ìïú Í∞íÏùÑ ÏÉùÏÑ±
        // Ïã§Ï†ú ÌôòÍ≤ΩÏóêÏÑúÎäî measComp ÎìúÎùºÏù¥Î≤ÑÎ•º ÌÜµÌï¥ USB1608G-2AOÏóêÏÑú Í∞íÏùÑ ÏùΩÏñ¥Ïò¥
        
        // ÏãúÎÆ¨Î†àÏù¥ÏÖò: ÏãúÍ∞ÑÏóê Îî∞Îùº Î≥ÄÌôîÌïòÎäî ÏÇ¨Ïù∏Ìåå Í∞í ÏÉùÏÑ± (ÌÖåÏä§Ìä∏Ïö©)
        epicsTimeStamp now;
        epicsTimeGetCurrent(&now);
        double timeSeconds = now.secPastEpoch + now.nsec / 1e9;
        
        // 0.0 ~ 10.0V Î≤îÏúÑÏùò ÏÇ¨Ïù∏Ìåå + ÎÖ∏Ïù¥Ï¶à
        currentValue_ = 5.0 + 4.0 * sin(timeSeconds * 0.1) + 0.1 * (rand() / (double)RAND_MAX - 0.5);
        
        // Í∞íÏùò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
        if (currentValue_ < -10.0 || currentValue_ > 10.0) {
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: ÏùΩÏñ¥Ïò® Í∞íÏù¥ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %f\n",
                      driverName, functionName, currentValue_);
            currentValue_ = fmax(-10.0, fmin(10.0, currentValue_)); // Î≤îÏúÑ Ï†úÌïú
        }
        
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DEVICE,
                  "%s::%s: Ïû•ÏπòÏóêÏÑú Í∞í ÏùΩÍ∏∞ ÏÑ±Í≥µ: %f V\n",
                  driverName, functionName, currentValue_);
        
    } catch (...) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Ïû•Ïπò ÏùΩÍ∏∞ Ï§ë ÏòàÏô∏ Î∞úÏÉù\n",
                  driverName, functionName);
        status = asynError;
    }
    
    // asyn ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú
    if (pasynUser) {
        pasynOctetSyncIO->disconnect(pasynUser);
    }
    
    return status;
}

/** Ïû•ÏπòÏóê Ï∂úÎ†• ÏÉÅÌÉúÎ•º ÏÑ§Ï†ïÌïòÎäî Î©îÏÑúÎìú 
 * 
 * Ïù¥ Î©îÏÑúÎìúÎäî Ïó∞Í≤∞Îêú Ïû•Ïπò Ìè¨Ìä∏Î•º ÌÜµÌï¥ ÎîîÏßÄÌÑ∏ Ï∂úÎ†• ÏÉÅÌÉúÎ•º ÏÑ§Ï†ïÌï©ÎãàÎã§.
 * Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî asyn ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Î•º ÌÜµÌï¥ Ïû•ÏπòÏôÄ ÌÜµÏã†Ìï©ÎãàÎã§.
 */
asynStatus ThresholdLogicController::writeOutputStateToDevice(bool state)
{
    const char* functionName = "writeOutputStateToDevice";
    asynStatus status = asynSuccess;
    asynUser *pasynUser = NULL;
    
    // asyn ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÉùÏÑ± (Ïû•Ïπò Ìè¨Ìä∏Ïóê Ïó∞Í≤∞)
    status = pasynOctetSyncIO->connect(devicePortName_, deviceAddr_, &pasynUser, NULL);
    if (status != asynSuccess) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Ïû•Ïπò Ìè¨Ìä∏ %sÏóê Ïó∞Í≤∞ Ïã§Ìå®\n",
                  driverName, functionName, devicePortName_);
        return status;
    }
    
    try {
        // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Ïó¨Í∏∞ÏÑú Ïû•ÏπòÎ≥Ñ ÌîÑÎ°úÌÜ†ÏΩúÏóê Îî∞Îùº Ï∂úÎ†•ÏùÑ ÏÑ§Ï†ï
        // ÌòÑÏû¨Îäî ÏãúÎÆ¨Î†àÏù¥ÏÖòÏùÑ ÏúÑÌï¥ Î°úÍ∑∏Îßå Ï∂úÎ†•
        // Ïã§Ï†ú ÌôòÍ≤ΩÏóêÏÑúÎäî measComp ÎìúÎùºÏù¥Î≤ÑÎ•º ÌÜµÌï¥ USB1608G-2AOÏùò ÎîîÏßÄÌÑ∏ Ï∂úÎ†•ÏùÑ Ï†úÏñ¥
        
        // ÏãúÎÆ¨Î†àÏù¥ÏÖò: Ï∂úÎ†• ÏÉÅÌÉú ÏÑ§Ï†ï Î™ÖÎ†π Ï†ÑÏÜ° (ÌÖåÏä§Ìä∏Ïö©)
        const char* stateStr = state ? "HIGH" : "LOW";
        int digitalValue = state ? 1 : 0;
        
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DEVICE,
                  "%s::%s: Ïû•ÏπòÏóê ÎîîÏßÄÌÑ∏ Ï∂úÎ†• ÏÑ§Ï†ï - ÏÉÅÌÉú: %s (Í∞í: %d)\n",
                  driverName, functionName, stateStr, digitalValue);
        
        // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Ïó¨Í∏∞ÏÑú Îã§ÏùåÍ≥º Í∞ôÏùÄ ÏûëÏóÖÏùÑ ÏàòÌñâ:
        // 1. Ïû•ÏπòÏùò ÎîîÏßÄÌÑ∏ Ï∂úÎ†• Î†àÏßÄÏä§ÌÑ∞Ïóê Í∞í Ïì∞Í∏∞
        // 2. Î™ÖÎ†π Ï†ÑÏÜ° Î∞è ÏùëÎãµ ÌôïÏù∏
        // 3. Ïò§Î•ò ÏÉÅÌÉú Í≤ÄÏÇ¨
        
        // ÏãúÎÆ¨Î†àÏù¥ÏÖò: ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÑ§Ï†ïÎêòÏóàÎã§Í≥† Í∞ÄÏ†ï
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
                  "%s::%s: Ï∂úÎ†• ÏÉÅÌÉú ÏÑ§Ï†ï ÏôÑÎ£å: %s\n",
                  driverName, functionName, stateStr);
        
    } catch (...) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Ïû•Ïπò Ïì∞Í∏∞ Ï§ë ÏòàÏô∏ Î∞úÏÉù\n",
                  driverName, functionName);
        status = asynError;
    }
    
    // asyn ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ïó∞Í≤∞ Ìï¥Ï†ú
    if (pasynUser) {
        pasynOctetSyncIO->disconnect(pasynUser);
    }
    
    return status;
}

/** ÏïåÎûå ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Î©îÏÑúÎìú 
 * 
 * Ïù¥ Î©îÏÑúÎìúÎäî ÌòÑÏû¨ ÏïåÎûå ÏÉÅÌÉúÏóê Îî∞Îùº EPICS ÏïåÎûå ÏãúÏä§ÌÖúÏùÑ ÏóÖÎç∞Ïù¥Ìä∏Ìï©ÎãàÎã§.
 * ÏïåÎûå Ïã¨Í∞ÅÎèÑÏôÄ ÏÉÅÌÉúÎ•º ÏÑ§Ï†ïÌïòÏó¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Ïóê ÏïåÎ¶ºÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
 */
void ThresholdLogicController::updateAlarmStatus()
{
    const char* functionName = "updateAlarmStatus";
    int alarmSeverity = 0;  // NO_ALARM
    int alarmStatus = 0;    // NO_ALARM
    
    // ÏïåÎûå ÏÉÅÌÉúÏóê Îî∞Î•∏ Ïã¨Í∞ÅÎèÑ Î∞è ÏÉÅÌÉú ÏÑ§Ï†ï
    switch (alarmStatus_) {
        case 0:  // Ï†ïÏÉÅ ÏÉÅÌÉú
            alarmSeverity = 0;  // NO_ALARM
            alarmStatus = 0;    // NO_ALARM
            break;
            
        case 1:  // Í≤ΩÍ≥† ÏÉÅÌÉú (MINOR)
            alarmSeverity = 1;  // MINOR_ALARM
            alarmStatus = 3;    // STATE_ALARM
            asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                      "%s::%s: MINOR ÏïåÎûå ÏÑ§Ï†ï - Í≤ΩÍ≥† ÏÉÅÌÉú\n",
                      driverName, functionName);
            break;
            
        case 2:  // Ï£ºÏöî Ïò§Î•ò ÏÉÅÌÉú (MAJOR)
            alarmSeverity = 2;  // MAJOR_ALARM
            alarmStatus = 4;    // COMM_ALARM (ÌÜµÏã† Ïò§Î•ò)
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: MAJOR ÏïåÎûå ÏÑ§Ï†ï - ÌÜµÏã† Ïò§Î•ò\n",
                      driverName, functionName);
            break;
            
        case 3:  // ÏπòÎ™ÖÏ†Å Ïò§Î•ò ÏÉÅÌÉú (INVALID)
            alarmSeverity = 3;  // INVALID_ALARM
            alarmStatus = 17;   // UDF_ALARM (Ï†ïÏùòÎêòÏßÄ ÏïäÏùÄ Í∞í)
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: INVALID ÏïåÎûå ÏÑ§Ï†ï - ÏπòÎ™ÖÏ†Å Ïò§Î•ò\n",
                      driverName, functionName);
            break;
            
        default:
            // Ïïå Ïàò ÏóÜÎäî ÏïåÎûå ÏÉÅÌÉú
            alarmSeverity = 2;  // MAJOR_ALARM
            alarmStatus = 17;   // UDF_ALARM
            asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                      "%s::%s: Ïïå Ïàò ÏóÜÎäî ÏïåÎûå ÏÉÅÌÉú: %d\n",
                      driverName, functionName, alarmStatus_);
            break;
    }
    
    // Ï£ºÏöî Îß§Í∞úÎ≥ÄÏàòÎì§Ïóê ÏïåÎûå ÏÉÅÌÉú ÏÑ§Ï†ï
    // ÌòÑÏû¨ Í∞í Îß§Í∞úÎ≥ÄÏàòÏóê ÏïåÎûå ÏÑ§Ï†ï
    setParamAlarmStatus(P_CurrentValue, alarmStatus);
    setParamAlarmSeverity(P_CurrentValue, alarmSeverity);
    
    // Ï∂úÎ†• ÏÉÅÌÉú Îß§Í∞úÎ≥ÄÏàòÏóê ÏïåÎûå ÏÑ§Ï†ï
    setParamAlarmStatus(P_OutputState, alarmStatus);
    setParamAlarmSeverity(P_OutputState, alarmSeverity);
    
    // ÏïåÎûå ÏÉÅÌÉú Îß§Í∞úÎ≥ÄÏàò ÏûêÏ≤¥ ÏóÖÎç∞Ïù¥Ìä∏
    setIntegerParam(P_AlarmStatus, alarmStatus_);
    setParamAlarmStatus(P_AlarmStatus, alarmStatus);
    setParamAlarmSeverity(P_AlarmStatus, alarmSeverity);
    
    // ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥ Ï∂úÎ†•
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: ÏïåÎûå ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å - ÏÉÅÌÉú: %d, Ïã¨Í∞ÅÎèÑ: %d, EPICSÏÉÅÌÉú: %d\n",
              driverName, functionName, alarmStatus_, alarmSeverity, alarmStatus);
}

/** Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Î©îÏÑúÎìú */
bool ThresholdLogicController::validateParameters()
{
    const char* functionName = "validateParameters";
    bool isValid = true;
    
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
              "%s::%s: Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ ÏãúÏûë\n",
              driverName, functionName);
    
    // 1. ÏûÑÍ≥ÑÍ∞í Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (thresholdValue_ < -10.0 || thresholdValue_ > 10.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ÏûÑÍ≥ÑÍ∞íÏù¥ Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %f (Î≤îÏúÑ: -10.0 ~ +10.0 V)\n",
                  driverName, functionName, thresholdValue_);
        isValid = false;
    }
    
    // 2. ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (hysteresis_ < 0.0 || hysteresis_ > 5.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Í∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %f (Î≤îÏúÑ: 0.0 ~ 5.0 V)\n",
                  driverName, functionName, hysteresis_);
        isValid = false;
    }
    
    // 3. ÏûÑÍ≥ÑÍ∞íÍ≥º ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í¥ÄÍ≥Ñ Í≤ÄÏÇ¨
    if (hysteresis_ > fabs(thresholdValue_)) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§Í∞Ä ÏûÑÍ≥ÑÍ∞íÏùò Ï†àÎåìÍ∞íÎ≥¥Îã§ ÌÅº - ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§: %f, ÏûÑÍ≥ÑÍ∞í: %f\n",
                  driverName, functionName, hysteresis_, thresholdValue_);
        // Í≤ΩÍ≥†Ïù¥ÏßÄÎßå ÎèôÏûëÏùÄ Í∞ÄÎä•ÌïòÎØÄÎ°ú isValidÎäî falseÎ°ú ÏÑ§Ï†ïÌïòÏßÄ ÏïäÏùå
    }
    
    // 4. ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (updateRate_ < 0.1 || updateRate_ > 1000.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞Í∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %f (Î≤îÏúÑ: 0.1 ~ 1000.0 Hz)\n",
                  driverName, functionName, updateRate_);
        isValid = false;
    }
    
    // 5. Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ Í≤ÄÏÇ¨
    if (strlen(devicePortName_) == 0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶ÑÏù¥ ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå\n",
                  driverName, functionName);
        isValid = false;
    } else if (strlen(devicePortName_) >= sizeof(devicePortName_)) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶ÑÏù¥ ÎÑàÎ¨¥ ÍπÄ: %s\n",
                  driverName, functionName, devicePortName_);
        isValid = false;
    }
    
    // 6. Ïû•Ïπò Ï£ºÏÜå Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (deviceAddr_ < 0 || deviceAddr_ > 255) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Ïû•Ïπò Ï£ºÏÜåÍ∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %d (Î≤îÏúÑ: 0-255)\n",
                  driverName, functionName, deviceAddr_);
        isValid = false;
    }
    
    // 7. ÌòÑÏû¨Í∞í Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (Í≤ΩÍ≥†Îßå Ï∂úÎ†•)
    if (currentValue_ < -10.0 || currentValue_ > 10.0) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: ÌòÑÏû¨Í∞íÏù¥ ÏòàÏÉÅ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %f V (ÏòàÏÉÅ Î≤îÏúÑ: -10.0 ~ +10.0 V)\n",
                  driverName, functionName, currentValue_);
        // ÌòÑÏû¨Í∞íÏùÄ Ï∏°Ï†ïÍ∞íÏù¥ÎØÄÎ°ú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå®Î°ú Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
    }
    
    // 8. ÏïåÎûå ÏÉÅÌÉú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (alarmStatus_ < 0 || alarmStatus_ > 3) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ÏïåÎûå ÏÉÅÌÉúÍ∞Ä Ïú†Ìö® Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: %d (Î≤îÏúÑ: 0-3)\n",
                  driverName, functionName, alarmStatus_);
        // ÏïåÎûå ÏÉÅÌÉúÎ•º Ï†ïÏÉÅÏúºÎ°ú Î¶¨ÏÖã
        alarmStatus_ = 0;
        setIntegerParam(P_AlarmStatus, alarmStatus_);
    }
    
    // 9. ÎÖºÎ¶¨Ï†Å ÏùºÍ¥ÄÏÑ± Í≤ÄÏÇ¨
    if (enabled_ && !threadRunning_) {
        asynPrint(pasynUserSelf, ASYN_TRACE_WARNING,
                  "%s::%s: ÌôúÏÑ±Ìôî ÏÉÅÌÉúÏù¥ÏßÄÎßå Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìúÍ∞Ä Ïã§ÌñâÎêòÏßÄ ÏïäÏùå\n",
                  driverName, functionName);
        // Ïù¥Îäî ÏùºÏãúÏ†ÅÏù∏ ÏÉÅÌÉúÏùº Ïàò ÏûàÏúºÎØÄÎ°ú Ïò§Î•òÎ°ú Ï≤òÎ¶¨ÌïòÏßÄ ÏïäÏùå
    }
    
    // 10. Î©îÎ™®Î¶¨ Î∞è Î¶¨ÏÜåÏä§ ÏÉÅÌÉú Í≤ÄÏÇ¨
    if (enabled_ && monitorThread_ == NULL) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: ÌôúÏÑ±Ìôî ÏÉÅÌÉúÏù¥ÏßÄÎßå Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú Í∞ùÏ≤¥Í∞Ä NULLÏûÑ\n",
                  driverName, functionName);
        isValid = false;
    }
    
    // Í≤ÄÏÇ¨ Í≤∞Í≥º Î°úÍπÖ
    if (isValid) {
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: Î™®Îì† Îß§Í∞úÎ≥ÄÏàòÍ∞Ä Ïú†Ìö®Ìï®\n",
                  driverName, functionName);
        asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
                  "%s::%s: ÌòÑÏû¨ ÏÑ§Ï†ï - ÏûÑÍ≥ÑÍ∞í: %f V, ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§: %f V, Ï£ºÍ∏∞: %f Hz\n",
                  driverName, functionName, thresholdValue_, hysteresis_, updateRate_);
    } else {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s: Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ Ïã§Ìå® - ÏÑ§Ï†ïÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî\n",
                  driverName, functionName);
    }
    
    return isValid;
}



/* IOC Ïâò Î™ÖÎ†πÏñ¥ Íµ¨ÌòÑ */

/** ThresholdLogicConfig IOC Ïâò Î™ÖÎ†πÏñ¥ Íµ¨ÌòÑ
 * 
 * ÏÉàÎ°úÏö¥ ThresholdLogicController Ïù∏Ïä§ÌÑ¥Ïä§Î•º ÏÉùÏÑ±ÌïòÍ≥† Íµ¨ÏÑ±Ìï©ÎãàÎã§.
 * 
 * Îß§Í∞úÎ≥ÄÏàò:
 *   portName   - ÏÉùÏÑ±Ìï† asyn Ìè¨Ìä∏Ïùò Ïù¥Î¶Ñ (Î¨∏ÏûêÏó¥)
 *   devicePort - Ïó∞Í≤∞Ìï† Ïû•Ïπò Ìè¨Ìä∏Ïùò Ïù¥Î¶Ñ (Î¨∏ÏûêÏó¥)  
 *   deviceAddr - Ïû•Ïπò Ï£ºÏÜå (Ï†ïÏàò, 0-255 Î≤îÏúÑ)
 * 
 * Î∞òÌôòÍ∞í:
 *   0  - ÏÑ±Í≥µ
 *   -1 - Ïã§Ìå®
 * 
 * ÏÇ¨Ïö© Ïòà:
 *   ThresholdLogicConfig("THRESHOLD1", "USB1608G_2AO_cpp_PORT", 0)
 */
extern "C" int ThresholdLogicConfig(const char* portName, const char* devicePort, int deviceAddr)
{
    const char* functionName = "ThresholdLogicConfig";
    
    // ÏûÖÎ†• Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (portName == NULL || strlen(portName) == 0) {
        printf("%s Ïò§Î•ò: Ìè¨Ìä∏ Ïù¥Î¶ÑÏù¥ NULLÏù¥Í±∞ÎÇò ÎπÑÏñ¥ÏûàÏäµÎãàÎã§\n", functionName);
        return -1;
    }
    
    if (devicePort == NULL || strlen(devicePort) == 0) {
        printf("%s Ïò§Î•ò: Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶ÑÏù¥ NULLÏù¥Í±∞ÎÇò ÎπÑÏñ¥ÏûàÏäµÎãàÎã§\n", functionName);
        return -1;
    }
    
    if (deviceAddr < 0 || deviceAddr > 255) {
        printf("%s Ïò§Î•ò: Ïû•Ïπò Ï£ºÏÜåÍ∞Ä Ïú†Ìö® Î≤îÏúÑ(0-255)Î•º Î≤óÏñ¥ÎÇ¨ÏäµÎãàÎã§: %d\n", 
               functionName, deviceAddr);
        return -1;
    }
    
    // Ìè¨Ìä∏ Ïù¥Î¶Ñ Ï§ëÎ≥µ Í≤ÄÏÇ¨
    if (findAsynPortDriver(portName) != NULL) {
        printf("%s Ïò§Î•ò: Ìè¨Ìä∏ Ïù¥Î¶Ñ '%s'Ïù¥ Ïù¥ÎØ∏ ÏÇ¨Ïö© Ï§ëÏûÖÎãàÎã§\n", 
               functionName, portName);
        return -1;
    }
    
    try {
        // ThresholdLogicController Ïù∏Ïä§ÌÑ¥Ïä§ ÏÉùÏÑ±
        ThresholdLogicController* pController = new ThresholdLogicController(portName, devicePort, deviceAddr);
        
        if (pController == NULL) {
            printf("%s Ïò§Î•ò: ThresholdLogicController ÏÉùÏÑ± Ïã§Ìå®\n", functionName);
            return -1;
        }
        
        printf("%s: ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÉùÏÑ±Îê® - Ìè¨Ìä∏: %s, Ïû•ÏπòÌè¨Ìä∏: %s, Ï£ºÏÜå: %d\n",
               functionName, portName, devicePort, deviceAddr);
        
        return 0;
        
    } catch (std::bad_alloc& e) {
        printf("%s Ïò§Î•ò: Î©îÎ™®Î¶¨ Ìï†Îãπ Ïã§Ìå® - %s\n", functionName, e.what());
        return -1;
    } catch (std::exception& e) {
        printf("%s Ïò§Î•ò: ÏòàÏô∏ Î∞úÏÉù - %s\n", functionName, e.what());
        return -1;
    } catch (...) {
        printf("%s Ïò§Î•ò: Ïïå Ïàò ÏóÜÎäî ÏòàÏô∏ Î∞úÏÉù\n", functionName);
        return -1;
    }
}

/** ThresholdLogicHelp IOC Ïâò Î™ÖÎ†πÏñ¥ Íµ¨ÌòÑ - ÏÇ¨Ïö©Î≤ï ÎèÑÏõÄÎßê ÌëúÏãú */
extern "C" void ThresholdLogicHelp(void)
{
    printf("\n=== ThresholdLogicController ÏÇ¨Ïö© Í∞ÄÏù¥Îìú ===\n\n");
    
    printf("1. ThresholdLogicConfig - ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ïª®Ìä∏Î°§Îü¨ ÏÉùÏÑ±\n");
    printf("   ÏÇ¨Ïö©Î≤ï: ThresholdLogicConfig(portName, devicePort, deviceAddr)\n");
    printf("   Îß§Í∞úÎ≥ÄÏàò:\n");
    printf("     portName   : ÏÉùÏÑ±Ìï† asyn Ìè¨Ìä∏ Ïù¥Î¶Ñ (Î¨∏ÏûêÏó¥)\n");
    printf("     devicePort : Ïó∞Í≤∞Ìï† Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ (Î¨∏ÏûêÏó¥)\n");
    printf("     deviceAddr : Ïû•Ïπò Ï£ºÏÜå (Ï†ïÏàò, 0-255)\n");
    printf("   ÏòàÏ†ú:\n");
    printf("     ThresholdLogicConfig(\"THRESHOLD1\", \"USB1608G_2AO_cpp_PORT\", 0)\n\n");
    
    printf("2. Ï£ºÏöî Í∏∞Îä•:\n");
    printf("   - ÏïÑÎÇ†Î°úÍ∑∏ ÏûÖÎ†• Í∞í Ïã§ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ\n");
    printf("   - ÏÑ§Ï†ï Í∞ÄÎä•Ìïú ÏûÑÍ≥ÑÍ∞íÍ≥º ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§\n");
    printf("   - ÎîîÏßÄÌÑ∏ Ï∂úÎ†• ÏûêÎèô Ï†úÏñ¥\n");
    printf("   - EPICS Î†àÏΩîÎìúÎ•º ÌÜµÌïú ÏõêÍ≤© Ï†úÏñ¥\n");
    printf("   - ÏïåÎûå Î∞è ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ\n\n");
    
    printf("3. Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Î†àÏΩîÎìú Ï†ëÍ∑º:\n");
    printf("   $(P)$(R)Threshold     - ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï (V)\n");
    printf("   $(P)$(R)CurrentValue  - ÌòÑÏû¨ Ï∏°Ï†ïÍ∞í (V)\n");
    printf("   $(P)$(R)OutputState   - Ï∂úÎ†• ÏÉÅÌÉú (0/1)\n");
    printf("   $(P)$(R)Enable        - ÌôúÏÑ±Ìôî Ï†úÏñ¥ (0/1)\n");
    printf("   $(P)$(R)Hysteresis    - ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í∞í (V)\n");
    printf("   $(P)$(R)UpdateRate    - ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ (Hz)\n");
    printf("   $(P)$(R)AlarmStatus   - ÏïåÎûå ÏÉÅÌÉú\n\n");
    
    printf("4. ÏùºÎ∞òÏ†ÅÏù∏ ÏÇ¨Ïö© ÏàúÏÑú:\n");
    printf("   a) ThresholdLogicConfigÎ°ú Ïª®Ìä∏Î°§Îü¨ ÏÉùÏÑ±\n");
    printf("   b) Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ ÌÖúÌîåÎ¶ø Î°úÎìú\n");
    printf("   c) ÏûÑÍ≥ÑÍ∞í Î∞è ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ ÏÑ§Ï†ï\n");
    printf("   d) Enable Î†àÏΩîÎìúÎ°ú Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë\n\n");
    
    printf("5. Î¨∏Ï†ú Ìï¥Í≤∞:\n");
    printf("   - Ìè¨Ìä∏ Ïù¥Î¶Ñ Ï§ëÎ≥µ: Îã§Î•∏ Ìè¨Ìä∏ Ïù¥Î¶Ñ ÏÇ¨Ïö©\n");
    printf("   - Ïû•Ïπò Ïó∞Í≤∞ Ïã§Ìå®: Ïû•Ïπò Ìè¨Ìä∏ Î∞è Ï£ºÏÜå ÌôïÏù∏\n");
    printf("   - ÏïåÎûå Î∞úÏÉù: AlarmStatus Î†àÏΩîÎìú ÌôïÏù∏\n");
    printf("   - ÏÑ±Îä• Î¨∏Ï†ú: UpdateRate Ï°∞Ï†ï\n\n");
    
    printf("ÏûêÏÑ∏Ìïú Ï†ïÎ≥¥Îäî ThresholdLogicController Î¨∏ÏÑúÎ•º Ï∞∏Ï°∞ÌïòÏÑ∏Ïöî.\n");
    printf("===============================================\n\n");
}

/* IOC Ïâò Î™ÖÎ†πÏñ¥ Îì±Î°ù Íµ¨Ï°∞Ï≤¥ Ï†ïÏùò */

// ThresholdLogicConfig Î™ÖÎ†πÏñ¥ Ïù∏Ïàò Ï†ïÏùò
static const iocshArg thresholdConfigArg0 = {
    "portName", 
    iocshArgString
};
static const iocshArg thresholdConfigArg1 = {
    "devicePort", 
    iocshArgString
};
static const iocshArg thresholdConfigArg2 = {
    "deviceAddr", 
    iocshArgInt
};

static const iocshArg *thresholdConfigArgs[] = {
    &thresholdConfigArg0,
    &thresholdConfigArg1,
    &thresholdConfigArg2
};

// ThresholdLogicConfig Î™ÖÎ†πÏñ¥ Ï†ïÏùò
static const iocshFuncDef thresholdConfigFuncDef = {
    "ThresholdLogicConfig",                    // Î™ÖÎ†πÏñ¥ Ïù¥Î¶Ñ
    3,                                         // Ïù∏Ïàò Í∞úÏàò
    thresholdConfigArgs                        // Ïù∏Ïàò Î∞∞Ïó¥
};

// ThresholdLogicHelp Î™ÖÎ†πÏñ¥ Ï†ïÏùò (Ïù∏Ïàò ÏóÜÏùå)
static const iocshFuncDef thresholdHelpFuncDef = {
    "ThresholdLogicHelp",                      // Î™ÖÎ†πÏñ¥ Ïù¥Î¶Ñ
    0,                                         // Ïù∏Ïàò Í∞úÏàò
    NULL                                       // Ïù∏Ïàò ÏóÜÏùå
};

/* IOC Ïâò Î™ÖÎ†πÏñ¥ ÏΩúÎ∞± Ìï®ÏàòÎì§ */

/** ThresholdLogicConfig Î™ÖÎ†πÏñ¥ ÏΩúÎ∞± Ìï®Ïàò */
static void thresholdConfigCallFunc(const iocshArgBuf *args)
{
    // Ïù∏Ïàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    if (args == NULL) {
        printf("ThresholdLogicConfig: Ïù∏ÏàòÍ∞Ä NULLÏûÖÎãàÎã§\n");
        return;
    }
    
    // Î™ÖÎ†πÏñ¥ Ïã§Ìñâ Î∞è Í≤∞Í≥º Ï≤òÎ¶¨
    int result = ThresholdLogicConfig(args[0].sval, args[1].sval, args[2].ival);
    
    if (result != 0) {
        printf("ThresholdLogicConfig: Î™ÖÎ†πÏñ¥ Ïã§Ìñâ Ïã§Ìå® (Î∞òÌôòÍ∞í: %d)\n", result);
        printf("ÎèÑÏõÄÎßêÏùÑ Î≥¥Î†§Î©¥ 'ThresholdLogicHelp'Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.\n");
    }
}

/** ThresholdLogicHelp Î™ÖÎ†πÏñ¥ ÏΩúÎ∞± Ìï®Ïàò */
static void thresholdHelpCallFunc(const iocshArgBuf *args)
{
    // Ïù∏ÏàòÎäî ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÏùå (ÎèÑÏõÄÎßê Î™ÖÎ†πÏñ¥)
    (void)args; // Ïª¥ÌååÏùºÎü¨ Í≤ΩÍ≥† Î∞©ÏßÄ
    
    ThresholdLogicHelp();
}

/** IOC Ïâò Î™ÖÎ†πÏñ¥ Îì±Î°ù Ìï®Ïàò 
 * 
 * Ïù¥ Ìï®ÏàòÎäî EPICS IOC ÏãúÏûë Ïãú ÏûêÎèôÏúºÎ°ú Ìò∏Ï∂úÎêòÏñ¥
 * ThresholdLogicController Í¥ÄÎ†® Î™ÖÎ†πÏñ¥Îì§ÏùÑ IOC ÏâòÏóê Îì±Î°ùÌï©ÎãàÎã§.
 */
extern "C" void ThresholdLogicRegister(void)
{
    const char* functionName = "ThresholdLogicRegister";
    
    // ThresholdLogicConfig Î™ÖÎ†πÏñ¥ Îì±Î°ù
    iocshRegister(&thresholdConfigFuncDef, thresholdConfigCallFunc);
    
    // ThresholdLogicHelp Î™ÖÎ†πÏñ¥ Îì±Î°ù
    iocshRegister(&thresholdHelpFuncDef, thresholdHelpCallFunc);
    
    printf("%s: IOC Ïâò Î™ÖÎ†πÏñ¥ Îì±Î°ù ÏôÑÎ£å\n", functionName);
    printf("  - ThresholdLogicConfig: ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ïª®Ìä∏Î°§Îü¨ ÏÉùÏÑ±\n");
    printf("  - ThresholdLogicHelp: ÏÇ¨Ïö©Î≤ï ÎèÑÏõÄÎßê ÌëúÏãú\n");
    printf("ÎèÑÏõÄÎßêÏùÑ Î≥¥Î†§Î©¥ 'ThresholdLogicHelp'Î•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.\n");
}

/** Íµ¨ÏÑ± Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (ErrorHandler ÏÇ¨Ïö©) */
bool ThresholdLogicController::validateConfigurationWithErrorHandler()
{
    const char* functionName = "validateConfigurationWithErrorHandler";
    
    // ErrorHandler::ThresholdConfig Íµ¨Ï°∞Ï≤¥ ÏÉùÏÑ±
    ErrorHandler::ThresholdConfig config;
    strncpy(config.portName, portName, sizeof(config.portName) - 1);
    config.portName[sizeof(config.portName) - 1] = '\0';
    
    strncpy(config.devicePort, devicePortName_, sizeof(config.devicePort) - 1);
    config.devicePort[sizeof(config.devicePort) - 1] = '\0';
    
    config.deviceAddr = deviceAddr_;
    config.updateRate = updateRate_;
    config.priority = 50; // Í∏∞Î≥∏ Ïö∞ÏÑ†ÏàúÏúÑ
    config.thresholdValue = thresholdValue_;
    config.hysteresis = hysteresis_;
    
    // ErrorHandlerÎ•º ÏÇ¨Ïö©Ìïú Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    ErrorHandler::ValidationResult result = ErrorHandler::validateConfiguration(config);
    
    if (!result.isValid) {
        ErrorHandler::logError(result.errorLevel, functionName, result.errorMessage, pasynUserSelf);
        if (strlen(result.suggestion) > 0) {
            ErrorHandler::logError(ErrorHandler::INFO, functionName, 
                                  result.suggestion, pasynUserSelf);
        }
        return false;
    }
    
    if (result.errorLevel == ErrorHandler::WARNING) {
        ErrorHandler::logError(ErrorHandler::WARNING, functionName, 
                              result.errorMessage, pasynUserSelf);
        if (strlen(result.suggestion) > 0) {
            ErrorHandler::logError(ErrorHandler::INFO, functionName, 
                                  result.suggestion, pasynUserSelf);
        }
    }
    
    return true;
}

/** Ïò§Î•ò Î°úÍπÖ (ErrorHandler ÏÇ¨Ïö©) */
void ThresholdLogicController::logError(const char* functionName, const char* message)
{
    if (functionName == NULL || message == NULL) {
        ErrorHandler::logError(ErrorHandler::ERROR, "ThresholdLogicController::logError", 
                              "NULL Ìè¨Ïù∏ÌÑ∞Í∞Ä Ï†ÑÎã¨Îê®");
        return;
    }
    
    // Ï†ÑÏ≤¥ Ìï®Ïàò Ïù¥Î¶Ñ Íµ¨ÏÑ±
    char fullFunctionName[128];
    snprintf(fullFunctionName, sizeof(fullFunctionName), 
            "ThresholdLogicController::%s", functionName);
    
    // ErrorHandlerÎ•º ÌÜµÌïú Î°úÍπÖ
    ErrorHandler::logError(ErrorHandler::ERROR, fullFunctionName, message, pasynUserSelf);
}
/* EPICS Îì±Î°ùÏûê ÎÇ¥Î≥¥ÎÇ¥Í∏∞ */
epicsExportRegistrar(ThresholdLogicRegister);











üî• File: ./USB1608G_2AO_V2App/src/ThresholdLogicController.h
=================================================
#ifndef ThresholdLogicControllerInclude
#define ThresholdLogicControllerInclude

#include <asynPortDriver.h>
#include <epicsThread.h>
#include <epicsTime.h>
#include <shareLib.h>
#include "ErrorHandler.h"

/** ÏûÑÍ≥ÑÍ∞í Í∏∞Î∞ò Î°úÏßÅ Ï†úÏñ¥Î•º ÏúÑÌïú asynPortDriver ÌÅ¥ÎûòÏä§
 * 
 * Ïù¥ ÌÅ¥ÎûòÏä§Îäî ÏïÑÎÇ†Î°úÍ∑∏ ÏûÖÎ†• Í∞íÏùÑ Î™®ÎãàÌÑ∞ÎßÅÌïòÍ≥† ÏÑ§Ï†ïÎêú ÏûÑÍ≥ÑÍ∞íÍ≥º ÎπÑÍµêÌïòÏó¨
 * ÎîîÏßÄÌÑ∏ Ï∂úÎ†•ÏùÑ Ï†úÏñ¥ÌïòÎäî Í∏∞Îä•ÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§.
 * ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í∏∞Îä•ÏùÑ Ìè¨Ìï®ÌïòÏó¨ ÏïàÏ†ïÏ†ÅÏù∏ Ï∂úÎ†• Ï†úÏñ¥Î•º Î≥¥Ïû•Ìï©ÎãàÎã§.
 */
class epicsShareClass ThresholdLogicController : public asynPortDriver, public epicsThreadRunable {
public:
    /** ÏÉùÏÑ±Ïûê
     * \param[in] portName Ïù¥ ÎìúÎùºÏù¥Î≤ÑÏùò asyn Ìè¨Ìä∏ Ïù¥Î¶Ñ
     * \param[in] devicePort Ïó∞Í≤∞Ìï† Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ
     * \param[in] deviceAddr Ïû•Ïπò Ï£ºÏÜå
     */
    ThresholdLogicController(const char* portName, const char* devicePort, int deviceAddr);
    
    /** ÏÜåÎ©∏Ïûê */
    virtual ~ThresholdLogicController();
    
    // asynPortDriverÏóêÏÑú ÏÉÅÏÜçÎ∞õÏùÄ Î©îÏÑúÎìúÎì§
    virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
    virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
    virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
    virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
    
    /** ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ Ï≤òÎ¶¨ Î©îÏÑúÎìú */
    void processThresholdLogic();
    
    /** Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë */
    void startMonitoring();
    
    /** Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏßÄ */
    void stopMonitoring();
    
    /** Ï†ïÏ†Å Ïä§Î†àÎìú Ìï®Ïàò (epicsThreadÏóêÏÑú Ìò∏Ï∂ú) */
    static void monitorThreadFunc(void* param);
    
    /** epicsThreadRunable Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Íµ¨ÌòÑ */
    virtual void run();
    
    // ÌÖåÏä§Ìä∏Ïö© public Ï†ëÍ∑ºÏûê Î©îÏÑúÎìúÎì§
    /** ÌÖåÏä§Ìä∏Ïö©: Îß§Í∞úÎ≥ÄÏàò Ïù∏Îç±Ïä§ Ï†ëÍ∑ºÏûê */
    int getThresholdValueParam() const { return P_ThresholdValue; }
    int getCurrentValueParam() const { return P_CurrentValue; }
    int getOutputStateParam() const { return P_OutputState; }
    int getEnableParam() const { return P_Enable; }
    int getHysteresisParam() const { return P_Hysteresis; }
    int getUpdateRateParam() const { return P_UpdateRate; }
    int getAlarmStatusParam() const { return P_AlarmStatus; }

protected:
    // Îß§Í∞úÎ≥ÄÏàò Ïù∏Îç±Ïä§Îì§
    int P_ThresholdValue;      ///< ÏûÑÍ≥ÑÍ∞í ÏÑ§Ï†ï Îß§Í∞úÎ≥ÄÏàò
    int P_CurrentValue;        ///< ÌòÑÏû¨ Ï∏°Ï†ïÍ∞í Îß§Í∞úÎ≥ÄÏàò
    int P_OutputState;         ///< Ï∂úÎ†• ÏÉÅÌÉú Îß§Í∞úÎ≥ÄÏàò
    int P_Enable;              ///< ÌôúÏÑ±Ìôî ÏÉÅÌÉú Îß§Í∞úÎ≥ÄÏàò
    int P_Hysteresis;          ///< ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í∞í Îß§Í∞úÎ≥ÄÏàò
    int P_UpdateRate;          ///< ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ Îß§Í∞úÎ≥ÄÏàò
    int P_AlarmStatus;         ///< ÏïåÎûå ÏÉÅÌÉú Îß§Í∞úÎ≥ÄÏàò
    int P_DevicePort;          ///< Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ Îß§Í∞úÎ≥ÄÏàò
    int P_DeviceAddr;          ///< Ïû•Ïπò Ï£ºÏÜå Îß§Í∞úÎ≥ÄÏàò

private:
    // Ïä§Î†àÎìú Í¥ÄÎ¶¨
    epicsThread *monitorThread_;    ///< Î™®ÎãàÌÑ∞ÎßÅ Ïä§Î†àÎìú Ìè¨Ïù∏ÌÑ∞
    bool threadRunning_;            ///< Ïä§Î†àÎìú Ïã§Ìñâ ÏÉÅÌÉú
    bool threadExit_;               ///< Ïä§Î†àÎìú Ï¢ÖÎ£å ÌîåÎûòÍ∑∏
    
    // ÏûÑÍ≥ÑÍ∞í Î°úÏßÅ ÏÉÅÌÉú Î≥ÄÏàòÎì§
    double thresholdValue_;         ///< ÌòÑÏû¨ ÏûÑÍ≥ÑÍ∞í
    double currentValue_;           ///< ÌòÑÏû¨ Ï∏°Ï†ïÍ∞í
    bool outputState_;              ///< ÌòÑÏû¨ Ï∂úÎ†• ÏÉÅÌÉú
    bool enabled_;                  ///< ÌôúÏÑ±Ìôî ÏÉÅÌÉú
    double hysteresis_;             ///< ÌûàÏä§ÌÖåÎ¶¨ÏãúÏä§ Í∞í
    double updateRate_;             ///< ÏóÖÎç∞Ïù¥Ìä∏ Ï£ºÍ∏∞ (Hz)
    int alarmStatus_;               ///< ÏïåÎûå ÏÉÅÌÉú
    
    // Ïû•Ïπò Ïó∞Í≤∞ Ï†ïÎ≥¥
    char devicePortName_[64];       ///< Ïó∞Í≤∞Ìï† Ïû•Ïπò Ìè¨Ìä∏ Ïù¥Î¶Ñ
    int deviceAddr_;                ///< Ïû•Ïπò Ï£ºÏÜå
    
    // ÏÉÅÌÉú Ï∂îÏ†Å
    epicsTimeStamp lastUpdate_;     ///< ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏ ÏãúÍ∞Ñ
    bool lastOutputState_;          ///< Ïù¥Ï†Ñ Ï∂úÎ†• ÏÉÅÌÉú (ÏÉÅÌÉú Î≥ÄÌôî Í∞êÏßÄÏö©)
    
    // ÎÇ¥Î∂Ä Î©îÏÑúÎìúÎì§
    /** Ïû•ÏπòÏóêÏÑú ÌòÑÏû¨ Í∞íÏùÑ ÏùΩÏñ¥Ïò¥ */
    asynStatus readCurrentValueFromDevice();
    
    /** Ïû•ÏπòÏóê Ï∂úÎ†• ÏÉÅÌÉúÎ•º ÏÑ§Ï†ï */
    asynStatus writeOutputStateToDevice(bool state);
    
    /** ÏïåÎûå ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ */
    void updateAlarmStatus();
    
    /** Îß§Í∞úÎ≥ÄÏàò Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ */
    bool validateParameters();
    
    /** Ïò§Î•ò Î°úÍπÖ (ErrorHandler ÏÇ¨Ïö©) */
    void logError(const char* functionName, const char* message);
    
    /** Íµ¨ÏÑ± Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (ErrorHandler ÏÇ¨Ïö©) */
    bool validateConfigurationWithErrorHandler();
};

// IOC Ïâò Î™ÖÎ†πÏñ¥ Îì±Î°ù Ìï®Ïàò
extern "C" {
    epicsShareFunc int ThresholdLogicConfig(const char* portName, const char* devicePort, int deviceAddr);
    epicsShareFunc void ThresholdLogicHelp(void);
    epicsShareFunc void ThresholdLogicRegister(void);
}

// Îß§Í∞úÎ≥ÄÏàò Î¨∏ÏûêÏó¥ Ï†ïÏùò
#define THRESHOLD_VALUE_STRING      "THRESHOLD_VALUE"
#define CURRENT_VALUE_STRING        "CURRENT_VALUE"
#define OUTPUT_STATE_STRING         "OUTPUT_STATE"
#define ENABLE_STRING               "ENABLE"
#define HYSTERESIS_STRING           "HYSTERESIS"
#define UPDATE_RATE_STRING          "UPDATE_RATE"
#define ALARM_STATUS_STRING         "ALARM_STATUS"
#define DEVICE_PORT_STRING          "DEVICE_PORT"
#define DEVICE_ADDR_STRING          "DEVICE_ADDR"

#endif /* ThresholdLogicControllerInclude */










üî• File: ./USB1608G_2AO_V2App/src/USB1608G_2AO_V2Main.cpp
=================================================
/* USB1608G_2AO_V2Main.cpp */
/* Author:  Marty Kraimer Date:    17MAR2000 */

#include <stddef.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "epicsExit.h"
#include "epicsThread.h"
#include "iocsh.h"

int main(int argc,char *argv[])
{
    if(argc>=2) {
        iocsh(argv[1]);
        epicsThreadSleep(.2);
    }
    iocsh(NULL);
    epicsExit(0);
    return(0);
}











üî• File: ./USB1608G_2AO_V2App/src/USBCTR_SNL.st
=================================================
program USBCTR_SNL("P=USBCTR:MCS:, R=mca, NUM_COUNTERS=8,  FIELD=READ")

/*  This sequencer program works with measCompMCS.template
 *  It supports multi-element MCA operations
 *
 *  Mark Rivers
 *  June 2, 2014
 *
 * This program must be compiled with the recursive option so that multiple copies
 * can run at once */
option +r;

/* Allow the program to start, even if not all assigned channels are connected.
 * This could be useful if the SNL is running on a different ioc. */
option -c;

%%#include <stdlib.h>
%%#include <errlog.h>
%%#include <string.h>

/* Maximum number of counters supported */
#define MAX_COUNTERS 9

int i;
int n;
int numCounters;
char temp[100];

char *prefix;
char *record;
char *field;

int     ReadArray[MAX_COUNTERS];
assign  ReadArray to {};
int     ReadArrays; assign ReadArrays to "{P}DoReadAll";
monitor ReadArrays; evflag ReadArraysMon; sync ReadArrays ReadArraysMon;

int     HardwareAcquiring; assign HardwareAcquiring to "{P}HardwareAcquiring";
monitor HardwareAcquiring; evflag HardwareAcquiringMon; sync HardwareAcquiring HardwareAcquiringMon;

int     MCSAbsTimeWF; assign MCSAbsTimeWF to "{P}AbsTimeWF.PROC";

int     SNL_Connected;  assign SNL_Connected      to "{P}SNL_Connected";
int     AsynDebug;      assign AsynDebug          to "{P}Asyn.TB1";
monitor AsynDebug;

int Acquiring; assign Acquiring to "{P}Acquiring";

ss mca_control {
  state init {
    when() {
      prefix = macValueGet("P");
      record = macValueGet("R");
      field = macValueGet("FIELD");
      numCounters = atoi(macValueGet("NUM_COUNTERS"));
      if ((numCounters <= 0) || (numCounters > MAX_COUNTERS)) {
        printf ("NUM_COUNTERS is illegal.\n");
        numCounters = 0;
      }
      for (i=0; i<numCounters; i++) {
        n = i+1;
        sprintf(temp, "%s%s%d.%s", prefix, record, n, field);
        pvAssign(ReadArray[i], temp);
       }
    } state waitConnected
  }

  state waitConnected {
    when (numCounters <= 0) {
      printf (">>>>>>>>>>>>>> USBCTR is dead. <<<<<<<<<<<<<<\n");
    } state dead

    when (pvAssignCount () == pvConnectCount ()) {
      printf ("USBCTR: All channels connected.\n");
      SNL_Connected = 1;
      pvPut(SNL_Connected);
    } state monitor_changes
  }

  state dead {
    when (delay (3600.0)) {
    } state dead
  }

  state monitor_changes {
    when (pvAssignCount () != pvConnectCount ()) {
      printf ("USBCTR: Not all channels connected.\n");
    } state waitConnected

    when(efTestAndClear(ReadArraysMon) && (ReadArrays == 1)) {
      if (AsynDebug) printf("USBCTR.st: Read array data\n");
      for (i=0; i<numCounters; i++) {
        ReadArray[i] = 1;
        pvPut(ReadArray[i]);
      }
      MCSAbsTimeWF = 1;
      pvPut(MCSAbsTimeWF);
      ReadArrays = 0;
      pvPut(ReadArrays);
    } state monitor_changes

    when(efTestAndClear(HardwareAcquiringMon)) {
      if (AsynDebug) printf("USBCTR.st: HardwareAcquiringMon, HardwareAcquiring=%d\n", HardwareAcquiring);
      /* If the detector is acquiring then force each record to read status */
      if (!HardwareAcquiring) {
        /* If the detector is done then force each record to read data */
        for (i=0; i<numCounters; i++) {
          ReadArray[i] = 1;
          pvPut(ReadArray[i], SYNC);
        }
        MCSAbsTimeWF = 1;
        pvPut(MCSAbsTimeWF);
        /* Clear the Acquiring busy record */
        Acquiring = 0;
        pvPut(Acquiring);
      }
    } state monitor_changes
  }
}












üî• File: ./USB1608G_2AO_V2App/src/drvMultiFunction.cpp
=================================================
/* drvMultiFunction.cpp
 *
 * Driver for Measurement Computing multi-function DAQ board using asynPortDriver base class
 *
 * This driver supports simple analog in/out, digital in/out bit and word, timer (digital pulse generator), counter,
 *   waveform out (aribtrary waveform generator), and waveform in (digital oscilloscope)
 *
 * This driver was previously name drv1608G.cpp but was renamed because it now supports several models.
 *
 * Mark Rivers
 * November 1, 2015
*/

#include <math.h>
#include <string.h>
#include <stdlib.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsString.h>

#include <asynPortDriver.h>

#define DRIVER_VERSION "4.2"

#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

// This needs to be global because we need to protect the UL library from simultaneous access from any driver
epicsMutex ULMutex;

// This function maps the Gain values from UL on Windows to the Range values in UL for Linux.
// We can't use the macros from Windows cbw.h because they conflict with UL for Linux.
// These definitions are taken from cbw.h, but added CBW_ prefix.
#define CBW_BIP60VOLTS       20             /* -60 to 60 Volts */
#define CBW_BIP30VOLTS       23
#define CBW_BIP20VOLTS       15             /* -20 to +20 Volts */
#define CBW_BIP15VOLTS       21             /* -15 to +15 Volts */
#define CBW_BIP10VOLTS       1              /* -10 to +10 Volts */
#define CBW_BIP5VOLTS        0              /* -5 to +5 Volts */
#define CBW_BIP4VOLTS        16             /* -4 to + 4 Volts */
#define CBW_BIP2PT5VOLTS     2              /* -2.5 to +2.5 Volts */
#define CBW_BIP2VOLTS        14             /* -2.0 to +2.0 Volts */
#define CBW_BIP1PT25VOLTS    3              /* -1.25 to +1.25 Volts */
#define CBW_BIP1VOLTS        4              /* -1 to +1 Volts */
#define CBW_BIPPT625VOLTS    5              /* -.625 to +.625 Volts */
#define CBW_BIPPT5VOLTS      6              /* -.5 to +.5 Volts */
#define CBW_BIPPT25VOLTS     12             /* -0.25 to +0.25 Volts */
#define CBW_BIPPT2VOLTS      13             /* -0.2 to +0.2 Volts */
#define CBW_BIPPT1VOLTS      7              /* -.1 to +.1 Volts */
#define CBW_BIPPT05VOLTS     8              /* -.05 to +.05 Volts */
#define CBW_BIPPT01VOLTS     9              /* -.01 to +.01 Volts */
#define CBW_BIPPT005VOLTS    10             /* -.005 to +.005 Volts */
#define CBW_BIP1PT67VOLTS    11             /* -1.67 to +1.67 Volts */
#define CBW_BIPPT312VOLTS    17             /* -0.312 to +0.312 Volts */
#define CBW_BIPPT156VOLTS    18             /* -0.156 to +0.156 Volts */
#define CBW_BIPPT125VOLTS    22             /* -0.125 to +0.125 Volts */
#define CBW_BIPPT078VOLTS    19             /* -0.078 to +0.078 Volts */


#define CBW_UNI10VOLTS       100            /* 0 to 10 Volts*/
#define CBW_UNI5VOLTS        101            /* 0 to 5 Volts */
#define CBW_UNI4VOLTS        114            /* 0 to 4 Volts */
#define CBW_UNI2PT5VOLTS     102            /* 0 to 2.5 Volts */
#define CBW_UNI2VOLTS        103            /* 0 to 2 Volts */
#define CBW_UNI1PT67VOLTS    109            /* 0 to 1.67 Volts */
#define CBW_UNI1PT25VOLTS    104            /* 0 to 1.25 Volts */
#define CBW_UNI1VOLTS        105            /* 0 to 1 Volt */
#define CBW_UNIPT5VOLTS      110            /* 0 to .5 Volt */
#define CBW_UNIPT25VOLTS     111            /* 0 to 0.25 Volt */
#define CBW_UNIPT2VOLTS      112            /* 0 to .2 Volt */
#define CBW_UNIPT1VOLTS      106            /* 0 to .1 Volt */
#define CBW_UNIPT05VOLTS     113            /* 0 to .05 Volt */
#define CBW_UNIPT02VOLTS     108            /* 0 to .02 Volt*/
#define CBW_UNIPT01VOLTS     107            /* 0 to .01 Volt*/

#define CBW_MA4TO20          200            /* 4 to 20 ma */
#define CBW_MA2TO10          201            /* 2 to 10 ma */
#define CBW_MA1TO5           202            /* 1 to 5 ma */
#define CBW_MAPT5TO2PT5      203            /* .5 to 2.5 ma */
#define CBW_MA0TO20          204            /* 0 to 20 ma */
#define CBW_BIPPT025AMPS     205            /* -0.025 to 0.025 ma */

#include <epicsExport.h>
#include <measCompDiscover.h>

static const char *driverName = "MultiFunction";

typedef enum {
  waveTypeUser,
  waveTypeSin,
  waveTypeSquare,
  waveTypeSawTooth,
  waveTypePulse,
  waveTypeRandom
} waveType_t;

// Board parameters
#define modelNameString           "MODEL_NAME"
#define modelNumberString         "MODEL_NUMBER"
#define firmwareVersionString     "FIRMWARE_VERSION"
#define uniqueIDString            "UNIQUE_ID"
#define ULVersionString           "UL_VERSION"
#define driverVersionString       "DRIVER_VERSION"
#define pollSleepMSString         "POLL_SLEEP_MS"
#define pollTimeMSString          "POLL_TIME_MS"
#define lastErrorMessageString    "LAST_ERROR_MESSAGE"

// Pulse output parameters
#define pulseGenRunString         "PULSE_RUN"
#define pulseGenPeriodString      "PULSE_PERIOD"
#define pulseGenDutyCycleString   "PULSE_DUTY_CYCLE"
#define pulseGenDelayString       "PULSE_DELAY"
#define pulseGenCountString       "PULSE_COUNT"
#define pulseGenIdleStateString   "PULSE_IDLE_STATE"

// Counter parameters
#define counterCountsString       "COUNTER_VALUE"
#define counterResetString        "COUNTER_RESET"

// Analog input parameters
#define analogInValueString       "ANALOG_IN_VALUE"
#define analogInRangeString       "ANALOG_IN_RANGE"
#define analogInTypeString        "ANALOG_IN_TYPE"
#define analogInModeString        "ANALOG_IN_MODE"
#define analogInRateString        "ANALOG_IN_RATE"

// Voltage input parameters
#define voltageInValueString      "VOLTAGE_IN_VALUE"
#define voltageInRangeString      "VOLTAGE_IN_RANGE"

// Temperature parameters
#define temperatureInValueString  "TEMPERATURE_IN_VALUE"
#define thermocoupleTypeString    "THERMOCOUPLE_TYPE"
#define thermocoupleOpenDetectString "THERMOCOUPLE_OPEN_DETECT"
#define temperatureScaleString    "TEMPERATURE_SCALE"
#define temperatureFilterString   "TEMPERATURE_FILTER"
#define temperatureSensorString   "TEMPERATURE_SENSOR"
#define temperatureWiringString   "TEMPERATURE_WIRING"

// Waveform digitizer parameters - global
#define waveDigDwellString        "WAVEDIG_DWELL"
#define waveDigDwellActualString  "WAVEDIG_DWELL_ACTUAL"
#define waveDigTotalTimeString    "WAVEDIG_TOTAL_TIME"
#define waveDigFirstChanString    "WAVEDIG_FIRST_CHAN"
#define waveDigNumChansString     "WAVEDIG_NUM_CHANS"
#define waveDigNumPointsString    "WAVEDIG_NUM_POINTS"
#define waveDigCurrentPointString "WAVEDIG_CURRENT_POINT"
#define waveDigExtTriggerString   "WAVEDIG_EXT_TRIGGER"
#define waveDigExtClockString     "WAVEDIG_EXT_CLOCK"
#define waveDigContinuousString   "WAVEDIG_CONTINUOUS"
#define waveDigAutoRestartString  "WAVEDIG_AUTO_RESTART"
#define waveDigRetriggerString    "WAVEDIG_RETRIGGER"
#define waveDigTriggerCountString "WAVEDIG_TRIGGER_COUNT"
#define waveDigBurstModeString    "WAVEDIG_BURST_MODE"
#define waveDigRunString          "WAVEDIG_RUN"
#define waveDigTimeWFString       "WAVEDIG_TIME_WF"
#define waveDigAbsTimeWFString    "WAVEDIG_ABS_TIME_WF"
#define waveDigReadWFString       "WAVEDIG_READ_WF"
// Waveform digitizer parameters - per input
#define waveDigVoltWFString       "WAVEDIG_VOLT_WF"

// Analog output parameters
#define analogOutValueString      "ANALOG_OUT_VALUE"
#define analogOutRangeString      "ANALOG_OUT_RANGE"

// Waveform generator parameters - global
#define waveGenFreqString         "WAVEGEN_FREQ"
#define waveGenDwellString        "WAVEGEN_DWELL"
#define waveGenDwellActualString  "WAVEGEN_DWELL_ACTUAL"
#define waveGenTotalTimeString    "WAVEGEN_TOTAL_TIME"
#define waveGenNumPointsString    "WAVEGEN_NUM_POINTS"
#define waveGenCurrentPointString "WAVEGEN_CURRENT_POINT"
#define waveGenIntDwellString     "WAVEGEN_INT_DWELL"
#define waveGenUserDwellString    "WAVEGEN_USER_DWELL"
#define waveGenIntNumPointsString  "WAVEGEN_INT_NUM_POINTS"
#define waveGenUserNumPointsString "WAVEGEN_USER_NUM_POINTS"
#define waveGenExtTriggerString   "WAVEGEN_EXT_TRIGGER"
#define waveGenExtClockString     "WAVEGEN_EXT_CLOCK"
#define waveGenContinuousString   "WAVEGEN_CONTINUOUS"
#define waveGenRetriggerString    "WAVEGEN_RETRIGGER"
#define waveGenTriggerCountString "WAVEGEN_TRIGGER_COUNT"
#define waveGenRunString          "WAVEGEN_RUN"
#define waveGenUserTimeWFString   "WAVEGEN_USER_TIME_WF"
#define waveGenIntTimeWFString    "WAVEGEN_INT_TIME_WF"
// Waveform generator parameters - per output
#define waveGenWaveTypeString     "WAVEGEN_WAVE_TYPE"
#define waveGenEnableString       "WAVEGEN_ENABLE"
#define waveGenAmplitudeString    "WAVEGEN_AMPLITUDE"
#define waveGenOffsetString       "WAVEGEN_OFFSET"
#define waveGenPulseWidthString   "WAVEGEN_PULSE_WIDTH"
#define waveGenIntWFString        "WAVEGEN_INT_WF"
#define waveGenUserWFString       "WAVEGEN_USER_WF"

// Trigger parameters
#define triggerModeString         "TRIGGER_MODE"

// Digital I/O parameters
#define digitalDirectionString    "DIGITAL_DIRECTION"
#define digitalInputString        "DIGITAL_INPUT"
#define digitalOutputString       "DIGITAL_OUTPUT"

// MAX_ANALOG_IN and MAX_ANALOG_OUT may need to be changed if additional models are added with larger numbers
// These are used as a convenience for allocating small arrays of pointers, not large amounts of data
#define MAX_ANALOG_IN      16
#define MAX_TEMPERATURE_IN 64
#define MAX_ANALOG_OUT     16
#define MAX_IO_PORTS        8
#define MAX_PULSE_GEN       4
#define MAX_SIGNALS        MAX_TEMPERATURE_IN

// For simplicity define a few constants on Linux to be the same as Windows cbw.h
// These need to be copied from cbw.h because uldaq.h and cbw.h cannot both be included due to some conflicting definitions
#ifdef linux
  #define AI_CHAN_TYPE_VOLTAGE  AI_VOLTAGE
  #define AI_CHAN_TYPE_TC       AI_TC
  #define TC_TYPE_J             TC_J
  #define DIFFERENTIAL          0
  #define SINGLE_ENDED          1
  /* Temperature scales */
  #define CELSIUS          0
  #define FAHRENHEIT       1
  #define KELVIN           2
  #define VOLTS            4     /* special scale for DAS-TC boards */
  #define NOSCALE          5
  /* Types of digital input ports */
  #define DIGITALOUT       1
  #define DIGITALIN        2
#endif

typedef enum {
  USB_231            = 297,
  USB_1208LS         = 122,
  USB_1208FS         = 130,
  USB_1208FS_PLUS    = 232,
  USB_1608G          = 308,
  USB_1608GX         = 309,
  USB_1608GX_2AO_OLD = 274,
  USB_1608GX_2AO     = 310,
  USB_1608HS_2AO     = 153,
  USB_1808           = 317, // Fix this when we know the correct value
  USB_1808X          = 318,
  USB_2408_2AO       = 254,
  USB_3101           = 154,
  USB_3102           = 155,
  USB_3103           = 156,
  USB_3104           = 157,
  USB_3105           = 158,
  USB_3106           = 159,
  USB_3110           = 162,
  USB_3112           = 163,
  USB_3114           = 164,
  USB_SSR08          = 134,
  USB_TEMP           = 141,
  USB_TEMP_AI        = 188,
  USB_TC32           = 305,
  ETH_TC32           = 306,
  E_1608             = 303,
  E_DIO24            = 311,
  E_TC               = 312,
  MAX_BOARD_TYPES
} boardType_t;

typedef struct {
  char *enumString;
  int  enumValue;
} enumStruct_t;

static const enumStruct_t inputRangeUSB_231[] = {
  {"+= 20V",   CBW_BIP20VOLTS},
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 4V",    CBW_BIP4VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 2V",    CBW_BIP2VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS},
  {"+= 1V",    CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_231[] = {
  {"+= 10V", CBW_UNI5VOLTS}
};

static const enumStruct_t inputTypeUSB_231[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1208[] = {
  {"+= 20V",   CBW_BIP20VOLTS},
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 4V",    CBW_BIP4VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 2V",    CBW_BIP2VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS},
  {"+= 1V",    CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_1208[] = {
  {"+= 5V", CBW_UNI5VOLTS}
};

static const enumStruct_t outputRangeUSB_1208FS[] = {
  {"+= 4V", CBW_UNI4VOLTS}
};

static const enumStruct_t inputTypeUSB_1208[] = {
    {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1608G[] = {
  {"+= 10V", CBW_BIP10VOLTS},
  {"+= 5V",  CBW_BIP5VOLTS},
  {"+= 2V",  CBW_BIP2VOLTS},
  {"+= 1V",  CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeUSB_1608G[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_1608G[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_1808[] = {
  {"+= 10V",    CBW_BIP10VOLTS},
  {"+= 5V",     CBW_BIP5VOLTS},
  {"0-10V",     CBW_UNI10VOLTS},
  {"0-5V",      CBW_UNI5VOLTS}
};

static const enumStruct_t outputRangeUSB_1808[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_1808[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeUSB_2408[] = {
  {"+= 10V",    CBW_BIP10VOLTS},
  {"+= 5V",     CBW_BIP5VOLTS},
  {"+= 2.5V",   CBW_BIP2PT5VOLTS},
  {"+= 1.25V",  CBW_BIP1PT25VOLTS},
  {"+= 0.625V", CBW_BIPPT625VOLTS},
  {"+= 0.312V", CBW_BIPPT312VOLTS},
  {"+= 0.156V", CBW_BIPPT156VOLTS},
  {"+= 0.078V", CBW_BIPPT078VOLTS}
};

static const enumStruct_t outputRangeUSB_2408[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_2408[] = {
  {"Volts",   AI_CHAN_TYPE_VOLTAGE},
  {"TC deg.", AI_CHAN_TYPE_TC}
};

static const enumStruct_t inputRangeUSB_3101[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeUSB_3101[] = {
  {"0-10V",  CBW_UNI10VOLTS},
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeUSB_3101[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_SSR08[] = {
  {"N.A.",  0}
};

static const enumStruct_t outputRangeUSB_SSR08[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_SSR08[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_TEMP[] = {
  {"N.A.", 0},
};

static const enumStruct_t outputRangeUSB_TEMP[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_TEMP[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeUSB_TEMP_AI[] = {
  {"+= 10V",   CBW_BIP10VOLTS},
  {"+= 5V",    CBW_BIP5VOLTS},
  {"+= 2.5V",  CBW_BIP2PT5VOLTS},
  {"+= 1.25V", CBW_BIP1PT25VOLTS}
};

static const enumStruct_t outputRangeUSB_TEMP_AI[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeUSB_TEMP_AI[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeTC32[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeTC32[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeTC32[] = {
  {"TC deg.", AI_CHAN_TYPE_TC}
};

static const enumStruct_t inputRangeE_1608[] = {
  {"+= 10V", CBW_BIP10VOLTS},
  {"+= 5V",  CBW_BIP5VOLTS},
  {"+= 2V",  CBW_BIP2VOLTS},
  {"+= 1V",  CBW_BIP1VOLTS}
};

static const enumStruct_t outputRangeE_1608[] = {
  {"+= 10V", CBW_BIP10VOLTS}
};

static const enumStruct_t inputTypeE_1608[] = {
  {"Volts", AI_CHAN_TYPE_VOLTAGE}
};

static const enumStruct_t inputRangeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeE_DIO24[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputRangeE_TC[] = {
  {"N.A.", 0}
};

static const enumStruct_t outputRangeE_TC[] = {
  {"N.A.", 0}
};

static const enumStruct_t inputTypeE_TC[] = {
  {"TC deg.", AI_CHAN_TYPE_TC}
};

#ifdef _WIN32
  // The sensor type cannot be configured in UL for Windows so widthwe use these default enum values
  static const enumStruct_t temperatureSensorUSB_TEMP[] = {
    {"RTD",           0},
    {"Thermistor",    1},
    {"Thermocouple",  2},
    {"Semiconductor", 3},
    {"Disabled",      4}
  };
  // The wiring cannot be configured in UL for Windows so we use these default enum values
  static const enumStruct_t temperatureWiringUSB_TEMP[] = {
    {"2 wire 1 sensor",   0},
    {"2 wire 2 sensors",  1},
    {"3 wire",            2},
    {"4 wire",            3}
  };
#else
  // These enum values are for UL for Linux.  
  static const enumStruct_t temperatureSensorUSB_TEMP[] = {
    {"RTD",           AI_RTD},
    {"Thermistor",    AI_THERMISTOR},
    {"Thermocouple",  AI_TC},
    {"Semiconductor", AI_SEMICONDUCTOR},
    {"Disabled",      AI_DISABLED}
  };
  static const enumStruct_t temperatureWiringUSB_TEMP[] = {
    {"2 wire 1 sensor",   SCT_2_WIRE_1},
    {"2 wire 2 sensors",  SCT_2_WIRE_2},
    {"3 wire",            SCT_3_WIRE},
    {"4 wire",            SCT_4_WIRE}
  };
#endif

typedef struct {
  boardType_t boardFamily;
  const enumStruct_t *pInputRange;
  int numInputRange;
  const enumStruct_t *pOutputRange;
  int numOutputRange;
  const enumStruct_t *pInputType;
  int numInputType;
} boardEnums_t;

static const boardEnums_t allBoardEnums[] = {
  {USB_231,        inputRangeUSB_231,     sizeof(inputRangeUSB_231)/sizeof(enumStruct_t),
                   outputRangeUSB_231,    sizeof(outputRangeUSB_231)/sizeof(enumStruct_t),
                   inputTypeUSB_231,      sizeof(inputTypeUSB_231)/sizeof(enumStruct_t)},

  {USB_1208LS,     inputRangeUSB_1208,    sizeof(inputRangeUSB_1208)/sizeof(enumStruct_t),
                   outputRangeUSB_1208,   sizeof(outputRangeUSB_1208)/sizeof(enumStruct_t),
                   inputTypeUSB_1208,     sizeof(inputTypeUSB_1208)/sizeof(enumStruct_t)},

  {USB_1208FS,     inputRangeUSB_1208,    sizeof(inputRangeUSB_1208)/sizeof(enumStruct_t),
                   outputRangeUSB_1208FS, sizeof(outputRangeUSB_1208FS)/sizeof(enumStruct_t),
                   inputTypeUSB_1208,     sizeof(inputTypeUSB_1208)/sizeof(enumStruct_t)},

  {USB_1608G,      inputRangeUSB_1608G,   sizeof(inputRangeUSB_1608G)/sizeof(enumStruct_t),
                   outputRangeUSB_1608G,  sizeof(outputRangeUSB_1608G)/sizeof(enumStruct_t),
                   inputTypeUSB_1608G,    sizeof(inputTypeUSB_1608G)/sizeof(enumStruct_t)},

  {USB_1808,       inputRangeUSB_1808,    sizeof(inputRangeUSB_1808)/sizeof(enumStruct_t),
                   outputRangeUSB_1808,   sizeof(outputRangeUSB_1808)/sizeof(enumStruct_t),
                   inputTypeUSB_1808,     sizeof(inputTypeUSB_1808)/sizeof(enumStruct_t)},

  {USB_3101,       inputRangeUSB_3101,    sizeof(inputRangeUSB_3101)/sizeof(enumStruct_t),
                   outputRangeUSB_3101,   sizeof(outputRangeUSB_3101)/sizeof(enumStruct_t),
                   inputTypeUSB_3101,     sizeof(inputTypeUSB_3101)/sizeof(enumStruct_t)},

  {USB_2408_2AO,   inputRangeUSB_2408,    sizeof(inputRangeUSB_2408)/sizeof(enumStruct_t),
                   outputRangeUSB_2408,   sizeof(outputRangeUSB_2408)/sizeof(enumStruct_t),
                   inputTypeUSB_2408,     sizeof(inputTypeUSB_2408)/sizeof(enumStruct_t)},

  {USB_SSR08,      inputRangeUSB_SSR08,   sizeof(inputRangeUSB_SSR08)/sizeof(enumStruct_t),
                   outputRangeUSB_SSR08,  sizeof(outputRangeUSB_SSR08)/sizeof(enumStruct_t),
                   inputTypeUSB_SSR08,    sizeof(inputTypeUSB_SSR08)/sizeof(enumStruct_t)},

  {USB_TEMP,       inputRangeUSB_TEMP,    sizeof(inputRangeUSB_TEMP)/sizeof(enumStruct_t),
                   outputRangeUSB_TEMP,   sizeof(outputRangeUSB_TEMP)/sizeof(enumStruct_t),
                   inputTypeUSB_TEMP,     sizeof(inputTypeUSB_TEMP)/sizeof(enumStruct_t)},

  {USB_TEMP_AI,    inputRangeUSB_TEMP_AI, sizeof(inputRangeUSB_TEMP_AI)/sizeof(enumStruct_t),
                   outputRangeUSB_TEMP_AI,sizeof(outputRangeUSB_TEMP_AI)/sizeof(enumStruct_t),
                   inputTypeUSB_TEMP_AI,  sizeof(inputTypeUSB_TEMP_AI)/sizeof(enumStruct_t)},

  {USB_TC32,       inputRangeTC32,        sizeof(inputRangeTC32)/sizeof(enumStruct_t),
                   outputRangeTC32,       sizeof(outputRangeTC32)/sizeof(enumStruct_t),
                   inputTypeTC32,         sizeof(inputTypeTC32)/sizeof(enumStruct_t)},

  {E_1608,         inputRangeE_1608,      sizeof(inputRangeE_1608)/sizeof(enumStruct_t),
                   outputRangeE_1608,     sizeof(outputRangeE_1608)/sizeof(enumStruct_t),
                   inputTypeE_1608,       sizeof(inputTypeE_1608)/sizeof(enumStruct_t)},

  {E_DIO24,        inputRangeE_DIO24,     sizeof(inputRangeE_DIO24)/sizeof(enumStruct_t),
                   outputRangeE_DIO24,    sizeof(outputRangeE_DIO24)/sizeof(enumStruct_t),
                   inputTypeE_DIO24,      sizeof(inputTypeE_DIO24)/sizeof(enumStruct_t)},

  {E_TC,           inputRangeE_TC,        sizeof(inputRangeE_TC)/sizeof(enumStruct_t),
                   outputRangeE_TC,       sizeof(outputRangeE_TC)/sizeof(enumStruct_t),
                   inputTypeE_TC,         sizeof(inputTypeE_TC)/sizeof(enumStruct_t)},
};

static int maxBoardFamilies = (int) (sizeof(allBoardEnums) / sizeof(boardEnums_t));
#define ROUND(x) ((x) >= 0. ? (int)x+0.5 : (int)(x-0.5))
#define MAX_BOARDNAME_LEN 256
#define MAX_LIBRARY_MESSAGE_LEN 256
#define PI 3.14159265

/** This is the class definition for the MultiFunction class
  */
class MultiFunction : public asynPortDriver {
public:
  MultiFunction(const char *portName, const char *uniqueID, int maxInputPoints, int maxOutputPoints);

  /* These are the methods that we override from asynPortDriver */
  virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
  virtual asynStatus getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high);
  virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
  virtual asynStatus readFloat64(asynUser *pasynUser, epicsFloat64 *value);
  virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);
  virtual asynStatus readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus writeFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements);
  virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readEnum(asynUser *pasynUser, char *strings[], int values[], int severities[], size_t nElements, size_t *nIn);
  virtual void report(FILE *fp, int details);
  // These should be private but are called from C
  virtual void pollerThread(void);

protected:
  // Model parameters
  int modelName_;
  int modelNumber_;
  int firmwareVersion_;
  int uniqueID_;
  int ULVersion_;
  int driverVersion_;
  int pollSleepMS_;
  int pollTimeMS_;
  int lastErrorMessage_;

  // Pulse generator parameters
  int pulseGenRun_;
  int pulseGenPeriod_;
  int pulseGenDutyCycle_;
  int pulseGenDelay_;
  int pulseGenCount_;
  int pulseGenIdleState_;

  // Counter parameters
  int counterCounts_;
  int counterReset_;

  // Analog input parameters
  int analogInValue_;
  int analogInRange_;
  int analogInType_;
  int analogInMode_;
  int analogInRate_;

  // Voltage input parameters
  int voltageInValue_;
  int voltageInRange_;

  // Temperature parameters
  int temperatureInValue_;
  int thermocoupleType_;
  int thermocoupleOpenDetect_;
  int temperatureScale_;
  int temperatureFilter_;
  int temperatureSensor_;
  int temperatureWiring_;

  // Waveform digitizer parameters - global
  int waveDigDwell_;
  int waveDigDwellActual_;
  int waveDigTotalTime_;
  int waveDigFirstChan_;
  int waveDigNumChans_;
  int waveDigNumPoints_;
  int waveDigCurrentPoint_;
  int waveDigExtTrigger_;
  int waveDigExtClock_;
  int waveDigContinuous_;
  int waveDigAutoRestart_;
  int waveDigRetrigger_;
  int waveDigTriggerCount_;
  int waveDigBurstMode_;
  int waveDigRun_;
  int waveDigTimeWF_;
  int waveDigAbsTimeWF_;
  int waveDigReadWF_;
  // Waveform digitizer parameters - per input
  int waveDigVoltWF_;

  // Analog output parameters
  int analogOutValue_;
  int analogOutRange_;

  // Waveform generator parameters - global
  int waveGenFreq_;
  int waveGenDwell_;
  int waveGenDwellActual_;
  int waveGenTotalTime_;
  int waveGenNumPoints_;
  int waveGenCurrentPoint_;
  int waveGenIntDwell_;
  int waveGenUserDwell_;
  int waveGenIntNumPoints_;
  int waveGenUserNumPoints_;
  int waveGenExtTrigger_;
  int waveGenExtClock_;
  int waveGenContinuous_;
  int waveGenRetrigger_;
  int waveGenTriggerCount_;
  int waveGenRun_;
  int waveGenUserTimeWF_;
  int waveGenIntTimeWF_;
  // Waveform generator parameters - per output
  int waveGenWaveType_;
  int waveGenEnable_;
  int waveGenAmplitude_;
  int waveGenOffset_;
  int waveGenPulseWidth_;
  int waveGenIntWF_;
  int waveGenUserWF_;

  // Trigger parameters
  int triggerMode_;

  // Digital I/O parameters
  int digitalDirection_;
  int digitalInput_;
  int digitalOutput_;

private:
  #ifdef _WIN32
    int boardNum_;
  #else
    DaqDeviceHandle daqDeviceHandle_;
  #endif
  DaqDeviceDescriptor daqDeviceDescriptor_;
  char boardName_[MAX_BOARDNAME_LEN];
  int boardType_;
  int boardFamily_;
  const boardEnums_t *pBoardEnums_;
  int numAnalogIn_;
  int analogInTypeConfigurable_;
  int analogInDataRateConfigurable_;
  int analogOutRangeConfigurable_;
  int numAnalogOut_;
  #ifdef linux
    AiInputMode aiInputMode_;
    TriggerType triggerType_;
    int aiScanTrigCount_;  // Not currently used
    int aoScanTrigCount_;  // Not currently used
  #endif
  int ADCResolution_;
  int DACResolution_;
  int numCounters_;
  int firstCounter_;
  int numTimers_;
  int numIOPorts_;
  int numTempChans_;
  int digitalIOPort_[MAX_IO_PORTS];
  int digitalIOBitConfigurable_[MAX_IO_PORTS];
  int digitalIOPortConfigurable_[MAX_IO_PORTS];
  int digitalIOPortWriteOnly_[MAX_IO_PORTS];
  int digitalIOPortReadOnly_[MAX_IO_PORTS];
  int numIOBits_[MAX_IO_PORTS];
  epicsUInt32 digitalIOMask_[MAX_IO_PORTS];
  double minPulseGenFrequency_;
  double maxPulseGenFrequency_;
  double minPulseGenDelay_;
  double maxPulseGenDelay_;
  double pollTime_;
  int forceCallback_[MAX_IO_PORTS];
  size_t maxInputPoints_;
  size_t maxOutputPoints_;
  epicsFloat64 *waveDigBuffer_[MAX_ANALOG_IN];
  epicsFloat32 *waveDigTimeBuffer_;
  epicsFloat64 *waveDigAbsTimeBuffer_;
  epicsFloat32 *waveGenIntBuffer_[MAX_ANALOG_OUT];
  epicsFloat32 *waveGenUserBuffer_[MAX_ANALOG_OUT];
  epicsFloat32 *waveGenUserTimeBuffer_;
  epicsFloat32 *waveGenIntTimeBuffer_;
  epicsFloat64 *pInBuffer_;
  #ifdef _WIN32
    epicsUInt16  *waveGenOutBuffer_;
  #else
    epicsFloat64 *waveGenOutBuffer_;
  #endif
  int numWaveGenChans_;
  int numWaveDigChans_;
  int pulseGenRunning_[MAX_PULSE_GEN];
  int waveGenRunning_;
  int waveDigRunning_;
  int startPulseGenerator(int timerNum);
  int stopPulseGenerator(int timerNum);
  int startWaveGen();
  int stopWaveGen();
  int computeWaveGenTimes();
  int startWaveDig();
  int stopWaveDig();
  int readWaveDig();
  int computeWaveDigTimes();
  int defineWaveform(int channel);
  int setOpenThermocoupleDetect(int addr, int value);
  int reportError(int err, const char *functionName, const char *message);
  #ifdef linux
  int mapRange(int Gain, Range *range);
  int mapTriggerType(int cbwTriggerType, TriggerType *triggerType);
  #endif
};

static void pollerThreadC(void * pPvt)
{
    MultiFunction *pMultiFunction = (MultiFunction *)pPvt;
    pMultiFunction->pollerThread();
}

MultiFunction::MultiFunction(const char *portName, const char *uniqueID, int maxInputPoints, int maxOutputPoints)
  : asynPortDriver(portName, MAX_SIGNALS,
      asynUInt32DigitalMask | asynInt32Mask   | asynInt32ArrayMask   | asynFloat32ArrayMask | 
                              asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask        | asynEnumMask | asynDrvUserMask,
      asynUInt32DigitalMask | asynInt32Mask   | asynInt32ArrayMask   | asynFloat32ArrayMask | 
                              asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask        | asynEnumMask,
      ASYN_MULTIDEVICE | ASYN_CANBLOCK, 1, /* ASYN_CANBLOCK=1, ASYN_MULTIDEVICE=1, autoConnect=1 */
      0, 0),  /* Default priority and stack size */
    maxInputPoints_(maxInputPoints),
    maxOutputPoints_(maxOutputPoints),
    numWaveGenChans_(1),
    numWaveDigChans_(1),
    waveGenRunning_(0),
    waveDigRunning_(0)
{
  int i, j;
  int status;
  long long handle;
  static const char *functionName = "MultiFunction";

  for (i=0; i<MAX_PULSE_GEN; i++) pulseGenRunning_[i]=0;
  for (i=0; i<MAX_IO_PORTS; i++) forceCallback_[i] = 1;

  status = measCompCreateDevice(uniqueID, daqDeviceDescriptor_, &handle);
  if (status) {
    printf("Error creating device with measCompCreateDevice\n");
    return;
  }
  #ifdef _WIN32
    boardNum_ = (int) handle;
    strcpy(boardName_, daqDeviceDescriptor_.ProductName);
    boardType_ = daqDeviceDescriptor_.ProductID;
  #else
    daqDeviceHandle_ = handle;
    strcpy(boardName_, daqDeviceDescriptor_.productName);
    boardType_ = daqDeviceDescriptor_.productId;
  #endif

  // Model parameters
  createParam(modelNameString,                 asynParamOctet,  &modelName_);
  createParam(modelNumberString,               asynParamInt32,  &modelNumber_);
  createParam(firmwareVersionString,            asynParamOctet, &firmwareVersion_);
  createParam(uniqueIDString,                   asynParamOctet, &uniqueID_);
  createParam(ULVersionString,                  asynParamOctet, &ULVersion_);
  createParam(driverVersionString,              asynParamOctet, &driverVersion_);
  createParam(pollSleepMSString,              asynParamFloat64, &pollSleepMS_);
  createParam(pollTimeMSString,               asynParamFloat64, &pollTimeMS_);
  createParam(lastErrorMessageString,           asynParamOctet, &lastErrorMessage_);

  // Pulse generator parameters
  createParam(pulseGenRunString,               asynParamInt32, &pulseGenRun_);
  createParam(pulseGenPeriodString,          asynParamFloat64, &pulseGenPeriod_);
  createParam(pulseGenDutyCycleString,       asynParamFloat64, &pulseGenDutyCycle_);
  createParam(pulseGenDelayString,           asynParamFloat64, &pulseGenDelay_);
  createParam(pulseGenCountString,             asynParamInt32, &pulseGenCount_);
  createParam(pulseGenIdleStateString,         asynParamInt32, &pulseGenIdleState_);

  // Counter parameters
  createParam(counterCountsString,             asynParamInt32, &counterCounts_);
  createParam(counterResetString,              asynParamInt32, &counterReset_);

  // Analog input parameters
  createParam(analogInValueString,             asynParamInt32, &analogInValue_);
  createParam(analogInRangeString,             asynParamInt32, &analogInRange_);
  createParam(analogInTypeString,              asynParamInt32, &analogInType_);
  createParam(analogInModeString,              asynParamInt32, &analogInMode_);
  createParam(analogInRateString,              asynParamInt32, &analogInRate_);

  // Voltage input parameters
  createParam(voltageInValueString,          asynParamFloat64, &voltageInValue_);
  createParam(voltageInRangeString,            asynParamInt32, &voltageInRange_);

  // Temperature parameters
  createParam(temperatureInValueString,      asynParamFloat64, &temperatureInValue_);
  createParam(thermocoupleTypeString,          asynParamInt32, &thermocoupleType_);
  createParam(thermocoupleOpenDetectString,    asynParamInt32, &thermocoupleOpenDetect_);
  createParam(temperatureScaleString,          asynParamInt32, &temperatureScale_);
  createParam(temperatureFilterString,         asynParamInt32, &temperatureFilter_);
  createParam(temperatureSensorString,         asynParamInt32, &temperatureSensor_);
  createParam(temperatureWiringString,         asynParamInt32, &temperatureWiring_);

  // Waveform digitizer parameters - global
  createParam(waveDigDwellString,            asynParamFloat64, &waveDigDwell_);
  createParam(waveDigDwellActualString,      asynParamFloat64, &waveDigDwellActual_);
  createParam(waveDigTotalTimeString,        asynParamFloat64, &waveDigTotalTime_);
  createParam(waveDigFirstChanString,          asynParamInt32, &waveDigFirstChan_);
  createParam(waveDigNumChansString,           asynParamInt32, &waveDigNumChans_);
  createParam(waveDigNumPointsString,          asynParamInt32, &waveDigNumPoints_);
  createParam(waveDigCurrentPointString,       asynParamInt32, &waveDigCurrentPoint_);
  createParam(waveDigExtTriggerString,         asynParamInt32, &waveDigExtTrigger_);
  createParam(waveDigExtClockString,           asynParamInt32, &waveDigExtClock_);
  createParam(waveDigContinuousString,         asynParamInt32, &waveDigContinuous_);
  createParam(waveDigAutoRestartString,        asynParamInt32, &waveDigAutoRestart_);
  createParam(waveDigRetriggerString,          asynParamInt32, &waveDigRetrigger_);
  createParam(waveDigTriggerCountString,       asynParamInt32, &waveDigTriggerCount_);
  createParam(waveDigBurstModeString,          asynParamInt32, &waveDigBurstMode_);
  createParam(waveDigRunString,                asynParamInt32, &waveDigRun_);
  createParam(waveDigTimeWFString,      asynParamFloat32Array, &waveDigTimeWF_);
  createParam(waveDigAbsTimeWFString,   asynParamFloat64Array, &waveDigAbsTimeWF_);
  createParam(waveDigReadWFString,             asynParamInt32, &waveDigReadWF_);
  // Waveform digitizer parameters - per input
  createParam(waveDigVoltWFString,      asynParamFloat32Array, &waveDigVoltWF_);

  // Analog output parameters
  createParam(analogOutValueString,            asynParamInt32, &analogOutValue_);
  createParam(analogOutRangeString,            asynParamInt32, &analogOutRange_);

  // Waveform generator parameters - global
  createParam(waveGenFreqString,             asynParamFloat64, &waveGenFreq_);
  createParam(waveGenDwellString,            asynParamFloat64, &waveGenDwell_);
  createParam(waveGenDwellActualString,      asynParamFloat64, &waveGenDwellActual_);
  createParam(waveGenTotalTimeString,        asynParamFloat64, &waveGenTotalTime_);
  createParam(waveGenNumPointsString,          asynParamInt32, &waveGenNumPoints_);
  createParam(waveGenCurrentPointString,       asynParamInt32, &waveGenCurrentPoint_);
  createParam(waveGenIntDwellString,         asynParamFloat64, &waveGenIntDwell_);
  createParam(waveGenUserDwellString,        asynParamFloat64, &waveGenUserDwell_);
  createParam(waveGenIntNumPointsString,       asynParamInt32, &waveGenIntNumPoints_);
  createParam(waveGenUserNumPointsString,      asynParamInt32, &waveGenUserNumPoints_);
  createParam(waveGenExtTriggerString,         asynParamInt32, &waveGenExtTrigger_);
  createParam(waveGenExtClockString,           asynParamInt32, &waveGenExtClock_);
  createParam(waveGenContinuousString,         asynParamInt32, &waveGenContinuous_);
  createParam(waveGenRetriggerString,          asynParamInt32, &waveGenRetrigger_);
  createParam(waveGenTriggerCountString,       asynParamInt32, &waveGenTriggerCount_);
  createParam(waveGenRunString,                asynParamInt32, &waveGenRun_);
  createParam(waveGenUserTimeWFString,  asynParamFloat32Array, &waveGenUserTimeWF_);
  createParam(waveGenIntTimeWFString,   asynParamFloat32Array, &waveGenIntTimeWF_);
  // Waveform generator parameters - per output
  createParam(waveGenWaveTypeString,           asynParamInt32, &waveGenWaveType_);
  createParam(waveGenEnableString,             asynParamInt32, &waveGenEnable_);
  createParam(waveGenAmplitudeString,        asynParamFloat64, &waveGenAmplitude_);
  createParam(waveGenOffsetString,           asynParamFloat64, &waveGenOffset_);
  createParam(waveGenPulseWidthString,       asynParamFloat64, &waveGenPulseWidth_);
  createParam(waveGenIntWFString,       asynParamFloat32Array, &waveGenIntWF_);
  createParam(waveGenUserWFString,      asynParamFloat32Array, &waveGenUserWF_);

  // Trigger parameters
  createParam(triggerModeString,               asynParamInt32, &triggerMode_);

  // Digital I/O parameters
  createParam(digitalDirectionString,  asynParamUInt32Digital, &digitalDirection_);
  createParam(digitalInputString,      asynParamUInt32Digital, &digitalInput_);
  createParam(digitalOutputString,     asynParamUInt32Digital, &digitalOutput_);

  // Map very similar boards for simplicity
  boardFamily_ = boardType_;
  switch (boardType_) {
    case USB_1208LS:
    case USB_1208FS_PLUS:
      boardFamily_ = USB_1208LS;
      break;
    case USB_1608G:
    case USB_1608GX:
    case USB_1608GX_2AO:
    case USB_1608GX_2AO_OLD:
    case USB_1608HS_2AO:
      boardFamily_ = USB_1608G;
      break;
    case USB_1808:
    case USB_1808X:
      boardFamily_ = USB_1808;
      break;
    case USB_3101:
    case USB_3102:
    case USB_3103:
    case USB_3104:
    case USB_3105:
    case USB_3106:
    case USB_3110:
    case USB_3112:
    case USB_3114:
      boardFamily_ = USB_3101;
      break;
    case USB_TC32:
    case ETH_TC32:
      boardFamily_ = USB_TC32;
      break;
    default:
      break;
  }

  char uniqueIDStr[256];
  char firmwareVersion[256];
  char ULVersion[256];
  ULMutex.lock();
  #ifdef _WIN32
    int size = sizeof(uniqueIDStr);
    cbGetConfigString(BOARDINFO, boardNum_, 0, BIDEVUNIQUEID, uniqueIDStr, &size);
    size = sizeof(firmwareVersion);
    cbGetConfigString(BOARDINFO, boardNum_, VER_FW_MAIN, BIDEVVERSION, firmwareVersion, &size);
    float DLLRevNum, VXDRevNum;
    cbGetRevision(&DLLRevNum, &VXDRevNum);
    sprintf(ULVersion, "%f %f", DLLRevNum, VXDRevNum);
  #else
    strcpy(uniqueIDStr, uniqueID);
    unsigned int size = sizeof(firmwareVersion);
    ulDevGetConfigStr(daqDeviceHandle_, ::DEV_CFG_VER_STR, DEV_VER_FW_MAIN, firmwareVersion, &size);
    size = sizeof(ULVersion);
    ulGetInfoStr(UL_INFO_VER_STR, 0, ULVersion, &size);
  #endif
  setIntegerParam(modelNumber_, boardType_);
  setStringParam(modelName_, boardName_);
  setStringParam(uniqueID_, uniqueIDStr);
  setStringParam(firmwareVersion_, firmwareVersion);
  setStringParam(ULVersion_, ULVersion);
  setStringParam(driverVersion_, DRIVER_VERSION);
  
  #ifdef _WIN32
    int inMask, outMask;
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMADCHANS,    &numAnalogIn_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMDACHANS,    &numAnalogOut_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIADRES,         &ADCResolution_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIDACRES,        &DACResolution_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BIDINUMDEVS,     &numIOPorts_);
    cbGetConfig(BOARDINFO, boardNum_, 0, BINUMTEMPCHANS,  &numTempChans_);
  #else
    long long infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_NUM_CHANS_BY_TYPE, AI_VOLTAGE, &infoValue);
    if (status)
      numAnalogIn_ = 0;
    else
      numAnalogIn_ = infoValue;
    status = ulAOGetInfo(daqDeviceHandle_, AO_INFO_NUM_CHANS, 0, &infoValue);
    if (status)
      numAnalogOut_ = 0;
    else
      numAnalogOut_ = infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_RESOLUTION, 0, &infoValue);
    ADCResolution_ = infoValue;
    status = ulAOGetInfo(daqDeviceHandle_, AO_INFO_RESOLUTION, 0, &infoValue);
    DACResolution_ = infoValue;
    status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_NUM_PORTS, 0, &infoValue);
    numIOPorts_ = infoValue;
    status = ulAIGetInfo(daqDeviceHandle_, AI_INFO_NUM_CHANS_BY_TYPE, AI_TC, &infoValue);
    numTempChans_ = infoValue;
  #endif
  if (numIOPorts_ > MAX_IO_PORTS) numIOPorts_ = MAX_IO_PORTS;
  for (i=0; i<numIOPorts_; i++) {
    digitalIOPortConfigurable_[i] = 0;
    #ifdef _WIN32
      cbGetConfig(DIGITALINFO, boardNum_, i, DIDEVTYPE, &digitalIOPort_[i]);
      cbGetConfig(DIGITALINFO, boardNum_, i, DIINMASK,  &inMask);
      cbGetConfig(DIGITALINFO, boardNum_, i, DIOUTMASK, &outMask);
      digitalIOPortReadOnly_[i]    = ((inMask != 0) && (outMask == 0));
      digitalIOPortWriteOnly_[i]   = ((inMask == 0) && (outMask != 0));
      digitalIOBitConfigurable_[i] = ((inMask & outMask) == 0);
      cbGetConfig(DIGITALINFO, boardNum_, i, DINUMBITS, &numIOBits_[i]);
    #else
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_PORT_TYPE, i, &infoValue);
      digitalIOPort_[i] = infoValue;
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_PORT_IO_TYPE, i, &infoValue);
      digitalIOPortReadOnly_[i]    = (infoValue == DPIOT_IN);
      digitalIOPortWriteOnly_[i]   = (infoValue == DPIOT_OUT);
      digitalIOBitConfigurable_[i] = (infoValue == DPIOT_BITIO);
      status = ulDIOGetInfo(daqDeviceHandle_, DIO_INFO_NUM_BITS, i, &infoValue);
      numIOBits_[i] = infoValue;
    #endif
    digitalIOMask_[i] = 0;
    for (j=0; j<numIOBits_[i]; j++) {
      digitalIOMask_[i] |= (1 << j);
    }
  }
  ULMutex.unlock();
  // Assume only voltage input is supported
  analogInTypeConfigurable_ = 0;
  // Assume analog in data rate not configurable
  analogInDataRateConfigurable_ = 0;
  // Assume analog output range is not configurable
  analogOutRangeConfigurable_ = 0;
  switch (boardFamily_) {
    case USB_231:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      // For output need to address all bits using first port
      numIOBits_[0] = 8;
      // The rules for bit configurable above don't work for this model
      digitalIOPortConfigurable_[0] = 1;
      digitalIOPortConfigurable_[1] = 1;
      digitalIOBitConfigurable_[0] = 0;
      digitalIOPortConfigurable_[1] = 1;
      break;
    case USB_1208LS:
    case USB_1208FS:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 1;
      // For output need to address all bits using first port
      numIOBits_[0] = 16;
      // The rules for bit configurable above don't work for this model
      digitalIOPortConfigurable_[0] = 1;
      digitalIOPortConfigurable_[1] = 1;
      digitalIOBitConfigurable_[0] = 0;
      digitalIOPortConfigurable_[1] = 1;
      break;
    case USB_1608G:
      numTimers_    = 1;
      numCounters_  = 2;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 32e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 67.11;
      break;
    case USB_1608HS_2AO:
      numTimers_    = 1;
      numCounters_  = 1;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 32e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 67.11;
      break;
    case USB_1808:
      numTimers_    = 2;
      numCounters_  = 4;
      firstCounter_ = 0;
      minPulseGenFrequency_ = 0.0149;
      maxPulseGenFrequency_ = 50e6;
      minPulseGenDelay_ = 0.;
      maxPulseGenDelay_ = 42.94;
      break;
    case USB_2408_2AO:
      numTimers_    = 0;
      numCounters_  = 2;
      firstCounter_ = 0;
      analogInTypeConfigurable_  = 1; // Supports voltage and thermocouple
      analogInDataRateConfigurable_ = 1; // Can configure analog input data rate
      break;
    case USB_3101:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      analogOutRangeConfigurable_ = 1; // Can select 0-10V or +-10V
      break;
    case USB_SSR08:
      numTimers_    = 0;
      numCounters_  = 0;
      for (i=0; i<2; i++) {
        // Digital I/O port 0 is outputs 1 - 4      
        // Digital I/O port 1 is outputs 5 - 8      
        setUIntDigitalParam(i, digitalDirection_, 0xFFFFFFFF, digitalIOMask_[i]);
      }
      break;
    case USB_TEMP:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<8; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      break;
    case USB_TEMP_AI:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<4; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      for (i=4; i<8; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_VOLTAGE);
      }
      break;
    case USB_TC32:
      numTimers_    = 0;
      numCounters_  = 0;
      for (i=0; i<MAX_TEMPERATURE_IN; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      // On Linux the TC-32 reports that numIOPorts_ = 4, but it is really only 2
      // This should be fixed in uldaq.
      #ifdef linux
        numIOPorts_ = 2;
      #endif
      // Digital I/O port 0 is input only
      setUIntDigitalParam(0, digitalDirection_, 0, 0xFFFFFFFF);
      // Digital I/O port 1 is output and temperature alarms
      setUIntDigitalParam(1, digitalDirection_, 0xFFFFFFFF, 0xFFFFFFFF);
      break;
    case E_1608:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      break;
    case E_DIO24:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      break;
    case E_TC:
      numTimers_    = 0;
      numCounters_  = 1;
      firstCounter_ = 0;
      for (i=0; i<MAX_TEMPERATURE_IN; i++) {
        setIntegerParam(i, analogInType_, AI_CHAN_TYPE_TC);
      }
      break;
    default:
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error, unknown board type=%d, board family=%d\n",
        driverName, functionName, boardType_, boardFamily_);
      break;
  }

  for (i=0, pBoardEnums_=0; i<maxBoardFamilies; i++) {
    if (allBoardEnums[i].boardFamily == boardFamily_) {
       pBoardEnums_ = &allBoardEnums[i];
       break;
    }
  }
  if (pBoardEnums_ == 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error, unknown board family=%d\n",
      driverName, functionName, boardFamily_);
  }

  // Allocate memory for the input and output buffers
  for (i=0; i<numAnalogIn_; i++) {
    waveDigBuffer_[i]  = (epicsFloat64 *) calloc(maxInputPoints_,  sizeof(epicsFloat64));
  }
  for (i=0; i<numAnalogOut_; i++) {
    waveGenIntBuffer_[i]  = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
    waveGenUserBuffer_[i] = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  }
  waveGenUserTimeBuffer_ = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  waveGenIntTimeBuffer_  = (epicsFloat32 *) calloc(maxOutputPoints_, sizeof(epicsFloat32));
  waveDigTimeBuffer_     = (epicsFloat32 *) calloc(maxInputPoints_,  sizeof(epicsFloat32));
  waveDigAbsTimeBuffer_  = (epicsFloat64 *) calloc(maxInputPoints_,  sizeof(epicsFloat64));
  pInBuffer_ = (epicsFloat64 *) calloc(maxInputPoints  * numAnalogIn_, sizeof(epicsFloat64));
  #ifdef _WIN32
    waveGenOutBuffer_ = (epicsUInt16 *) calloc(maxOutputPoints * numAnalogOut_, sizeof(epicsUInt16));
  #else
    waveGenOutBuffer_ = (epicsFloat64 *) calloc(maxOutputPoints * numAnalogOut_, sizeof(epicsFloat64));
  #endif

  // Set values of some parameters that need to be set because init record order is not predictable
  // or because the corresponding records are PINI=NO.
  setIntegerParam(waveGenUserNumPoints_, 1);
  setIntegerParam(waveGenIntNumPoints_, 1);
  setIntegerParam(waveDigNumPoints_, 1);
  setIntegerParam(pulseGenRun_, 0);
  setIntegerParam(waveDigRun_, 0);
  setIntegerParam(waveGenRun_, 0);
  for (i=0; i<numTempChans_; i++) {
    setIntegerParam(i, thermocoupleType_, TC_TYPE_J);
  }
  // Set the analog output range to the first supported value for this model
  for (i=0; i<MAX_ANALOG_OUT; i++) {
    setIntegerParam(i, analogOutRange_, pBoardEnums_->pOutputRange[0].enumValue);
  }

  /* Start the thread to poll counters and digital inputs and do callbacks to
   * device support */
  epicsThreadCreate("MultiFunctionPoller",
                    epicsThreadPriorityLow,
                    epicsThreadGetStackSize(epicsThreadStackMedium),
                    (EPICSTHREADFUNC)pollerThreadC,
                    this);
}

int  MultiFunction::reportError(int err, const char *functionName, const char *message)
{
  char libraryMessage[MAX_LIBRARY_MESSAGE_LEN];
  ULMutex.lock();
  switch (err) {
    case 0: 
      asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
        "%s::%s Info: %s\n", driverName, functionName, message);
      break;
    case -1: 
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s Error: %s\n", driverName, functionName, message);
      break;
    default:
      #ifdef _WIN32
        cbGetErrMsg(err, libraryMessage);
      #else
        ulGetErrMsg((UlError)err, libraryMessage);
      #endif
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s Error: %s, err=%d %s\n", driverName, functionName, message, err, libraryMessage);
  }
  ULMutex.unlock();
  return err;
}

#ifdef linux
int MultiFunction::mapRange(int Gain, Range *range)
{
    static const char *functionName = "mapRange";
    // Converts cbw Gain to uldaq Range
    switch (Gain) {
      case CBW_BIP60VOLTS:    *range = BIP60VOLTS; break;
      case CBW_BIP30VOLTS:    *range = BIP30VOLTS; break;
      case CBW_BIP20VOLTS:    *range = BIP20VOLTS; break;
      case CBW_BIP15VOLTS:    *range = BIP15VOLTS; break;
      case CBW_BIP10VOLTS:    *range = BIP10VOLTS; break;
      case CBW_BIP5VOLTS:     *range = BIP5VOLTS; break;
      case CBW_BIP4VOLTS:     *range = BIP4VOLTS; break;
      case CBW_BIP2PT5VOLTS:  *range = BIP2PT5VOLTS; break;
      case CBW_BIP2VOLTS:     *range = BIP2VOLTS; break;
      case CBW_BIP1PT25VOLTS: *range = BIP1PT25VOLTS; break;
      case CBW_BIP1VOLTS:     *range = BIP1VOLTS; break;
      case CBW_BIPPT625VOLTS: *range = BIPPT625VOLTS; break;
      case CBW_BIPPT5VOLTS:   *range = BIPPT5VOLTS; break;
      case CBW_BIPPT25VOLTS:  *range = BIPPT25VOLTS; break;
      case CBW_BIPPT2VOLTS:   *range = BIPPT2VOLTS; break;
      case CBW_BIPPT1VOLTS:   *range = BIPPT1VOLTS; break;
      case CBW_BIPPT05VOLTS:  *range = BIPPT05VOLTS; break;
      case CBW_BIPPT01VOLTS:  *range = BIPPT01VOLTS; break;
      case CBW_BIPPT005VOLTS: *range = BIPPT005VOLTS; break;
//      case CBW_BIP1PT67VOLTS: *range = BIP1PT67VOLTS; break;
      case CBW_BIPPT312VOLTS: *range = BIPPT312VOLTS; break;
      case CBW_BIPPT156VOLTS: *range = BIPPT156VOLTS; break;
      case CBW_BIPPT125VOLTS: *range = BIPPT125VOLTS; break;
      case CBW_BIPPT078VOLTS: *range = BIPPT078VOLTS; break;

      case CBW_UNI10VOLTS:    *range = UNI10VOLTS; break;
      case CBW_UNI5VOLTS:     *range = UNI5VOLTS; break;
      case CBW_UNI4VOLTS:     *range = UNI4VOLTS; break;
      case CBW_UNI2PT5VOLTS:  *range = UNI2PT5VOLTS; break;
      case CBW_UNI2VOLTS:     *range = UNI2VOLTS; break;
//      case CBW_UNI1PT67VOLTS: *range = UNI1PT67VOLTS; break;
      case CBW_UNI1PT25VOLTS: *range = UNI1PT25VOLTS; break;
      case CBW_UNI1VOLTS:     *range = UNI1VOLTS; break;
      case CBW_UNIPT5VOLTS:   *range = UNIPT5VOLTS; break;
      case CBW_UNIPT25VOLTS:  *range = UNIPT25VOLTS; break;
      case CBW_UNIPT2VOLTS:   *range = UNIPT2VOLTS; break;
      case CBW_UNIPT1VOLTS:   *range = UNIPT1VOLTS; break;
      case CBW_UNIPT05VOLTS:  *range = UNIPT05VOLTS; break;
//      case CBW_UNIPT02VOLTS:  *range = UNIPT02VOLTS; break;
      case CBW_UNIPT01VOLTS:  *range = UNIPT01VOLTS; break;

      case CBW_MA0TO20:       *range = MA0TO20; break;
      default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
            "%s::%s unsupported gain=%d\n", driverName, functionName, Gain);
          return -1;
    }
    return 0;
}

// This function maps the trigger types from UL on Windows to the values in UL for Linux.
// We can't use the macros from Windows cbw.h because they conflict with UL for Linux.
// These definitions are taken from cbw.h, but added CBW_ prefix.

#define CBW_TRIGABOVE           0
#define CBW_TRIGBELOW           1
#define CBW_GATE_NEG_HYS        2
#define CBW_GATE_POS_HYS        3
#define CBW_GATE_ABOVE          4
#define CBW_GATE_BELOW          5
#define CBW_GATE_IN_WINDOW      6
#define CBW_GATE_OUT_WINDOW     7
#define CBW_GATE_HIGH           8
#define CBW_GATE_LOW            9
#define CBW_TRIG_HIGH           10
#define CBW_TRIG_LOW            11
#define CBW_TRIG_POS_EDGE       12
#define CBW_TRIG_NEG_EDGE       13
#define CBW_TRIG_RISING         14
#define CBW_TRIG_FALLING        15
#define CBW_TRIG_PATTERN_EQ     16
#define CBW_TRIG_PATTERN_NE     17
#define CBW_TRIG_PATTERN_ABOVE  18
#define CBW_TRIG_PATTERN_BELOW  19

int MultiFunction::mapTriggerType(int cbwTriggerType, TriggerType *triggerType)
{
    static const char *functionName = "mapTriggerType";
    // Converts cbw trigger type to uldaq trigger type;
    switch (cbwTriggerType) {
      case CBW_TRIG_POS_EDGE:       *triggerType = TRIG_POS_EDGE; break;
      case CBW_TRIG_NEG_EDGE:       *triggerType = TRIG_NEG_EDGE; break;
      case CBW_TRIG_HIGH:           *triggerType = TRIG_HIGH; break;
      case CBW_TRIG_LOW:            *triggerType = TRIG_LOW; break;
      case CBW_GATE_HIGH:           *triggerType = GATE_HIGH; break;
      case CBW_GATE_LOW:            *triggerType = GATE_LOW; break;
      case CBW_TRIG_RISING:         *triggerType = TRIG_RISING; break;
      case CBW_TRIG_FALLING:        *triggerType = TRIG_FALLING; break;
      case CBW_TRIGABOVE:           *triggerType = TRIG_ABOVE; break;
      case CBW_TRIGBELOW:           *triggerType = TRIG_BELOW; break;
      case CBW_GATE_ABOVE:          *triggerType = GATE_ABOVE; break;
      case CBW_GATE_BELOW:          *triggerType = GATE_BELOW; break;
      case CBW_GATE_IN_WINDOW:      *triggerType = GATE_IN_WINDOW; break;
      case CBW_GATE_OUT_WINDOW:     *triggerType = GATE_OUT_WINDOW; break;
      case CBW_TRIG_PATTERN_EQ:     *triggerType = TRIG_PATTERN_EQ; break;
      case CBW_TRIG_PATTERN_NE:     *triggerType = TRIG_PATTERN_NE; break;
      case CBW_TRIG_PATTERN_ABOVE:  *triggerType = TRIG_PATTERN_ABOVE; break;
      case CBW_TRIG_PATTERN_BELOW:  *triggerType = TRIG_PATTERN_BELOW; break;
      default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s unsupported cbwTriggerType=%d\n", driverName, functionName, cbwTriggerType);
          *triggerType = TRIG_NONE;
          return -1;
    }
    return 0;
}

#endif

int MultiFunction::startPulseGenerator(int timerNum)
{
  int status=0;
  double frequency, period, delay;
  double dutyCycle;
  int count, idleState;
  static const char *functionName = "startPulseGenerator";

  getDoubleParam (timerNum, pulseGenPeriod_,    &period);
  getDoubleParam (timerNum, pulseGenDutyCycle_, &dutyCycle);
  getDoubleParam (timerNum, pulseGenDelay_,     &delay);
  getIntegerParam(timerNum, pulseGenCount_,     &count);
  getIntegerParam(timerNum, pulseGenIdleState_, &idleState);

  frequency = 1./period;
  if (frequency < minPulseGenFrequency_) frequency = minPulseGenFrequency_;
  if (frequency > maxPulseGenFrequency_) frequency = maxPulseGenFrequency_;
  period = 1. / frequency;
  if (dutyCycle <= 0.) dutyCycle = .0001;
  if (dutyCycle >= 1.) dutyCycle = .9999;
  if (delay < minPulseGenDelay_) delay = minPulseGenDelay_;
  if (delay > maxPulseGenDelay_) delay = maxPulseGenDelay_;

  ULMutex.lock();
  #ifdef _WIN32
    status = cbPulseOutStart(boardNum_, timerNum, &frequency, &dutyCycle, count, &delay, idleState, 0);
  #else
    TmrIdleState idle = (idleState == 0) ? TMRIS_LOW : TMRIS_HIGH;
    status = ulTmrPulseOutStart(daqDeviceHandle_, timerNum, &frequency, &dutyCycle, count, &delay, idle, PO_DEFAULT);
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling PulseOutStart");
  if (status) return status;
  // We may not have gotten the frequency, dutyCycle, and delay we asked for, set the actual values
  // in the parameter library
  pulseGenRunning_[timerNum] = 1;
  period = 1. / frequency;
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: started pulse generator %d actual frequency=%f, actual period=%f, actual duty cycle=%f, actual delay=%f\n",
    driverName, functionName, timerNum, frequency, period, dutyCycle, delay);
  setDoubleParam(timerNum, pulseGenPeriod_, period);
  setDoubleParam(timerNum, pulseGenDutyCycle_, dutyCycle);
  setDoubleParam(timerNum, pulseGenDelay_, delay);
  return 0;
}

int MultiFunction::stopPulseGenerator(int timerNum)
{
  pulseGenRunning_[timerNum] = 0;
  int err;
  ULMutex.lock();
  #ifdef _WIN32
    err = cbPulseOutStop(boardNum_, timerNum);
  #else
    err = ulTmrPulseOutStop(daqDeviceHandle_, timerNum);
  #endif
  ULMutex.unlock();
  return err;
}

int MultiFunction::defineWaveform(int channel)
{
  int waveType;
  int numPoints;
  int nPulse;
  int i;
  epicsFloat32 *outPtr = waveGenIntBuffer_[channel];
  double dwell, offset, base, amplitude, pulseWidth, scale;
  static const char *functionName = "defineWaveform";

  getIntegerParam(channel, waveGenWaveType_,  &waveType);
  if (waveType == waveTypeUser) {
    getIntegerParam(waveGenUserNumPoints_, &numPoints);
    if ((size_t)numPoints > maxOutputPoints_) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s:%s: ERROR numPoints=%d must be less than maxOutputPoints=%d\n",
        driverName, functionName, numPoints, (int)maxOutputPoints_);
      return -1;
    }
    getDoubleParam(waveGenUserDwell_, &dwell);
    setIntegerParam(waveGenNumPoints_, numPoints);
    setDoubleParam(waveGenDwell_, dwell);
    setDoubleParam(waveGenFreq_, 1./dwell/numPoints);
    return 0;
  }

  getIntegerParam(waveGenIntNumPoints_,  &numPoints);
  if ((size_t)numPoints > maxOutputPoints_) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s:%s: ERROR numPoints=%d must be less than maxOutputPoints=%d\n",
      driverName, functionName, numPoints, (int)maxOutputPoints_);
    return -1;
  }

  getDoubleParam(waveGenIntDwell_,             &dwell);
  getDoubleParam(channel, waveGenOffset_,      &offset);
  getDoubleParam(channel, waveGenAmplitude_,   &amplitude);
  getDoubleParam(channel, waveGenPulseWidth_,  &pulseWidth);
  setIntegerParam(waveGenNumPoints_, numPoints);
  setDoubleParam(waveGenDwell_, dwell);
  setDoubleParam(waveGenFreq_, 1./dwell/numPoints);
  base = offset - amplitude/2.;
  switch (waveType) {
    case waveTypeSin:
      scale = 2.*PI/(numPoints-1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (offset + amplitude/2. * sin(i*scale));
      break;
    case waveTypeSquare:
      for (i=0; i<numPoints/2; i++)         *outPtr++ = (epicsFloat32) (base + amplitude);
      for (i=numPoints/2; i<numPoints; i++) *outPtr++ = (epicsFloat32) (base);
      break;
    case waveTypeSawTooth:
      scale = 1./(numPoints-1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (base + amplitude*i*scale);
      break;
    case waveTypePulse:
      nPulse = (int) ((pulseWidth / dwell) + 0.5);
      if (nPulse < 1) nPulse = 1;
      if (nPulse >= numPoints-1) nPulse = numPoints-1;
      for (i=0; i<nPulse; i++)              *outPtr++ = (epicsFloat32) (base + amplitude);
      for (i=nPulse; i<numPoints; i++)      *outPtr++ = (epicsFloat32) (base);
      break;
    case waveTypeRandom:
      scale = amplitude / RAND_MAX;
      srand(1);
      for (i=0; i<numPoints; i++)           *outPtr++ = (epicsFloat32) (base + rand() * scale);
      break;
  }
  doCallbacksFloat32Array(waveGenIntBuffer_[channel], numPoints, waveGenIntWF_, channel);
  return 0;
}

int MultiFunction::startWaveGen()
{
  int status=0;
  int numPoints;
  int enable;
  int firstChan=-1, lastChan=-1, firstType=-1;
  int waveType;
  int extTrigger, extClock, continuous, retrigger;
  int options;
  int i, j, k;
  double offset, scale;
  double userOffset, userAmplitude;
  double dwell;
  epicsFloat32* inPtr[MAX_ANALOG_OUT];
  #ifdef _WIN32
    epicsUInt16 *outPtr;
  #else
    epicsFloat64 *outPtr;
  #endif
  static const char *functionName = "startWaveGen";

  getIntegerParam(waveGenExtTrigger_, &extTrigger);
  getIntegerParam(waveGenExtClock_,   &extClock);
  getIntegerParam(waveGenContinuous_, &continuous);
  getIntegerParam(waveGenRetrigger_,  &retrigger);

  for (i=0; i<numAnalogOut_; i++) {
    getIntegerParam(i, waveGenEnable_, &enable);
    if (!enable) continue;
    getIntegerParam(i, waveGenWaveType_,  &waveType);
    if (waveType == waveTypeUser)
      inPtr[i] = waveGenUserBuffer_[i];
    else
      inPtr[i] = waveGenIntBuffer_[i];
    if (firstChan < 0) {
      firstChan = i;
      firstType = waveType;
    }
    // Cannot mix user-defined and internal waveform types, because internal modifies dwell time
    // based on frequency
    if (((firstType == waveTypeUser) && (waveType != waveTypeUser)) ||
        ((firstType != waveTypeUser) && (waveType == waveTypeUser))) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s:%s: ERROR if any enabled waveform type is user-defined then all must be.\n",
        driverName, functionName);
      return -1;
    }
    lastChan = i;
    status = defineWaveform(i);
    if (status) return -1;
  }

  if (firstChan < 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s:%s: ERROR no enabled channels\n",
      driverName, functionName);
     return -1;
  }

  numWaveGenChans_ = lastChan - firstChan + 1;

  // dwell and numPoints were computed by defineWaveform above
  getIntegerParam(waveGenNumPoints_, &numPoints);
  getDoubleParam(waveGenDwell_, &dwell);
 
  // Copy data from float32 array to outputMemHandel, converting from volts to D/A units
  // Pre-defined waveforms have been fully defined at this point
  // User-defined waveforms need to have the offset and scale applied
  for (i=0; i<numWaveGenChans_; i++) {
    k = firstChan + i;
    outPtr = &(waveGenOutBuffer_[i]);
    offset = 10.;        // Mid-scale range of DAC
    scale = 65535./20.;  // D/A units per volt; 16-bit DAC, +-10V range
    if (waveType == waveTypeUser) {
      getDoubleParam(i, waveGenOffset_, &userOffset);
      getDoubleParam(i, waveGenAmplitude_,  &userAmplitude);
    } else {
      userOffset = 0.;
      userAmplitude = 1.0;
    }
    for (j=0; j<numPoints; j++) {
     *outPtr = (epicsUInt16)((inPtr[k][j]*userAmplitude + userOffset + offset)*scale + 0.5);
      outPtr += numWaveGenChans_;
    }
  }
  ULMutex.lock();
  #ifdef _WIN32
    long pointsPerSecond = (long)((1. / dwell) + 0.5);
    options                  = BACKGROUND;
    if (extTrigger) options |= EXTTRIGGER;
    if (extClock)   options |= EXTCLOCK;
    if (continuous) options |= CONTINUOUS;
    if (retrigger)  options |= RETRIGMODE;
    status = cbAOutScan(boardNum_, firstChan, lastChan, numWaveGenChans_*numPoints, &pointsPerSecond, BIP10VOLTS,
                        waveGenOutBuffer_, options);
    // Convert back from pointsPerSecond to dwell, since value might have changed
    dwell = (1. / pointsPerSecond);
  #else
    options                  = SO_DEFAULTIO;
    if (extTrigger) options |= SO_EXTTRIGGER;
    if (extClock)   options |= SO_EXTCLOCK;
    if (continuous) options |= SO_CONTINUOUS;
    if (retrigger)  options |= SO_RETRIGGER;
    double rate = 1./dwell;
    status = ulAOutScan(daqDeviceHandle_, firstChan, lastChan, BIP10VOLTS, numPoints, &rate, (ScanOption) options, AOUTSCAN_FF_NOSCALEDATA, waveGenOutBuffer_);
    // Convert back from rate to dwell, since value might have changed
    dwell = 1./rate;
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling AOutScan");

  if (status) return status;

  waveGenRunning_ = 1;
  setIntegerParam(waveGenRun_, 1);
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: called cbAOutScan, firstChan=%d, lastChan=%d, numPoints*numWaveGenChans_=%d, dwell=%f, options=0x%x\n",
    driverName, functionName, firstChan, lastChan,  numWaveGenChans_*numPoints, dwell, options);

  setDoubleParam(waveGenDwellActual_, dwell);
  setDoubleParam(waveGenTotalTime_, dwell*numPoints);
  return status;
}

int MultiFunction::stopWaveGen()
{
  int err;
  waveGenRunning_ = 0;
  setIntegerParam(waveGenRun_, 0);
  ULMutex.lock();
  #ifdef _WIN32
    err = cbStopBackground(boardNum_, AOFUNCTION);
  #else
    err = ulAOutScanStop(daqDeviceHandle_);
  #endif
  ULMutex.unlock();
  return err;
}

int MultiFunction::computeWaveGenTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(waveGenUserNumPoints_, &numPoints);
  getDoubleParam(waveGenUserDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveGenUserTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveGenUserTimeBuffer_, numPoints, waveGenUserTimeWF_, 0);

  getIntegerParam(waveGenIntNumPoints_, &numPoints);
  getDoubleParam(waveGenIntDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveGenIntTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveGenIntTimeBuffer_, numPoints, waveGenIntTimeWF_, 0);
  return 0;
}

int MultiFunction::startWaveDig()
{
  int firstChan, lastChan, numChans, numPoints;
  int chan, range;
  short gainArray[MAX_ANALOG_IN], chanArray[MAX_ANALOG_IN];
  int i;
  int extTrigger, extClock, continuous, retrigger, burstMode;
  int status;
  int options;
  double dwell;
  bool invalidScanRate=false;
  static const char *functionName = "startWaveDig";

  getIntegerParam(waveDigNumPoints_,  &numPoints);
  getIntegerParam(waveDigFirstChan_,  &firstChan);
  getIntegerParam(waveDigNumChans_,   &numChans);
  numWaveDigChans_ = numChans;
  getIntegerParam(waveDigExtTrigger_, &extTrigger);
  getIntegerParam(waveDigExtClock_,   &extClock);
  getIntegerParam(waveDigContinuous_, &continuous);
  getIntegerParam(waveDigRetrigger_,  &retrigger);
  getIntegerParam(waveDigBurstMode_,  &burstMode);
  getDoubleParam(waveDigDwell_, &dwell);

  lastChan = firstChan + numChans - 1;
  setIntegerParam(waveDigCurrentPoint_, 0);

  // Construct the gain array
  for (i=0; i<numChans; i++) {
    chan = firstChan + i;
    chanArray[i] = chan;
    getIntegerParam(chan, analogInRange_, &range);
    gainArray[i] = range;
  }
  ULMutex.lock();
  #ifdef _WIN32
    status = cbALoadQueue(boardNum_, chanArray, gainArray, numChans);
  #else
    AiQueueElement *queue = new AiQueueElement[numChans];
    for (int i=0; i<numChans; i++) {
        queue[i].channel = chanArray[i];
        queue[i].inputMode = aiInputMode_ == DIFFERENTIAL ? AI_DIFFERENTIAL : AI_SINGLE_ENDED;
        mapRange(gainArray[i], &queue[i].range);
    }
    status = ulAInLoadQueue(daqDeviceHandle_, queue, numChans);
    delete[] queue;
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Calling ALoadQueue");
  if (status) return status;

  ULMutex.lock();
  #ifdef _WIN32
    long pointsPerSecond = (long)((1. / dwell) + 0.5);
    options                  = BACKGROUND;
    options                 |= SCALEDATA;
    if (extTrigger) options |= EXTTRIGGER;
    if (extClock)   options |= EXTCLOCK;
    if (continuous) options |= CONTINUOUS;
    if (retrigger)  options |= RETRIGMODE;
    if (burstMode)  options |= BURSTMODE;
    status = cbAInScan(boardNum_, firstChan, lastChan, numWaveDigChans_*numPoints, &pointsPerSecond, BIP10VOLTS,
                       pInBuffer_, options);
    if (status == BADRATE) invalidScanRate = true;
    // Convert back from pointsPerSecond to dwell, since value might have changed
    dwell = (1. / pointsPerSecond);
  #else
    double rate = 1./dwell;
    options                  = SO_DEFAULTIO;
    if (extTrigger) options |= SO_EXTTRIGGER;
    if (extClock)   options |= SO_EXTCLOCK;
    if (continuous) options |= SO_CONTINUOUS;
    if (retrigger)  options |= SO_RETRIGGER;
    if (burstMode)  options |= SO_BURSTMODE;
    // This is equivalent to OPTIONS |= SCALEDATA on Windows
    AInScanFlag flags = AINSCAN_FF_DEFAULT;
    status = ulAInScan(daqDeviceHandle_, firstChan, lastChan, aiInputMode_, BIP10VOLTS, numPoints, &rate, (ScanOption) options, flags, pInBuffer_);
    if (status == ERR_BAD_RATE) invalidScanRate = true;
     // Convert back from rate to dwell, since value might have changed
    dwell = (1. / rate);
  #endif
  ULMutex.unlock();

  if (invalidScanRate) {
    setDoubleParam(waveDigDwellActual_, -9999);
  } else {
    setDoubleParam(waveDigDwellActual_, dwell);
  }

  reportError(status, functionName, "Calling AInScan");
  if (status) return status;

  waveDigRunning_ = 1;
  setIntegerParam(waveDigRun_, 1);
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: called cbAInScan, firstChan=%d, lastChan=%d, numPoints=%d, dwell=%f, options=0x%x\n",
    driverName, functionName, firstChan, lastChan, numPoints, dwell, options);

  setDoubleParam(waveDigTotalTime_, dwell*numPoints);
  return 0;
}

int MultiFunction::stopWaveDig()
{
  int autoRestart;
  int status;
  static const char *functionName = "stopWaveDig";

  waveDigRunning_ = 0;
  setIntegerParam(waveDigRun_, 0);
  readWaveDig();
  getIntegerParam(waveDigAutoRestart_, &autoRestart);
  ULMutex.lock();
  #ifdef _WIN32
    status = cbStopBackground(boardNum_, AIFUNCTION);
  #else
    status = ulAInScanStop(daqDeviceHandle_);
  #endif
  ULMutex.unlock();
  reportError(status, functionName, "Stopping AIn scan");
  if (autoRestart)
    status |= startWaveDig();
  return status;
}

int MultiFunction::readWaveDig()
{
  int firstChan, lastChan;
  int currentPoint;
  int i;
  static const char *functionName = "readWaveDig";

  getIntegerParam(waveDigFirstChan_,    &firstChan);
  lastChan = firstChan + numWaveDigChans_ - 1;
  getIntegerParam(waveDigCurrentPoint_, &currentPoint);

  for (i=firstChan; i<=lastChan; i++) {
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
      "%s:%s:, doing callbacks on input %d, first value=%f\n",
      driverName, functionName, i, waveDigBuffer_[i][0]);
    doCallbacksFloat64Array(waveDigBuffer_[i], currentPoint, waveDigVoltWF_, i);
  }
  doCallbacksFloat64Array(waveDigAbsTimeBuffer_, currentPoint, waveDigAbsTimeWF_, 0);
  return 0;
}

int MultiFunction::computeWaveDigTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(waveDigNumPoints_, &numPoints);
  getDoubleParam(waveDigDwell_, &dwell);
  for (i=0; i<numPoints; i++) {
    waveDigTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(waveDigTimeBuffer_, numPoints, waveDigTimeWF_, 0);
  return 0;
}


asynStatus MultiFunction::getBounds(asynUser *pasynUser, epicsInt32 *low, epicsInt32 *high)
{
  int function = pasynUser->reason;


  if (function == analogOutValue_) {
    *low = 0;
    *high = (1 << DACResolution_) - 1;
  }
  else if (function == analogInValue_) {
    *low = 0;
    *high = (1 << ADCResolution_) - 1;
  }
  else {
    return(asynError);
  }
  return(asynSuccess);
}

asynStatus MultiFunction::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
  int addr;
  int function = pasynUser->reason;
  int range;
  int status=0;
  static const char *functionName = "writeInt32";

  this->getAddress(pasynUser, &addr);
  setIntegerParam(addr, function, value);

  bool isThermocouple = true;
  if (analogInTypeConfigurable_) {
    int ival;
    getIntegerParam(addr, analogInType_, &ival);
    if (ival != AI_CHAN_TYPE_TC) isThermocouple = false;
  }

  ULMutex.lock();
  // Analog input functions
  if (function == analogInType_ && analogInTypeConfigurable_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIADCHANTYPE, value);
      // It seems to be necessary to reprogram the thermocouple type when switching from volts to TC
    #else
      long long configValue = (value == AI_CHAN_TYPE_VOLTAGE) ? AI_VOLTAGE : AI_TC;
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TYPE, addr, configValue);
    #endif
    reportError(status, functionName, "Setting analog input type");
    // It seems to be necessary to reprogram the thermocouple type when switching from volts to TC
    if (value == AI_CHAN_TYPE_TC) {
      int ival;
      // Set the TC type.  Note that the enums for thermocouple types are the same on Windows and Linux
      getIntegerParam(addr, thermocoupleType_, &ival);
      #ifdef _WIN32
        status = cbSetConfig(BOARDINFO, boardNum_, addr, BICHANTCTYPE, ival);
      #else
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TC_TYPE, addr, ival);
      #endif
      reportError(status, functionName, "Set thermocouple type");
      // Set open thermocouple detection
      getIntegerParam(addr, thermocoupleOpenDetect_, &ival);
      setOpenThermocoupleDetect(addr, ival);
    }
  }

  // Analog output functions
  if ((function == analogOutRange_) && analogOutRangeConfigurable_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIDACRANGE, value);
    #else
      // No function to immediately set it on Linux, this value is read from parameter library when calling ulAOut
    #endif
    reportError(status, functionName, "Setting analog out range");
  }

  else if (function == analogInMode_) {
    #ifdef _WIN32
      status = cbAInputMode(boardNum_, value);
    #else
      aiInputMode_ = (value == DIFFERENTIAL) ? AI_DIFFERENTIAL : AI_SINGLE_ENDED;
    #endif
    reportError(status, functionName, "Setting analog input mode");
  }

  else if ((function == analogInRate_) && analogInDataRateConfigurable_) {
    #ifdef _WIN32 
        status = cbSetConfig(BOARDINFO, boardNum_, addr, BIADDATARATE, value);
    #else
        status = ulAISetConfigDbl(daqDeviceHandle_, AI_CFG_CHAN_DATA_RATE, addr, value);
    #endif
    reportError(status, functionName, "Setting data rate");
  }

  else if ((function == thermocoupleType_) && isThermocouple) {
    // NOTE:
    // This sleep is a hack to get it working on the TC-32.  Without it the call to cbSetConfig()
    // will often hang if more than 6 channels are being configured.
    // This makes no sense.  The problem cannot be reproduced in the testTC32.c test application
    if (boardFamily_ == USB_TC32) epicsThreadSleep(0.01);
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BICHANTCTYPE, value);
    #else
      // The enums for thermocouple types are the same on Windows and Linux
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TC_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting thermocouple type");
  }

  else if ((function == thermocoupleOpenDetect_) && isThermocouple) {
    setOpenThermocoupleDetect(addr, value);
  }

  else if (function == temperatureSensor_) {
    #ifdef _WIN32 
      // Sensor cannot be configured on UL for Windows
      status = NOERRORS;
    #else
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting temperature sensor");
  }

  else if (function == temperatureWiring_) {
    #ifdef _WIN32
      // Wiring cannot be configured on UL for Windows
      status = NOERRORS;
    #else
      status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_SENSOR_CONNECTION_TYPE, addr, value);
    #endif
    reportError(status, functionName, "Setting temperature wiring");
  }

  // Pulse generator functions
  else if (function == pulseGenRun_) {
    // Allow starting a run even if it thinks its running,
    // since there is no way to know when it got done if Count!=0
    if (value) {
      status = startPulseGenerator(addr);
    }
    else if (!value && pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
    }
  }
  else if ((function == pulseGenCount_) ||
           (function == pulseGenIdleState_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Counter functions
  else if (function == counterReset_) {
    #ifdef _WIN32
      // LOADREG0=0, LOADREG1=1, so we use addr
      status = cbCLoad32(boardNum_, addr, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, addr, CRT_LOAD, 0);
    #endif
    reportError(status, functionName, "Resetting counter");
  }

  // Trigger functions
  else if (function == triggerMode_) {
    #ifdef _WIN32
      status = cbSetTrigger(boardNum_, value, 0, 0);
    #else
      // In uldaq there are separate calls for ulDaqInSetTrigger, ulDaqOutSetTrigger, etc.
      // We just cache the information here and then call those functions when starting the appropriate scan
      status = mapTriggerType(value, &triggerType_);
    #endif
    reportError(status, functionName, "Setting trigger mode");
  }

  // Waveform digitizer functions
  else if (function == waveDigRun_) {
    if (value && !waveDigRunning_)
      status = startWaveDig();
    else if (!value && waveDigRunning_)
      status = stopWaveDig();
  }

  else if (function == waveDigReadWF_) {
    readWaveDig();
  }

  else if (function == waveDigNumPoints_) {
    if (value > (int)maxInputPoints_) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                "%s::%s error WaveDigNumPoints=%d must be less than MaxInputPoints=%d\n",
                driverName, functionName, value, (int)maxInputPoints_);
      setIntegerParam(waveDigNumPoints_, maxInputPoints_);
    }
    computeWaveDigTimes();
  }

  else if (function == waveDigTriggerCount_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, 0, BIADTRIGCOUNT, value);
    #else
      aiScanTrigCount_ = value;
    #endif
    reportError(status, functionName, "Setting waveDig trigger count");
  }

  // Analog output functions
  else if (function == analogOutValue_) {
    if (waveGenRunning_) {
      reportError(-1, functionName, "cannot write analog outputs while waveform generator is running.");
      ULMutex.unlock();
      return asynError;
    }
    status = getIntegerParam(addr, analogOutRange_, &range);

    #ifdef _WIN32
      status = cbAOut(boardNum_, addr, range, value);
    #else
      Range ulRange;
      mapRange(range, &ulRange);
      status = ulAOut(daqDeviceHandle_, addr, ulRange, AOUT_FF_NOSCALEDATA, (double) value);
    #endif
    reportError(status, functionName, "calling AOut");
  }

  // Waveform generator functions
  else if (function == waveGenRun_) {
    if (value && !waveGenRunning_)
      status = startWaveGen();
    else if (!value && waveGenRunning_)
      status = stopWaveGen();
  }

  else if ((function == waveGenWaveType_) ||
      (function == waveGenUserNumPoints_) ||
      (function == waveGenIntNumPoints_)  ||
      (function == waveGenEnable_)        ||
      (function == waveGenExtTrigger_)    ||
      (function == waveGenExtClock_)      ||
      (function == waveGenContinuous_)) {
    defineWaveform(addr);
    if (waveGenRunning_) {
      status = stopWaveGen();
      status |= startWaveGen();
    }
  }

  else if (function == waveGenTriggerCount_) {
    #ifdef _WIN32
      status = cbSetConfig(BOARDINFO, boardNum_, 0, BIDACTRIGCOUNT, value);
    #else
      aoScanTrigCount_ = value;
    #endif
    reportError(status, functionName, "Setting waveGen trigger count");
  }
  ULMutex.unlock();

  // This is a separate if statement because these cases are also treated above
  if ((function == waveGenUserNumPoints_) ||
      (function == waveGenIntNumPoints_)) {
    computeWaveGenTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %d to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, function=%d, ERROR writing %d to address %d, status=%d\n",
             driverName, functionName, this->portName, function, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

int MultiFunction::setOpenThermocoupleDetect(int addr, int value)
{
  int status=0;
  static const char *functionName = "setOpenThermocoupleDetect";

  if ((boardFamily_ != USB_TEMP) && (boardFamily_ != USB_TEMP_AI)) {
    ULMutex.lock();
    #ifdef _WIN32 
      status = cbSetConfig(BOARDINFO, boardNum_, addr, BIDETECTOPENTC, value);
    #else
      OtdMode mode = value ? OTD_ENABLED : OTD_DISABLED;
      // TC-32 and E-TC can only change open thermocouple detect for the entire device, not per-channel
      if (boardFamily_ == USB_TC32 || boardFamily_ == E_TC ) {
        int dev = 0;
        if (addr >= 32) dev = 1;
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_OTD_MODE, dev, mode);
      } else { 
        status = ulAISetConfig(daqDeviceHandle_, AI_CFG_CHAN_OTD_MODE, addr, mode);
      }
    #endif
    ULMutex.unlock();
    reportError(status, functionName, "Setting thermocouple open detect mode");
  }
  return status;
}

asynStatus MultiFunction::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  static const char *functionName = "writeFloat64";

  this->getAddress(pasynUser, &addr);
  setDoubleParam(addr, function, value);

  // Pulse generator functions
  if ((function == pulseGenPeriod_)    ||
      (function == pulseGenDutyCycle_) ||
      (function == pulseGenDelay_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Waveform generator functions
  else if ((function == waveGenUserDwell_)  ||
           (function == waveGenIntDwell_)   ||
           (function == waveGenPulseWidth_) ||
           (function == waveGenAmplitude_)  ||
           (function == waveGenOffset_)) {
    defineWaveform(addr);
    if (waveGenRunning_) {
      status = stopWaveGen();
      status |= startWaveGen();
    }
  }

  // Waveform digitizer functions
  else if (function == waveDigDwell_) {
    computeWaveDigTimes();
  }

  // This is a separate if statement because these cases are also treated above
  if ((function == waveGenUserDwell_)  ||
      (function == waveGenIntDwell_)) {
    computeWaveGenTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %f to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing %f to address %d, status=%d\n",
             driverName, functionName, this->portName, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::readFloat64(asynUser *pasynUser, epicsFloat64 *value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  int type;
  int scale;
  int filter=0;
  int range;
  static const char *functionName = "readFloat64";

  this->getAddress(pasynUser, &addr);

  // Temperature input function
  if (function == temperatureInValue_) {
    if (waveDigRunning_) {
      int currentPoint;
      getIntegerParam(waveDigCurrentPoint_, &currentPoint);
      if (currentPoint > 0) {
        *value = waveDigBuffer_[addr][currentPoint-1];
      }
    }
    else {
      getIntegerParam(addr, analogInType_, &type);
      getIntegerParam(addr, temperatureScale_, &scale);
      getIntegerParam(addr, temperatureFilter_, &filter);
      if (type != AI_CHAN_TYPE_TC) return asynSuccess;
      ULMutex.lock();
      #ifdef _WIN32
        float fVal;
        status = cbTIn(boardNum_, addr, scale, &fVal, filter);
        if (status == OPENCONNECTION) {
          // This is an "expected" error if the thermocouple is broken or disconnected
          // Don't print error message, just set temp to -9999.
          fVal = -9999.;
          status = 0;
          *value = (double) fVal;
        }
        *value = (double) fVal;
      #else
        TempScale tempScale;
        // cbTin has a filter option but ulTin does not?
        TInFlag flags = TIN_FF_DEFAULT;
        switch (scale) {
            case CELSIUS:     tempScale = TS_CELSIUS; break;
            case FAHRENHEIT:  tempScale = TS_FAHRENHEIT; break;
            case KELVIN:      tempScale = TS_KELVIN; break;
            case VOLTS:       tempScale = TS_VOLTS; break;
            case NOSCALE:     tempScale = TS_NOSCALE; break;
            default:
                asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                  "%s::%s unsupported Scale=%d\n", driverName, functionName, scale);
                tempScale = TS_CELSIUS;
        }
        status = ulTIn(daqDeviceHandle_, addr, tempScale, flags, value);
        if (status == ERR_OPEN_CONNECTION) {
          // This is an "expected" error if the thermocouple is broken or disconnected
          // Don't print error message, just set temp to -9999.
          status = 0;
          *value = -9999.;
        }
      #endif
      ULMutex.unlock();
    }
    setDoubleParam(addr, temperatureInValue_, *value);
    reportError(status, functionName, "Calling TIn");
  }
  else if (function == voltageInValue_) {
    getIntegerParam(addr, voltageInRange_, &range);
    ULMutex.lock();
    #ifdef _WIN32
      float fVal;
      status = cbVIn(boardNum_, addr, range, &fVal, 0);
      *value = fVal;
    #else
      double data;
      Range ulRange;
      mapRange(range, &ulRange);
      int chan = addr;
      if (boardFamily_ == USB_TEMP_AI) {
        // On Linux the address needs to be 4 larger
        chan = addr + 4;
      }
      status = ulAIn(daqDeviceHandle_, chan, aiInputMode_, ulRange, AIN_FF_DEFAULT, &data);
      *value = (float) data;
    #endif
    ULMutex.unlock();
    reportError(status, functionName, "Calling AIn");
    setDoubleParam(addr, voltageInValue_, *value);
  }

  // Other functions we call the base class method
  else {
     status = asynPortDriver::readFloat64(pasynUser, value);
  }

  callParamCallbacks(addr);
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
  int function = pasynUser->reason;
  int status=0;
  int i;
  int addr;
  epicsUInt32 direction=0;
  static const char *functionName = "writeUInt32Digital";

  this->getAddress(pasynUser, &addr);
  setUIntDigitalParam(addr, function, value, mask);
  ULMutex.lock();
  if (function == digitalDirection_) {
    if (digitalIOPortConfigurable_[addr]) {
      #ifdef _WIN32
        int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
        status = cbDConfigPort(boardNum_, digitalIOPort_[addr], dir);
      #else
        DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
        status = ulDConfigPort(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], dir);
      #endif
      reportError(status, functionName, "Calling ConfigPort");
      direction = value ? 0xFFFF : 0;
      setUIntDigitalParam(0, digitalDirection_, direction, 0xFFFFFFFF);
    }
    else {
      for (i=0; i<numIOBits_[addr]; i++) {
        if ((mask & (1<<i)) != 0) {
          if (digitalIOBitConfigurable_[addr]) {
            #ifdef _WIN32
              int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
              status = cbDConfigBit(boardNum_, digitalIOPort_[addr], i, dir);
            #else
             DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
             status = ulDConfigBit(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, dir);
            #endif
            reportError(status, functionName, "Calling ConfigBit");
          }
          else {
            // Cannot program direction.  Set open collector output to 0.
            #ifdef _WIN32
              status = cbDBitOut(boardNum_, digitalIOPort_[addr], i, 0);
            #else
              status = ulDBitOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, 0);
            #endif
            reportError(status, functionName, "Calling BitOut");
          }
        }
      }
    }
  }

  else if (function == digitalOutput_) {
    getUIntDigitalParam(addr, digitalDirection_, &direction, 0xFFFFFFFF);
    if ((mask & direction) == digitalIOMask_[addr]) {
      // Use word I/O if all bits are outputs and we are writing all bits
      #ifdef _WIN32
        if (numIOBits_[addr] > 16) {
          status = cbDOut32(boardNum_, digitalIOPort_[addr], value & mask);
        } else {
          status = cbDOut(boardNum_, digitalIOPort_[addr], value & mask);
        }
      #else
        status = ulDOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], value & mask);
      #endif
      reportError(status, functionName, "Calling DOut");
    }
    else {
      // Use bit I/O if we are not writing all bits
      epicsUInt32 outMask, outValue;
      for (i=0, outMask=1; i<numIOBits_[addr]; i++, outMask = (outMask<<1)) {
        // Only write the value if the mask has this bit set and the direction for that bit is output (1)
        outValue = ((value & outMask) == 0) ? 0 : 1;
        if ((mask & outMask & direction) != 0) {
          #ifdef _WIN32
            status = cbDBitOut(boardNum_, digitalIOPort_[addr], i, outValue);
          #else
            status = ulDBitOut(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[addr], i, outValue);
          #endif
          reportError(status, functionName, "Calling DBitOut");
        }
      }
    }
  }
  ULMutex.unlock();

  callParamCallbacks();
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, function=%d, wrote value=0x%x, mask=0x%x, direction=0x%x\n",
             driverName, functionName, this->portName, function, value, mask, direction);
  } 
  return (status==0) ? asynSuccess : asynError;
}

asynStatus MultiFunction::readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat32 *inPtr;
  static const char *functionName = "readFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (addr >= numAnalogOut_) {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: addr=%d max=%d\n",
      driverName, functionName, addr, numAnalogOut_-1);
    return asynError;
  }
  // Assume WaveGen function, WaveDig numPoints handled below
  getIntegerParam(waveGenNumPoints_, &numPoints);
  if (function == waveGenUserWF_)
    inPtr = waveGenUserBuffer_[addr];
  else if (function == waveGenIntWF_)
    inPtr = waveGenIntBuffer_[addr];
  else if (function == waveGenUserTimeWF_)
    inPtr = waveGenUserTimeBuffer_;
  else if (function == waveGenIntTimeWF_)
    inPtr = waveGenIntTimeBuffer_;
  else if (function == waveDigTimeWF_) {
    inPtr = waveDigTimeBuffer_;
    getIntegerParam(waveDigNumPoints_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat32));

  return asynSuccess;
}

asynStatus MultiFunction::readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat64 *inPtr;
  static const char *functionName = "readFloat64Array";

  this->getAddress(pasynUser, &addr);

  if (function == waveDigVoltWF_) {
    if (addr >= numAnalogIn_) {
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
        "%s:%s: ERROR: addr=%d max=%d\n",
        driverName, functionName, addr, numAnalogIn_-1);
      return asynError;
    }
    inPtr = waveDigBuffer_[addr];
  }
  else if (function == waveDigAbsTimeWF_) {
    inPtr = waveDigAbsTimeBuffer_;
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  getIntegerParam(waveDigNumPoints_, &numPoints);
  if (*nIn > (size_t)numPoints) *nIn = numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat64));
  return asynSuccess;
}

asynStatus MultiFunction::writeFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements)
{
  int function = pasynUser->reason;
  int addr;
  static const char *functionName = "writeFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (function == waveGenUserWF_) {
    if ((addr >= numAnalogOut_) || (nElements > maxOutputPoints_)) {
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
        "%s:%s: ERROR: addr=%d max=%d, nElements=%d max=%d\n",
        driverName, functionName, addr, numAnalogOut_-1, (int)nElements, (int)maxOutputPoints_);
      return asynError;
    }
    memcpy(waveGenUserBuffer_[addr], value, nElements*sizeof(epicsFloat32));
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }

  return asynSuccess;
}

asynStatus MultiFunction::readEnum(asynUser *pasynUser, char *strings[], int values[], int severities[], size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int i;
  const enumStruct_t *pEnum;
  int numEnums;
  //static const char *functionName = "readEnum";

  if (function == analogInRange_) {
    pEnum    = pBoardEnums_->pInputRange;
    numEnums = pBoardEnums_->numInputRange;
  }
  else if (function == voltageInRange_) {
    pEnum    = pBoardEnums_->pInputRange;
    numEnums = pBoardEnums_->numInputRange;
  }
  else if (function == analogOutRange_) {
    pEnum    = pBoardEnums_->pOutputRange;
    numEnums = pBoardEnums_->numOutputRange;
  }
  else if (function == analogInType_) {
    pEnum    = pBoardEnums_->pInputType;
    numEnums = pBoardEnums_->numInputType;
  }
  else if (function == temperatureSensor_) {
    pEnum    = temperatureSensorUSB_TEMP;
    numEnums = sizeof(temperatureSensorUSB_TEMP)/sizeof(enumStruct_t);
  }
  else if (function == temperatureWiring_) {
    pEnum    = temperatureWiringUSB_TEMP;
    numEnums = sizeof(temperatureWiringUSB_TEMP)/sizeof(enumStruct_t);
  }
  else {
      *nIn = 0;
      return asynError;
  }
  for (i=0; ((i<numEnums) && (i<(int)nElements)); i++) {
    if (strings[i]) free(strings[i]);
    strings[i] = epicsStrDup(pEnum[i].enumString);
    values[i] = pEnum[i].enumValue;
    severities[i] = 0;
  }
  *nIn = i;
  return asynSuccess;
}

void MultiFunction::pollerThread()
{
  /* This function runs in a separate thread.  It waits for the poll
   * time */
  static const char *functionName = "pollerThread";
  epicsUInt32 newValue, changedBits, prevInput[MAX_IO_PORTS]={0};
  int i;
  int currentPoint;
  epicsUInt32 countVal;
  long aoCount, aoIndex, aiCount, aiIndex;
  short aoStatus, aiStatus;
  epicsTime startTime=epicsTime::getCurrent(), endTime, currentTime;
  int lastPoint;
  int status=0, prevStatus=0;

  while(1) {
    lock();
    ULMutex.lock();
    endTime = epicsTime::getCurrent();
    setDoubleParam(pollTimeMS_, (endTime-startTime)*1000.);
    startTime = epicsTime::getCurrent();

    // Read the digital inputs
    for (i=0; i<numIOPorts_; i++) {
      if (digitalIOPortWriteOnly_[i]) continue;
      #ifdef _WIN32
        epicsUInt16 biVal16;
        if (numIOBits_[i] > 16) {
          status = cbDIn32(boardNum_, digitalIOPort_[i], &newValue);
        } else {
          status = cbDIn(boardNum_, digitalIOPort_[i], &biVal16);
          newValue = biVal16;
        }
      #else
        unsigned long long data;
        status = ulDIn(daqDeviceHandle_, (DigitalPortType)digitalIOPort_[i], &data);
        newValue = (epicsUInt32) data;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling DIn");
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR, "portNumber=%d\n", i);
        }
        goto error;
      }
      changedBits = newValue ^ prevInput[i];
      if (forceCallback_[i] || (changedBits != 0)) {
        prevInput[i] = newValue;
        forceCallback_[i] = 0;
        setUIntDigitalParam(i, digitalInput_, newValue, 0xFFFFFFFF);
      }
    }

    // Read the counter inputs
    for (i=0; i<numCounters_; i++) {
      #ifdef _WIN32
        ULONG data;
        status = cbCIn32(boardNum_, firstCounter_ + i, &data);
        countVal = (epicsUInt32)data;
      #else
        unsigned long long data;
        status = ulCIn(daqDeviceHandle_, firstCounter_ + i, &data);
        countVal = (epicsUInt32)data;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling CIn");
        }
        goto error;
      }
      setIntegerParam(i, counterCounts_, countVal);
    }

    if (waveGenRunning_) {
      // Poll the status of the waveform generator output
      #ifdef _WIN32
        status = cbGetIOStatus(boardNum_, &aoStatus, &aoCount, &aoIndex, AOFUNCTION);
      #else
        ScanStatus scanStatus;
        TransferStatus xferStatus;
        status = ulAOutScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
        aoStatus = scanStatus;
        aoCount = xferStatus.currentTotalCount;
        aoIndex = xferStatus.currentIndex;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling AOutScanStatus");
        }
        goto error;
      } else {
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
          "%s::%s waveform generator status, aoStatus=%d, aoCount=%ld, aoIndex=%ld\n",
          driverName, functionName, aoStatus, aoCount, aoIndex);
      }
      currentPoint = (aoIndex / numWaveGenChans_) + 1;
      setIntegerParam(waveGenCurrentPoint_, currentPoint);
      if (aoStatus == 0) {
        stopWaveGen();
      }
    }

    if (waveDigRunning_) {
      // Poll the status of the waveform digitizer input
      #ifdef _WIN32
        status = cbGetIOStatus(boardNum_, &aiStatus, &aiCount, &aiIndex, AIFUNCTION);
      #else
        ScanStatus scanStatus;
        TransferStatus xferStatus;
        status = ulAInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
        aiStatus = scanStatus;
        aiCount = xferStatus.currentTotalCount;
        aiIndex = xferStatus.currentIndex;
      #endif
      if (status) {
        if (!prevStatus) {
          reportError(status, functionName, "Calling AInScanStatus");
        }
        #ifdef _WIN32
          // On Windows after a network glitch cbGetIOStatus will return continually return DEADDEV
          // Need to stop and start the waveform digitizer if it was running
          if (status == DEADDEV) {
            stopWaveDig();
            startWaveDig();
          }
          goto error;
        #endif
      } else {
        asynPrint(pasynUserSelf, ASYN_TRACEIO_DRIVER,
          "%s::%s waveform digitizer status, aiStatus=%d, aiCount=%ld, aiIndex=%ld\n",
          driverName, functionName, aiStatus, aiCount, aiIndex);
      }
      getIntegerParam(waveDigCurrentPoint_, &currentPoint);
      lastPoint = aiIndex / numWaveDigChans_ + 1;
      if (lastPoint > currentPoint) {
        currentTime = epicsTime::getCurrent();
        epicsTimeStamp now = (epicsTimeStamp)currentTime;
        int firstChan;
        getIntegerParam(waveDigFirstChan_, &firstChan);
        int lastChan = firstChan + numWaveDigChans_ - 1;
        epicsFloat64 *pAnalogIn = pInBuffer_ + currentPoint*numWaveDigChans_;
        for(; currentPoint < lastPoint; currentPoint++) {
          for (int j=firstChan; j<=lastChan; j++) {
            waveDigBuffer_[j][currentPoint] = *pAnalogIn++;
          }
          waveDigAbsTimeBuffer_[currentPoint] = now.secPastEpoch + now.nsec/1.e9;
        }
        setIntegerParam(waveDigCurrentPoint_, currentPoint);
      }
      if (aiStatus == 0) {
        stopWaveDig();
      }
    } else {
      // If the waveform digitizer is not running then read the analog inputs
      int range, type, mode;
      epicsInt32 value;
      getIntegerParam(0, analogInMode_, &mode);
      for (i=0; i<numAnalogIn_; i++) {
        getIntegerParam(i, analogInRange_, &range);
        getIntegerParam(i, analogInType_, &type);
        if (type != AI_CHAN_TYPE_VOLTAGE) continue;
        if ((boardType_ == E_1608) && (mode == DIFFERENTIAL) && (i>3)) break;
        #ifdef _WIN32
          if (ADCResolution_ <= 16) {
            epicsUInt16 shortVal;
            status = cbAIn(boardNum_, i, range, &shortVal);
            value = shortVal;
          } else {
            ULONG ulongVal;
            status = cbAIn32(boardNum_, i, range, &ulongVal, 0);
            value = (epicsInt32)ulongVal;
          }
        #else
          double data;
          Range ulRange;
          mapRange(range, &ulRange);
          status = ulAIn(daqDeviceHandle_, i, aiInputMode_, ulRange, AIN_FF_NOSCALEDATA, &data);
          value = (epicsInt32) data;
        #endif
        setIntegerParam(i, analogInValue_, value);
      }
    }

    for (i=0; i<MAX_SIGNALS; i++) {
      callParamCallbacks(i);
    }
error:
    if (prevStatus && !status) {
      reportError(-1, functionName, "Device returned to normal status");
    }
    prevStatus = status;
    double pollTime;
    getDoubleParam(pollSleepMS_, &pollTime);
    ULMutex.unlock();
    unlock();
    epicsThreadSleep(pollTime/1000.);
  }
}

/* Report  parameters */
void MultiFunction::report(FILE *fp, int details)
{
  int i;
  int counts;

  asynPortDriver::report(fp, details);
  fprintf(fp, "  Port: %s, board ID=%d, board type=%s\n",
          this->portName, boardType_, boardName_);
  if (details >= 1) {
    fprintf(fp, "  analog inputs      = %d\n", numAnalogIn_);
    fprintf(fp, "  analog input bits  = %d\n", ADCResolution_);
    fprintf(fp, "  analog outputs     = %d\n", numAnalogOut_);
    fprintf(fp, "  analog output bits = %d\n", DACResolution_);
    fprintf(fp, "  temperature inputs = %d\n", numTempChans_);
    fprintf(fp, "  digital I/O ports  = %d\n", numIOPorts_);
    for (i=0; i<numIOPorts_; i++) {
      fprintf(fp, "  digital I/O port     %d\n", i);
      fprintf(fp, "    I/O port              = %d\n", digitalIOPort_[i]);
      fprintf(fp, "    I/O bits              = %d\n", numIOBits_[i]);
      fprintf(fp, "    I/O bit configurable  = %d\n", digitalIOBitConfigurable_[i]);
      fprintf(fp, "    I/O port configurable = %d\n", digitalIOPortConfigurable_[i]);
      fprintf(fp, "    I/O port read only    = %d\n", digitalIOPortReadOnly_[i]);
      fprintf(fp, "    I/O port write only   = %d\n", digitalIOPortWriteOnly_[i]);
      fprintf(fp, "    I/O port mask         = 0x%x\n", digitalIOMask_[i]);
    }
    fprintf(fp, "  timers             = %d\n", numTimers_);
    if (numTimers_ > 0) {
      fprintf(fp, "  pulse generator\n");
      fprintf(fp, "    frequency range  = %f : %f\n", minPulseGenFrequency_, maxPulseGenFrequency_);
      fprintf(fp, "    delay range      = %f : %f\n", minPulseGenDelay_, maxPulseGenDelay_);
    }
    fprintf(fp, "  # counters         = %d", numCounters_);
    fprintf(fp, "  first counter      = %d", firstCounter_);
    fprintf(fp, "  counterCounts = ");
    for (i=0; i<numCounters_; i++) {
      getIntegerParam(i, counterCounts_, &counts);
      fprintf(fp, " %d", counts);
    }
    fprintf(fp, "\n");
  }
}

/** Configuration command, called directly or from iocsh */
extern "C" int MultiFunctionConfig(const char *portName, const char *uniqueID,
                              int maxInputPoints, int maxOutputPoints)
{
  new MultiFunction(portName, uniqueID, maxInputPoints, maxOutputPoints);
  return asynSuccess;
}


static const iocshArg configArg0 = { "Port name",      iocshArgString};
static const iocshArg configArg1 = { "UniqueID",       iocshArgString};
static const iocshArg configArg2 = { "Max. input points", iocshArgInt};
static const iocshArg configArg3 = { "Max. output points",iocshArgInt};
static const iocshArg * const configArgs[] = {&configArg0,
                                              &configArg1,
                                              &configArg2,
                                              &configArg3};
static const iocshFuncDef configFuncDef = {"MultiFunctionConfig",4,configArgs};
static void configCallFunc(const iocshArgBuf *args)
{
  MultiFunctionConfig(args[0].sval, args[1].sval, args[2].ival, args[3].ival);
}


static const iocshFuncDef showDevicesFuncDef = {"measCompShowDevices",0,0};
static void showDevicesCallFunc(const iocshArgBuf *args)
{
  measCompShowDevices();
}

void drvMultiFunctionRegister(void)
{
  iocshRegister(&configFuncDef,configCallFunc);
  iocshRegister(&showDevicesFuncDef,showDevicesCallFunc);
}


extern "C" {
epicsExportRegistrar(drvMultiFunctionRegister);
}












üî• File: ./USB1608G_2AO_V2App/src/drvUSBCTR.cpp
=================================================
/* drvUSBCTR.cpp
 *
 * Driver for Measurement Computing USB-CTR04/08 counter/timer module using asynPortDriver base class
 *
 * This driver supports simple digital in/out bit and word, timer (digital pulse generator), counter,
 *   EPICS scaler record, multi-channel scaler mode
 *
 * Mark Rivers
 * May 29, 2014
*/

#include <math.h>
#include <stdlib.h>
#include <string.h>

#include <iocsh.h>
#include <epicsThread.h>
#include <epicsTime.h>

#include <asynPortDriver.h>

#include "drvMca.h"
#include "devScalerAsyn.h"

#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

#include <epicsExport.h>
#include <measCompDiscover.h>

#define DRIVER_VERSION "4.2"

typedef enum {
  MCSPoint0Clear,
  MCSPoint0NoClear,
  MCSPoint0Skip
} MCSPoint0Action_t;

static const char *driverName = "USBCTR";

// Board parameters
#define modelNameString           "MODEL_NAME"
#define modelNumberString         "MODEL_NUMBER"
#define firmwareVersionString     "FIRMWARE_VERSION"
#define uniqueIDString            "UNIQUE_ID"
#define ULVersionString           "UL_VERSION"
#define driverVersionString       "DRIVER_VERSION"
#define pollSleepMSString         "POLL_SLEEP_MS"
#define pollTimeMSString          "POLL_TIME_MS"
#define lastErrorMessageString    "LAST_ERROR_MESSAGE"

// Pulse output parameters
#define pulseGenRunString         "PULSE_RUN"
#define pulseGenPeriodString      "PULSE_PERIOD"
#define pulseGenDutyCycleString   "PULSE_DUTY_CYCLE"
#define pulseGenDelayString       "PULSE_DELAY"
#define pulseGenCountString       "PULSE_COUNT"
#define pulseGenIdleStateString   "PULSE_IDLE_STATE"

// Counter parameters
#define counterCountsString       "COUNTER_VALUE"
#define counterResetString        "COUNTER_RESET"

// Trigger parameters
#define triggerModeString         "TRIGGER_MODE"

// Digital I/O parameters
#define digitalDirectionString    "DIGITAL_DIRECTION"
#define digitalInputString        "DIGITAL_INPUT"
#define digitalOutputString       "DIGITAL_OUTPUT"

// MCS parameters other than those in drvMca.h
#define MCSCurrentPointString     "MCS_CURRENT_POINT"
#define MCSMaxPointsString        "MCS_MAX_POINTS"
#define MCSTimeWFString           "MCS_TIME_WF"
#define MCSAbsTimeWFString        "MCS_ABS_TIME_WF"
#define MCSCounterEnableString    "MCS_COUNTER_ENABLE"
#define MCSPrescaleCounterString  "MCS_PRESCALE_COUNTER"
#define MCSPoint0ActionString     "MCS_POINT0_ACTION"

// Model ID
#define modelString               "MODEL"

#define MIN_FREQUENCY   0.023
#define MAX_FREQUENCY   48e6
#define MIN_DELAY       0.
#define MAX_DELAY       67.11
#define MAX_COUNTERS    8   // Maximum mumber of counters on USB-CTR04/08
#define MAX_MCS_COUNTERS (MAX_COUNTERS + 1) // +1 for collecting the digital I/O in MCS mode
#define DIGITAL_IO_COUNTER (MAX_MCS_COUNTERS-1) // Index of the digital I/O enable in mcsCounterEnable_ array;
#define MAX_DAQ_LEN     2*MAX_MCS_COUNTERS // Each counter can take 2 words
#define NUM_TIMERS      4   // Number of timers on USB-CTR08
#define NUM_IO_BITS     8   // Number of digital I/O bits on USB-CTR08
#define MAX_SIGNALS     MAX_MCS_COUNTERS
#define MAX_ERROR_STRING_LEN 256
#define MAX_BOARDNAME_LEN    256

#define DEFAULT_POLL_TIME 0.01
#define SINGLEIO_THRESHOLD_TIME 0.01  // Above this time uses SINGLEIO, below uses block I/O.

/** This is the class definition for the USBCTR class
  */
class USBCTR : public asynPortDriver {
public:
  USBCTR(const char *portName, const char *uniqueID, int maxTimePoints, double pollTime);

  /* These are the methods that we override from asynPortDriver */
  virtual asynStatus writeInt32(asynUser *pasynUser, epicsInt32 value);
  virtual asynStatus readInt32(asynUser *pasynUser, epicsInt32 *value);
  virtual asynStatus writeFloat64(asynUser *pasynUser, epicsFloat64 value);
  virtual asynStatus writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask);
  virtual asynStatus readInt32Array(asynUser *pasynUser, epicsInt32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn);
  virtual asynStatus readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn);
  virtual void report(FILE *fp, int details);
  // These should be private but are called from C
  virtual void pollerThread(void);

protected:
  // Model parameters
  int modelName_;
  int modelNumber_;
  int firmwareVersion_;
  int uniqueID_;
  int ULVersion_;
  int driverVersion_;
  int pollSleepMS_;
  int pollTimeMS_;
  int lastErrorMessage_;

  // Pulse generator parameters
  int pulseGenRun_;
  int pulseGenPeriod_;
  int pulseGenDutyCycle_;
  int pulseGenDelay_;
  int pulseGenCount_;
  int pulseGenIdleState_;

  // Counter parameters
  int counterCounts_;
  int counterReset_;

  // Trigger parameters
  int triggerMode_;

  // Digital I/O parameters
  int digitalDirection_;
  int digitalInput_;
  int digitalOutput_;

  // MCS parameters other than those in drvMca.h
  int MCSCurrentPoint_;
  int MCSMaxPoints_;
  int MCSTimeWF_;
  int MCSAbsTimeWF_;
  int MCSCounterEnable_;
  int MCSPrescaleCounter_;
  int MCSPoint0Action_;

  // Command for EPICS MCA record
  int mcaStartAcquire_;
  int mcaStopAcquire_;
  int mcaErase_;
  int mcaData_;
  int mcaReadStatus_;
  int mcaChannelAdvanceSource_;
  int mcaNumChannels_;
  int mcaDwellTime_;
  int mcaPresetLiveTime_;
  int mcaPresetRealTime_;
  int mcaPresetCounts_;
  int mcaPresetLowChannel_;
  int mcaPresetHighChannel_;
  int mcaPresetSweeps_;
  int mcaAcquireMode_;
  int mcaSequence_;
  int mcaPrescale_;
  int mcaAcquiring_;
  int mcaElapsedLiveTime_;
  int mcaElapsedRealTime_;
  int mcaElapsedCounts_;

  // Commands for EPICS scaler record
  int scalerReset_;
  int scalerChannels_;
  int scalerRead_;
  int scalerPresets_;
  int scalerArm_;
  int scalerDone_;

// Model ID
  int model_;

private:
  int boardType_;
  #ifdef _WIN32
    int boardNum_;
  #else
    DaqDeviceHandle daqDeviceHandle_;
  #endif
  DaqDeviceDescriptor daqDeviceDescriptor_;
  char boardName_[MAX_BOARDNAME_LEN];
  double pollTime_;
  int forceCallback_;
  int numCounters_;
  int numMCSCounters_;
  int maxTimePoints_;
  epicsInt32 scalerCounts_[MAX_COUNTERS];
  epicsInt32 scalerPresetCounts_[MAX_COUNTERS];
  epicsInt32 *MCSBuffer_[MAX_MCS_COUNTERS];
  bool mcsCounterEnable_[MAX_MCS_COUNTERS];
  short chanArray_[MAX_DAQ_LEN];
  short chanTypeArray_[MAX_DAQ_LEN];
  short gainArray_[MAX_DAQ_LEN];

  epicsFloat32 *MCSTimeBuffer_;
  epicsFloat64 *MCSAbsTimeBuffer_;
  epicsFloat64 *pCountsF64_;
  epicsUInt64 *pCountsUI64_;
  epicsInt32 *pCountsI32_;
  epicsInt16 *pCountsI16_;
  int counterBits_;

  bool pulseGenRunning_[NUM_TIMERS];
  bool scalerRunning_;
  bool MCSRunning_;
  bool MCSErased_;
  epicsTimeStamp startTime_;
  double elapsedPrevious_;
  char errorMessage_[MAX_ERROR_STRING_LEN];

  char *getErrorMessage(int error);
  int startPulseGenerator(int timerNum);
  int stopPulseGenerator(int timerNum);
  int resetScaler();
  int startScaler();
  int readScaler();
  int stopScaler();
  int clearScalerPresets();
  int setScalerPresets();
  int startMCS();
  int stopMCS();
  int readMCS();
  int eraseMCS();
  int computeMCSTimes();
};

static void pollerThreadC(void * pPvt)
{
    USBCTR *pUSBCTR = (USBCTR *)pPvt;
    pUSBCTR->pollerThread();
}

USBCTR::USBCTR(const char *portName, const char *uniqueID, int maxTimePoints, double pollTime)
  : asynPortDriver(portName, MAX_SIGNALS,
      asynInt32Mask | asynUInt32DigitalMask | asynInt32ArrayMask | asynFloat32ArrayMask | asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask |asynDrvUserMask,
      asynInt32Mask | asynUInt32DigitalMask | asynInt32ArrayMask | asynFloat32ArrayMask | asynFloat64Mask | asynFloat64ArrayMask | asynOctetMask,
      // Note: ASYN_CANBLOCK must not be set because the scaler record does not work with asynchronous device support
      ASYN_MULTIDEVICE, 1, /* ASYN_CANBLOCK=0, ASYN_MULTIDEVICE=1, autoConnect=1 */
      0, 0),  /* Default priority and stack size */
    pollTime_((pollTime > 0.) ? pollTime : DEFAULT_POLL_TIME),
    forceCallback_(1),
    maxTimePoints_(maxTimePoints),
    scalerRunning_(false),
    MCSRunning_(false)
{
  int i;
  int status;
  long long handle;
  //static const char *functionName = "USBCTR";

  for (i=0; i<NUM_TIMERS; i++) pulseGenRunning_[i]=0;

  status = measCompCreateDevice(uniqueID, daqDeviceDescriptor_, &handle);
  if (status) {
    printf("Error creating device with measCompCreateDevice\n");
    return;
  }

  #ifdef _WIN32
    boardNum_ = (int) handle;
    strcpy(boardName_, daqDeviceDescriptor_.ProductName);
    boardType_ = daqDeviceDescriptor_.ProductID;
  #else
    daqDeviceHandle_ = handle;
    strcpy(boardName_, daqDeviceDescriptor_.productName);
    boardType_ = daqDeviceDescriptor_.productId;
  #endif

  // Model parameters
  createParam(modelNameString,                 asynParamOctet,  &modelName_);
  createParam(modelNumberString,               asynParamInt32,  &modelNumber_);
  createParam(firmwareVersionString,            asynParamOctet, &firmwareVersion_);
  createParam(uniqueIDString,                   asynParamOctet, &uniqueID_);
  createParam(ULVersionString,                  asynParamOctet, &ULVersion_);
  createParam(driverVersionString,              asynParamOctet, &driverVersion_);
  createParam(pollSleepMSString,              asynParamFloat64, &pollSleepMS_);
  createParam(pollTimeMSString,               asynParamFloat64, &pollTimeMS_);
  createParam(lastErrorMessageString,           asynParamOctet, &lastErrorMessage_);

  // Pulse generator parameters
  createParam(pulseGenRunString,               asynParamInt32, &pulseGenRun_);
  createParam(pulseGenPeriodString,          asynParamFloat64, &pulseGenPeriod_);
  createParam(pulseGenDutyCycleString,       asynParamFloat64, &pulseGenDutyCycle_);
  createParam(pulseGenDelayString,           asynParamFloat64, &pulseGenDelay_);
  createParam(pulseGenCountString,             asynParamInt32, &pulseGenCount_);
  createParam(pulseGenIdleStateString,         asynParamInt32, &pulseGenIdleState_);

  // Counter parameters
  createParam(counterCountsString,             asynParamInt32, &counterCounts_);
  createParam(counterResetString,              asynParamInt32, &counterReset_);

  // Trigger parameters
  createParam(triggerModeString,               asynParamInt32, &triggerMode_);

  // Digital I/O parameters
  createParam(digitalDirectionString,  asynParamUInt32Digital, &digitalDirection_);
  createParam(digitalInputString,      asynParamUInt32Digital, &digitalInput_);
  createParam(digitalOutputString,     asynParamUInt32Digital, &digitalOutput_);

  // MCS parameters other than those in drvMca.h
  createParam(MCSCurrentPointString,           asynParamInt32, &MCSCurrentPoint_);
  createParam(MCSMaxPointsString,              asynParamInt32, &MCSMaxPoints_);
  createParam(MCSTimeWFString,          asynParamFloat32Array, &MCSTimeWF_);
  createParam(MCSAbsTimeWFString,       asynParamFloat64Array, &MCSAbsTimeWF_);
  createParam(MCSCounterEnableString,  asynParamUInt32Digital, &MCSCounterEnable_);
  createParam(MCSPrescaleCounterString,        asynParamInt32, &MCSPrescaleCounter_);
  createParam(MCSPoint0ActionString,           asynParamInt32, &MCSPoint0Action_);

  // MCA record parameters
  createParam(mcaStartAcquireString,                asynParamInt32, &mcaStartAcquire_);
  createParam(mcaStopAcquireString,                 asynParamInt32, &mcaStopAcquire_);            /* int32, write */
  createParam(mcaEraseString,                       asynParamInt32, &mcaErase_);                  /* int32, write */
  createParam(mcaDataString,                   asynParamInt32Array, &mcaData_);                   /* int32Array, read/write */
  createParam(mcaReadStatusString,                  asynParamInt32, &mcaReadStatus_);             /* int32, write */
  createParam(mcaChannelAdvanceSourceString,        asynParamInt32, &mcaChannelAdvanceSource_);   /* int32, write */
  createParam(mcaNumChannelsString,                 asynParamInt32, &mcaNumChannels_);            /* int32, write */
  createParam(mcaDwellTimeString,                 asynParamFloat64, &mcaDwellTime_);              /* float64, write */
  createParam(mcaPresetLiveTimeString,            asynParamFloat64, &mcaPresetLiveTime_);         /* float64, write */
  createParam(mcaPresetRealTimeString,            asynParamFloat64, &mcaPresetRealTime_);         /* float64, write */
  createParam(mcaPresetCountsString,              asynParamFloat64, &mcaPresetCounts_);           /* float64, write */
  createParam(mcaPresetLowChannelString,            asynParamInt32, &mcaPresetLowChannel_);       /* int32, write */
  createParam(mcaPresetHighChannelString,           asynParamInt32, &mcaPresetHighChannel_);      /* int32, write */
  createParam(mcaPresetSweepsString,                asynParamInt32, &mcaPresetSweeps_);           /* int32, write */
  createParam(mcaAcquireModeString,                 asynParamInt32, &mcaAcquireMode_);            /* int32, write */
  createParam(mcaSequenceString,                    asynParamInt32, &mcaSequence_);               /* int32, write */
  createParam(mcaPrescaleString,                    asynParamInt32, &mcaPrescale_);               /* int32, write */
  createParam(mcaAcquiringString,                   asynParamInt32, &mcaAcquiring_);              /* int32, read */
  createParam(mcaElapsedLiveTimeString,           asynParamFloat64, &mcaElapsedLiveTime_);        /* float64, read */
  createParam(mcaElapsedRealTimeString,           asynParamFloat64, &mcaElapsedRealTime_);        /* float64, read */
  createParam(mcaElapsedCountsString,             asynParamFloat64, &mcaElapsedCounts_);          /* float64, read */

  // Scaler record parameters
  createParam(SCALER_RESET_COMMAND_STRING,          asynParamInt32, &scalerReset_);               /* int32, write */
  createParam(SCALER_CHANNELS_COMMAND_STRING,       asynParamInt32, &scalerChannels_);            /* int32, read */
  createParam(SCALER_READ_COMMAND_STRING,      asynParamInt32Array, &scalerRead_);                /* int32Array, read */
  createParam(SCALER_PRESET_COMMAND_STRING,         asynParamInt32, &scalerPresets_);             /* int32, write */
  createParam(SCALER_ARM_COMMAND_STRING,            asynParamInt32, &scalerArm_);                 /* int32, write */
  createParam(SCALER_DONE_COMMAND_STRING,           asynParamInt32, &scalerDone_);                /* int32, read */

  // Model ID
  createParam(modelString,                          asynParamInt32, &model_);                     /* int32, read */

  if (strcmp(boardName_, "USB-CTR08") == 0) {
    setIntegerParam(model_, 0);
    numCounters_ = 8;
  } else if (strcmp(boardName_, "USB-CTR04") == 0) {
    setIntegerParam(model_, 1);
    numCounters_ = 4;
  } else {
    printf("Unknown model\n");
  }

  char uniqueIDStr[256];
  char firmwareVersion[256];
  char ULVersion[256];
  #ifdef _WIN32
    int size = sizeof(uniqueIDStr);
    cbGetConfigString(BOARDINFO, boardNum_, 0, BIDEVUNIQUEID, uniqueIDStr, &size);
    size = sizeof(firmwareVersion);
    cbGetConfigString(BOARDINFO, boardNum_, VER_FW_MAIN, BIDEVVERSION, firmwareVersion, &size);
    float DLLRevNum, VXDRevNum;
    cbGetRevision(&DLLRevNum, &VXDRevNum);
    sprintf(ULVersion, "%f %f", DLLRevNum, VXDRevNum);
  #else
    strcpy(uniqueIDStr, uniqueID);
    unsigned int size = sizeof(firmwareVersion);
    ulDevGetConfigStr(daqDeviceHandle_, ::DEV_CFG_VER_STR, DEV_VER_FW_MAIN, firmwareVersion, &size);
    size = sizeof(ULVersion);
    ulGetInfoStr(UL_INFO_VER_STR, 0, ULVersion, &size);
  #endif
  setIntegerParam(modelNumber_, boardType_);
  setStringParam(modelName_, boardName_);
  setStringParam(uniqueID_, uniqueIDStr);
  setStringParam(firmwareVersion_, firmwareVersion);
  setStringParam(ULVersion_, ULVersion);
  setStringParam(driverVersion_, DRIVER_VERSION);
  
  // Allocate memory for the input buffers
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    MCSBuffer_[i]  = (epicsInt32 *) calloc(maxTimePoints_,  sizeof(epicsInt32));
  }
  MCSTimeBuffer_    = (epicsFloat32 *) calloc(maxTimePoints_,  sizeof(epicsFloat32));
  MCSAbsTimeBuffer_ = (epicsFloat64 *) calloc(maxTimePoints_,  sizeof(epicsFloat64));
  for (i=0; i<MAX_DAQ_LEN; i++) {
    gainArray_[i] = BIP10VOLTS;
  }
  pCountsF64_  = (epicsFloat64 *) calloc((maxTimePoints+1)  * MAX_MCS_COUNTERS, sizeof(epicsFloat64));
  pCountsUI64_ = (epicsUInt64 *)pCountsF64_;
  pCountsI32_ = (epicsInt32 *)pCountsF64_;
  pCountsI16_ = (epicsInt16 *)pCountsF64_;

  // Set values of some parameters that need to be set because init record order is not predictable
  // or because the corresponding records are PINI=NO.
  setIntegerParam(pulseGenRun_, 0);
  setIntegerParam(scalerDone_, 1);
  setIntegerParam(scalerChannels_, numCounters_);
  setIntegerParam(MCSMaxPoints_, maxTimePoints_);
  setIntegerParam(mcaNumChannels_, maxTimePoints_);
  resetScaler();
  clearScalerPresets();
  MCSErased_ = false;

  eraseMCS();

  // Put pulse generators in known state
  for (i=0; i<NUM_TIMERS; i++) {
    stopPulseGenerator(i);
  }

  /* Start the thread to poll counters and digital inputs and do callbacks to
   * device support */
  epicsThreadCreate("USBCTRPoller",
                    epicsThreadPriorityLow,
                    epicsThreadGetStackSize(epicsThreadStackMedium),
                    (EPICSTHREADFUNC)pollerThreadC,
                    this);
}

char *USBCTR::getErrorMessage(int error)
{
  #ifdef _WIN32
      cbGetErrMsg(error, errorMessage_);
  #else
      ulGetErrMsg((UlError)error, errorMessage_);
  #endif
  return errorMessage_;
}

int USBCTR::startPulseGenerator(int timerNum)
{
  int status=0;
  double frequency, period, delay;
  double dutyCycle;
  int count, idleState;
  static const char *functionName = "startPulseGenerator";

  getDoubleParam (timerNum, pulseGenPeriod_,    &period);
  getDoubleParam (timerNum, pulseGenDutyCycle_, &dutyCycle);
  getDoubleParam (timerNum, pulseGenDelay_,     &delay);
  getIntegerParam(timerNum, pulseGenCount_,     &count);
  getIntegerParam(timerNum, pulseGenIdleState_, &idleState);

  frequency = 1./period;
  if (frequency < MIN_FREQUENCY) frequency = MIN_FREQUENCY;
  if (frequency > MAX_FREQUENCY) frequency = MAX_FREQUENCY;
  period = 1. / frequency;
  if (dutyCycle <= 0.) dutyCycle = .0001;
  if (dutyCycle >= 1.) dutyCycle = .9999;
  if (delay < MIN_DELAY) delay = MIN_DELAY;
  if (delay > MAX_DELAY) delay = MAX_DELAY;

  #ifdef _WIN32
    status = cbPulseOutStart(boardNum_, timerNum, &frequency, &dutyCycle, count, &delay, idleState, 0);
  #else
    TmrIdleState idle = (idleState == 0) ? TMRIS_LOW : TMRIS_HIGH;
    status = ulTmrPulseOutStart(daqDeviceHandle_, timerNum, &frequency, &dutyCycle, count, &delay, idle, PO_DEFAULT);
  #endif
  if (status != 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbPulseOutStart timerNum=%d frequency=%f, dutyCycle=%f,"
      " count=%d, delay=%f, idleState=%d, status=%d, error=%s\n",
      driverName, functionName, timerNum, frequency, dutyCycle,
      count, delay, idleState, status, getErrorMessage(status));
    return status;
  }
  // We may not have gotten the frequency, dutyCycle, and delay we asked for, set the actual values
  // in the parameter library
  pulseGenRunning_[timerNum] = true;
  period = 1. / frequency;
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s:%s: started pulse generator %d actual frequency=%f, actual period=%f, actual duty cycle=%f, actual delay=%f\n",
    driverName, functionName, timerNum, frequency, period, dutyCycle, delay);
  setDoubleParam(timerNum, pulseGenPeriod_, period);
  setDoubleParam(timerNum, pulseGenDutyCycle_, dutyCycle);
  setDoubleParam(timerNum, pulseGenDelay_, delay);
  return 0;
}

int USBCTR::stopPulseGenerator(int timerNum)
{
  int status;
  static const char *functionName = "stopPulseGenerator";

  pulseGenRunning_[timerNum] = false;
  #ifdef _WIN32
    status = cbPulseOutStop(boardNum_, timerNum);
  #else
    status = ulTmrPulseOutStop(daqDeviceHandle_, timerNum);
  #endif
  if (status != 0) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbPulseOutStop timerNum=%d, status=%d, error=%s\n",
      driverName, functionName, timerNum, status, getErrorMessage(status));
  }
  return status;
}

int USBCTR::startMCS()
{
  int numPoints;
  int i;
  int options;
  int status;
  epicsUInt32 counterEnable;
  int prescale;
  int prescaleCounter;
  int mode;
  int point0Action;
  double dwell;
  int channelAdvance;
  static const char *functionName = "startMCS";

  getIntegerParam(MCSPrescaleCounter_, &prescaleCounter);
  getIntegerParam(mcaPrescale_, &prescale);
  getIntegerParam(mcaChannelAdvanceSource_, &channelAdvance);
  getUIntDigitalParam(MCSCounterEnable_,  &counterEnable, 0xFFFFFFFF);

  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    mcsCounterEnable_[i] = (counterEnable & (1<<i)) ? true : false;
  }
  numMCSCounters_ = 0;
  for (i=0; i<numCounters_; i++) {
    if (!mcsCounterEnable_[i]) continue;
    numMCSCounters_++;
    #ifdef _WIN32
      mode = OUTPUT_ON | CLEAR_ON_READ;
      status = cbCConfigScan(boardNum_, i, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
    #else
      mode = CMM_OUTPUT_ON | CMM_CLEAR_ON_READ;
      status = ulCConfigScan(daqDeviceHandle_, i, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
        driverName, functionName, i, mode, status, getErrorMessage(status));
    }
  }

  if ((channelAdvance == mcaChannelAdvance_External) && (prescale > 1) ) {
    #ifdef _WIN32
      status = cbCLoad32(boardNum_, OUTPUTVAL0REG0+prescaleCounter, 0);
      status = cbCLoad32(boardNum_, OUTPUTVAL1REG0+prescaleCounter, prescale-1);
      status = cbCLoad32(boardNum_, MAXLIMITREG0+prescaleCounter, prescale-1);
      mode = OUTPUT_ON | RANGE_LIMIT_ON;
      status = cbCConfigScan(boardNum_, prescaleCounter, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_OUTPUT_VAL0, 0);
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_OUTPUT_VAL1, prescale-1);
      status = ulCLoad(daqDeviceHandle_, prescaleCounter, CRT_MAX_LIMIT, prescale-1);
      mode = CMM_OUTPUT_ON | CMM_RANGE_LIMIT_ON;
      status = ulCConfigScan(daqDeviceHandle_, prescaleCounter, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
        driverName, functionName, prescaleCounter, mode, status, getErrorMessage(status));
    }
  }
  getIntegerParam(mcaNumChannels_, &numPoints);
  getDoubleParam(mcaDwellTime_, &dwell);
  getIntegerParam(MCSPoint0Action_, &point0Action);
  if (point0Action == MCSPoint0Skip) numPoints++;
  #ifdef _WIN32
    long count;
    int chanCount;
    long pretrigCount = 0;
    double rateFactor=1.0;
    if (dwell > 1e-6) rateFactor = 1000.;
    long rate = (LONG)((rateFactor / dwell) + 0.5);
    options = 0;
    if (dwell > 1e-4) {
      counterBits_ = 32;
    } else {
      counterBits_ = 16;
    }
    options |= BACKGROUND;
    if (rateFactor > 1.0)
      options |= HIGHRESRATE;
    if (channelAdvance == mcaChannelAdvance_External)
      options |= EXTCLOCK;
    // At long dwell times read use a single buffer for reading the data
    if (dwell >= SINGLEIO_THRESHOLD_TIME)
      options |= SINGLEIO;
    // Always use EXTTRIGGER
    options |= EXTTRIGGER;
    if (point0Action == MCSPoint0NoClear)
      options |= NOCLEAR;
  
    for (i=0, chanCount=0; i<numCounters_; i++) {
      if (!mcsCounterEnable_[i]) continue;
      chanArray_[chanCount] = i;
      chanTypeArray_[chanCount] = CTRBANK0;
      chanCount++;
      if (counterBits_ == 16) continue;
      chanArray_[chanCount] = i;
      chanTypeArray_[chanCount] = CTRBANK1;
      chanCount++;
    }
    if (mcsCounterEnable_[DIGITAL_IO_COUNTER]) {
      numMCSCounters_++;
      chanArray_[chanCount] = AUXPORT;
      chanTypeArray_[chanCount] = DIGITAL8;
      chanCount++;
      if (counterBits_ == 32) { // Add padding for binary data
        chanArray_[chanCount] = 0;
        chanTypeArray_[chanCount] = PADZERO;
        chanCount++;
      }
    }
    count = chanCount * numPoints;
    status = cbDaqInScan(boardNum_, chanArray_, chanTypeArray_, gainArray_, chanCount, &rate,
                         &pretrigCount, &count, pCountsI16_, options);
    asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
      "%s::%s called cbDaqInScan, chanCount=%d, count=%ld, rate=%ld,"
      " inputMemHandle_=%p, options=0x%x, status=%d\n",
      driverName, functionName, chanCount, count, rate,
      pCountsI16_, options, status);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbDaqInScan, chanCount=%d, count=%ld, rate=%ld,"
        " inputMemHandle_=%p, options=0x%x, status=%d, error=%s\n",
        driverName, functionName, chanCount, count, rate,
        pCountsI16_, options, status, getErrorMessage(status));
    }
    // The actual dwell time can be different from requested due to clock granularity
    setDoubleParam(mcaDwellTime_, rateFactor/rate);
  #else
    double rate = 1. / dwell;  
    options = SO_DEFAULTIO;
    if (channelAdvance == mcaChannelAdvance_External)
      options |= SO_EXTCLOCK;
    // At long dwell times read use a single buffer for reading the data
    if (dwell >= SINGLEIO_THRESHOLD_TIME)
      options |= SO_SINGLEIO;
    // Always use EXTTRIGGER
    options |= SO_EXTTRIGGER;
    int flags = DAQINSCAN_FF_DEFAULT;
    if (point0Action == MCSPoint0NoClear)
      flags |= DAQINSCAN_FF_NOCLEAR;
    DaqInChanDescriptor *pDICD = new DaqInChanDescriptor[MAX_MCS_COUNTERS];
    int outChan=0;
    for (i=0; i<numCounters_; i++) {
      if (!mcsCounterEnable_[i]) continue;
      pDICD[outChan].channel = i;
      pDICD[outChan].type = DAQI_CTR32;
      pDICD[outChan].range = BIP10VOLTS;
      outChan++;
    }
    if (mcsCounterEnable_[DIGITAL_IO_COUNTER]) {
      numMCSCounters_++;
      pDICD[outChan].channel = AUXPORT;
      pDICD[outChan].type = DAQI_DIGITAL;
      pDICD[outChan].range = BIP10VOLTS;
      outChan++;
    }
    int numChans = outChan;
    status = ulDaqInScan(daqDeviceHandle_, pDICD, numChans, numPoints, &rate, (ScanOption) options, (DaqInScanFlag) flags, pCountsF64_);
    delete[] pDICD;
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling ulDaqInScan, numChans=%d, numPoints=%d, rate=%f, options=0x%x, flags=0x%x, status=%d, error=%s\n",
        driverName, functionName, numChans, numPoints, rate,
        options, status, flags, getErrorMessage(status));
    }
    // The actual dwell time can be different from requested due to clock granularity
    setDoubleParam(mcaDwellTime_, 1./rate);
  #endif
  setIntegerParam(MCSCurrentPoint_, 0);
  MCSRunning_ = true;

  return 0;
}

int USBCTR::readMCS()
{
  int lastPoint=0;
  int currentPoint;
  int status;
  int i, j;
  short ctrStatus;
  long ctrCount, ctrIndex;
  epicsTimeStamp now;
  int numTimePoints;
  int point0Action;
  double presetReal, elapsedTime;
  static const char *functionName = "readMCS";

  // We need to treat Windows and Linux differently here because with UL for Linux the buffer is always float64, while on
  // Windows it is either int32 or int16.
  getIntegerParam(MCSCurrentPoint_, &currentPoint);
  getIntegerParam(mcaNumChannels_,  &numTimePoints);
  getIntegerParam(MCSPoint0Action_, &point0Action);
  #ifdef _WIN32
    status = cbGetIOStatus(boardNum_, &ctrStatus, &ctrCount, &ctrIndex, DAQIFUNCTION);
  #else
    ScanStatus scanStatus;
    TransferStatus xferStatus;
    status = ulDaqInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
    ctrStatus = scanStatus;
    ctrCount = xferStatus.currentTotalCount;
    ctrIndex = xferStatus.currentIndex;
  #endif
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s getStatus returned status=%d, ctrStatus=%d, ctrCount=%ld, ctrIndex=%ld\n",
    driverName, functionName, status, ctrStatus, ctrCount, ctrIndex);
  if (ctrStatus == 0) {
    MCSRunning_ = false;
  }
  if (ctrIndex >= 0) {
#ifdef _WIN32
    if (counterBits_ == 32) ctrIndex /= 2;
#endif
    lastPoint = ctrIndex / numMCSCounters_ + 1;

    int inPtr = currentPoint;
    if (point0Action == MCSPoint0Skip) {
      inPtr++;
    }
    epicsTimeStamp now;
    epicsTimeGetCurrent(&now);
    for(; inPtr < lastPoint; inPtr++) {
      for (i=0, j=0; i<MAX_MCS_COUNTERS; i++) {
        if (!mcsCounterEnable_[i]) continue;
#ifdef _WIN32
        if (counterBits_ == 32) {
          MCSBuffer_[i][currentPoint] = pCountsI32_[inPtr*numMCSCounters_ + j];
          // There seems to be a bug in PADZERO and it is actually giving counter0 value not 0
          if (i == DIGITAL_IO_COUNTER) MCSBuffer_[i][currentPoint] &= 0xff;
        } else {
          MCSBuffer_[i][currentPoint] = pCountsI16_[inPtr*numMCSCounters_ + j];
        }
#else
          MCSBuffer_[i][currentPoint] = (int) pCountsF64_[inPtr*numMCSCounters_ + j];
#endif
        j++;
      }
      MCSAbsTimeBuffer_[currentPoint] = now.secPastEpoch + now.nsec/1.e9;
      currentPoint++;
    }
  }
  setIntegerParam(MCSCurrentPoint_, currentPoint);

  getDoubleParam(mcaPresetRealTime_,  &presetReal);
  getDoubleParam(mcaElapsedRealTime_, &elapsedTime);
  epicsTimeGetCurrent(&now);
  elapsedTime = epicsTimeDiffInSeconds(&now, &startTime_);
  if (MCSRunning_ && (presetReal > 0) && (elapsedTime >= presetReal)) {
    MCSRunning_ = false;
  }

  // Set elapsed times
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    setDoubleParam(i, mcaElapsedRealTime_, elapsedTime);
    setDoubleParam(i, mcaElapsedLiveTime_, elapsedTime);
  }

  if (!MCSRunning_) {
    stopMCS();
    for (i=0; i<numCounters_; i++) {
      setIntegerParam(i, mcaAcquiring_, 0);
    }
  }

  // Do callbacks on all channels
  for (i=0; i<numCounters_; i++) {
    callParamCallbacks(i);
  }

  return 0;
}

int USBCTR::eraseMCS()
{
  int i;
  int numTimePoints;
  //static const char *functionName="eraseMCS";

  MCSErased_ = true;

  getIntegerParam(mcaNumChannels_, &numTimePoints);

  /* Reset pointers to start of buffer */
  setIntegerParam(MCSCurrentPoint_, 0);

  /* Reset the elapsed time and counts */
  elapsedPrevious_ = 0.;
  for (i=0; i<MAX_MCS_COUNTERS; i++) {
    memset(MCSBuffer_[i], 0, numTimePoints * sizeof(epicsUInt32));
    setDoubleParam(i, mcaElapsedLiveTime_, 0.0);
    setDoubleParam(i, mcaElapsedRealTime_, 0.0);
    setDoubleParam(i, mcaElapsedCounts_, 0.0);
    callParamCallbacks(i);
  }

  /* Reset the start time.  This is necessary here because we may be
   * acquiring, and AcqOn will not be called. Normally this is set in AcqOn.
   */
  epicsTimeGetCurrent(&startTime_);

  return 0;
}

int USBCTR::stopMCS()
{
  int status;
  static const char *functionName = "stopMCS";

  if (MCSRunning_) {
    // Forced stop
    MCSRunning_ = false;
    readMCS();
    // readMCS will call this function when it finds MCSRunning=false so we can return now
    return 0;
  }
  #ifdef _WIN32
    status = cbStopBackground(boardNum_, DAQIFUNCTION);
  #else
    status = ulDaqInScanStop(daqDeviceHandle_);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s ERROR calling cbStopBackground(CTRFUNCTION), status=%d, error=%s\n",
      driverName, functionName, status, getErrorMessage(status));
  }
  return status;
}

int USBCTR::computeMCSTimes()
{
  int numPoints, i;
  double dwell;

  getIntegerParam(mcaNumChannels_, &numPoints);
  getDoubleParam(mcaDwellTime_, &dwell);
  for (i=0; i<numPoints; i++) {
    MCSTimeBuffer_[i] = (epicsFloat32) (i * dwell);
  }
  doCallbacksFloat32Array(MCSTimeBuffer_, numPoints, MCSTimeWF_, 0);
  return 0;
}

int USBCTR::startScaler()
{
  int status;
  int i;
  int mode;
  int samplesPerCounter = 20;
  long rate = 100;
  int firstCounter = 0;
  int lastCounter = numCounters_ - 1;
  int options;
  static const char *functionName = "startScaler";

  #ifdef _WIN32
    for (i=0; i<numCounters_; i++) {
      mode = OUTPUT_ON | COUNT_DOWN_OFF | GATING_ON;
      if (i == 0) mode = mode | RANGE_LIMIT_ON | NO_RECYCLE_ON | INVERT_GATE;
      status = cbCConfigScan(boardNum_, i, mode, CTR_DEBOUNCE_NONE, CTR_TRIGGER_BEFORE_STABLE,
                             CTR_RISING_EDGE, CTR_TICK20PT83ns, 0);
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling cbCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
          driverName, functionName, i, mode, status, getErrorMessage(status));
      }
    }
    int count = samplesPerCounter * numCounters_;
    options = BACKGROUND | CONTINUOUS | CTR64BIT | SINGLEIO;
    status = cbCInScan(boardNum_, firstCounter, lastCounter, count, &rate,
                       pCountsUI64_, options);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbCInScan, firstCounter=%d, lastCounter=%d, count=%d, rate=%d, options=0x%x, status=%d, error=%s\n",
        driverName, functionName, firstCounter, lastCounter, count, rate, options, status, getErrorMessage(status));
    }
  #else
    for (i=0; i<numCounters_; i++) {
      mode = CMM_OUTPUT_ON | CMM_GATING_ON;
      if (i == 0) mode = mode | CMM_RANGE_LIMIT_ON | CMM_NO_RECYCLE | CMM_INVERT_GATE;
      status = ulCConfigScan(daqDeviceHandle_, i, CMT_COUNT,  (CounterMeasurementMode) mode,
					                   CED_RISING_EDGE, CTS_TICK_20PT83ns, CDM_NONE, CDT_DEBOUNCE_0ns, CF_DEFAULT);
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling ulCConfigScan, counter=%d, mode=0x%x, status=%d, error=%s\n",
          driverName, functionName, i, mode, status, getErrorMessage(status));
      }
    }
    options = SO_CONTINUOUS | SO_SINGLEIO;
    double dblRate = (double) rate;
    CInScanFlag flags = CINSCAN_FF_CTR64_BIT;
    status = ulCInScan(daqDeviceHandle_, firstCounter, lastCounter, samplesPerCounter, &dblRate, (ScanOption) options, flags, pCountsUI64_);
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling ulCInScan, firstCounter=%d, lastCounter=%d, samplesPerCounter=%d, rate=%d, options=0x%x, flags=0x%x, status=%d, error=%s\n",
        driverName, functionName, firstCounter, lastCounter, samplesPerCounter, (int) rate, options, flags, status, getErrorMessage(status));
    }
  #endif
  scalerRunning_ = true;
  return 0;
}

int USBCTR::readScaler()
{
  int numValues;
  int i, j;
  int status;
  short ctrStatus;
  long ctrCount, ctrIndex;
  int lastIndex;
  bool scalerDone = false;
  static const char *functionName = "readScaler";

  // Poll the status of the counter scan
  #ifdef _WIN32
    status = cbGetIOStatus(boardNum_, &ctrStatus, &ctrCount, &ctrIndex, CTRFUNCTION);
  #else
    ScanStatus scanStatus;
    TransferStatus xferStatus;
    status = ulDaqInScanStatus(daqDeviceHandle_, &scanStatus, &xferStatus);
    ctrStatus = scanStatus;
    ctrCount = xferStatus.currentTotalCount;
    ctrIndex = xferStatus.currentIndex;
  #endif
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s getStatus returned status=%d, ctrStatus=%d, ctrCount=%ld, ctrIndex=%ld\n",
    driverName, functionName, status, ctrStatus, ctrCount, ctrIndex);

  numValues = ctrIndex + 1;
  // Get the index of the start of the last complete set of counts in the buffer
  if (numValues < numCounters_) return 0;
  lastIndex = (numValues/numCounters_ - 1) * numCounters_;
  for (i=0; i<=lastIndex; i+= numCounters_) {
    for (j=0; j<numCounters_; j++) {
      scalerCounts_[j] = (epicsInt32) pCountsUI64_[i+j];
      if ((scalerPresetCounts_[j] > 0) && (scalerCounts_[j] >= scalerPresetCounts_[j])) {
        scalerDone = true;
      }
    }
    if (scalerDone) {
      stopScaler();
      break;
    }
  }
  asynPrint(pasynUserSelf, ASYN_TRACE_FLOW,
    "%s::%s lastIndex=%d, scalerCounts_[0]=%d, scalerPresetCounts_[0]=%d\n",
    driverName, functionName, lastIndex, scalerCounts_[0], scalerPresetCounts_[0]);
  return 0;
}

int USBCTR::stopScaler()
{
  int status;
  static const char *functionName = "stopScaler";

  #ifdef _WIN32
    status = cbStopBackground(boardNum_, CTRFUNCTION);
  #else
    status = ulCInScanStop(daqDeviceHandle_);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s ERROR calling cbStopBackground(CTRFUNCTION), status=%d, error=%s\n",
      driverName, functionName, status, getErrorMessage(status));
  }
  scalerRunning_ = false;
  setIntegerParam(scalerDone_, 1);
  return status;
}

int USBCTR::resetScaler()
{
  int i;
  int status=0;

  /* Reset scaler */
  if (scalerRunning_) {
    status = stopScaler();
  }
  for (i=0; i<numCounters_; i++) {
    scalerCounts_[i] = 0;
  }
  return status;
}


int USBCTR::clearScalerPresets()
{
  int i;

  for (i=0; i<numCounters_; i++) {
    scalerPresetCounts_[i] = 0;
  }
  return 0;
}

int USBCTR::setScalerPresets()
{
  int i;
  int status;
  static const char *functionName = "setScalerPresets";

  for (i=0; i<numCounters_; i++) {
    getIntegerParam(i, scalerPresets_, &scalerPresetCounts_[i]);
    if (scalerPresetCounts_[i] > 0) {
      #ifdef _WIN32
        status = cbCLoad32(boardNum_, MAXLIMITREG0+i, scalerPresetCounts_[i]);
      #else
        status = ulCLoad(daqDeviceHandle_, i, CRT_MAX_LIMIT, scalerPresetCounts_[i]);
      #endif
      if (status) {
        asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
          "%s::%s error calling cbCLoad32, counter=%d, presetCounts=%d, status=%d, error=%s\n",
          driverName, functionName, i, scalerPresetCounts_[i], status, getErrorMessage(status));
      }
    }
  }
  // For counter0 output register 0 and 1 control when the counter output goes low and high
  #ifdef _WIN32
    status = cbCLoad32(boardNum_, OUTPUTVAL0REG0, 0);
  #else 
    status = ulCLoad(daqDeviceHandle_, 0, CRT_OUTPUT_VAL0, 0);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbCLoad32, reg=OUTPUTVAL0REG0, value=%d, status=%d, error=%s\n",
      driverName, functionName, 0, status, getErrorMessage(status));
  }
  #ifdef _WIN32
    status = cbCLoad32(boardNum_, OUTPUTVAL1REG0, scalerPresetCounts_[0]);
  #else 
    status = ulCLoad(daqDeviceHandle_, 0, CRT_OUTPUT_VAL1, scalerPresetCounts_[0]);
  #endif
  if (status) {
    asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
      "%s::%s error calling cbCLoad32, reg=OUTPUTVAL1REG0, value=%d, status=%d, error=%s\n",
      driverName, functionName, scalerPresetCounts_[0], status, getErrorMessage(status));
  }

  return 0;
}

asynStatus USBCTR::writeInt32(asynUser *pasynUser, epicsInt32 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  int numTimePoints;
  int currentPoint;
  int i;
  static const char *functionName = "writeInt32";

  this->getAddress(pasynUser, &addr);
  setIntegerParam(addr, function, value);

  // Pulse generator functions
  if (function == pulseGenRun_) {
    // Allow starting a run even if it thinks its running,
    // since there is no way to know when it got done if Count!=0
    if (value) {
      status = startPulseGenerator(addr);
    }
    else if (!value && pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
    }
  }
  if ((function == pulseGenCount_) ||
      (function == pulseGenIdleState_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // Counter functions
  if (function == counterReset_) {
    #ifdef _WIN32
      // LOADREG0=0, LOADREG1=1, so we use addr
      status = cbCLoad32(boardNum_, addr, 0);
    #else
      status = ulCLoad(daqDeviceHandle_, addr, CRT_LOAD, 0);
    #endif
  }

  // Trigger functions
  if (function == triggerMode_) {
    #ifdef _WIN32
      status = cbDaqSetTrigger(boardNum_, TRIG_EXTTTL, value, 0, CTRBANK0, 0, 0, 0, START_EVENT);
    #else
      TriggerType triggerType = TRIG_LOW;
      // We map the UL Windows trigger types to Ul Linux
      // We can't use macros from cbw.h because that file conflicts with uldaq.h
      switch (value) {
        case 0: triggerType = TRIG_RISING; break;
        case 1: triggerType = TRIG_FALLING; break;
        case 6: triggerType = TRIG_HIGH; break;
        case 7: triggerType = TRIG_LOW; break;
        default:
          asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
            "%s::%s error unsupported trigger value=%d\n",
            driverName, functionName, value);
          break;
      }
      DaqInChanDescriptor trigChanDescriptor;
      status = ulDaqInSetTrigger(daqDeviceHandle_, triggerType, trigChanDescriptor, 0, 0, 0);
    #endif
    if (status) {
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
        "%s::%s error calling cbDaqSetTrigger status=%d, error=%s\n",
        driverName, functionName, status, getErrorMessage(status));
    }
  }

  // Scaler functions
  else if (function == scalerReset_) {
    /* Reset scaler */
    if (MCSRunning_) goto done;
    resetScaler();
    scalerRunning_ = false;
    /* Clear all of the presets and counts*/
    for (i=0; i<numCounters_; i++) {
      scalerCounts_[i] = 0;
      setIntegerParam(i, scalerPresets_, 0);
    }
  }

  else if (function == scalerArm_) {
    if (MCSRunning_) goto done;
    /* Arm or disarm scaler */
    if (value != 0) {
      setScalerPresets();
      startScaler();
    } else {
      stopScaler();
    }
    setIntegerParam(scalerDone_, 0);
  }

  // MCA commands
  getIntegerParam(mcaNumChannels_, &numTimePoints);
  if (function == mcaStartAcquire_) {
    if (scalerRunning_) {
      status = -1;
      goto done;
    }
    if (MCSRunning_) goto done;
    // If we have already completed acquisition due to nextChan_, don't start, signal error
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    if (currentPoint >= numTimePoints) {
        // Must toggle mcaAcquiring to 1 and back to 0 to signal SNL program to clear Acquiring
      setIntegerParam(mcaAcquiring_, 1);
      callParamCallbacks();
      setIntegerParam(mcaAcquiring_, 0);
      goto done;
    }
    setIntegerParam(mcaAcquiring_, 1);
    MCSErased_ = false;
    // Set the acquisition start time
    epicsTimeGetCurrent(&startTime_);
    // Start the hardware
    startMCS();
  }

  else if (function == mcaStopAcquire_) {
    if (scalerRunning_) goto done;
    /* Stop data acquisition */
    if (!MCSRunning_) {
      // We are not acquiring.
      status = asynSuccess;
      goto done;
    }
    // Stop the hardware
    stopMCS();
  }

  else if (function == mcaErase_) {
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: [%s addr=%d]: erased\n",
              driverName, functionName, portName, addr);

    /* Erase the buffer in the private data structure */
    eraseMCS();

  }

  else if (function == mcaNumChannels_) {
    /* Terminology warning:
     * This is the number of channels that are to be acquired. Channels
     * correspond to time bins or external channel advance triggers, as
     * opposed to the 8 input counters that the USB-CTR08 supports.
     */
    if (value > maxTimePoints_) {
      setIntegerParam(mcaNumChannels_, maxTimePoints_);
      asynPrint(pasynUser, ASYN_TRACE_ERROR,
                "%s:%s:  # channels=%d too large, max=%d\n",
                driverName, functionName, value, maxTimePoints_);
    }
  }

  done:
  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, function=%d, wrote %d to address %d\n",
             driverName, functionName, this->portName, function, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, function=%d, ERROR writing %d to address %d, status=%d\n",
             driverName, functionName, this->portName, function, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}


asynStatus USBCTR::readInt32(asynUser *pasynUser, epicsInt32 *value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  //static const char *functionName = "readInt32";

  this->getAddress(pasynUser, &addr);

  if (function == scalerRead_) {
    /* Read a single scaler channel */
    *value = scalerCounts_[addr];
  }

  // Other functions we call the base class method
  else {
     status = asynPortDriver::readInt32(pasynUser, value);
  }

  callParamCallbacks(addr);
  return (status==0) ? asynSuccess : asynError;
}

asynStatus USBCTR::writeFloat64(asynUser *pasynUser, epicsFloat64 value)
{
  int addr;
  int function = pasynUser->reason;
  int status=0;
  static const char *functionName = "writeFloat64";

  this->getAddress(pasynUser, &addr);
  setDoubleParam(addr, function, value);

  // Pulse generator functions
  if ((function == pulseGenPeriod_)    ||
      (function == pulseGenDutyCycle_) ||
      (function == pulseGenDelay_)) {
    if (pulseGenRunning_[addr]) {
      status = stopPulseGenerator(addr);
      status |= startPulseGenerator(addr);
    }
  }

  // MCS functions
  else if (function == mcaDwellTime_) {
    computeMCSTimes();
  }

  callParamCallbacks(addr);
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote %f to address %d\n",
             driverName, functionName, this->portName, value, addr);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing %f to address %d, status=%d\n",
             driverName, functionName, this->portName, value, addr, status);
  }
  return (status==0) ? asynSuccess : asynError;
}

asynStatus USBCTR::writeUInt32Digital(asynUser *pasynUser, epicsUInt32 value, epicsUInt32 mask)
{
  int function = pasynUser->reason;
  int status=0;
  int i;
  epicsUInt32 outValue=0, outMask, direction;
  static const char *functionName = "writeUInt32Digital";


  setUIntDigitalParam(function, value, mask);
  if (function == digitalDirection_) {
    for (i=0; i<NUM_IO_BITS; i++) {
      if ((mask & (1<<i)) != 0) {
        #ifdef _WIN32
          int dir = (value == 0) ? DIGITALIN : DIGITALOUT;
          status = cbDConfigBit(boardNum_, AUXPORT, i, dir);
        #else
          DigitalDirection dir = (value == 0) ? DD_INPUT : DD_OUTPUT;
          status = ulDConfigBit(daqDeviceHandle_, AUXPORT, i, dir);
        #endif
      }
    }
  }

  else if (function == digitalOutput_) {
    getUIntDigitalParam(digitalDirection_, &direction, 0xFFFFFFFF);
    for (i=0, outMask=1; i<NUM_IO_BITS; i++, outMask = (outMask<<1)) {
      // Only write the value if the mask has this bit set and the direction for that bit is output (1)
      outValue = ((value &outMask) == 0) ? 0 : 1;
      if ((mask & outMask & direction) != 0) {
        #ifdef _WIN32
          status = cbDBitOut(boardNum_, AUXPORT, i, outValue);
        #else
          status = ulDBitOut(daqDeviceHandle_, AUXPORT, i, outValue);
        #endif
      }
    }
  }

  callParamCallbacks();
  if (status == 0) {
    asynPrint(pasynUser, ASYN_TRACEIO_DRIVER,
             "%s:%s, port %s, wrote outValue=0x%x, value=0x%x, mask=0x%x, direction=0x%x\n",
             driverName, functionName, this->portName, outValue, value, mask, direction);
  } else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
             "%s:%s, port %s, ERROR writing outValue=0x%x, value=0x%x, mask=0x%x, direction=0x%x, status=%d\n",
             driverName, functionName, this->portName, outValue, value, mask, direction, status);
  }
  return (status==0) ? asynSuccess : asynError;
}


asynStatus USBCTR::readInt32Array(asynUser *pasynUser, epicsInt32 *data,
                                  size_t numRead, size_t *numActual)
{
  int signal;
  int command;
  const char *paramName;
  asynStatus status = asynSuccess;
  int currentPoint;
  size_t i;
  static const char* functionName="readInt32Array";

  parseAsynUser(pasynUser, &command, &signal, &paramName);
  pasynManager->getAddr(pasynUser, &signal);
  asynPrint(pasynUser, ASYN_TRACE_FLOW,
            "%s:%s: entry, command=%d, signal=%d, numRead=%d, &data=%p\n",
            driverName, functionName, command, signal, (int)numRead, data);

  if (command == mcaData_) {
    /* Transfer the data from the private driver structure to the supplied data
     * buffer. The private data structure will have the information for all the
     * signals, so we need to just extract the signal being requested.
     */
    int nChans;
    int numCopy;
    getIntegerParam(mcaNumChannels_, &nChans);
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    numCopy = (int)numRead;
    if (numCopy > nChans) numCopy = nChans;
    // We copy all the channels but we only report nchans
    // This ensures the entire array is correct even if it was not set to zero at the start
    memcpy(data, MCSBuffer_[signal], numCopy*sizeof(epicsInt32));
    *numActual = numRead;
    if ((int)*numActual > currentPoint) *numActual = currentPoint;
    // Make it set NORD non-zero?
    if (*numActual == 0) *numActual = 1;
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: [signal=%d]: read %d chans (numRead=%d, numCopy=%d, currentPoint=%d, nChans=%d)\n",
              driverName, functionName, signal, (int)*numActual, (int)numRead, numCopy, currentPoint, nChans);
    }
  else if (command == scalerRead_) {
    for (i=0; (i<numRead && i<(size_t)numCounters_); i++) {
      data[i] = scalerCounts_[i];
    }
    for (i=numCounters_; i<numRead; i++) {
      data[i] = 0;
    }
    *numActual = numRead;
    asynPrint(pasynUser, ASYN_TRACE_FLOW,
              "%s:%s: scalerReadCommand: read %d chans, data=%d %d %d %d %d %d %d %d\n",
              driverName, functionName, (int)numRead, data[0], data[1], data[2], data[3],
                                                      data[4], data[5], data[6], data[7]);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
              "%s:%s: got illegal command %d\n",
              driverName, functionName, command);
    status = asynError;
  }
  return status;
}


asynStatus USBCTR::readFloat32Array(asynUser *pasynUser, epicsFloat32 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat32 *inPtr;
  static const char *functionName = "readFloat32Array";

  this->getAddress(pasynUser, &addr);

  if (function == MCSTimeWF_) {
    inPtr = MCSTimeBuffer_;
    getIntegerParam(mcaNumChannels_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat32));

  return asynSuccess;
}

asynStatus USBCTR::readFloat64Array(asynUser *pasynUser, epicsFloat64 *value, size_t nElements, size_t *nIn)
{
  int function = pasynUser->reason;
  int addr;
  int numPoints;
  epicsFloat64 *inPtr;
  static const char *functionName = "readFloat6Array";

  this->getAddress(pasynUser, &addr);

  if (function == MCSAbsTimeWF_) {
    inPtr = MCSAbsTimeBuffer_;
    getIntegerParam(mcaNumChannels_, &numPoints);
  }
  else {
    asynPrint(pasynUser, ASYN_TRACE_ERROR,
      "%s:%s: ERROR: unknown function=%d\n",
      driverName, functionName, function);
    return asynError;
  }
  *nIn = nElements;
  if (*nIn > (size_t) numPoints) *nIn = (size_t) numPoints;
  memcpy(value, inPtr, *nIn*sizeof(epicsFloat64));

  return asynSuccess;
}

void USBCTR::pollerThread()
{
  /* This function runs in a separate thread.  It waits for the poll
   * time */
  static const char *functionName = "pollerThread";
  epicsUInt32 newValue, changedBits, prevInput=0;
  epicsTime startTime=epicsTime::getCurrent(), endTime, currentTime;
  unsigned short biVal;;
  int i;
  int status;

  while(1) {
    lock();
    endTime = epicsTime::getCurrent();
    setDoubleParam(pollTimeMS_, (endTime-startTime)*1000.);
    startTime = epicsTime::getCurrent();

    // Read the digital inputs
    #ifdef _WIN32
      status = cbDIn(boardNum_, AUXPORT, &biVal);
    #else
      unsigned long long data;
      status = ulDIn(daqDeviceHandle_, AUXPORT, &data);
      biVal = (unsigned short) data;
    #endif
    if (status)
      asynPrint(pasynUserSelf, ASYN_TRACE_ERROR,
                "%s:%s: ERROR calling cbDIn, status=%d\n",
                driverName, functionName, status);
    newValue = biVal;
    changedBits = newValue ^ prevInput;
    if (forceCallback_ || (changedBits != 0)) {
      prevInput = newValue;
      forceCallback_ = 0;
      setUIntDigitalParam(digitalInput_, newValue, 0xFFFFFFFF);
    }

    if (scalerRunning_) {
      readScaler();
    }

    if (MCSRunning_) {
      readMCS();
    }

    for (i=0; i<MAX_SIGNALS; i++) {
      callParamCallbacks(i);
    }
    double pollTime;
    getDoubleParam(pollSleepMS_, &pollTime);
    unlock();
    epicsThreadSleep(pollTime/1000.);
  }
}


/* Report  parameters */
void USBCTR::report(FILE *fp, int details)
{
  int i;
  int currentPoint;

  fprintf(fp, "  Port: %s, pollTime=%f\n",
          this->portName, pollTime_);
  if (details >= 1) {
    fprintf(fp, "  Pulse generators:\n");
    for (i=0; i<NUM_TIMERS; i++) {
      fprintf(fp, "    %d: Running:%d\n", i, pulseGenRunning_[i]);
    }
    fprintf(fp, "  numCounters: %d\n", numCounters_);
    fprintf(fp, "  Scaler:\n");
    fprintf(fp, "    Running: %d\n", scalerRunning_);
    for (i=0; i<numCounters_; i++) {
      fprintf(fp, "    %d: preset=%d, count=%d\n", i, scalerPresetCounts_[i], scalerCounts_[i]);
    }
    fprintf(fp, "  MCS:\n");
    fprintf(fp, "    Running: %d\n", MCSRunning_);
    fprintf(fp, "    maxTimePoints: %d\n", maxTimePoints_);
    fprintf(fp, "    MCSErased: %d\n", MCSErased_);
    getIntegerParam(MCSCurrentPoint_, &currentPoint);
    fprintf(fp, "    currentPoint: %d\n", currentPoint);
  }
  asynPortDriver::report(fp, details);
}

/** Configuration command, called directly or from iocsh */
extern "C" int USBCTRConfig(const char *portName, const char *uniqueID,
                            int maxTimePoints, double pollTime)
{
  new USBCTR(portName, uniqueID, maxTimePoints, pollTime);
  return(asynSuccess);
}


static const iocshArg configArg0 = { "Port name",             iocshArgString};
static const iocshArg configArg1 = { "uniqueID",              iocshArgString};
static const iocshArg configArg2 = { "Max. # of time points", iocshArgInt};
static const iocshArg configArg3 = { "Poll time",             iocshArgDouble};
static const iocshArg * const configArgs[] = {&configArg0,
                                              &configArg1,
                                              &configArg2,
                                              &configArg3};
static const iocshFuncDef configFuncDef = {"USBCTRConfig",4,configArgs};
static void configCallFunc(const iocshArgBuf *args)
{
  USBCTRConfig(args[0].sval, args[1].sval, args[2].ival, args[3].dval);
}

void drvUSBCTRRegister(void)
{
  iocshRegister(&configFuncDef,configCallFunc);
}

extern "C" {
epicsExportRegistrar(drvUSBCTRRegister);
}











üî• File: ./USB1608G_2AO_V2App/src/measCompAppMain.cpp
=================================================
/* exampleMain.cpp */
/* Author:  Marty Kraimer Date:    17MAR2000 */

#include <stddef.h>
#include <stdlib.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "epicsExit.h"
#include "epicsThread.h"
#include "iocsh.h"

int main(int argc,char *argv[])
{
    if(argc>=2) {
        iocsh(argv[1]);
        epicsThreadSleep(.2);
    }
    iocsh(NULL);
    epicsExit(0);
    return(0);
}











üî• File: ./USB1608G_2AO_V2App/src/measCompDiscover.cpp
=================================================
#include <stdio.h>
#include <string>
#include <string.h>
#include <stdlib.h>
#include <osiSock.h>
#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

#include <measCompDiscover.h>

#define MAX_DEVICES 100
// All current Measurement Computing devices (E-1608, E-TC, TC32) use this port for
// discovery.  But it is configurable so we allow the user to specify it.
#define DEFAULT_DISCOVERY_PORT 54211

static DaqDeviceDescriptor measCompInventory[MAX_DEVICES];
static int measCompNumDevices = 0;
bool measCompInventoryInitialized = false;

int measCompDiscoverDevices()
{
  int numDevices = MAX_DEVICES;
  int status;

  if (measCompInventoryInitialized) return 0;
  #ifdef WIN32
    cbIgnoreInstaCal();
    status = cbGetDaqDeviceInventory(ANY_IFC, measCompInventory, &numDevices);
    // Windows eliminates leading zeros on USB device serial numbers, Linux does not.
    // Add the leading zero if the string length is 7
    for (int i=0; i<numDevices; i++) {
        if (measCompInventory[i].InterfaceType == USB_IFC) {
            if (strlen(measCompInventory[i].UniqueID) == 7) {
                std::string tempString = "0" + std::string(measCompInventory[i].UniqueID);
                strcpy(measCompInventory[i].UniqueID, tempString.c_str());
            }
        }
    } 
  #else
    status = ulGetDaqDeviceInventory(ANY_IFC, measCompInventory, (unsigned int *)&numDevices);
    // Copy the IP address to the reserved field for Ethernet devices.
    for (int i=0; i<numDevices; i++) {
        if (measCompInventory[i].devInterface == ETHERNET_IFC) {
            DaqDeviceHandle devHandle = ulCreateDaqDevice(measCompInventory[i]);
            unsigned int maxLen = sizeof(measCompInventory[i].reserved);
            ulDevGetConfigStr(devHandle, DEV_CFG_IP_ADDR_STR, 0, measCompInventory[i].reserved, &maxLen);
            ulReleaseDaqDevice(devHandle);
        }
    }
  #endif
  if (status) {
    printf("Error calling cbGetDaqDeviceInventory=%d\n", status);
    return status;
  }
  measCompNumDevices = numDevices;
  measCompInventoryInitialized = true;
  return 0;
}

void measCompShowDevices()
{
  measCompDiscoverDevices();
  printf("measCompShowDevices, numDevices=%d\n", measCompNumDevices);
  #ifdef WIN32
    for (int i=0; i<measCompNumDevices; i++) {
      printf("Device %d\n", i);
      printf("    ProductName: %s\n",   measCompInventory[i].ProductName);
      printf("      ProductID: %d\n",   measCompInventory[i].ProductID);
      printf("  InterfaceType: %d\n",   measCompInventory[i].InterfaceType);
      printf("      DevString: %s\n",   measCompInventory[i].DevString);
      printf("       UniqueID: %s\n",   measCompInventory[i].UniqueID);
      printf("           NUID: %llu\n", measCompInventory[i].NUID);
      printf("       Reserved: %s\n",   measCompInventory[i].Reserved);
    }
  #else
    for (int i=0; i<measCompNumDevices; i++) {
      printf("Device %d\n", i);
      printf("    ProductName: %s\n",   measCompInventory[i].productName);
      printf("      ProductID: %d\n",   measCompInventory[i].productId);
      printf("  InterfaceType: %d\n",   measCompInventory[i].devInterface);
      printf("      DevString: %s\n",   measCompInventory[i].devString);
      printf("       UniqueID: %s\n",   measCompInventory[i].uniqueId);
      printf("       Reserved: %s\n",   measCompInventory[i].reserved);
    }
  #endif
}

/** Create a measComp device.
  * This method finds a device and connects to it.  It is called from the driver constructor.
  * \param[in] uniqueID 
  *                     This is an 8 digital hex serial number for USB devices without a leading 0x.
  *                     For Ethernet devices it can be:
  *                         An IP DNS name with optional discovery port, e.g. gse-e1608-6:54211
  *                         An IP address with optional discovery port, e.g. 10.54.160.63:54211
  *                         A MAC address, e.g. 00:80:2F:24:53:E5
  * \param[out] deviceDescriptor Pointer to a DaqDeviceDescription structure for this device
  * \param[out] handle A handle for this device.  
  *                         On Windows this is the index in the device inventory list.
  *                         On Linux it is a DaqDeviceHandle.
  */
int measCompCreateDevice(std::string uniqueId, DaqDeviceDescriptor& deviceDescriptor, long long *handle)
{
  size_t colon;
  std::string host = uniqueId;
  std::string port;
  struct sockaddr_in ipAddr;
  bool isEthernet = false;
  char *endptr;
  int portNum = DEFAULT_DISCOVERY_PORT;
  int status;
  int devIndex=-1;
  char ipAddrAsString[25];
  double timeout = 1.0;

  measCompDiscoverDevices();
  // If the uniqueId is a hex number it is USB, else Ethernet
  strtol(uniqueId.c_str(), &endptr, 16);
  if (*endptr != '\0') isEthernet = true;

  // Use hostToIPAddr for 2 reasons:
  // - It will translate IP names to IP addresses
  // - It will fail if the uniqueId is a MAC address
  status = aToIPAddr(uniqueId.c_str(), portNum, &ipAddr);
  if (isEthernet && (status == 0)) {
    ipAddrToDottedIP(&ipAddr, ipAddrAsString, sizeof(ipAddrAsString));
    // The string from ipAddrToDottedIP will always have a :port at the end
    // Parse the port and remove from the host string.
    host = ipAddrAsString;
    colon = host.find(":");
    if (colon != std::string::npos) {
      port = host.substr(colon+1, std::string::npos);
      portNum = atoi(port.c_str());
      host = host.substr(0, colon);
    }
    // See if this host is already known, i.e. it was found on the local subnet
    for (int i=0; i<measCompNumDevices; i++) {
      #ifdef WIN32
        /*  This logic does not work on Windows because there is no way to retrieve the IP address and copy it to .Reserved
         *  This is OK, it is just slightly less efficient because it will always call cbGetNetDeviceDescriptor unless UniqueID is a MAC address.
        if (host.compare(measCompInventory[i].Reserved) == 0) {
          devIndex = i;
        } */
      #else
        if (host.compare(measCompInventory[i].reserved) == 0) {
          devIndex = i;
        }
      #endif
    }
    // We did not find this device on the local subnet, create a new one
    if (devIndex == -1) {
      devIndex = measCompNumDevices++;
      #ifdef WIN32
        status = cbGetNetDeviceDescriptor((char*)host.c_str(), portNum,
                                          &measCompInventory[devIndex], (int) (timeout * 1000));
      #else
        status = ulGetNetDaqDeviceDescriptor((char*)host.c_str(), portNum, NULL,
                                             &measCompInventory[devIndex], timeout);
      #endif
      if (status) {
          printf("Error calling cbGetNetDeviceDescriptor=%d\n", status);
          return -1;
      }
    }
  }
  else {
    // uniqueId was not an IP address or IP DNS name, so it must be a serial number (USB) or MAC address (Ethernet)
    // Search the inventory for the matching UniqueID
    for (int i=0; i<measCompNumDevices; i++) {
      #ifdef WIN32
        if (uniqueId.compare(measCompInventory[i].UniqueID) == 0) {
      #else
        if (uniqueId.compare(measCompInventory[i].uniqueId) == 0) {
      #endif
        devIndex = i;
        break;
      }
    }
  }
  if (devIndex != -1) {
    #ifdef WIN32
      status = cbCreateDaqDevice(devIndex, measCompInventory[devIndex]);
      if (status) {
        printf("Error calling cbCreateDaqDevice=%d\n", status);
        return -1;
      }
      *handle = devIndex;
    #else
      DaqDeviceHandle devHandle = ulCreateDaqDevice(measCompInventory[devIndex]);
      if (!devHandle) {
        printf("Error calling ulCreateDaqDevice devIndex=%d\n", devIndex);
        return -1;
      }
      *handle = devHandle;
      UlError error = ulConnectDaqDevice(devHandle);
      if (error) {
        printf("Error calling ulConnectDaqDevice error=%d\n", error);
        return -1;
      }
    #endif
    //
    deviceDescriptor = measCompInventory[devIndex];
    return 0;
  }
  return -1;
}












üî• File: ./USB1608G_2AO_V2App/src/measCompDiscover.h
=================================================
#ifndef measCompDiscoverInclude
#define measCompDiscoverInclude

#include <string>
#include <shareLib.h>
#ifdef _WIN32
  #include "cbw.h"
#else
  #include "uldaq.h"
#endif

epicsShareFunc int measCompDiscoverDevices();
epicsShareFunc void measCompShowDevices();
epicsShareFunc int measCompCreateDevice(std::string uniqueId, DaqDeviceDescriptor& deviceDescriptor, long long *handle);

#endif /* measCompDiscoverInclude */











üî• File: ./USB1608G_2AO_V2App/src/measCompSupport.dbd
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.dbd)]











üî• File: ./USB1608G_2AO_V2App/src/thresholdLogicSupport.dbd
=================================================
[SKIPPED: üöã OP ÌôîÎ©¥Ïö© ÌååÏùº (*.dbd)]
